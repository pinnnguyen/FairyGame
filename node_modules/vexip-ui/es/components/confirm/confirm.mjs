import { defineComponent, ref, onMounted, nextTick, resolveComponent, openBlock, createBlock, normalizeClass, withCtx, createElementBlock, Fragment, createElementVNode, toDisplayString, withModifiers, renderSlot, createVNode, createCommentVNode, normalizeStyle, createTextVNode } from "vue";
import "../button/index.mjs";
import "../icon/index.mjs";
import "../modal/index.mjs";
import "../renderer/index.mjs";
import "../../common/config/src/index.mjs";
import { isFunction, isPromise } from "@vexip-ui/utils";
import { Xmark, CircleQuestion } from "@vexip-ui/icons";
import { confirmProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Button from "../button/button.mjs";
import Icon from "../icon/icon.mjs";
import Modal from "../modal/modal.mjs";
import Renderer from "../renderer/renderer.mjs";
import { useProps } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const positionValidator = (value) => {
  return value === "auto" || !Number.isNaN(parseFloat(value));
};
const confirmTypes = Object.freeze([
  "default",
  "primary",
  "info",
  "success",
  "warning",
  "error"
]);
const _sfc_main = defineComponent({
  name: "Confirm",
  components: {
    Button,
    Icon,
    Modal,
    Renderer,
    Xmark
  },
  props: confirmProps,
  setup(_props) {
    const props = useProps("confirm", _props, {
      top: {
        default: "auto",
        validator: positionValidator
      },
      left: {
        default: "auto",
        validator: positionValidator
      },
      width: {
        default: 420,
        validator: positionValidator
      },
      maskClose: false,
      confirmType: {
        default: "default",
        validator: (value) => confirmTypes.includes(value)
      },
      confirmText: null,
      cancelText: null,
      icon: null,
      className: null,
      style: null,
      renderer: {
        default: null,
        isFunc: true,
        static: true
      },
      iconColor: "",
      closable: false,
      parseHtml: false,
      contentAlign: "center",
      actionsAlign: "center"
    });
    const visible = ref(false);
    const loading = ref(false);
    const title = ref("");
    const content = ref("");
    const iconColorR = ref(props.iconColor);
    const classR = ref(props.className);
    const styleR = ref(props.style || {});
    const confirmTypeR = ref(props.confirmType);
    const confirmTextR = ref(props.confirmText);
    const cancelTextR = ref(props.cancelText);
    const maskCloseR = ref(props.maskClose);
    const parseHtmlR = ref(props.parseHtml);
    const closableR = ref(props.closable);
    const contentAlignR = ref(props.contentAlign);
    const actionsAlignR = ref(props.actionsAlign);
    const iconR = ref(props.icon);
    const rendererR = ref(props.renderer);
    const onBeforeConfirm = ref(null);
    const onConfirm = ref(null);
    const onCancel = ref(null);
    const mounted = new Promise((resolve) => {
      onMounted(() => {
        nextTick(resolve);
      });
    });
    async function openConfirm(options) {
      await mounted;
      return await new Promise((resolve) => {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        title.value = (_a = options.title) != null ? _a : "";
        content.value = (_b = options.content) != null ? _b : "";
        classR.value = (_c = options.className) != null ? _c : props.className;
        styleR.value = (_d = options.style) != null ? _d : props.style;
        iconColorR.value = (_e = options.iconColor) != null ? _e : props.iconColor;
        maskCloseR.value = (_f = options.maskClose) != null ? _f : props.maskClose;
        confirmTypeR.value = (_g = options.confirmType) != null ? _g : props.confirmType;
        confirmTextR.value = (_h = options.confirmText) != null ? _h : props.confirmText;
        cancelTextR.value = (_i = options.cancelText) != null ? _i : props.cancelText;
        parseHtmlR.value = (_j = options.parseHtml) != null ? _j : props.parseHtml;
        closableR.value = (_k = options.closable) != null ? _k : props.closable;
        contentAlignR.value = (_l = options.contentAlign) != null ? _l : props.contentAlign;
        actionsAlignR.value = (_m = options.actionsAlign) != null ? _m : props.actionsAlign;
        iconR.value = (_n = options.icon) != null ? _n : props.icon;
        rendererR.value = isFunction(options.renderer) ? options.renderer : props.renderer;
        onBeforeConfirm.value = isFunction(options.onBeforeConfirm) ? options.onBeforeConfirm : null;
        if (isFunction(rendererR.value)) {
          rendererR.value = () => rendererR.value(options, handleConfirm, handleCancel);
        }
        visible.value = true;
        onConfirm.value = () => {
          resolve(true);
          onBeforeConfirm.value = null;
        };
        onCancel.value = () => {
          resolve(false);
          onBeforeConfirm.value = null;
        };
      });
    }
    async function handleConfirm() {
      loading.value = true;
      if (isFunction(onBeforeConfirm.value)) {
        let result = onBeforeConfirm.value();
        if (isPromise(result)) {
          result = await result;
        }
        if (result === false) {
          loading.value = false;
          return;
        }
      }
      visible.value = false;
      loading.value = false;
      if (isFunction(onConfirm.value)) {
        onConfirm.value();
        onConfirm.value = null;
      }
    }
    function handleCancel() {
      visible.value = false;
      if (isFunction(onCancel.value)) {
        onCancel.value();
        onCancel.value = null;
      }
    }
    function handleReset() {
      visible.value = false;
      title.value = "";
      content.value = "";
      iconColorR.value = props.iconColor;
      classR.value = props.className;
      styleR.value = props.style;
      maskCloseR.value = props.maskClose;
      confirmTypeR.value = props.confirmType;
      confirmTextR.value = props.confirmText;
      cancelTextR.value = props.cancelText;
      parseHtmlR.value = props.parseHtml;
      closableR.value = props.closable;
      contentAlignR.value = props.contentAlign;
      actionsAlignR.value = props.actionsAlign;
      iconR.value = props.icon;
      rendererR.value = props.renderer;
    }
    return {
      CircleQuestion,
      props,
      nh: useNameHelper("confirm"),
      locale: useLocale("confirm"),
      visible,
      loading,
      title,
      content,
      classR,
      styleR,
      iconColorR,
      maskCloseR,
      confirmTypeR,
      confirmTextR,
      cancelTextR,
      parseHtmlR,
      closableR,
      contentAlignR,
      actionsAlignR,
      iconR,
      rendererR,
      isFunction,
      openConfirm,
      handleConfirm,
      handleCancel,
      handleReset
    };
  }
});
const _hoisted_1 = ["innerHTML"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button");
  const _component_Modal = resolveComponent("Modal");
  return openBlock(), createBlock(_component_Modal, {
    "no-footer": "",
    closable: false,
    active: _ctx.visible,
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars")]),
    "modal-class": _ctx.classR,
    "modal-style": _ctx.styleR,
    top: _ctx.props.top,
    left: _ctx.props.left,
    width: _ctx.props.width,
    "mask-close": _ctx.maskCloseR,
    onHide: _ctx.handleReset
  }, {
    default: withCtx(() => [
      _ctx.isFunction(_ctx.rendererR) ? (openBlock(), createBlock(_component_Renderer, {
        key: 0,
        renderer: _ctx.rendererR
      }, null, 8, ["renderer"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.title ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("header"))
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.nh.be("title"))
          }, toDisplayString(_ctx.title), 3),
          _ctx.closableR ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("close")),
            onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"])),
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              createVNode(_component_Icon, {
                scale: 1.2,
                label: "close"
              }, {
                default: withCtx(() => [
                  createVNode(_component_Xmark)
                ]),
                _: 1
              }, 8, ["scale"])
            ])
          ], 34)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createElementVNode("div", {
          class: normalizeClass([
            _ctx.nh.be("body"),
            _ctx.nh.bem("body", _ctx.contentAlignR),
            _ctx.title && _ctx.nh.bem("body", "with-title")
          ])
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.nh.be("icon"))
          }, [
            _ctx.isFunction(_ctx.icon) ? (openBlock(), createBlock(_component_Renderer, {
              key: 0,
              renderer: _ctx.icon
            }, null, 8, ["renderer"])) : (openBlock(), createBlock(_component_Icon, {
              key: 1,
              icon: _ctx.iconR || _ctx.CircleQuestion,
              scale: 2.2,
              style: normalizeStyle({ color: _ctx.iconColorR })
            }, null, 8, ["icon", "scale", "style"]))
          ], 2),
          _ctx.parseHtmlR ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("content")),
            innerHTML: _ctx.content
          }, null, 10, _hoisted_1)) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.nh.be("content"))
          }, toDisplayString(_ctx.content), 3))
        ], 2),
        createElementVNode("div", {
          class: normalizeClass([_ctx.nh.be("footer"), _ctx.nh.bem("footer", _ctx.actionsAlignR)])
        }, [
          createVNode(_component_Button, {
            class: normalizeClass(_ctx.nh.be("button")),
            inherit: "",
            "no-pulse": "",
            onClick: _ctx.handleCancel
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.cancelTextR || _ctx.locale.cancel), 1)
            ]),
            _: 1
          }, 8, ["class", "onClick"]),
          createVNode(_component_Button, {
            class: normalizeClass(_ctx.nh.be("button")),
            inherit: "",
            "no-pulse": "",
            type: _ctx.confirmTypeR,
            loading: _ctx.loading,
            onClick: _ctx.handleConfirm
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.confirmTextR || _ctx.locale.confirm), 1)
            ]),
            _: 1
          }, 8, ["class", "type", "loading", "onClick"])
        ], 2),
        _ctx.closableR && !_ctx.title ? (openBlock(), createElementBlock("button", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("close")),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"])),
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
        }, [
          renderSlot(_ctx.$slots, "close", {}, () => [
            createVNode(_component_Icon, {
              scale: 1.2,
              label: "close"
            }, {
              default: withCtx(() => [
                createVNode(_component_Xmark)
              ]),
              _: 1
            }, 8, ["scale"])
          ])
        ], 34)) : createCommentVNode("", true)
      ], 64))
    ]),
    _: 3
  }, 8, ["active", "class", "modal-class", "modal-style", "top", "left", "width", "mask-close", "onHide"]);
}
var Component = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Component as default };
