import { defineComponent, ref, computed, provide, reactive, toRef, watchEffect, onMounted, nextTick, openBlock, createElementBlock, normalizeClass, renderSlot } from "vue";
import "../../common/config/src/index.mjs";
import { removeArrayItem } from "@vexip-ui/utils";
import { collapseProps } from "./props.mjs";
import { COLLAPSE_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "Collapse",
  props: collapseProps,
  emits: ["update:expanded"],
  setup(_props, { emit }) {
    const props = useProps("collapse", _props, {
      expanded: {
        default: null,
        static: true
      },
      card: false,
      accordion: false,
      arrowType: {
        default: "right",
        validator: (value) => ["right", "left", "none"].includes(value)
      },
      ghost: false
    });
    const nh = useNameHelper("collapse");
    const paneExpandedMap = /* @__PURE__ */ new Map();
    const currentExpanded = ref([]);
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(`arrow-${props.arrowType}`),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("card")]: props.card,
          [nh.bm("ghost")]: !props.card && props.ghost
        }
      ];
    });
    provide(
      COLLAPSE_STATE,
      reactive({
        arrowType: toRef(props, "arrowType"),
        registerPane,
        unregisterPane,
        expandPane
      })
    );
    watchEffect(() => {
      const rawExpanded = props.expanded;
      const expanded = props.accordion && Array.isArray(rawExpanded) ? rawExpanded[0] : rawExpanded || rawExpanded === 0 ? rawExpanded : [];
      currentExpanded.value = Array.isArray(expanded) ? Array.from(expanded) : [expanded];
    });
    onMounted(() => {
      nextTick(updateItemExpanded);
    });
    function registerPane(label, paneExpanded) {
      paneExpandedMap.set(label, paneExpanded);
      if (currentExpanded.value.includes(label)) {
        paneExpanded.value = true;
      } else if (paneExpanded.value) {
        expandPane(label, true);
      }
    }
    function unregisterPane(label) {
      paneExpandedMap.delete(label);
      expandPane(label, false);
    }
    function expandPane(label, expanded) {
      if (!label && label !== 0)
        return;
      if (props.accordion) {
        currentExpanded.value = expanded ? [label] : [];
      } else {
        if (expanded) {
          currentExpanded.value.push(label);
        } else {
          removeArrayItem(currentExpanded.value, label);
        }
      }
      emitChangeEvent();
      updateItemExpanded();
    }
    function emitChangeEvent() {
      emitEvent(props.onChange, currentExpanded.value);
      emit("update:expanded", currentExpanded.value);
    }
    function updateItemExpanded() {
      paneExpandedMap.forEach((expanded, label) => {
        expanded.value = currentExpanded.value.includes(label);
      });
    }
    return {
      className
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "tablist"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var Collapse = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Collapse as default };
