import { defineComponent, ref, computed, watch, watchEffect, createVNode } from "vue";
import "../checkbox/index.mjs";
import "../collapse-transition/index.mjs";
import "../icon/index.mjs";
import "../input/index.mjs";
import "../number-input/index.mjs";
import "../renderer/index.mjs";
import "../resize-observer/index.mjs";
import "../virtual-list/index.mjs";
import { Retweet, ChevronRight, ChevronLeft, MagnifyingGlass } from "@vexip-ui/icons";
import "../../common/config/src/index.mjs";
import { useModifier } from "@vexip-ui/hooks";
import { boundRange } from "@vexip-ui/utils";
import Checkbox from "../checkbox/checkbox.mjs";
import CollapseTransition from "../collapse/collapse-transition.mjs";
import Icon from "../icon/icon.mjs";
import Input from "../input/input.mjs";
import NumberInput from "../number-input/number-input.mjs";
import Renderer from "../renderer/renderer.mjs";
import ResizeObserver from "../resize-observer/resize-observer.mjs";
import VirtualList from "../virtual-list/virtual-list.mjs";
import { stateProp } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
var _sfc_main = defineComponent({
  name: "TransferPanel",
  components: {
    Checkbox,
    CollapseTransition,
    Icon,
    Input,
    NumberInput,
    Renderer,
    ResizeObserver,
    VirtualList,
    Retweet,
    ChevronRight,
    ChevronLeft
  },
  props: {
    type: {
      type: String,
      default: null
    },
    state: {
      type: stateProp,
      default: "default"
    },
    selected: {
      type: Set,
      default: () => /* @__PURE__ */ new Set()
    },
    paged: {
      type: Boolean,
      default: false
    },
    filter: {
      type: Function,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    },
    options: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String,
      default: "\u6682\u65E0\u6570\u636E"
    },
    optionHeight: {
      type: Number,
      default: 32
    },
    deepState: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadingIcon: {
      type: Object,
      default: null
    },
    loadingLock: {
      type: Boolean,
      default: false
    },
    loadingSpin: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:selected", "select", "enter", "switch"],
  setup(props, {
    slots,
    emit
  }) {
    const nh = useNameHelper("transfer");
    const locale = useLocale("transfer");
    const currentSelected = ref(new Set(props.selected));
    const pageSize = ref(10);
    const currentPage = ref(1);
    const currentMark = ref(null);
    const currentHitting = ref(-1);
    const currentFilter = ref("");
    const searching = ref(false);
    const header = ref();
    const body = ref();
    const footer = ref();
    const search = ref();
    const input = ref();
    const list = ref();
    let bodyRealHeight = 0;
    let lastSelected = null;
    let keyUsed = false;
    const {
      target: wrapper,
      modifier
    } = useModifier({
      passive: false,
      onKeyDown: (event, modifier2) => {
        if (modifier2.up || modifier2.down) {
          if (!keyUsed && currentHitting.value < 0) {
            keyUsed = true;
            if (lastSelected) {
              currentHitting.value = props.options.findIndex((option) => option.value === lastSelected);
            } else if (list.value) {
              currentHitting.value = Math.round(list.value.scrollOffset / props.optionHeight);
            }
            currentHitting.value = currentHitting.value === -1 ? 0 : currentHitting.value;
          } else {
            currentHitting.value = boundRange(findEnabledIndex(currentHitting.value + (modifier2.up ? -1 : 1), modifier2.up ? -1 : 1), 0, currentOptions.value.length - 1);
          }
          if (!props.paged) {
            ensureOptionInView(currentHitting.value, modifier2.up ? "top" : "bottom");
          }
          event.preventDefault();
        } else if (props.paged && (modifier2.left || modifier2.right) && event.ctrlKey) {
          handlePageChange(currentPage.value + (modifier2.left ? -1 : 1));
          currentHitting.value = 0;
          event.preventDefault();
        } else if (props.type === "source" && modifier2.right || props.type === "target" && modifier2.left) {
          keyUsed = false;
          currentHitting.value = -1;
          lastSelected = null;
          emit("switch");
          event.preventDefault();
        } else if (modifier2.space) {
          const option = currentOptions.value[currentHitting.value];
          if (option) {
            currentSelected.value[currentSelected.value.has(option.value) ? "delete" : "add"](option.value);
            emitSelectedChange();
          }
          event.preventDefault();
        } else if (modifier2.enter) {
          event.preventDefault();
          emit("enter");
          event.preventDefault();
        } else if (typeof props.filter === "function" && input.value && modifier2["ctrl+f"]) {
          event.preventDefault();
          event.stopPropagation();
          input.value.focus();
          event.preventDefault();
        }
      }
    });
    const className = computed(() => {
      return {
        [nh.be("panel")]: true,
        [nh.bem("panel", props.state)]: props.state !== "default",
        [nh.bem("panel", "disabled")]: props.disabled
      };
    });
    const visibleOptions = computed(() => {
      const filter = props.filter;
      const filterValue = currentFilter.value;
      if (filter && filterValue) {
        return props.options.filter((option) => filter(filterValue, option));
      }
      return props.options;
    });
    const optionSize = computed(() => visibleOptions.value.length);
    const pagedOptions = computed(() => {
      return visibleOptions.value.slice((currentPage.value - 1) * pageSize.value, currentPage.value * pageSize.value);
    });
    const currentOptions = computed(() => props.paged ? pagedOptions.value : visibleOptions.value);
    const totalPages = computed(() => Math.ceil(optionSize.value / (pageSize.value || 1)));
    watch(() => props.selected, (value) => {
      currentSelected.value = value;
    });
    watch(optionSize, () => {
      keyUsed = false;
      currentHitting.value = -1;
      lastSelected = null;
    });
    const partial = ref(false);
    const allSelected = ref(false);
    watchEffect(() => {
      const options = visibleOptions.value;
      const selected = currentSelected.value;
      let hasSelected = false;
      let hasUnselected = false;
      for (let i = 0, len = optionSize.value; i < len; ++i) {
        const option = options[i];
        if (!option.disabled) {
          if (selected.has(option.value)) {
            hasSelected = true;
          } else {
            hasUnselected = true;
          }
        }
        if (hasSelected && hasUnselected) {
          break;
        }
      }
      allSelected.value = hasSelected && !hasUnselected;
      partial.value = !allSelected.value && selected.size > 0;
    });
    function computePageSize() {
      requestAnimationFrame(() => {
        var _a;
        const bodyEl = body.value || ((_a = list.value) == null ? void 0 : _a.wrapper);
        if (bodyEl) {
          const style = getComputedStyle(bodyEl);
          const paddingTop = parseInt(style.paddingTop);
          const paddingBottom = parseInt(style.paddingBottom);
          const innerHeight = bodyEl.offsetHeight - paddingTop - paddingBottom;
          bodyRealHeight = innerHeight;
          pageSize.value = Math.floor(innerHeight / (props.optionHeight || 1));
        }
      });
    }
    function toggleSelect(option) {
      if (props.disabled || option.disabled)
        return;
      if (currentMark.value && modifier.shift) {
        handleRangeSelect(currentMark.value, option.value);
        return;
      }
      if (currentSelected.value.has(option.value)) {
        currentSelected.value.delete(option.value);
      } else {
        currentSelected.value.add(option.value);
      }
      keyUsed = false;
      currentHitting.value = -1;
      lastSelected = option.value;
      currentMark.value = option.value;
      emitSelectedChange();
    }
    function handleRangeSelect(start, end) {
      var _a;
      const options = visibleOptions.value;
      let startIndex = -1;
      let endIndex = -1;
      for (let i = 0, len = options.length; i < len; ++i) {
        const option = options[i];
        if (option.value === start) {
          startIndex = i;
        } else if (option.value === end) {
          endIndex = i;
        }
        if (startIndex > 0 && endIndex > 0)
          break;
      }
      const method = currentSelected.value.has((_a = options[startIndex]) == null ? void 0 : _a.value) ? "add" : "delete";
      if (startIndex > endIndex) {
        [startIndex, endIndex] = [endIndex, startIndex];
      }
      for (let i = startIndex; i <= endIndex; ++i) {
        const option = options[i];
        if (!option.disabled) {
          currentSelected.value[method](option.value);
        }
      }
      emitSelectedChange();
    }
    function toggleSelectAll() {
      if (props.disabled)
        return;
      if (allSelected.value) {
        for (const option of visibleOptions.value) {
          !option.disabled && currentSelected.value.delete(option.value);
        }
      } else {
        for (const option of visibleOptions.value) {
          !option.disabled && currentSelected.value.add(option.value);
        }
      }
      currentMark.value = null;
      emitSelectedChange();
    }
    function handleReverse() {
      if (props.disabled)
        return;
      if (partial.value) {
        const prevSelected = new Set(currentSelected.value);
        for (const option of visibleOptions.value) {
          if (!option.disabled) {
            if (prevSelected.has(option.value)) {
              currentSelected.value.delete(option.value);
            } else {
              currentSelected.value.add(option.value);
            }
          }
        }
        currentMark.value = null;
        emitSelectedChange();
      } else {
        toggleSelectAll();
      }
    }
    function handleBlur() {
      currentMark.value = null;
      modifier.resetAll();
    }
    function emitSelectedChange() {
      emit("update:selected", currentSelected.value);
      emit("select");
    }
    function handlePageChange(page) {
      currentPage.value = boundRange(page, 1, totalPages.value);
    }
    function queryEnabledIndex(index, step) {
      var _a;
      const options = currentOptions.value;
      step = step / Math.abs(step);
      while ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index += step;
        if (index < 0 || index >= options.length)
          break;
      }
      return index;
    }
    function findEnabledIndex(index, sign = 1) {
      var _a;
      const options = currentOptions.value;
      if ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index = queryEnabledIndex(index, sign);
        if (sign > 0 ? index >= options.length : index < 0) {
          index = queryEnabledIndex(index, -sign);
          if (sign > 0 ? index < 0 : index >= options.length)
            index = -1;
        }
      }
      return index;
    }
    function ensureOptionInView(index, direction) {
      const option = props.options[index];
      if (props.paged || !option || !list.value)
        return;
      if (direction === "bottom") {
        const target = (index + 1) * props.optionHeight;
        if (list.value.scrollOffset + bodyRealHeight < target) {
          list.value.scrollTo((index - pageSize.value + 1) * props.optionHeight);
        }
      } else {
        const target = index * props.optionHeight;
        if (list.value.scrollOffset > target) {
          list.value.scrollTo(target);
        }
      }
    }
    function getSlotPayload() {
      return {
        type: props.type,
        currentPage: currentPage.value,
        pageSize: pageSize.value,
        totalPages: totalPages.value,
        allSelected: allSelected.value,
        partial: partial.value,
        selected: Array.from(currentSelected.value),
        options: visibleOptions.value,
        toggleSelectAll,
        handleReverse
      };
    }
    function renderOption({
      option,
      index
    }) {
      const disabled = props.disabled || option.disabled;
      const handleCheck = (event) => {
        event.preventDefault();
        event.stopPropagation();
        toggleSelect(option);
      };
      return createVNode("li", {
        "class": {
          [nh.be("option")]: true,
          [nh.bem("option", "disabled")]: disabled,
          [nh.bem("option", "hitting")]: currentHitting.value === index
        },
        "role": "option",
        "aria-disabled": disabled ? "true" : void 0,
        "onClick": () => toggleSelect(option)
      }, [slots.option ? slots.option({
        type: props.type,
        option,
        index
      }) : [createVNode(Checkbox, {
        "class": nh.be("checkbox"),
        "state": props.deepState ? props.state : void 0,
        "checked": currentSelected.value.has(option.value),
        "disabled": disabled,
        "tab-index": -1,
        "onClick": handleCheck
      }, null), createVNode("span", {
        "class": nh.be("label")
      }, [slots.label ? slots.label({
        option,
        index
      }) : option.label])]]);
    }
    return {
      MagnifyingGlass,
      nh,
      locale,
      currentSelected,
      pageSize,
      currentPage,
      currentMark,
      currentFilter,
      searching,
      className,
      visibleOptions,
      partial,
      allSelected,
      pagedOptions,
      totalPages,
      wrapper,
      header,
      body,
      footer,
      search,
      input,
      list,
      computePageSize,
      toggleSelect,
      toggleSelectAll,
      handleReverse,
      handlePageChange,
      handleBlur,
      getSlotPayload,
      renderOption
    };
  }
});
export { _sfc_main as default };
