import { defineComponent, ref, computed, watchEffect, watch, reactive, createVNode } from "vue";
import TransferPanel from "./transfer-panel.mjs";
import "../button/index.mjs";
import "../icon/index.mjs";
import "../form/index.mjs";
import { Spinner, ChevronRight, ChevronLeft } from "@vexip-ui/icons";
import "../../common/config/src/index.mjs";
import { isNull } from "@vexip-ui/utils";
import { transferProps } from "./props.mjs";
import Button from "../button/button.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
import Icon from "../icon/icon.mjs";
const defaultKeyConfig = {
  value: "value",
  label: "label",
  disabled: "disabled"
};
var Transfer = defineComponent({
  name: "Transfer",
  components: {
    Button,
    TransferPanel
  },
  props: transferProps,
  emits: ["update:value"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      validateField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a, _b;
      return (_b = (_a = source.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus();
    });
    const props = useProps("transfer", _props, {
      state: createStateProp(state),
      options: {
        default: () => [],
        static: true
      },
      value: {
        default: () => getFieldValue([]),
        static: true
      },
      disabled: () => disabled.value,
      paged: false,
      filter: false,
      emptyText: null,
      keyConfig: () => ({}),
      optionHeight: {
        default: 32,
        validator: (value) => value > 0
      },
      ignoreCase: false,
      sourceTitle: null,
      targetTitle: null,
      deepState: false,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false
    });
    const nh = useNameHelper("transfer");
    const locale = useLocale("transfer");
    const currentValue = ref(null);
    const sourceSelected = ref(/* @__PURE__ */ new Set());
    const targetSelected = ref(/* @__PURE__ */ new Set());
    const sourceOptions = ref([]);
    const targetOptions = ref([]);
    const optionStates = ref([]);
    const source = ref();
    const target = ref();
    const keyConfig = computed(() => ({
      ...defaultKeyConfig,
      ...props.keyConfig
    }));
    let optionValueMap = /* @__PURE__ */ new Map();
    let emittedValue = props.value;
    const updateTrigger = ref(0);
    watchEffect(() => {
      props.keyConfig.value;
      props.keyConfig.label;
      props.keyConfig.disabled;
      props.options;
      updateTrigger.value++;
    });
    watch(updateTrigger, initOptions, {
      immediate: true
    });
    watchEffect(() => {
      if (!currentValue.value.size) {
        sourceOptions.value = Array.from(optionStates.value);
        targetOptions.value = [];
        return;
      }
      const selectedValues = new Set(currentValue.value);
      const target2 = [];
      const source2 = [];
      for (const option of optionStates.value) {
        if (selectedValues.has(option.value)) {
          target2.push(option);
        } else {
          source2.push(option);
        }
      }
      targetOptions.value = target2;
      sourceOptions.value = source2;
    });
    function initOptions() {
      const {
        value: valueKey,
        label: labelKey,
        disabled: disabledKey
      } = keyConfig.value;
      const oldMap = optionValueMap;
      const map = /* @__PURE__ */ new Map();
      props.options.forEach((option) => {
        var _a, _b;
        const rawOption = typeof option === "string" ? {
          [valueKey]: option
        } : option;
        const value = rawOption[valueKey];
        if (isNull(value))
          return;
        const label = rawOption[labelKey] || String(value);
        const {
          [disabledKey]: disabled2 = false
        } = rawOption;
        const oldState = oldMap.get(rawOption.value);
        const optionState = reactive({
          disabled: disabled2,
          value,
          label,
          hidden: (_a = oldState == null ? void 0 : oldState.hidden) != null ? _a : false,
          hitting: (_b = oldState == null ? void 0 : oldState.hitting) != null ? _b : false,
          data: option
        });
        map.set(value, optionState);
      });
      optionValueMap = map;
      optionStates.value = Array.from(map.values());
      currentValue.value = new Set(emittedValue);
    }
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.state)]: props.state !== "default"
      }];
    });
    const actionType = computed(() => {
      return props.deepState && props.state !== "default" ? props.state : "primary";
    });
    const toTargetEnabled = computed(() => !!sourceSelected.value.size);
    const toSourceEnabled = computed(() => !!targetSelected.value.size);
    const defaultFilter = computed(() => {
      return props.ignoreCase ? (value, option) => String(option.value).toLocaleLowerCase().includes(value) : (value, option) => String(option.value).includes(value);
    });
    const sourceFilter = computed(() => getFilterMethod("source"));
    const targetFilter = computed(() => getFilterMethod("target"));
    watch(() => props.value, (value) => {
      emittedValue = value;
      currentValue.value = new Set(emittedValue);
    });
    expose({
      handleToTarget,
      handleToSource,
      handlePanelFocus,
      handlePanelBlur
    });
    function getFilterMethod(type) {
      const filter = props.filter;
      if (!filter)
        return void 0;
      if (typeof filter === "function") {
        return (value, option) => filter(value, option, type);
      }
      return defaultFilter.value;
    }
    function handleChange() {
      emittedValue = Array.from(currentValue.value);
      setFieldValue(emittedValue);
      emitEvent(props.onChange, emittedValue);
      emit("update:value", emittedValue);
      validateField();
    }
    function handleToTarget() {
      for (const value of sourceSelected.value) {
        currentValue.value.add(value);
      }
      sourceSelected.value.clear();
      handleChange();
    }
    function handleToSource() {
      for (const value of targetSelected.value) {
        currentValue.value.delete(value);
      }
      targetSelected.value.clear();
      handleChange();
    }
    function handleSelect(type) {
      const selected = {
        source: Array.from(sourceSelected.value),
        target: Array.from(targetSelected.value)
      };
      const data = {
        source: selected.source.map((value) => {
          var _a, _b;
          return (_b = (_a = optionValueMap.get(value)) == null ? void 0 : _a.data) != null ? _b : "";
        }),
        target: selected.target.map((value) => {
          var _a, _b;
          return (_b = (_a = optionValueMap.get(value)) == null ? void 0 : _a.data) != null ? _b : "";
        })
      };
      emitEvent(props.onSelect, type, selected, data);
    }
    function handlePanelFocus(type) {
      var _a, _b;
      if (type === "source") {
        (_a = source.value) == null ? void 0 : _a.$el.focus();
      } else {
        (_b = target.value) == null ? void 0 : _b.$el.focus();
      }
    }
    function handlePanelBlur() {
      var _a, _b;
      (_a = source.value) == null ? void 0 : _a.$el.blur();
      (_b = target.value) == null ? void 0 : _b.$el.blur();
    }
    return () => {
      return createVNode("div", {
        "id": idFor.value,
        "class": className.value
      }, [createVNode(TransferPanel, {
        "ref": source,
        "selected": sourceSelected.value,
        "onUpdate:selected": ($event) => sourceSelected.value = $event,
        "type": "source",
        "class": nh.bem("panel", "source"),
        "state": props.state,
        "paged": props.paged,
        "filter": sourceFilter.value,
        "disabled": props.disabled,
        "title": props.sourceTitle || locale.value.source,
        "options": sourceOptions.value,
        "empty-text": props.emptyText || locale.value.empty,
        "option-height": props.optionHeight,
        "ignore-case": props.ignoreCase,
        "deep-state": props.deepState,
        "loading": props.loading,
        "loading-icon": props.loadingIcon,
        "loading-lock": props.loadingLock,
        "loading-spin": props.loadingSpin,
        "onSelect": () => handleSelect("source"),
        "onEnter": handleToTarget,
        "onSwitch": () => handlePanelFocus("target")
      }, {
        header: slots["source-header"] || slots.sourceHeader || slots.header,
        title: slots["source-title"] || slots.sourceTitle || slots.title,
        body: slots["source-body"] || slots.sourceBody || slots.body,
        footer: slots["source-footer"] || slots.sourceFooter || slots.footer,
        option: slots["source-option"] || slots.sourceOption || slots.option
      }), createVNode("div", {
        "class": nh.be("actions")
      }, [slots.actions ? slots.actions({
        handleToTarget,
        handleToSource
      }) : [createVNode(Button, {
        "inherit": true,
        "class": nh.be("action"),
        "type": actionType.value,
        "size": "small",
        "disabled": props.disabled || !toTargetEnabled.value,
        "loading": props.loading && props.loadingLock,
        "loading-icon": props.loadingIcon,
        "loading-spin": props.loadingSpin,
        "style": {
          marginBottom: "6px"
        },
        "onClick": handleToTarget
      }, {
        icon: () => createVNode(Icon, {
          "label": "to right"
        }, {
          default: () => [createVNode(ChevronRight, null, null)]
        })
      }), createVNode(Button, {
        "inherit": true,
        "class": nh.be("action"),
        "type": actionType.value,
        "size": "small",
        "disabled": props.disabled || !toSourceEnabled.value,
        "loading": props.loading && props.loadingLock,
        "loading-icon": props.loadingIcon,
        "loading-spin": props.loadingSpin,
        "style": {
          margin: "0"
        },
        "onClick": handleToSource
      }, {
        icon: () => createVNode(Icon, {
          "label": "to left"
        }, {
          default: () => [createVNode(ChevronLeft, null, null)]
        })
      })]]), createVNode(TransferPanel, {
        "ref": target,
        "selected": targetSelected.value,
        "onUpdate:selected": ($event) => targetSelected.value = $event,
        "type": "target",
        "class": nh.bem("panel", "target"),
        "state": props.state,
        "paged": props.paged,
        "filter": targetFilter.value,
        "disabled": props.disabled,
        "title": props.targetTitle || locale.value.target,
        "options": targetOptions.value,
        "empty-text": props.emptyText || locale.value.empty,
        "option-height": props.optionHeight,
        "ignore-case": props.ignoreCase,
        "deep-state": props.deepState,
        "loading": props.loading,
        "loading-icon": props.loadingIcon,
        "loading-lock": props.loadingLock,
        "loading-spin": props.loadingSpin,
        "onSelect": () => handleSelect("target"),
        "onEnter": handleToSource,
        "onSwitch": () => handlePanelFocus("source")
      }, {
        header: slots["target-header"] || slots.targetHeader || slots.header,
        title: slots["target-title"] || slots.targetTitle || slots.title,
        body: slots["target-body"] || slots.targetBody || slots.body,
        footer: slots["target-footer"] || slots.targetFooter || slots.footer,
        option: slots["target-option"] || slots.targetOption || slots.option
      })]);
    };
  }
});
export { Transfer as default };
