import { defineComponent, ref, computed, toRef, watch, nextTick, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, withModifiers, createVNode, withCtx, createBlock, resolveDynamicComponent, renderSlot, createCommentVNode } from "vue";
import "../scrollbar/index.mjs";
import "../resize-observer/index.mjs";
import "../../common/config/src/index.mjs";
import { USE_TOUCH, createEventEmitter, isTrue, isElement } from "@vexip-ui/utils";
import { scrollProps } from "./props.mjs";
import { useScrollWrapper } from "./hooks.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Scrollbar from "../scrollbar/scrollbar.mjs";
import ResizeObserver from "../resize-observer/resize-observer.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const scrollModes = Object.freeze(["horizontal", "horizontal-exact", "vertical", "both"]);
const MOVE_EVENT = USE_TOUCH ? "touchmove" : "mousemove";
const UP_EVENT = USE_TOUCH ? "touchend" : "mouseup";
const _sfc_main = defineComponent({
  name: "Scroll",
  components: {
    Scrollbar,
    ResizeObserver
  },
  props: scrollProps,
  emits: [],
  setup(_props) {
    const props = useProps("scroll", _props, {
      scrollClass: null,
      mode: {
        default: "vertical",
        validator: (value) => scrollModes.includes(value)
      },
      width: "",
      height: "",
      deltaX: 20,
      deltaY: 20,
      disabled: false,
      pointer: USE_TOUCH,
      wheel: true,
      scrollX: {
        default: 0,
        static: true
      },
      scrollY: {
        default: 0,
        static: true
      },
      useXBar: false,
      useYBar: false,
      barFade: 1500,
      barClass: null,
      autoplay: false,
      playWaiting: 500,
      noBuffer: false,
      noTransition: false,
      onBeforeScroll: {
        default: null,
        isFunc: true
      },
      useBarTrack: false,
      wrapperTag: "div"
    });
    const emitter = createEventEmitter();
    const nh = useNameHelper("scroll");
    const usingBar = ref(false);
    const scrolling = ref(false);
    const transitionDuration = ref(-1);
    const mode = computed(() => props.mode === "horizontal-exact" ? "horizontal" : props.mode);
    const {
      wrapperElement,
      contentElement,
      wrapper,
      isReady,
      currentScroll,
      percentX,
      percentY,
      xScrollLimit,
      yScrollLimit,
      enableXScroll,
      enableYScroll,
      xBarLength,
      yBarLength,
      handleResize,
      verifyScroll,
      computePercent,
      refresh
    } = useScrollWrapper({
      mode,
      disabled: toRef(props, "disabled"),
      width: toRef(props, "width"),
      height: toRef(props, "height"),
      scrollX: toRef(props, "scrollX"),
      scrollY: toRef(props, "scrollY"),
      onResize: (entry) => {
        emitEvent(props.onResize, entry);
      },
      onBeforeRefresh: stopAutoplay,
      onAfterRefresh: startAutoplay
    });
    const canPlay = ref(false);
    const canAutoplay = computed(() => {
      return mode.value !== "both" && (isTrue(props.autoplay) || props.autoplay > 1e3) && (mode.value === "horizontal" && enableXScroll.value || mode.value === "vertical" && enableYScroll.value);
    });
    watch(
      () => props.autoplay,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    watch(
      () => props.playWaiting,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    let playTimer;
    let startTimer;
    let endTimer;
    onBeforeUnmount(stopAutoplay);
    function startAutoplay() {
      if (!canAutoplay.value)
        return;
      stopAutoplay();
      const distance = mode.value === "horizontal" ? "width" : "height";
      const limit = mode.value === "horizontal" ? xScrollLimit : yScrollLimit;
      const prop = mode.value === "horizontal" ? "x" : "y";
      const waiting = props.playWaiting < 20 ? 20 : props.playWaiting;
      let playSpeed = 0.5;
      if (typeof props.autoplay === "number") {
        playSpeed = wrapper[distance] / props.autoplay * 16;
      }
      const scroll = () => {
        currentScroll[prop] -= playSpeed;
        if (currentScroll[prop] <= limit.value) {
          currentScroll[prop] = limit.value;
          canPlay.value = false;
          computePercent();
          syncBarScroll();
          endTimer = setTimeout(() => {
            scrollTo(0, 0, 500);
            startTimer = setTimeout(() => {
              canPlay.value = true;
              scroll();
            }, 500 + waiting);
          }, waiting);
        } else {
          computePercent();
          syncBarScroll();
          if (canPlay.value) {
            requestAnimationFrame(scroll);
          }
        }
      };
      playTimer = setTimeout(() => {
        canPlay.value = true;
        scroll();
      }, waiting);
    }
    function stopAutoplay() {
      canPlay.value = false;
      clearTimeout(playTimer);
      clearTimeout(startTimer);
      clearTimeout(endTimer);
    }
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(mode.value),
        {
          [nh.bm("inherit")]: props.inherit
        }
      ];
    });
    const style = computed(() => {
      const { width, height } = props;
      return {
        width: width ? typeof width === "string" ? Number.isNaN(Number(width)) ? width : `${Number(width)}px` : `${width}px` : void 0,
        height: height ? typeof height === "string" ? Number.isNaN(Number(height)) ? height : `${Number(height)}px` : `${height}px` : void 0
      };
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        props.scrollClass,
        {
          [nh.bem("wrapper", "scrolling")]: scrolling.value,
          [nh.bem("wrapper", "no-ready")]: !isReady.value,
          [nh.bem("wrapper", "using-bar")]: usingBar.value,
          [nh.bem("wrapper", "no-transition")]: props.noTransition
        }
      ];
    });
    const wrapperStyle = computed(() => {
      return {
        transform: `translate3d(${currentScroll.x}px, ${currentScroll.y}px, 0)`,
        transitionDuration: transitionDuration.value < 0 ? void 0 : `${transitionDuration.value}ms`
      };
    });
    watch(enableXScroll, (value) => {
      emitEvent(props.onXEnabledChange, value);
    });
    watch(enableYScroll, (value) => {
      emitEvent(props.onYEnabledChange, value);
    });
    watch(isReady, (value) => {
      if (value)
        emitEvent(props.onReady);
    });
    const xBar = ref();
    const yBar = ref();
    function syncBarScroll() {
      var _a, _b;
      (_a = xBar.value) == null ? void 0 : _a.handleScroll(percentX.value);
      (_b = yBar.value) == null ? void 0 : _b.handleScroll(percentY.value);
    }
    function handleMouseDown(event) {
      if (!props.pointer || event.button > 0 || USE_TOUCH) {
        return false;
      }
      handlePointerDown(event);
    }
    function handleTouchStart(event) {
      if (!props.pointer || event.touches.length !== 1) {
        return false;
      }
      handlePointerDown(event);
    }
    let xScrollStartAt = 0;
    let yScrollStartAt = 0;
    let cursorXPosition = 0;
    let cursorYPosition = 0;
    let moved = false;
    let target = null;
    let lastDate = 0;
    function handlePointerDown(event) {
      if (!enableXScroll.value && !enableYScroll.value) {
        return false;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      prepareScroll();
      transitionDuration.value = 0;
      const pointer = "touches" in event ? event.touches[0] : event;
      xScrollStartAt = currentScroll.x;
      yScrollStartAt = currentScroll.y;
      cursorXPosition = pointer.clientX;
      cursorYPosition = pointer.clientY;
      moved = false;
      target = event.target;
      lastDate = Date.now();
      document.addEventListener(MOVE_EVENT, handlePointerMove);
      document.addEventListener(UP_EVENT, handlePointerUp);
      emitEvent(props.onScrollStart, {
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handlePointerMove(event) {
      var _a;
      event.stopPropagation();
      if (!USE_TOUCH) {
        event.preventDefault();
      }
      const pointer = "touches" in event ? event.touches[0] : event;
      const signX = pointer.clientX - cursorXPosition > 0 ? 1 : -1;
      const signY = pointer.clientY - cursorYPosition > 0 ? 1 : -1;
      if (((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX, signY })) === false) {
        return false;
      }
      scrolling.value = true;
      if (enableXScroll.value) {
        currentScroll.x = xScrollStartAt + pointer.clientX - cursorXPosition;
        moved = true;
      }
      if (enableYScroll.value) {
        currentScroll.y = yScrollStartAt + pointer.clientY - cursorYPosition;
        moved = true;
      }
      if (props.noBuffer) {
        verifyScroll();
      } else {
        computePercent();
      }
      syncBarScroll();
      emitScrollEvent(mode.value);
    }
    function handlePointerUp(event) {
      if (!moved && target && event.target === target && Date.now() - lastDate <= 500) {
        target.dispatchEvent(new MouseEvent("click", event));
      }
      document.removeEventListener(MOVE_EVENT, handlePointerMove);
      document.removeEventListener(UP_EVENT, handlePointerUp);
      transitionDuration.value = -1;
      moved = false;
      handleBuffer();
      verifyScroll();
      syncBarScroll();
      emitEvent(props.onScrollEnd, {
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      startAutoplay();
    }
    function handleWheel(event, type) {
      var _a;
      const isVerticalScroll = enableYScroll.value && type === "vertical";
      const isHorizontalScroll = enableXScroll.value && type === "horizontal";
      const sign = event.deltaY > 0 ? -1 : 1;
      if (props.wheel && (isVerticalScroll || isHorizontalScroll) && ((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX: -sign, signY: -sign })) !== false) {
        event.preventDefault();
        event.stopPropagation();
      } else {
        return true;
      }
      if (mode.value !== "both" && mode.value !== type)
        return false;
      prepareScroll();
      const computedDelta = sign * (type === "horizontal" ? props.deltaX : props.deltaY);
      if (isVerticalScroll) {
        currentScroll.y += computedDelta;
      } else if (isHorizontalScroll) {
        currentScroll.x += computedDelta;
      }
      verifyScroll();
      syncBarScroll();
      emitScrollEvent(type);
      emitEvent(props.onWheel, {
        type,
        sign: -sign,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      startAutoplay();
    }
    let bufferTimer;
    function prepareScroll() {
      stopAutoplay();
      clearTimeout(bufferTimer);
    }
    function handleBuffer() {
      if (props.noBuffer) {
        bufferTimer = setTimeout(() => {
          scrolling.value = false;
        }, 300);
      } else {
        scrolling.value = false;
      }
    }
    function handleBarScrollStart(type) {
      usingBar.value = true;
      emitEvent(props.onBarScrollStart, {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleBarScrollEnd(type) {
      usingBar.value = false;
      emitEvent(props.onBarScrollEnd, {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleXBarScroll(percent) {
      percentX.value = percent;
      currentScroll.x = percent * xScrollLimit.value / 100;
      emitEvent(props.onBarScroll, {
        type: "horizontal",
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("horizontal");
    }
    function handleYBarScroll(percent) {
      percentY.value = percent;
      currentScroll.y = percent * yScrollLimit.value / 100;
      emitEvent(props.onBarScroll, {
        type: "vertical",
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("vertical");
    }
    function emitScrollEvent(type) {
      emitEvent(props.onScroll, {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitter.emit("scroll", {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function ensureScrollOffset() {
      if (wrapperElement.value) {
        wrapperElement.value.scrollTop = 0;
        wrapperElement.value.scrollLeft = 0;
      }
    }
    function scrollTo(clientX, clientY, duration) {
      setDuration(duration);
      nextTick(() => {
        let changed = false;
        if (enableXScroll.value && Math.abs(currentScroll.x + clientX) > 0.01) {
          currentScroll.x = -clientX;
          changed = true;
        }
        if (enableYScroll.value && Math.abs(currentScroll.y + clientY) > 0.01) {
          currentScroll.y = -clientY;
          changed = true;
        }
        verifyScroll();
        syncBarScroll();
        if (!changed)
          transitionDuration.value = -1;
      });
    }
    function scrollBy(deltaX, deltaY, duration) {
      setDuration(duration);
      nextTick(() => {
        let changed = false;
        if (deltaX && enableXScroll) {
          currentScroll.x -= deltaX;
          changed = true;
        }
        if (deltaY && enableYScroll) {
          currentScroll.y -= deltaY;
          changed = true;
        }
        verifyScroll();
        syncBarScroll();
        if (!changed)
          transitionDuration.value = -1;
      });
    }
    function setDuration(duration) {
      if (typeof duration === "number") {
        transitionDuration.value = duration;
        if (transitionDuration.value === 0) {
          nextTick(() => {
            transitionDuration.value = -1;
          });
        }
      }
    }
    function getXScrollLimit() {
      return [0, -xScrollLimit.value];
    }
    function getYScrollLimit() {
      return [0, -yScrollLimit.value];
    }
    function scrollToElement(el, duration, offset = 0) {
      if (!contentElement.value)
        return;
      if (typeof el === "string") {
        el = contentElement.value.querySelector(el);
      }
      if (!isElement(el))
        return;
      const wrapperRect = contentElement.value.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      let clientX = 0;
      let clientY = 0;
      if (mode.value !== "vertical") {
        clientX = elRect.left - wrapperRect.left + offset;
      }
      if (mode.value !== "horizontal") {
        clientY = elRect.top - wrapperRect.top + offset;
      }
      scrollTo(clientX, clientY, duration);
    }
    function ensureInView(el, duration, offset = 0) {
      if (!wrapperElement.value)
        return;
      if (typeof el === "string") {
        el = wrapperElement.value.querySelector(el);
      }
      if (!isElement(el))
        return;
      const wrapperRect = wrapperElement.value.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      let clientX = 0;
      let clientY = 0;
      if (mode.value !== "vertical") {
        if (elRect.left < wrapperRect.left + offset) {
          clientX = elRect.left - wrapperRect.left - offset;
        } else if (elRect.right > wrapperRect.right - offset) {
          clientX = elRect.right - wrapperRect.right + offset;
        }
      }
      if (mode.value !== "horizontal") {
        if (elRect.top < wrapperRect.top + offset) {
          clientY = elRect.top - wrapperRect.top - offset;
        } else if (elRect.bottom > wrapperRect.bottom - offset) {
          clientY = elRect.bottom - wrapperRect.bottom + offset;
        }
      }
      scrollBy(clientX, clientY, duration);
    }
    function addScrollListener(listener) {
      emitter.on("scroll", listener);
    }
    function removeScrollListener(listener) {
      emitter.off("scroll", listener);
    }
    return {
      props,
      nh,
      percentX,
      percentY,
      transitionDuration,
      currentScroll,
      className,
      style,
      wrapperClass,
      wrapperStyle,
      xBarLength,
      yBarLength,
      enableXScroll,
      enableYScroll,
      wrapper: wrapperElement,
      content: contentElement,
      xBar,
      yBar,
      handleResize,
      handleMouseDown,
      handleTouchStart,
      handleWheel,
      handleBarScrollStart,
      handleBarScrollEnd,
      handleXBarScroll,
      handleYBarScroll,
      ensureScrollOffset,
      refresh,
      scrollTo,
      scrollBy,
      getXScrollLimit,
      getYScrollLimit,
      scrollToElement,
      ensureInView,
      addScrollListener,
      removeScrollListener
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.style),
    onMousedown: _cache[5] || (_cache[5] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args)),
    onTouchstart: _cache[6] || (_cache[6] = (...args) => _ctx.handleTouchStart && _ctx.handleTouchStart(...args)),
    onScroll: _cache[7] || (_cache[7] = (...args) => _ctx.ensureScrollOffset && _ctx.ensureScrollOffset(...args)),
    onWheel: [
      _cache[8] || (_cache[8] = withModifiers(($event) => _ctx.handleWheel($event, _ctx.mode === "horizontal-exact" ? "horizontal" : "vertical"), ["exact"])),
      _cache[9] || (_cache[9] = withModifiers(($event) => _ctx.handleWheel($event, "horizontal"), ["shift"]))
    ]
  }, [
    createVNode(_component_ResizeObserver, {
      throttle: "",
      "on-resize": _ctx.handleResize
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.props.wrapperTag || "div"), {
          ref: "content",
          class: normalizeClass(_ctx.wrapperClass),
          style: normalizeStyle(_ctx.wrapperStyle),
          onTransitionend: _cache[0] || (_cache[0] = ($event) => _ctx.transitionDuration = -1)
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 40, ["class", "style"]))
      ]),
      _: 3
    }, 8, ["on-resize"]),
    _ctx.props.useXBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 0,
      ref: "xBar",
      inherit: "",
      placement: "bottom",
      class: normalizeClass([_ctx.nh.bem("bar", "horizontal"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.xBarLength,
      disabled: !_ctx.enableXScroll,
      duration: _ctx.transitionDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[1] || (_cache[1] = ($event) => _ctx.handleBarScrollStart("horizontal")),
      onScroll: _ctx.handleXBarScroll,
      onScrollEnd: _cache[2] || (_cache[2] = ($event) => _ctx.handleBarScrollEnd("horizontal"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "duration", "use-track", "onScroll"])) : createCommentVNode("", true),
    _ctx.props.useYBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 1,
      ref: "yBar",
      inherit: "",
      placement: "right",
      class: normalizeClass([_ctx.nh.bem("bar", "vertical"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.yBarLength,
      disabled: !_ctx.enableYScroll,
      duration: _ctx.transitionDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[3] || (_cache[3] = ($event) => _ctx.handleBarScrollStart("vertical")),
      onScroll: _ctx.handleYBarScroll,
      onScrollEnd: _cache[4] || (_cache[4] = ($event) => _ctx.handleBarScrollEnd("vertical"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "duration", "use-track", "onScroll"])) : createCommentVNode("", true)
  ], 38);
}
var Scroll = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Scroll as default };
