import { defineComponent, ref, computed, watch, openBlock, createElementBlock, normalizeClass, renderSlot, createElementVNode, Fragment, renderList, toDisplayString, withKeys, withModifiers } from "vue";
import { useHover } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { toFalse, startOfDay, endOfDay, debounceMinor, rangeDate, startOfWeek, differenceDays } from "@vexip-ui/utils";
import { calendarPanelProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "CalendarPanel",
  props: calendarPanelProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const props = useProps("calendarBase", _props, {
      value: {
        default: null,
        static: true
      },
      year: () => new Date().getFullYear(),
      month: {
        default: () => new Date().getMonth() + 1,
        validator: (value) => value > 0 && value <= 12
      },
      weekDays: {
        default: null,
        validator: (value) => !value || value.length === 0 || value.length === 7
      },
      weekStart: {
        default: 0,
        validator: (value) => value >= 0 && value < 7
      },
      today: {
        default: () => new Date(),
        validator: (value) => !Number.isNaN(+new Date(value))
      },
      disabledDate: {
        default: toFalse,
        isFunc: true
      },
      isRange: false,
      valueType: {
        default: "start",
        validator: (value) => value === "start" || value === "end"
      },
      min: null,
      max: null
    });
    const startValue = ref(null);
    const endValue = ref(null);
    const dateRange = ref([]);
    const hoveredDate = ref(null);
    const { wrapper, isHover } = useHover();
    const locale = useLocale("calendar");
    const min = computed(() => props.min ? +startOfDay(props.min) : -Infinity);
    const max = computed(() => props.max ? +endOfDay(props.max) : Infinity);
    const reversed = computed(() => {
      if (Number.isNaN(min.value) || Number.isNaN(max.value)) {
        return false;
      }
      return min.value > max.value;
    });
    const updateDateRange = debounceMinor(setDateRange);
    parseValue(props.value);
    setDateRange();
    watch(() => props.value, parseValue);
    watch(() => props.year, updateDateRange);
    watch(() => props.month, updateDateRange);
    watch(isHover, (value) => {
      if (!value) {
        hoveredDate.value = null;
      }
    });
    watch(hoveredDate, (value) => {
      emitEvent(props.onHover, value);
    });
    function getWeekLabel(index) {
      var _a;
      return ((_a = props.weekDays) == null ? void 0 : _a[index]) || locale.value[`week${index || 7}`];
    }
    function setDateRange() {
      dateRange.value = rangeDate(
        startOfWeek(new Date(props.year, props.month - 1, 1), props.weekStart),
        42
      );
    }
    function parseValue(value) {
      var _a;
      if (!Array.isArray(value)) {
        value = [value, value];
      }
      for (let i = 0; i < 2; ++i) {
        const date = new Date((_a = value[i]) != null ? _a : "");
        if (i === 0) {
          startValue.value = Number.isNaN(+date) ? null : date;
        } else {
          endValue.value = Number.isNaN(+date) ? null : date;
        }
        if (!props.isRange)
          break;
      }
    }
    function isSelected(date) {
      if (!date || !startValue.value && !endValue.value) {
        return false;
      }
      return !!(startValue.value && !differenceDays(date, startValue.value) || endValue.value && !differenceDays(date, endValue.value));
    }
    function disabledDate(date) {
      if (typeof props.disabledDate === "function") {
        if (props.disabledDate(date)) {
          return true;
        }
      }
      const time = date.getTime();
      if (reversed.value) {
        if (time > max.value && time < min.value) {
          return true;
        }
      } else {
        if (time < min.value || time > max.value) {
          return true;
        }
      }
      return false;
    }
    function isDisabled(date) {
      if (!props.isRange) {
        return disabledDate(date);
      }
      if (props.valueType === "end" && startValue.value && differenceDays(startValue.value, date) < 0) {
        return true;
      }
      if (props.valueType === "start" && endValue.value && differenceDays(date, endValue.value) < 0) {
        return true;
      }
      return disabledDate(date);
    }
    function isHovered(date) {
      if (!date || !hoveredDate.value) {
        return false;
      }
      return !differenceDays(date, hoveredDate.value);
    }
    function isPrevMonth(date) {
      const { year, month } = props;
      const dateYear = date.getFullYear();
      const dateMonth = date.getMonth();
      return dateYear < year || dateYear === year && dateMonth < month - 1;
    }
    function isNextMonth(date) {
      const { year, month } = props;
      const dateYear = date.getFullYear();
      const dateMonth = date.getMonth();
      return dateYear > year || dateYear === year && dateMonth > month - 1;
    }
    function isToday(date) {
      return differenceDays(date, props.today) === 0;
    }
    function handleClick(date) {
      if (!isDisabled(date)) {
        if (props.valueType) {
          startValue.value = date;
        } else {
          endValue.value = date;
        }
        emitEvent(props.onSelect, date);
        emit("update:value", date);
      }
    }
    function handleHover(date) {
      hoveredDate.value = isDisabled(date) ? null : date;
    }
    function isInRange(date) {
      var _a;
      if (!hoveredDate.value && !startValue.value && !endValue.value) {
        return false;
      }
      let min2;
      let max2;
      if (!hoveredDate.value && startValue.value && endValue.value) {
        const startTime = startValue.value.getTime();
        const endTime = endValue.value.getTime();
        min2 = Math.min(startTime, endTime);
        max2 = Math.max(startTime, endTime);
      } else if (hoveredDate.value) {
        if (!startValue.value && !endValue.value)
          return false;
        const hoveredTime = hoveredDate.value.getTime();
        if (!startValue.value || !endValue.value) {
          const selectedTime = ((_a = startValue.value) != null ? _a : endValue.value).getTime();
          min2 = Math.min(hoveredTime, selectedTime);
          max2 = Math.max(hoveredTime, selectedTime);
        } else {
          const startTime = startValue.value.getTime();
          const endTime = endValue.value.getTime();
          const minTime = Math.min(startTime, endTime);
          const maxTime = Math.max(startTime, endTime);
          min2 = Math.min(hoveredTime, minTime);
          max2 = Math.max(hoveredTime, maxTime);
        }
      } else {
        return false;
      }
      return date.getTime() >= min2 && date.getTime() <= max2;
    }
    return {
      props,
      nh: useNameHelper("calendar"),
      startValue,
      endValue,
      dateRange,
      hoveredDate,
      body: wrapper,
      getWeekLabel,
      isSelected,
      isHovered,
      isPrevMonth,
      isNextMonth,
      isDisabled,
      isToday,
      handleClick,
      handleHover,
      isInRange
    };
  }
});
const _hoisted_1 = ["onMouseenter"];
const _hoisted_2 = ["onClick", "onKeydown"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.nh.be("panel"), _ctx.nh.bs("vars"), _ctx.props.inherit && _ctx.nh.bem("panel", "inherit")])
  }, [
    renderSlot(_ctx.$slots, "header"),
    createElementVNode("div", {
      class: normalizeClass([_ctx.nh.be("row"), _ctx.nh.bem("row", "week")])
    }, [
      (openBlock(), createElementBlock(Fragment, null, renderList(7, (week) => {
        return createElementVNode("div", {
          key: week,
          class: normalizeClass([_ctx.nh.be("cell"), _ctx.nh.be("cell-week")])
        }, [
          renderSlot(_ctx.$slots, "week", {
            index: week - 1,
            label: _ctx.getWeekLabel((week - 1 + _ctx.props.weekStart) % 7),
            week: (week - 1 + _ctx.props.weekStart) % 7
          }, () => [
            createElementVNode("div", {
              class: normalizeClass(_ctx.nh.be("index"))
            }, toDisplayString(_ctx.getWeekLabel((week - 1 + _ctx.props.weekStart) % 7)), 3)
          ])
        ], 2);
      }), 64))
    ], 2),
    createElementVNode("div", {
      ref: "body",
      class: normalizeClass(_ctx.nh.be("body"))
    }, [
      (openBlock(), createElementBlock(Fragment, null, renderList(6, (row) => {
        return createElementVNode("div", {
          key: row,
          class: normalizeClass(_ctx.nh.be("row"))
        }, [
          (openBlock(), createElementBlock(Fragment, null, renderList(7, (cell) => {
            return createElementVNode("div", {
              key: (row - 1) * 7 + cell,
              class: normalizeClass(_ctx.nh.be("cell")),
              onMouseenter: ($event) => _ctx.handleHover(_ctx.dateRange[(row - 1) * 7 + cell - 1])
            }, [
              renderSlot(_ctx.$slots, "item", {
                selected: _ctx.isSelected(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                hovered: _ctx.isHovered(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                date: _ctx.dateRange[(row - 1) * 7 + cell - 1],
                isPrev: _ctx.isPrevMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                isNext: _ctx.isNextMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                isToday: _ctx.isToday(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                disabled: _ctx.isDisabled(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                inRange: _ctx.props.isRange && _ctx.isInRange(_ctx.dateRange[(row - 1) * 7 + cell - 1])
              }, () => [
                createElementVNode("div", {
                  class: normalizeClass({
                    [_ctx.nh.be("index")]: true,
                    [_ctx.nh.bem("index", "selected")]: _ctx.isSelected(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "prev")]: _ctx.isPrevMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "next")]: _ctx.isNextMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "today")]: _ctx.isToday(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "disabled")]: _ctx.isDisabled(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "in-range")]: _ctx.props.isRange && _ctx.isInRange(_ctx.dateRange[(row - 1) * 7 + cell - 1])
                  }),
                  tabindex: "0",
                  onClick: ($event) => _ctx.handleClick(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                  onKeydown: [
                    withKeys(withModifiers(($event) => _ctx.handleClick(_ctx.dateRange[(row - 1) * 7 + cell - 1]), ["prevent"]), ["enter"]),
                    withKeys(withModifiers(($event) => _ctx.handleClick(_ctx.dateRange[(row - 1) * 7 + cell - 1]), ["prevent"]), ["space"])
                  ]
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(_ctx.nh.be("index-inner"))
                  }, toDisplayString(_ctx.dateRange[(row - 1) * 7 + cell - 1].getDate()), 3)
                ], 42, _hoisted_2)
              ])
            ], 42, _hoisted_1);
          }), 64))
        ], 2);
      }), 64))
    ], 2),
    renderSlot(_ctx.$slots, "footer")
  ], 2);
}
var CalendarPanel = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { CalendarPanel as default };
