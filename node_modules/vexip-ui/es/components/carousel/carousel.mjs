import { defineComponent, ref, reactive, computed, watch, provide, toRef, onMounted, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, renderSlot, createVNode, createCommentVNode, withModifiers, Fragment, renderList } from "vue";
import "../icon/index.mjs";
import "../../common/config/src/index.mjs";
import { useHover, useSetTimeout } from "@vexip-ui/hooks";
import { debounceMinor } from "@vexip-ui/utils";
import { ArrowUp, ArrowDown, ArrowLeft, ArrowRight } from "@vexip-ui/icons";
import { carouselProps } from "./props.mjs";
import { CAROUSEL_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "Carousel",
  components: {
    Icon
  },
  props: carouselProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const props = useProps("carousel", _props, {
      active: {
        default: 0,
        static: true
      },
      viewSize: {
        default: 3,
        validator: (value) => value > 0
      },
      vertical: false,
      disabled: false,
      loop: false,
      arrow: {
        default: "outside",
        validator: (value) => ["outside", "inside", "none"].includes(value)
      },
      arrowTrigger: {
        default: "hover",
        validator: (value) => ["hover", "always"].includes(value)
      },
      autoplay: {
        default: false,
        validator: (value) => typeof value === "number" ? value > 500 : true
      },
      pointer: {
        default: "none",
        validator: (value) => ["outside", "inside", "none"].includes(value)
      },
      speed: 300,
      activeOffset: 0,
      height: null,
      ignoreHover: false
    });
    const nh = useNameHelper("carousel");
    const itemStates = ref(/* @__PURE__ */ new Set());
    const currentActive = ref(0);
    const isLocked = ref(false);
    const arrowActive = ref(props.arrowTrigger === "always");
    const listRect = reactive({
      width: 0,
      height: 0
    });
    const trackRect = reactive({
      width: 0,
      height: 0,
      offset: 0
    });
    const itemRect = reactive({
      width: 0,
      height: 0
    });
    const { wrapper, isHover } = useHover();
    const prev = ref();
    const next = ref();
    const isDisabled = computed(() => {
      return props.disabled || itemStates.value.size <= props.viewSize;
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("vertical")]: props.vertical,
        [nh.bm("disabled")]: isDisabled.value
      };
    });
    const style = computed(() => {
      return {
        height: props.vertical && props.height ? `${props.height}${typeof props.height === "number" ? "px" : ""}` : void 0
      };
    });
    const listStyle = computed(() => {
      return {
        width: listRect.width ? `${listRect.width}px` : void 0,
        height: listRect.height ? `${listRect.height}px` : void 0
      };
    });
    const trackStyle = computed(() => {
      return {
        width: trackRect.width ? `${trackRect.width}px` : void 0,
        height: trackRect.height ? `${trackRect.height}px` : void 0,
        transform: trackRect.offset ? `translate${props.vertical ? "Y" : "X"}(${trackRect.offset}px) translateZ(0)` : void 0,
        transitionDuration: isLocked.value ? "0ms" : `${props.speed}ms`
      };
    });
    const disabledPrev = computed(() => {
      return isDisabled.value || !props.loop && currentActive.value <= 0;
    });
    const disabledNext = computed(() => {
      return isDisabled.value || !props.loop && currentActive.value >= itemStates.value.size - props.viewSize;
    });
    const arrowIcons = computed(() => {
      return props.vertical ? [ArrowUp, ArrowDown] : [ArrowLeft, ArrowRight];
    });
    watch(
      () => props.active,
      (value) => {
        handleWheel(value - props.activeOffset);
      }
    );
    watch(currentActive, (value) => {
      const active = (value + props.activeOffset) % itemStates.value.size;
      emitEvent(props.onChange, active);
      emit("update:active", active);
    });
    watch(isHover, (value) => {
      if (props.ignoreHover)
        return;
      if (value) {
        handleMouseEnter();
      } else {
        handleMouseLeave();
      }
    });
    watch(() => props.viewSize, refresh);
    watch(() => props.autoplay, setAutoplay);
    const refreshLabels = debounceMinor(() => {
      Array.from(itemStates.value).forEach((item, index) => {
        item.label = index;
      });
    });
    const updateItemRect = debounceMinor(() => {
      itemStates.value.forEach((state) => {
        state.width = itemRect.width;
        state.height = itemRect.height;
      });
    });
    const updateListRect = debounceMinor(() => {
      trackRect.width = itemRect.width * itemStates.value.size;
      trackRect.height = itemRect.height * itemStates.value.size;
    });
    provide(
      CAROUSEL_STATE,
      reactive({
        vertical: toRef(props, "vertical"),
        increaseItem,
        decreaseItem,
        isItemActive,
        handleSelect
      })
    );
    let inTransition = false;
    let shouldReset = false;
    isLocked.value = true;
    let observer;
    onMounted(() => {
      computeItemRect();
      handleWheel(props.active - props.activeOffset);
      handleAfterMove();
      setTimeout(() => {
        isLocked.value = false;
        inTransition = false;
        setAutoplay();
      }, 0);
      window.addEventListener("resize", refresh);
      if (wrapper.value) {
        observer = new MutationObserver(() => {
          refresh();
        });
        observer.observe(wrapper.value, {
          attributes: true,
          childList: true,
          characterData: true,
          attributeFilter: ["style"]
        });
      }
    });
    onBeforeUnmount(() => {
      observer == null ? void 0 : observer.disconnect();
      observer = null;
      window.removeEventListener("resize", refresh);
    });
    function increaseItem(item) {
      itemStates.value.add(item);
      refreshLabels();
      updateItemRect();
      updateListRect();
    }
    function decreaseItem(item) {
      itemStates.value.delete(item);
      refreshLabels();
      updateListRect();
    }
    function isItemActive(label) {
      return (currentActive.value + props.activeOffset) % itemStates.value.size === label;
    }
    function computeItemRect() {
      if (!wrapper.value)
        return;
      let prevFix = 0;
      let nextFix = 0;
      if (props.arrow === "outside") {
        if (props.vertical) {
          prevFix = prev.value ? prev.value.offsetHeight : 0;
          nextFix = next.value ? next.value.offsetHeight : 0;
        } else {
          prevFix = prev.value ? prev.value.offsetWidth : 0;
          nextFix = next.value ? next.value.offsetWidth : 0;
        }
      }
      if (props.vertical) {
        listRect.width = 0;
        listRect.height = wrapper.value.offsetHeight - prevFix - nextFix;
        itemRect.width = 0;
        itemRect.height = listRect.height / props.viewSize;
      } else {
        listRect.width = wrapper.value.offsetWidth - prevFix - nextFix;
        listRect.height = 0;
        itemRect.width = listRect.width / props.viewSize;
        itemRect.height = 0;
      }
    }
    function refresh() {
      computeItemRect();
      updateItemRect();
      updateListRect();
      if (trackRect.offset > 0) {
        handlePrev(0);
      } else {
        handleNext(0);
      }
      setTimeout(() => {
        isLocked.value = false;
        inTransition = false;
      }, 0);
    }
    function handlePrev(amount = 1) {
      if (isDisabled.value || inTransition)
        return;
      const itemLength = props.vertical ? itemRect.height : itemRect.width;
      const itemList = Array.from(itemStates.value);
      const itemCount = itemList.length;
      const targetIndex = (currentActive.value - amount + itemCount) % itemCount;
      if (targetIndex >= itemCount - props.viewSize) {
        if (!props.loop)
          return;
        if (trackRect.offset < 0) {
          if (amount < currentActive.value) {
            trackRect.offset = -targetIndex * itemLength;
          } else {
            trackRect.offset = itemLength * (itemCount - targetIndex);
            for (let i = targetIndex; i < itemCount; ++i) {
              itemList[i].offset = -itemCount * itemLength;
            }
          }
        } else {
          for (let i = 0; i < itemCount; ++i) {
            itemList[i].offset = i < targetIndex ? 0 : -itemCount * itemLength;
          }
          trackRect.offset = itemLength * (itemCount - targetIndex);
        }
        currentActive.value = targetIndex;
      } else {
        currentActive.value = targetIndex;
        trackRect.offset = -currentActive.value * itemLength;
      }
      shouldReset = currentActive.value <= itemCount - props.viewSize;
      inTransition = true;
    }
    function handleNext(amount = 1) {
      if (isDisabled.value || inTransition)
        return;
      const itemLength = props.vertical ? itemRect.height : itemRect.width;
      const itemList = Array.from(itemStates.value);
      const itemCount = itemList.length;
      const targetIndex = currentActive.value + amount;
      if (targetIndex > itemStates.value.size - props.viewSize) {
        if (!props.loop)
          return;
        if (trackRect.offset > 0) {
          trackRect.offset = itemLength * (itemCount - targetIndex);
        } else {
          const anchorIndex = targetIndex + props.viewSize - itemCount;
          for (let i = 0, len = itemList.length; i < len; ++i) {
            itemList[i].offset = i < anchorIndex ? itemCount * itemLength : 0;
          }
          trackRect.offset = -targetIndex * itemLength;
        }
        currentActive.value = targetIndex % itemCount;
      } else {
        currentActive.value = targetIndex;
        trackRect.offset = -currentActive.value * itemLength;
      }
      shouldReset = currentActive.value <= itemCount - props.viewSize;
      inTransition = true;
    }
    function handleWheel(active) {
      if (isDisabled.value || inTransition || active === currentActive.value)
        return;
      const itemCount = itemStates.value.size;
      active = active % itemCount + (active < 0 ? itemCount : 0);
      if (props.loop) {
        let forward;
        let back;
        if (active > currentActive.value) {
          forward = active - currentActive.value;
          back = itemCount - active + currentActive.value;
        } else {
          forward = itemCount - currentActive.value + active;
          back = currentActive.value - active;
        }
        if (forward < back) {
          handleNext(forward);
        } else if (forward > back) {
          handlePrev(back);
        } else {
          if (trackRect.offset > 0) {
            handlePrev(forward);
          } else {
            handleNext(forward);
          }
        }
      } else {
        if (active < currentActive.value) {
          handlePrev(currentActive.value - active);
        } else {
          handleNext(active - currentActive.value);
        }
      }
    }
    function handleAfterMove() {
      if (!shouldReset) {
        inTransition = false;
      } else {
        itemStates.value.forEach((state) => {
          state.offset = 0;
        });
        shouldReset = false;
        isLocked.value = true;
        requestAnimationFrame(() => {
          trackRect.offset = -currentActive.value * (props.vertical ? itemRect.height : itemRect.width);
          requestAnimationFrame(() => {
            isLocked.value = false;
            inTransition = false;
          });
        });
      }
    }
    function handlePrevClick() {
      handlePrev(1);
      emitEvent(props.onPrev, (currentActive.value + props.activeOffset) % itemStates.value.size);
    }
    function handleNextClick() {
      handleNext(1);
      emitEvent(props.onNext, (currentActive.value + props.activeOffset) % itemStates.value.size);
    }
    function handleSelect(label) {
      emitEvent(props.onSelect, label);
    }
    const { timer } = useSetTimeout();
    function setAutoplay() {
      clearInterval(timer.play);
      if (!props.autoplay)
        return;
      let waiting = 4e3;
      if (typeof props.autoplay === "number") {
        waiting = props.autoplay;
      }
      timer.play = window.setInterval(() => {
        if (!props.loop && disabledNext.value) {
          handleWheel(0);
        } else {
          handleNext();
        }
      }, waiting);
    }
    function handleMouseEnter() {
      if (props.autoplay) {
        clearTimeout(timer.hover);
        timer.hover = setTimeout(() => {
          clearInterval(timer.play);
        }, 250);
      }
      if (props.arrowTrigger === "hover" && props.arrow === "inside") {
        arrowActive.value = true;
      }
    }
    function handleMouseLeave() {
      if (props.autoplay) {
        clearTimeout(timer.hover);
        timer.hover = setTimeout(() => {
          setAutoplay();
        }, 250);
      }
      if (props.arrowTrigger === "hover") {
        arrowActive.value = false;
      }
    }
    function isPointerDisabled(index) {
      if (props.loop)
        return false;
      return !(index >= props.activeOffset - 1 && index < itemStates.value.size - props.activeOffset - 1);
    }
    return {
      props,
      nh,
      itemStates,
      currentActive,
      arrowActive,
      className,
      style,
      listStyle,
      trackStyle,
      disabledPrev,
      disabledNext,
      arrowIcons,
      wrapper,
      prev,
      next,
      handlePrevClick,
      handleNextClick,
      handleWheel,
      handleAfterMove,
      isPointerDisabled,
      refresh
    };
  }
});
const _hoisted_1 = ["onClick"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    role: "list",
    style: normalizeStyle(_ctx.style)
  }, [
    createElementVNode("div", {
      style: normalizeStyle({
        position: "relative",
        display: "flex",
        flexDirection: _ctx.props.vertical ? "column" : "row",
        width: "100%"
      })
    }, [
      _ctx.props.arrow !== "none" ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "prev",
        class: normalizeClass([
          _ctx.nh.bem("arrow", _ctx.props.arrow),
          _ctx.nh.bem("arrow", "prev"),
          _ctx.arrowActive ? _ctx.nh.bem("arrow", "show") : ""
        ])
      }, [
        createElementVNode("div", {
          class: normalizeClass({
            [_ctx.nh.be("handler")]: true,
            [_ctx.nh.bem("handler", "disabled")]: _ctx.disabledPrev
          }),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handlePrevClick && _ctx.handlePrevClick(...args))
        }, [
          renderSlot(_ctx.$slots, "prev-arrow", { disabled: _ctx.disabledPrev }, () => [
            createVNode(_component_Icon, {
              icon: _ctx.arrowIcons[0],
              scale: 1.5
            }, null, 8, ["icon", "scale"])
          ])
        ], 2)
      ], 2)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("list")),
        style: normalizeStyle(_ctx.listStyle)
      }, [
        createElementVNode("div", {
          class: normalizeClass(_ctx.nh.be("track")),
          style: normalizeStyle(_ctx.trackStyle),
          onTransitionend: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleAfterMove && _ctx.handleAfterMove(...args), ["self"]))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 38)
      ], 6),
      _ctx.props.arrow !== "none" ? (openBlock(), createElementBlock("div", {
        key: 1,
        ref: "next",
        class: normalizeClass([
          _ctx.nh.bem("arrow", _ctx.props.arrow),
          _ctx.nh.bem("arrow", "next"),
          _ctx.arrowActive ? _ctx.nh.bem("arrow", "show") : ""
        ])
      }, [
        createElementVNode("div", {
          class: normalizeClass({
            [_ctx.nh.be("handler")]: true,
            [_ctx.nh.bem("handler", "disabled")]: _ctx.disabledNext
          }),
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleNextClick && _ctx.handleNextClick(...args))
        }, [
          renderSlot(_ctx.$slots, "next-arrow", { disabled: _ctx.disabledNext }, () => [
            createVNode(_component_Icon, {
              icon: _ctx.arrowIcons[1],
              scale: 1.5
            }, null, 8, ["icon", "scale"])
          ])
        ], 2)
      ], 2)) : createCommentVNode("", true)
    ], 4),
    _ctx.props.pointer !== "none" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.bem("pointers", _ctx.props.pointer))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.itemStates.size, (index) => {
        return openBlock(), createElementBlock("div", {
          key: index,
          class: normalizeClass({
            [_ctx.nh.be("pointer")]: true,
            [_ctx.nh.bem("pointer", "active")]: index - 1 === (_ctx.currentActive + _ctx.props.activeOffset) % _ctx.itemStates.size,
            [_ctx.nh.bem("pointer", "disabled")]: _ctx.isPointerDisabled(index - _ctx.props.activeOffset - 1)
          }),
          onClick: ($event) => _ctx.handleWheel(index - _ctx.props.activeOffset - 1)
        }, [
          renderSlot(_ctx.$slots, "pointer", {
            active: index - 1 === (_ctx.currentActive + _ctx.props.activeOffset) % _ctx.itemStates.size
          }, () => [
            createElementVNode("span", {
              class: normalizeClass(_ctx.nh.be("pointer-inner"))
            }, null, 2)
          ])
        ], 10, _hoisted_1);
      }), 128))
    ], 2)) : createCommentVNode("", true)
  ], 6);
}
var Carousel = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Carousel as default };
