import { defineComponent, ref, computed, watch, nextTick, onMounted, resolveComponent, openBlock, createBlock, normalizeClass, withCtx, withDirectives, createElementVNode, normalizeStyle, createElementBlock, renderSlot, createTextVNode, toDisplayString, withModifiers, createVNode, createCommentVNode, vShow } from "vue";
import "../button/index.mjs";
import "../icon/index.mjs";
import "../masker/index.mjs";
import "../../common/config/src/index.mjs";
import { useMoving } from "@vexip-ui/hooks";
import { toNumber, isPromise } from "@vexip-ui/utils";
import { Xmark } from "@vexip-ui/icons";
import { modalProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Button from "../button/button.mjs";
import Icon from "../icon/icon.mjs";
import Masker from "../masker/masker.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const positionValidator = (value) => {
  return value === "auto" || !Number.isNaN(parseFloat(value));
};
const positionProp = {
  default: "auto",
  validator: positionValidator
};
let idCount = 0;
const _sfc_main = defineComponent({
  name: "Modal",
  components: {
    Button,
    Icon,
    Masker,
    Xmark
  },
  props: modalProps,
  emits: ["update:active"],
  setup(_props, { slots, emit }) {
    const nh = useNameHelper("modal");
    const props = useProps("modal", _props, {
      transfer: false,
      active: {
        default: false,
        static: true
      },
      width: positionProp,
      height: positionProp,
      top: {
        default: 100,
        validator: positionValidator
      },
      left: positionProp,
      right: positionProp,
      bottom: positionProp,
      title: "",
      closable: true,
      inner: false,
      maskClose: true,
      modalClass: null,
      modalStyle: null,
      noFooter: false,
      hideMask: false,
      draggable: false,
      resizable: false,
      onBeforeClose: {
        default: null,
        isFunc: true
      },
      loading: false,
      minWidth: 150,
      minHeight: 120,
      transitionName: () => nh.ns("ease"),
      confirmText: null,
      cancelText: null,
      autoRemove: false
    });
    const currentActive = ref(props.active);
    const currentTop = ref(toNumber(props.top));
    const currentLeft = ref(toNumber(props.left));
    const currentWidth = ref(normalizeSizeValue(props.width));
    const currentHeight = ref(normalizeSizeValue(props.height));
    const idIndex = `${idCount++}`;
    let hasComputedTop = false;
    let hasComputedLeft = false;
    const wrapper = ref();
    const footer = ref();
    const { target: header, moving: dragging } = useMoving({
      onStart: (state, event) => {
        if (!props.draggable || event.button > 0) {
          return false;
        }
        state.xStart = currentLeft.value;
        state.yStart = currentTop.value;
        emitEvent(props.onDragStart, {
          top: currentTop.value,
          left: currentLeft.value
        });
      },
      onMove: (state) => {
        currentLeft.value = state.xEnd;
        currentTop.value = state.yEnd;
        emitEvent(props.onDragMove, {
          top: currentTop.value,
          left: currentLeft.value
        });
      },
      onEnd: () => {
        emitEvent(props.onDragEnd, {
          top: currentTop.value,
          left: currentLeft.value
        });
      }
    });
    const { target: resizer, moving: resizing } = useMoving({
      onStart: (state, event) => {
        var _a, _b, _c, _d;
        if (!props.resizable || event.button > 0) {
          return false;
        }
        let widthStart;
        let heightStart;
        let minHeight = 32;
        if (currentWidth.value === "auto") {
          widthStart = (_b = (_a = wrapper.value) == null ? void 0 : _a.offsetWidth) != null ? _b : 0;
        } else {
          widthStart = currentWidth.value;
        }
        if (currentHeight.value === "auto") {
          heightStart = (_d = (_c = wrapper.value) == null ? void 0 : _c.offsetHeight) != null ? _d : 0;
        } else {
          heightStart = currentHeight.value;
        }
        if (header.value) {
          minHeight += header.value.offsetHeight;
        }
        if (footer.value) {
          minHeight += footer.value.offsetHeight;
        }
        state.xStart = widthStart;
        state.yStart = heightStart;
        state.minHeight = Math.max(minHeight, props.minHeight);
        emitEvent(props.onResizeStart, {
          width: widthStart,
          height: heightStart
        });
      },
      onMove: (state) => {
        currentWidth.value = state.xEnd;
        currentHeight.value = state.yEnd;
        currentWidth.value = Math.max(props.minWidth, state.xEnd);
        currentHeight.value = Math.max(state.minHeight, state.yEnd);
        emitEvent(props.onResizeMove, {
          width: currentWidth.value,
          height: currentHeight.value
        });
      },
      onEnd: () => {
        emitEvent(props.onResizeEnd, {
          width: currentWidth.value,
          height: currentHeight.value
        });
      }
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inner")]: props.inner,
          [nh.bm("draggable")]: props.draggable,
          [nh.bm("resizable")]: props.resizable
        }
      ];
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        {
          [nh.bem("wrapper", "closable")]: props.closable,
          [nh.bem("wrapper", "dragging")]: dragging.value,
          [nh.bem("wrapper", "resizing")]: resizing.value
        },
        props.modalClass
      ];
    });
    const wrapperStyle = computed(() => {
      const fixedHeight = currentHeight.value !== "auto";
      return [
        props.modalStyle,
        {
          top: `${currentTop.value}px`,
          right: fixedHeight || !props.right || props.right === "auto" ? void 0 : `${props.right}px`,
          bottom: fixedHeight || !props.bottom || props.bottom === "auto" ? void 0 : `${props.bottom}px`,
          left: `${currentLeft.value}px`,
          width: `${currentWidth.value}px`,
          height: fixedHeight ? `${currentHeight.value}px` : void 0
        }
      ];
    });
    const hasTitle = computed(() => {
      return !!(slots.header || props.title);
    });
    const titleId = computed(() => `${nh.bs(idIndex)}__title`);
    const bodyId = computed(() => `${nh.bs(idIndex)}__body`);
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    watch(currentActive, (value) => {
      emitEvent(props.onToggle, value);
      emit("update:active", value);
      if (value) {
        nextTick(() => {
          computeTop();
          computeLeft();
        });
      }
    });
    watch(
      () => props.top,
      () => {
        hasComputedTop = false;
        currentActive.value && computeTop();
      }
    );
    watch(
      () => props.left,
      () => {
        hasComputedLeft = false;
        currentActive.value && computeLeft();
      }
    );
    watch(
      () => props.width,
      (value) => {
        currentWidth.value = normalizeSizeValue(value);
        computeLeft();
      }
    );
    watch(
      () => props.height,
      (value) => {
        currentHeight.value = normalizeSizeValue(value);
        computeTop();
      }
    );
    onMounted(() => {
      nextTick(() => {
        if (currentActive.value) {
          computeTop();
          computeLeft();
        }
      });
    });
    function normalizeSizeValue(value) {
      return value === "auto" ? "auto" : toNumber(value);
    }
    function findPositionalParent() {
      if (!wrapper.value)
        return document.body;
      let parentElement = wrapper.value.parentElement;
      while (parentElement && parentElement !== document.body) {
        if (getComputedStyle(parentElement).position !== "static") {
          return parentElement;
        }
        parentElement = parentElement.parentElement;
      }
      return parentElement;
    }
    function computeTop() {
      if (!wrapper.value || hasComputedTop)
        return;
      const currentHeight2 = wrapper.value.offsetHeight;
      if (props.top === "auto" && props.inner) {
        currentTop.value = (findPositionalParent().offsetHeight - currentHeight2) / 2;
      } else {
        currentTop.value = props.top === "auto" ? (window.innerHeight - currentHeight2) / 2 - 20 : toNumber(props.top);
      }
      hasComputedTop = true;
    }
    function computeLeft() {
      if (!wrapper.value || hasComputedLeft)
        return;
      const currentWidth2 = wrapper.value.offsetWidth;
      if (props.left === "auto" && props.inner) {
        currentLeft.value = (findPositionalParent().offsetWidth - currentWidth2) / 2;
      } else {
        currentLeft.value = props.left === "auto" ? (window.innerWidth - currentWidth2) / 2 : toNumber(props.left);
      }
      hasComputedLeft = true;
    }
    function handleConfirm() {
      handleClose(true);
      emitEvent(props.onConfirm);
    }
    function handleCancle() {
      handleClose(false);
      emitEvent(props.onCancel);
    }
    async function handleClose(isConfirm) {
      let result = true;
      if (typeof props.onBeforeClose === "function") {
        result = props.onBeforeClose(isConfirm);
        if (isPromise(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        nextTick(() => {
          currentActive.value = false;
          emitEvent(props.onClose);
        });
      }
      return result;
    }
    function handleShow() {
      emitEvent(props.onShow);
    }
    function handleHide() {
      emitEvent(props.onHide);
    }
    function handleMaskClose() {
      if (props.maskClose) {
        return handleClose(false);
      }
    }
    return {
      props,
      nh,
      locale: useLocale("modal"),
      currentActive,
      dragging,
      resizing,
      titleId,
      bodyId,
      className,
      wrapperClass,
      wrapperStyle,
      hasTitle,
      wrapper,
      header,
      footer,
      resizer,
      handleConfirm,
      handleCancle,
      handleClose,
      handleShow,
      handleHide,
      handleMaskClose
    };
  }
});
const _hoisted_1 = ["aria-modal", "aria-labelledby", "aria-describedby"];
const _hoisted_2 = ["id"];
const _hoisted_3 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button");
  const _component_Masker = resolveComponent("Masker");
  return openBlock(), createBlock(_component_Masker, {
    active: _ctx.currentActive,
    "onUpdate:active": _cache[2] || (_cache[2] = ($event) => _ctx.currentActive = $event),
    inherit: _ctx.props.inherit,
    class: normalizeClass(_ctx.className),
    inner: _ctx.props.inner,
    "transition-name": _ctx.props.transitionName,
    closable: _ctx.props.maskClose,
    disabled: _ctx.props.hideMask,
    "on-before-close": _ctx.handleMaskClose,
    transfer: _ctx.props.transfer,
    "auto-remove": _ctx.props.autoRemove,
    onShow: _ctx.handleShow,
    onHide: _ctx.handleHide
  }, {
    default: withCtx(({ show }) => [
      withDirectives(createElementVNode("section", {
        ref: "wrapper",
        class: normalizeClass(_ctx.wrapperClass),
        role: "dialog",
        style: normalizeStyle(_ctx.wrapperStyle),
        "aria-modal": show ? "true" : void 0,
        "aria-labelledby": _ctx.titleId,
        "aria-describedby": _ctx.bodyId
      }, [
        _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "header",
          class: normalizeClass(_ctx.nh.be("header"))
        }, [
          renderSlot(_ctx.$slots, "header", {}, () => [
            createElementVNode("div", {
              id: _ctx.titleId,
              class: normalizeClass(_ctx.nh.be("title"))
            }, [
              renderSlot(_ctx.$slots, "title", {}, () => [
                createTextVNode(toDisplayString(_ctx.props.title), 1)
              ])
            ], 10, _hoisted_2),
            _ctx.props.closable ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("close")),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleClose(false))
            }, [
              renderSlot(_ctx.$slots, "close", {}, () => [
                createVNode(_component_Icon, {
                  scale: 1.2,
                  label: "close"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_Xmark)
                  ]),
                  _: 1
                }, 8, ["scale"])
              ])
            ], 34)) : createCommentVNode("", true)
          ])
        ], 2)) : createCommentVNode("", true),
        createElementVNode("div", {
          id: _ctx.bodyId,
          class: normalizeClass(_ctx.nh.be("content")),
          style: normalizeStyle({
            overflow: _ctx.resizing ? "hidden" : void 0
          })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 14, _hoisted_3),
        !_ctx.props.noFooter ? (openBlock(), createElementBlock("div", {
          key: 1,
          ref: "footer",
          class: normalizeClass(_ctx.nh.be("footer"))
        }, [
          renderSlot(_ctx.$slots, "footer", {}, () => [
            createVNode(_component_Button, {
              inherit: "",
              text: "",
              size: "small",
              onClick: _ctx.handleCancle
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
              ]),
              _: 1
            }, 8, ["onClick"]),
            createVNode(_component_Button, {
              inherit: "",
              type: "primary",
              size: "small",
              loading: _ctx.props.loading,
              onClick: _ctx.handleConfirm
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
              ]),
              _: 1
            }, 8, ["loading", "onClick"])
          ])
        ], 2)) : createCommentVNode("", true),
        _ctx.props.resizable ? (openBlock(), createElementBlock("div", {
          key: 2,
          ref: "resizer",
          class: normalizeClass(_ctx.nh.be("resizer"))
        }, null, 2)) : createCommentVNode("", true)
      ], 14, _hoisted_1), [
        [vShow, show]
      ])
    ]),
    _: 3
  }, 8, ["active", "inherit", "class", "inner", "transition-name", "closable", "disabled", "on-before-close", "transfer", "auto-remove", "onShow", "onHide"]);
}
var Modal = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Modal as default };
