import { defineComponent, ref, watch, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode } from "vue";
import "../../common/config/src/index.mjs";
import { useModifier, useMoving } from "@vexip-ui/hooks";
import { toFixed, boundRange } from "@vexip-ui/utils";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "ColorPalette",
  props: {
    hue: {
      type: Number,
      default: 0,
      validator: (value) => {
        return value >= 0 && value <= 360;
      }
    },
    value: {
      type: Number,
      default: 1,
      validator: (value) => {
        return value >= 0 && value <= 1;
      }
    },
    saturation: {
      type: Number,
      default: 0,
      validator: (value) => {
        return value >= 0 && value <= 1;
      }
    }
  },
  emits: ["edit-start", "edit-end", "change"],
  setup(props, { emit }) {
    const currentTop = ref((1 - props.value) * 100);
    const currentLeft = ref(props.saturation * 100);
    let prevTop = currentTop.value;
    let prevLeft = currentLeft.value;
    let widthLimit;
    let heightLimit;
    let topStartAt;
    let leftStartAt;
    const { target: wrapper } = useModifier({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down || modifier.left || modifier.right) {
          event.preventDefault();
          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2;
          const sign = modifier.up || modifier.left ? -1 : 1;
          const delta = step * sign;
          if (modifier.up || modifier.down) {
            currentTop.value += delta;
          } else {
            currentLeft.value += delta;
          }
          verifyPosition();
          prevTop = currentTop.value;
          prevLeft = currentLeft.value;
          handleChange();
        }
      }
    });
    const { moving: editing } = useMoving({
      target: wrapper,
      onStart: (state, event) => {
        if (!wrapper.value || event.button > 0) {
          return false;
        }
        const rect = wrapper.value.getBoundingClientRect();
        const { top, left, width, height } = rect;
        widthLimit = width;
        heightLimit = height;
        currentTop.value = (topStartAt = state.clientY - top) / height * 100;
        currentLeft.value = (leftStartAt = state.clientX - left) / width * 100;
        verifyPosition();
        emit("edit-start");
        let changed = false;
        if (Math.abs(currentTop.value - prevTop) >= 0.01) {
          prevTop = currentTop.value;
          changed = true;
        }
        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {
          prevLeft = currentLeft.value;
          changed = true;
        }
        changed && handleChange();
      },
      onMove: (state) => {
        currentTop.value = (topStartAt + state.deltaY) / heightLimit * 100;
        currentLeft.value = (leftStartAt + state.deltaX) / widthLimit * 100;
        verifyPosition();
        handleChange();
      },
      onEnd: () => {
        emit("edit-end");
      }
    });
    watch(
      () => props.value,
      (value) => {
        currentTop.value = (1 - value) * 100;
        verifyPosition();
      },
      { immediate: true }
    );
    watch(
      () => props.saturation,
      (value) => {
        currentLeft.value = value * 100;
        verifyPosition();
      },
      { immediate: true }
    );
    function verifyPosition() {
      currentTop.value = toFixed(boundRange(currentTop.value, 0, 100), 3);
      currentLeft.value = toFixed(boundRange(currentLeft.value, 0, 100), 3);
    }
    function handleChange() {
      emit("change", {
        h: props.hue,
        s: currentLeft.value / 100,
        v: toFixed(1 - currentTop.value / 100, 3)
      });
    }
    return {
      nh: useNameHelper("color-picker"),
      currentTop,
      currentLeft,
      editing,
      wrapper
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("palette")),
    tabindex: "-1",
    style: normalizeStyle({
      backgroundColor: `hsl(${_ctx.hue}, 100%, 50%)`
    })
  }, [
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("saturation"))
    }, null, 2),
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("value"))
    }, null, 2),
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("palette-handler")),
      style: normalizeStyle({
        top: `${_ctx.currentTop}%`,
        left: `${_ctx.currentLeft}%`
      })
    }, [
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("palette-pointer"))
      }, null, 2)
    ], 6)
  ], 6);
}
var ColorPalette = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { ColorPalette as default };
