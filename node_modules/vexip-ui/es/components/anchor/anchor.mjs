import { defineComponent, ref, provide, reactive, watch, onMounted, onBeforeUnmount, getCurrentInstance, nextTick, isVNode, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, renderSlot, Fragment, renderList, createBlock, withCtx, createTextVNode, toDisplayString, createVNode, Transition, normalizeStyle, createCommentVNode } from "vue";
import "../anchor-link/index.mjs";
import "../../common/config/src/index.mjs";
import { isClient, isElement } from "@vexip-ui/utils";
import { anchorProps } from "./props.mjs";
import { animateScrollTo } from "./helper.mjs";
import { ANCHOR_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import AnchorLink from "./anchor-link.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
const _sfc_main = defineComponent({
  name: "Anchor",
  components: {
    AnchorLink
  },
  props: anchorProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const nh = useNameHelper("anchor");
    const props = useProps("anchor", _props, {
      active: {
        default: "",
        static: true
      },
      viewer: {
        default: null,
        static: true
      },
      offset: 8,
      marker: false,
      scrollDuration: 500,
      markerTransition: () => nh.ns("fade"),
      options: {
        default: () => [],
        static: true
      },
      bindHash: false,
      forceActive: false
    });
    const currentActive = ref(props.active);
    const animating = ref(false);
    const markerTop = ref(0);
    const linkStates = /* @__PURE__ */ new Set();
    const wrapper = ref();
    let timer;
    let isRawViewer = false;
    let container = null;
    let scroller = null;
    if (isClient && !currentActive.value && props.bindHash) {
      currentActive.value = decodeURIComponent(location.hash);
    }
    provide(
      ANCHOR_STATE,
      reactive({
        currentActive,
        increaseLink,
        decreaseLink,
        handleActive
      })
    );
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    watch(currentActive, (value) => {
      emitEvent(props.onChange, value);
      emit("update:active", value);
    });
    watch(() => props.viewer, updateContainer);
    onMounted(() => {
      updateContainer();
      computeMarkerPoisiton();
    });
    onBeforeUnmount(() => {
      removeListener();
      clearTimeout(timer);
    });
    function increaseLink(state) {
      linkStates.add(state);
      state.active = currentActive.value === state.to;
    }
    function decreaseLink(state) {
      linkStates.delete(state);
    }
    const instance = getCurrentInstance();
    function updateContainer() {
      removeListener();
      nextTick(() => {
        var _a, _b, _c, _d;
        const viewer = props.viewer;
        let _container = null;
        let refName = "scroll";
        if (typeof viewer === "string") {
          if (viewer.startsWith("ref:")) {
            refName = viewer.substring(4);
            refName = refName || "scroll";
          } else if (["window", "document", "body"].includes(viewer)) {
            _container = document.body;
          } else if (viewer === "root") {
            _container = instance.root;
          } else {
            _container = document.querySelector(viewer);
          }
        } else if (typeof viewer === "function") {
          _container = viewer();
        } else if (isElement(viewer)) {
          _container = viewer;
        }
        if (isElement(_container)) {
          isRawViewer = true;
        } else {
          isRawViewer = false;
        }
        if (!isRawViewer) {
          _container = _container;
          _container = isVNode(_container == null ? void 0 : _container.vnode) ? _container : instance.parent;
          while (_container) {
            const name = (_a = _container.type) == null ? void 0 : _a.name;
            if (name === "Scroll" || name === "NativeScroll") {
              scroller = _container.proxy;
              break;
            }
            const refTemp = (_b = _container.refs) == null ? void 0 : _b[refName];
            if (refTemp) {
              if (isElement(refTemp)) {
                isRawViewer = true;
                container = refTemp;
              } else {
                scroller = refTemp;
              }
              break;
            }
            _container = _container.parent;
          }
          if (scroller) {
            scroller.addScrollListener(handleContainerScroll);
            container = scroller.$el;
          } else if (!container) {
            isRawViewer = true;
            container = (_d = (_c = instance.parent) == null ? void 0 : _c.proxy) == null ? void 0 : _d.$el;
          }
          if (isRawViewer && container) {
            container.addEventListener("scroll", handleContainerScroll);
          }
        } else {
          container = _container;
          container.addEventListener("scroll", handleContainerScroll);
        }
      });
    }
    function computeCurrentLink(scrollTop) {
      if (!linkStates.size || !container)
        return;
      const containerTop = container.offsetTop;
      const offsetList = [];
      let offset = scrollTop + props.offset;
      if (isRawViewer) {
        offset += containerTop;
      }
      linkStates.forEach((state) => {
        const id = state.to;
        if (!id.startsWith("#"))
          return;
        const element = document.querySelector(id);
        if (element) {
          offsetList.push({
            link: id,
            offset: element.offsetTop
          });
        }
      });
      offsetList.sort((prev, next) => prev.offset - next.offset);
      offsetList.push({
        link: "",
        offset: Infinity
      });
      let currentLink = "";
      for (let i = 0, len = offsetList.length - 1; i < len; ++i) {
        const current = offsetList[i];
        const next = offsetList[i + 1];
        if (current.offset <= offset && next.offset > offset) {
          currentLink = current.link;
          break;
        }
      }
      currentActive.value = currentLink;
    }
    function handleContainerScroll(event) {
      if (animating.value)
        return;
      const scrollTop = isRawViewer ? event.target.scrollTop : event.clientY;
      computeCurrentLink(scrollTop);
      computeMarkerPoisiton();
    }
    function removeListener() {
      if (scroller) {
        scroller.removeScrollListener(handleContainerScroll);
        scroller = null;
      }
      if (container) {
        container.removeEventListener("scroll", handleContainerScroll);
      }
    }
    function handleActive(link) {
      if (!props.forceActive && link === currentActive.value || !link.startsWith("#") || link.length < 2) {
        return;
      }
      const element = document.querySelector(link);
      if (!element)
        return;
      clearTimeout(timer);
      animating.value = true;
      const elementTop = element.offsetTop;
      const duration = Math.max(props.scrollDuration, 0);
      if (isRawViewer && container) {
        const from = container.scrollTop;
        const to = Math.min(
          elementTop - container.offsetTop - props.offset,
          container.scrollHeight - container.offsetHeight
        );
        animateScrollTo(container, from, to, duration, () => {
          timer = setTimeout(() => {
            animating.value = false;
          }, 10);
        });
        computeCurrentLink(to);
        computeMarkerPoisiton();
      } else if (scroller) {
        const [min, max] = scroller.getYScrollLimit();
        const clientY = Math.max(Math.min(elementTop - props.offset, max), min);
        scroller.scrollTo(0, clientY, duration);
        timer = setTimeout(() => {
          animating.value = false;
        }, duration + 10);
        computeCurrentLink(clientY);
        computeMarkerPoisiton();
      } else {
        animating.value = false;
      }
      if (isClient && props.bindHash && location) {
        location.hash = encodeURIComponent(currentActive.value.replace(/^#/, ""));
      }
    }
    function computeMarkerPoisiton() {
      var _a, _b;
      const currentLink = Array.from(linkStates).find(
        (state) => state.to && state.to === currentActive.value
      );
      if (currentLink == null ? void 0 : currentLink.el) {
        const linkRect = currentLink.el.getBoundingClientRect();
        const wrapperTop = (_b = (_a = wrapper.value) == null ? void 0 : _a.getBoundingClientRect().top) != null ? _b : 0;
        markerTop.value = linkRect.top - wrapperTop + linkRect.height / 2 + 0.5;
      }
    }
    return {
      props,
      nh,
      currentActive,
      markerTop,
      wrapper
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AnchorLink = resolveComponent("AnchorLink");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass({
      [_ctx.nh.b()]: true,
      [_ctx.nh.bs("vars")]: true,
      [_ctx.nh.bm("inherit")]: _ctx.props.inherit,
      [_ctx.nh.bm("no-marker")]: !_ctx.props.marker
    })
  }, [
    createElementVNode("ul", {
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.options, (link) => {
          return openBlock(), createBlock(_component_AnchorLink, {
            key: link.to,
            to: link.to,
            title: link.title,
            children: link.children
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(link.label), 1)
            ]),
            _: 2
          }, 1032, ["to", "title", "children"]);
        }), 128))
      ])
    ], 2),
    createVNode(Transition, {
      appear: "",
      name: _ctx.props.markerTransition
    }, {
      default: withCtx(() => [
        _ctx.props.marker && _ctx.currentActive ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("marker")),
          style: normalizeStyle({ top: `${_ctx.markerTop}px` })
        }, [
          renderSlot(_ctx.$slots, "marker", {}, () => [
            createElementVNode("div", {
              class: normalizeClass(_ctx.nh.be("pointer"))
            }, null, 2)
          ])
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["name"])
  ], 2);
}
var Anchor = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Anchor as default };
