import { defineComponent, ref, computed, provide, nextTick, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, createVNode, createCommentVNode, createElementVNode, withCtx, normalizeStyle, Fragment, renderList, createBlock, renderSlot, createTextVNode, toDisplayString } from "vue";
import WheelItem from "./wheel-item.mjs";
import "../icon/index.mjs";
import "../scroll/index.mjs";
import "../form/index.mjs";
import { useDisplay, useModifier } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { USE_TOUCH, toFalse, debounceMinor, debounce, boundRange } from "@vexip-ui/utils";
import { AngleLeft, AngleUp, AngleRight, AngleDown } from "@vexip-ui/icons";
import { wheelProps } from "./props.mjs";
import { WHEEL_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import Scroll from "../scroll/scroll.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "Wheel",
  components: {
    WheelItem,
    Icon,
    Scroll
  },
  props: wheelProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = wrapper.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("wheel", _props, {
      state: createStateProp(state),
      horizontal: false,
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      candidate: {
        default: 2,
        validator: (value) => [0, 1, 2, 3].includes(value)
      },
      arrow: false,
      pointer: USE_TOUCH,
      options: {
        default: () => [],
        static: true
      },
      insertEmpty: false,
      disabled: () => disabled.value,
      loading: () => loading.value,
      loadingLock: false,
      disabledItem: {
        default: toFalse,
        isFunc: true
      }
    });
    const nh = useNameHelper("wheel");
    const items = ref(/* @__PURE__ */ new Set());
    const currentActive = ref(0);
    const wrapperWidth = ref(0);
    const wrapperHeight = ref(0);
    const targetWidth = ref(0);
    const targetHeight = ref(0);
    const horizontalPadding = ref(0);
    const verticalPadding = ref(0);
    const isInit = ref(false);
    const wrapper = useDisplay(displayInit);
    const scroll = ref();
    useModifier({
      target: wrapper,
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down) {
          event.preventDefault();
          modifier.up ? handlePrev() : handleNext();
        }
      }
    });
    const normalizedOptions = computed(() => {
      const options = props.options.map((option) => {
        if (typeof option === "object") {
          const { value, label, disabled: disabled2 = false } = option;
          return {
            value,
            label: label || String(value),
            disabled: disabled2,
            meta: option
          };
        }
        return { value: option, label: String(option), disabled: false, meta: option };
      });
      if (props.insertEmpty) {
        options.unshift({
          value: "",
          label: typeof props.insertEmpty === "string" ? props.insertEmpty : "-",
          disabled: false,
          meta: ""
        });
      }
      return options;
    });
    const itemList = computed(() => {
      return Array.from(items.value);
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(props.horizontal ? "horizontal" : "vertical"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading && props.loadingLock
        }
      ];
    });
    const listStyle = computed(() => {
      if (props.horizontal) {
        return {
          paddingRight: `${horizontalPadding.value}px`,
          paddingLeft: `${horizontalPadding.value}px`
        };
      }
      return {
        paddingTop: `${verticalPadding.value}px`,
        paddingBottom: `${verticalPadding.value}px`
      };
    });
    const maskStyle = computed(() => {
      if (props.horizontal) {
        return {
          width: horizontalPadding.value ? `${horizontalPadding.value}px` : void 0
        };
      }
      return {
        height: verticalPadding.value ? `${verticalPadding.value}px` : void 0
      };
    });
    const borderStyle = computed(() => {
      const style = {
        inset: props.horizontal ? `0 ${horizontalPadding.value - 1}px` : `${verticalPadding.value - 1}px 0`
      };
      if (props.horizontal) {
        style.borderTop = "0";
        style.borderBottom = "0";
      } else {
        style.borderRight = "0";
        style.borderLeft = "0";
      }
      return style;
    });
    const prevDisabled = computed(() => {
      return props.disabled || !itemList.value.slice(0, currentActive.value).some((item) => !isItemDisbaled(item));
    });
    const nextDisabled = computed(() => {
      return props.disabled || currentActive.value >= itemList.value.length - 1 || !itemList.value.slice(currentActive.value + 1, itemList.value.length).some((item) => !isItemDisbaled(item));
    });
    const prevIcon = computed(() => props.horizontal ? AngleLeft : AngleUp);
    const nextIcon = computed(() => props.horizontal ? AngleRight : AngleDown);
    provide(WHEEL_STATE, { increaseItem, decreaseItem });
    const updateActive = debounceMinor(() => {
      const active = Math.max(
        itemList.value.findIndex((item) => item.value === props.value),
        0
      );
      currentActive.value = findEnabledActive(active);
    });
    const computeSize = debounceMinor(() => {
      nextTick(() => {
        const horizontal = props.horizontal;
        itemList.value.forEach((item) => {
          if (item && item.el) {
            targetWidth.value = Math.max(targetWidth.value, item.el.offsetWidth);
            targetHeight.value = Math.max(targetHeight.value, item.el.offsetHeight);
          }
        });
        const candidate = props.candidate;
        const showCount = 2 * candidate + 1;
        wrapperWidth.value = showCount * targetWidth.value;
        wrapperHeight.value = showCount * targetHeight.value;
        horizontalPadding.value = candidate * targetWidth.value;
        verticalPadding.value = candidate * targetHeight.value;
        items.value.forEach((item) => {
          if (horizontal) {
            item.width = targetWidth.value;
          } else {
            item.height = targetHeight.value;
          }
        });
        setTimeout(() => {
          var _a;
          (_a = scroll.value) == null ? void 0 : _a.refresh();
        }, 0);
      });
    });
    const refreshScroll = debounce(() => {
      if (scroll.value) {
        let targetXScroll = 0;
        let targetYScroll = 0;
        if (props.horizontal) {
          targetXScroll = currentActive.value * targetWidth.value;
        } else {
          targetYScroll = currentActive.value * targetHeight.value;
        }
        nextTick(() => {
          var _a;
          (_a = scroll.value) == null ? void 0 : _a.scrollTo(targetXScroll, targetYScroll);
        });
      }
    }, 20);
    watch(
      () => props.value,
      () => {
        updateActive();
        refreshScroll();
      },
      { immediate: true }
    );
    watch(() => props.horizontal, computeSize);
    watch(currentActive, () => {
      refreshScroll();
      const item = itemList.value[currentActive.value];
      const value = item == null ? void 0 : item.value;
      setFieldValue(value);
      emitEvent(props.onChange, value, item == null ? void 0 : item.meta);
      emit("update:value", value);
      validateField();
    });
    watch(() => props.candidate, computeSize);
    function isItemDisbaled(item) {
      return item.disabled || props.disabledItem(item.value, item.meta);
    }
    function queryEnabledActive(active, step) {
      step = step / Math.abs(step);
      while (itemList.value[active].disabled) {
        active += step;
        if (active < 0 || active >= itemList.value.length)
          break;
      }
      return active;
    }
    function findEnabledActive(active, sign = 1) {
      if (itemList.value[active] && isItemDisbaled(itemList.value[active])) {
        active = queryEnabledActive(active, 1 * sign);
        if (sign > 0 ? active >= itemList.value.length : active < 0) {
          active = queryEnabledActive(boundRange(active, 0, itemList.value.length - 1), -1 * sign);
          if (sign > 0 ? active < 0 : active >= itemList.value.length)
            active = 0;
        }
      }
      return active;
    }
    function increaseItem(item) {
      items.value.add(item);
      computeSize();
      updateActive();
    }
    function decreaseItem(item) {
      items.value.delete(item);
      computeSize();
      updateActive();
    }
    function displayInit() {
      var _a;
      computeSize();
      (_a = scroll.value) == null ? void 0 : _a.refresh();
      nextTick(() => {
        isInit.value = true;
        updateActive();
        refreshScroll();
      });
    }
    function beforeScroll({ signX, signY }) {
      if (props.disabled || props.loading && props.loadingLock)
        return false;
      const sign = props.horizontal ? signX : signY;
      return !(sign < 0 && prevDisabled.value || sign > 0 && nextDisabled.value);
    }
    function handleScrollEnd({ clientX, clientY }) {
      const aboutActive = props.horizontal ? clientX / targetWidth.value : clientY / targetHeight.value;
      const active = Math.round(aboutActive);
      if (active !== currentActive.value) {
        currentActive.value = findEnabledActive(active, active > aboutActive ? 1 : -1);
      } else {
        refreshScroll();
      }
    }
    function handleWheel({
      sign,
      clientX,
      clientY
    }) {
      const active = props.horizontal ? Math.round(clientX / targetWidth.value) : Math.round(clientY / targetHeight.value);
      currentActive.value = findEnabledActive(active, sign);
    }
    function handlePrev() {
      if (!prevDisabled.value) {
        currentActive.value = findEnabledActive(currentActive.value - 1, -1);
        const item = itemList.value[currentActive.value];
        emitEvent(props.onPrev, item == null ? void 0 : item.value, item == null ? void 0 : item.meta);
      }
    }
    function handleNext() {
      if (!nextDisabled.value) {
        currentActive.value = findEnabledActive(currentActive.value + 1, 1);
        const item = itemList.value[currentActive.value];
        emitEvent(props.onNext, item == null ? void 0 : item.value, item == null ? void 0 : item.meta);
      }
    }
    return {
      props,
      nh,
      idFor,
      currentActive,
      isInit,
      targetWidth,
      targetHeight,
      wrapperWidth,
      wrapperHeight,
      normalizedOptions,
      itemList,
      className,
      listStyle,
      maskStyle,
      borderStyle,
      prevDisabled,
      nextDisabled,
      prevIcon,
      nextIcon,
      wrapper,
      scroll,
      isItemDisbaled,
      beforeScroll,
      handleWheel,
      handleScrollEnd,
      handlePrev,
      handleNext,
      refreshScroll
    };
  }
});
const _hoisted_1 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_WheelItem = resolveComponent("WheelItem");
  const _component_Scroll = resolveComponent("Scroll");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    tabindex: "0"
  }, [
    _ctx.props.arrow ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "prevArrow",
      class: normalizeClass([
        _ctx.nh.be("arrow"),
        _ctx.nh.bem("arrow", "prev"),
        _ctx.prevDisabled ? _ctx.nh.bem("arrow", "disabled") : ""
      ]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handlePrev && _ctx.handlePrev(...args))
    }, [
      createVNode(_component_Icon, { icon: _ctx.prevIcon }, null, 8, ["icon"])
    ], 2)) : createCommentVNode("", true),
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("scroll"))
    }, [
      createVNode(_component_Scroll, {
        ref: "scroll",
        inherit: "",
        "scroll-x": _ctx.props.horizontal ? _ctx.targetWidth * _ctx.currentActive : 0,
        "scroll-y": _ctx.props.horizontal ? 0 : _ctx.targetHeight * _ctx.currentActive,
        width: _ctx.props.horizontal ? _ctx.wrapperWidth : "100%",
        height: _ctx.props.horizontal ? "100%" : _ctx.wrapperHeight,
        pointer: _ctx.props.pointer,
        mode: _ctx.props.horizontal ? "horizontal" : "vertical",
        "delta-x": _ctx.targetWidth,
        "delta-y": _ctx.targetHeight,
        "on-before-scroll": _ctx.beforeScroll,
        onWheel: _ctx.handleWheel,
        onScrollEnd: _ctx.handleScrollEnd
      }, {
        default: withCtx(() => [
          createElementVNode("ul", {
            ref: "list",
            class: normalizeClass(_ctx.nh.be("list")),
            style: normalizeStyle(_ctx.listStyle)
          }, [
            _ctx.isInit ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.normalizedOptions, (option, index) => {
              return openBlock(), createBlock(_component_WheelItem, {
                key: index,
                value: option.value,
                disabled: option.disabled || _ctx.props.disabledItem(option.value, option),
                active: _ctx.currentActive === index,
                meta: option.meta
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {
                    option,
                    index
                  }, () => [
                    createTextVNode(toDisplayString(option.label), 1)
                  ])
                ]),
                _: 2
              }, 1032, ["value", "disabled", "active", "meta"]);
            }), 128)) : createCommentVNode("", true)
          ], 6)
        ]),
        _: 3
      }, 8, ["scroll-x", "scroll-y", "width", "height", "pointer", "mode", "delta-x", "delta-y", "on-before-scroll", "onWheel", "onScrollEnd"]),
      _ctx.props.candidate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createElementVNode("div", {
          class: normalizeClass([_ctx.nh.be("mask"), _ctx.nh.bem("mask", "top")]),
          style: normalizeStyle(_ctx.maskStyle)
        }, null, 6),
        createElementVNode("div", {
          class: normalizeClass([_ctx.nh.be("mask"), _ctx.nh.bem("mask", "bottom")]),
          style: normalizeStyle(_ctx.maskStyle)
        }, null, 6)
      ], 64)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass({
          [_ctx.nh.be("border")]: true,
          [_ctx.nh.bem("border", "active")]: _ctx.props.loading,
          [_ctx.nh.bem("border", "vertical")]: _ctx.props.horizontal
        }),
        style: normalizeStyle(_ctx.borderStyle)
      }, null, 6)
    ], 2),
    _ctx.props.arrow ? (openBlock(), createElementBlock("div", {
      key: 1,
      ref: "nextArrow",
      class: normalizeClass([
        _ctx.nh.be("arrow"),
        _ctx.nh.bem("arrow", "next"),
        _ctx.nextDisabled ? _ctx.nh.bem("arrow", "disabled") : ""
      ]),
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleNext && _ctx.handleNext(...args))
    }, [
      createVNode(_component_Icon, { icon: _ctx.nextIcon }, null, 8, ["icon"])
    ], 2)) : createCommentVNode("", true)
  ], 10, _hoisted_1);
}
var Wheel = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Wheel as default };
