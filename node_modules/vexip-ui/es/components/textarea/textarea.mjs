import { defineComponent, ref, computed, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, withKeys, createVNode, Transition, withCtx, createCommentVNode, renderSlot, createTextVNode, toDisplayString } from "vue";
import "../icon/index.mjs";
import "../form/index.mjs";
import { Spinner } from "@vexip-ui/icons";
import "../../common/config/src/index.mjs";
import { debounce, throttle } from "@vexip-ui/utils";
import { textareaProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const _sfc_main = defineComponent({
  name: "Textarea",
  components: {
    Icon
  },
  props: textareaProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = textarea.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("textarea", _props, {
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      placeholder: null,
      rows: 2,
      noResize: false,
      autofocus: false,
      spellcheck: false,
      autocomplete: false,
      readonly: false,
      disabled: () => disabled.value,
      debounce: false,
      maxLength: 0,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      sync: false
    });
    const nh = useNameHelper("textarea");
    const focused = ref(false);
    const currentValue = ref(props.value);
    const currentLength = ref(props.value ? props.value.length : 0);
    const textarea = ref();
    let lastValue = props.value;
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("focused")]: focused.value,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("loading")]: props.loading && props.loadingLock,
        [nh.bm("no-resize")]: props.noResize,
        [nh.bm(props.state)]: props.state !== "default"
      };
    });
    const isReadonly = computed(() => {
      return props.loading && props.loadingLock || props.readonly;
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
        lastValue = value;
      }
    );
    function handleFocus(event) {
      focused.value = true;
      emitEvent(props.onFocus, event);
    }
    function handleBlur(event) {
      focused.value = false;
      emitEvent(props.onBlur, event);
    }
    function handleChange(event) {
      const type = event.type;
      const value = event.target.value;
      if (props.maxLength && value.length > props.maxLength) {
        currentValue.value = value.slice(0, props.maxLength);
      } else {
        currentValue.value = value;
      }
      currentLength.value = currentValue.value.length;
      event.target.value = currentValue.value;
      if (type === "change") {
        if (lastValue === currentValue.value)
          return;
        lastValue = currentValue.value;
        setFieldValue(currentValue.value);
        emitEvent(props.onChange, currentValue.value);
        if (!props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      } else {
        emitEvent(props.onInput, currentValue.value);
        if (props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      }
    }
    function handleEnter() {
      emitEvent(props.onEnter);
    }
    function handleKeyDown(event) {
      emitEvent(props.onKeyDown, event);
    }
    function handleKeyPress(event) {
      emitEvent(props.onKeyPress, event);
    }
    function handleKeyUp(event) {
      emitEvent(props.onKeyUp, event);
    }
    function copyValue() {
      const textarea2 = document.createElement("textarea");
      textarea2.style.height = "0";
      textarea2.setAttribute("readonly", "readonly");
      textarea2.value = currentValue.value;
      document.body.appendChild(textarea2);
      textarea2.select();
      const isSuccess = document.execCommand("copy");
      document.body.removeChild(textarea2);
      return isSuccess;
    }
    return {
      props,
      nh,
      locale: useLocale("input"),
      idFor,
      currentValue,
      currentLength,
      className,
      isReadonly,
      textarea,
      handleFocus,
      handleBlur,
      handleInput: props.debounce ? debounce(handleChange) : throttle(handleChange),
      handleChange,
      handleEnter,
      handleKeyDown,
      handleKeyPress,
      handleKeyUp,
      copyValue
    };
  }
});
const _hoisted_1 = ["id"];
const _hoisted_2 = ["value", "rows", "autofocus", "autocomplete", "spellcheck", "disabled", "readonly", "placeholder", "maxlength"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    onClick: _cache[8] || (_cache[8] = ($event) => {
      var _a2;
      return (_a2 = _ctx.textarea) == null ? void 0 : _a2.focus();
    })
  }, [
    createElementVNode("textarea", {
      ref: "textarea",
      class: normalizeClass(_ctx.nh.be("control")),
      value: _ctx.currentValue,
      rows: _ctx.props.rows,
      autofocus: _ctx.props.autofocus,
      autocomplete: _ctx.props.autocomplete ? "on" : "off",
      spellcheck: _ctx.props.spellcheck,
      disabled: _ctx.props.disabled,
      readonly: _ctx.isReadonly,
      placeholder: (_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder,
      maxlength: _ctx.props.maxLength > 0 ? _ctx.props.maxLength : void 0,
      onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onKeyup: [
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.handleEnter && _ctx.handleEnter(...args), ["enter"])),
        _cache[3] || (_cache[3] = (...args) => _ctx.handleKeyUp && _ctx.handleKeyUp(...args))
      ],
      onKeypress: _cache[4] || (_cache[4] = (...args) => _ctx.handleKeyPress && _ctx.handleKeyPress(...args)),
      onKeydown: _cache[5] || (_cache[5] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args)),
      onInput: _cache[6] || (_cache[6] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
      onChange: _cache[7] || (_cache[7] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 42, _hoisted_2),
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("extra"))
    }, [
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("loading"))
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"]),
      _ctx.props.maxLength > 0 ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("count"))
      }, [
        renderSlot(_ctx.$slots, "count", { value: _ctx.currentValue }, () => [
          createTextVNode(toDisplayString(`${_ctx.currentLength}/${_ctx.props.maxLength}`), 1)
        ])
      ], 2)) : createCommentVNode("", true)
    ], 2)
  ], 10, _hoisted_1);
}
var Textarea = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Textarea as default };
