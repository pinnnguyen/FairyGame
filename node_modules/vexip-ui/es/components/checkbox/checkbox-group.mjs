import { defineComponent, ref, computed, provide, reactive, toRef, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, renderSlot, createBlock, withCtx, createTextVNode, toDisplayString, createCommentVNode, Fragment, renderList } from "vue";
import "./index.mjs";
import "../form/index.mjs";
import "../../common/config/src/index.mjs";
import { debounceMinor, isDefined, isObject } from "@vexip-ui/utils";
import { checkboxGroupProps } from "./props.mjs";
import { GROUP_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Checkbox from "./checkbox.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const _sfc_main = defineComponent({
  name: "CheckboxGroup",
  components: {
    Checkbox
  },
  props: checkboxGroupProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, size, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a, _b;
      return (_b = (_a = Array.from(inputSet)[0]) == null ? void 0 : _a.value) == null ? void 0 : _b.focus();
    });
    const props = useProps("checkboxGroup", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue([]),
        static: true
      },
      vertical: false,
      disabled: () => disabled.value,
      border: false,
      options: {
        default: () => [],
        static: true
      },
      loading: () => loading.value,
      control: null,
      loadingLock: false
    });
    const nh = useNameHelper("checkbox-group");
    const locale = useLocale("checkbox");
    const valueMap = /* @__PURE__ */ new Map();
    const inputSet = /* @__PURE__ */ new Set();
    const controlSet = /* @__PURE__ */ new Set();
    const currentValues = ref(props.value || []);
    const className = computed(() => {
      return [
        nh.b(),
        nh.ns("checkbox-vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("vertical")]: props.vertical,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading && props.loadingLock,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("border")]: props.border,
          [nh.bm(props.state)]: props.state !== "default"
        }
      ];
    });
    const controlLabel = computed(() => {
      return typeof props.control === "string" ? props.control : locale.value.all;
    });
    const updateValue = debounceMinor(() => {
      currentValues.value = [];
      valueMap.forEach((checked, value) => {
        if (checked) {
          currentValues.value.push(value);
        }
      });
      handleChange(currentValues.value);
    });
    const updateControl = debounceMinor(() => {
      const valueLength = currentValues.value.length;
      const checked = valueLength === valueMap.size;
      const partial = valueLength > 0 && !checked;
      controlSet.forEach((state2) => {
        state2.checked = checked;
        state2.partial = partial;
      });
    });
    provide(
      GROUP_STATE,
      reactive({
        currentValues,
        size: toRef(props, "size"),
        state: toRef(props, "state"),
        disabled: toRef(props, "disabled"),
        loading: toRef(props, "loading"),
        loadingLock: toRef(props, "loadingLock"),
        increaseItem,
        decreaseItem,
        increaseControl,
        decreaseControl,
        handleControlChange,
        setItemChecked,
        replaceValue
      })
    );
    watch(
      () => props.value,
      (value) => {
        const checkedValues = new Set(value);
        const allValues = Array.from(valueMap.keys());
        currentValues.value = [];
        allValues.forEach((value2) => {
          const checked = checkedValues.has(value2);
          valueMap.set(value2, checkedValues.has(value2));
          checked && currentValues.value.push(value2);
        });
      }
    );
    watch(currentValues, () => {
      updateControl();
    });
    function increaseItem(value, checked, input) {
      valueMap.set(value, checked);
      inputSet.add(input);
    }
    function decreaseItem(value, input) {
      valueMap.delete(value);
      inputSet.delete(input);
    }
    function increaseControl(state2) {
      controlSet.add(state2);
      updateControl();
    }
    function decreaseControl(state2) {
      controlSet.delete(state2);
    }
    function setItemChecked(value, checked) {
      if (!isDefined(value) || !valueMap.has(value))
        return;
      valueMap.set(value, checked);
      updateValue();
      updateControl();
    }
    function handleControlChange() {
      const allValues = Array.from(valueMap.keys());
      const checked = currentValues.value.length !== allValues.length;
      allValues.forEach((value) => {
        valueMap.set(value, checked);
      });
      updateValue();
      updateControl();
    }
    function handleChange(value) {
      setFieldValue(value);
      emitEvent(props.onChange, value);
      emit("update:value", value);
      validateField();
    }
    function replaceValue(prevValue, newValue) {
      if (isDefined(prevValue) && isDefined(newValue) && prevValue !== newValue && valueMap.has(prevValue)) {
        valueMap.set(newValue, valueMap.get(prevValue));
        valueMap.delete(prevValue);
      }
    }
    return {
      props,
      idFor,
      className,
      controlLabel,
      isObject,
      increaseControl,
      decreaseControl
    };
  }
});
const _hoisted_1 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    role: "group"
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      _ctx.props.control ? (openBlock(), createBlock(_component_Checkbox, {
        key: 0,
        inherit: "",
        control: ""
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.controlLabel), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.options, (item, index) => {
        return openBlock(), createElementBlock(Fragment, { key: index }, [
          _ctx.isObject(item) ? (openBlock(), createBlock(_component_Checkbox, {
            key: 0,
            inherit: "",
            value: item.value,
            control: item.control
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item.label || item.value), 1)
            ]),
            _: 2
          }, 1032, ["value", "control"])) : (openBlock(), createBlock(_component_Checkbox, {
            key: 1,
            inherit: "",
            value: item
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item), 1)
            ]),
            _: 2
          }, 1032, ["value"]))
        ], 64);
      }), 128))
    ])
  ], 10, _hoisted_1);
}
var CheckboxGroup = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { CheckboxGroup as default };
