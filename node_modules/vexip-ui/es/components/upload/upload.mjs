import { defineComponent, ref, computed, watch, onBeforeUnmount, createVNode, Fragment } from "vue";
import "../button/index.mjs";
import "../icon/index.mjs";
import "../upload-list/index.mjs";
import "../form/index.mjs";
import "../../common/config/src/index.mjs";
import { randomString, isDefined, isPromise, isFalse, noop, isClient } from "@vexip-ui/utils";
import { CloudArrowUp, Spinner, Upload as Upload$1, Plus } from "@vexip-ui/icons";
import { uploadProps } from "./props.mjs";
import { upload } from "./request.mjs";
import { StatusType, uploadListTypes } from "./symbol.mjs";
import Button from "../button/button.mjs";
import Icon from "../icon/icon.mjs";
import UploadList from "./upload-list.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
function getDefaultFileState() {
  return {
    id: randomString(),
    name: "",
    size: 0,
    type: "",
    base64: null,
    status: StatusType.PENDING,
    percentage: 0,
    source: null,
    url: null,
    path: "",
    xhr: null,
    response: null,
    error: null
  };
}
var Upload = defineComponent({
  name: "Upload",
  components: {
    Button,
    Icon,
    UploadList,
    CloudArrowUp
  },
  props: uploadProps,
  emits: ["update:file-list"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a, _b;
      if ((_a = button.value) == null ? void 0 : _a.$el) {
        button.value.$el.focus();
      } else {
        (_b = panel.value) == null ? void 0 : _b.focus();
      }
    });
    const props = useProps("upload", _props, {
      state: createStateProp(state),
      url: {
        default: "",
        static: true
      },
      fileList: {
        default: () => getFieldValue([]),
        static: true
      },
      multiple: false,
      tip: "",
      accept: null,
      filter: "",
      maxSize: {
        default: null,
        validator: (value) => value >= 0
      },
      field: "file",
      data: () => ({}),
      headers: () => ({}),
      withCredentials: false,
      manual: false,
      hiddenFiles: false,
      countLimit: {
        default: 0,
        validator: (value) => value >= 0
      },
      allowDrag: false,
      onBeforeUpload: {
        default: null,
        isFunc: true
      },
      onBeforeSelect: {
        default: null,
        isFunc: true
      },
      iconRenderer: {
        default: null,
        isFunc: true
      },
      selectToAdd: false,
      listType: {
        default: "name",
        validator: (value) => uploadListTypes.includes(value)
      },
      block: false,
      loadingText: null,
      directory: false,
      pathField: "path",
      disabledClick: false,
      buttonLabel: null,
      disabled: () => disabled.value,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      defaultFiles: () => [],
      listStyle: null
    });
    const nh = useNameHelper("upload");
    const locale = useLocale("upload");
    const fileStates = ref([]);
    const isDragOver = ref(false);
    const input = ref();
    const button = ref();
    const panel = ref();
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), nh.bm(`type-${props.listType}`), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.state)]: props.state !== "default",
        [nh.bm("multiple")]: props.multiple,
        [nh.bm("drag")]: props.allowDrag,
        [nh.bm("to-add")]: props.selectToAdd,
        [nh.bm("block")]: props.block,
        [nh.bm("drag-only")]: props.disabledClick,
        [nh.bm("image")]: props.image,
        [nh.bm("has-file")]: !props.hiddenFiles && renderFiles.value.length
      }];
    });
    const controlClass = computed(() => {
      if (props.image) {
        return {
          [nh.be("image-control")]: true,
          [nh.bem("image-control", "drag-over")]: isDragOver.value,
          [nh.bem("image-control", "disabled")]: props.disabled
        };
      }
      return {
        [nh.be("control")]: true,
        [nh.bem("control", "drag-over")]: isDragOver.value
      };
    });
    const acceptString = computed(() => {
      if (props.image)
        return "image/*";
      const accept = props.accept;
      return accept && (typeof accept === "string" ? accept : accept.join());
    });
    const defaultList = computed(() => props.defaultFiles.map((file) => createFileState(file)));
    const renderFiles = computed(() => {
      return defaultList.value.concat(fileStates.value).filter((item) => item.status !== StatusType.DELETE);
    });
    watch(() => props.fileList, (value) => {
      const idMap = /* @__PURE__ */ new Map();
      const fileMap = /* @__PURE__ */ new Map();
      for (const state2 of fileStates.value) {
        if (isDefined(state2.id)) {
          idMap.set(state2.id, state2);
        }
        if (state2.source) {
          fileMap.set(state2.source, state2);
        }
      }
      fileStates.value = (value || []).map((file) => createFileState(file, file.id ? idMap.get(file.id) : file.source ? fileMap.get(file.source) : void 0));
      syncInputFiles();
    }, {
      immediate: true,
      deep: true
    });
    expose({
      execute,
      handleDelete
    });
    function handleClick() {
      var _a;
      !props.disabledClick && ((_a = input.value) == null ? void 0 : _a.click());
    }
    function handleKeyDown(event) {
      const key = event.code || event.key;
      if (key === "Enter" || key === "Space") {
        handleClick();
      }
    }
    function handleInputChange(event) {
      const target = event.target;
      if (target == null ? void 0 : target.files) {
        handleFilesChange(target.files);
      }
    }
    async function handleFilesChange(inputFiles) {
      const originFiles = Array.from(inputFiles || []);
      const shouldAdd = props.selectToAdd;
      const files = shouldAdd ? Array.from(fileStates.value) : [];
      for (const file of originFiles) {
        if (!file.path) {
          file.path = file.webkitRelativePath;
        }
        let fileState = getFileStateBySource(file);
        if (fileState) {
          if (fileState.status !== StatusType.SUCCESS && fileState.status !== StatusType.UPLOADING) {
            fileState.status = StatusType.PENDING;
          }
        } else {
          fileState = createFileState({
            name: file.name,
            size: file.size,
            type: file.type,
            source: file
          });
        }
        if (typeof props.onBeforeSelect === "function") {
          let result = props.onBeforeSelect(fileState, files);
          if (isPromise(result)) {
            result = await result;
          }
          if (isFalse(result))
            continue;
        }
        if (!files.includes(fileState)) {
          files.push(fileState);
        }
      }
      const countLimit = props.countLimit;
      if (countLimit > 0 && files.length > countLimit) {
        const exceedFiles = files.slice(countLimit);
        emitEvent(props.onExceed, exceedFiles);
        fileStates.value = files.slice(0, countLimit);
      } else {
        fileStates.value = files;
      }
      syncInputFiles();
      emitChangeEvent();
      if (!props.manual) {
        execute();
      }
    }
    function emitChangeEvent() {
      setFieldValue(fileStates.value);
      emitEvent(props.onChange, fileStates.value);
      emit("update:file-list", fileStates.value);
      validateField();
    }
    function getFileStateBySource(file) {
      const {
        name,
        size: size2,
        type
      } = file;
      const path = file.path || file.webkitRelativePath;
      return fileStates.value.find(({
        source
      }) => {
        return source && (source.path || source.webkitRelativePath) === path && source.name === name && source.size === size2 && source.type === type;
      });
    }
    function createFileState(file, defaults = getDefaultFileState()) {
      var _a;
      const {
        id,
        name,
        size: size2,
        type,
        base64,
        status,
        percentage,
        source,
        url,
        path
      } = file;
      Object.assign(defaults, {
        id: (_a = id != null ? id : defaults.id) != null ? _a : randomString(),
        name: name || "",
        size: size2 || 0,
        type: type || "",
        base64: base64 || null,
        status: status != null ? status : StatusType.PENDING,
        percentage: percentage || 0,
        source: source || null,
        url: url || null,
        path: path || "",
        xhr: null,
        response: null,
        error: null
      });
      return defaults;
    }
    function getFileExtension(file) {
      return file.name.split(".").pop().toLocaleLowerCase();
    }
    async function execute() {
      if (!props.url || !verifyFiles()) {
        return false;
      }
      const uploadFiles = fileStates.value.filter((item) => item.status !== StatusType.SUCCESS && item.status !== StatusType.DELETE);
      const requests = [];
      for (const file of uploadFiles) {
        requests.push(uploadFile(file).catch(noop));
      }
      return await Promise.all(requests).then((responses) => responses.filter((response) => response));
    }
    async function uploadFile(file) {
      if (typeof props.onBeforeUpload === "function") {
        let result = props.onBeforeUpload(file, fileStates.value.filter((item) => item.status !== StatusType.SUCCESS && item.status !== StatusType.DELETE));
        if (isPromise(result)) {
          try {
            result = await result;
          } catch (e) {
            return;
          }
        }
        if (isFalse(result))
          return;
        if (result instanceof Blob) {
          if (result instanceof File) {
            file.source = result;
          } else {
            file.source = new File([result], file.name, {
              type: file.type
            });
          }
        }
      }
      if (!file.source)
        return;
      file.status = StatusType.UPLOADING;
      const {
        url,
        headers,
        withCredentials,
        data,
        field,
        pathField
      } = props;
      return await new Promise((resolve, reject) => {
        file.xhr = upload({
          url,
          headers,
          withCredentials,
          data,
          field,
          pathField,
          file: file.source,
          onProgress: (percent) => {
            handleProgress(percent, file);
          },
          onSuccess: (response) => {
            handleSuccess(response, file);
            resolve(response);
          },
          onError: (error) => {
            handleError(error, file);
            reject(error);
          },
          onAbort: () => {
            resolve(null);
          }
        });
      });
    }
    function verifyFiles() {
      const limitSize = props.maxSize ? props.maxSize * 1024 : Infinity;
      const filter = typeof props.filter === "string" ? props.filter ? [props.filter] : [] : props.filter.filter((item) => item);
      for (let i = 0, len = fileStates.value.length; i < len; ++i) {
        const file = fileStates.value[i];
        const extension = getFileExtension(file);
        if (filter.length && !filter.includes(extension)) {
          emitEvent(props.onFilterError, file);
          return false;
        }
        if (file.size > limitSize) {
          emitEvent(props.onSizeError, file);
          return false;
        }
      }
      return true;
    }
    function handleDelete(file) {
      file.status = StatusType.DELETE;
      if (file.xhr) {
        file.xhr.abort();
      }
      syncInputFiles();
      emitEvent(props.onDelete, file);
      emitChangeEvent();
    }
    function handlePreview(file) {
      emitEvent(props.onPreview, file);
    }
    function syncInputFiles() {
      if (!isClient)
        return;
      const dataTransfer = new DataTransfer();
      fileStates.value = fileStates.value.filter((item) => item.status !== StatusType.DELETE);
      fileStates.value.forEach((item) => {
        item.source && dataTransfer.items.add(item.source);
      });
      if (input.value) {
        input.value.files = dataTransfer.files;
      }
    }
    function handleProgress(percent, file) {
      if (file.status === StatusType.DELETE)
        return;
      file.percentage = percent;
      emitEvent(props.onProgress, file, percent);
      emitChangeEvent();
    }
    function handleSuccess(response, file) {
      if (file.status === StatusType.DELETE)
        return;
      file.status = StatusType.SUCCESS;
      file.response = response;
      file.error = null;
      emitEvent(props.onSuccess, file, response);
      emitChangeEvent();
    }
    function handleError(error, file) {
      if (file.status === StatusType.DELETE)
        return;
      file.status = StatusType.FAIL;
      file.error = error;
      emitEvent(props.onError, file, error);
      emitChangeEvent();
    }
    let dragTimer;
    onBeforeUnmount(() => {
      clearTimeout(dragTimer);
    });
    async function handleDrop(event) {
      if (!props.allowDrag)
        return;
      clearTimeout(dragTimer);
      event.preventDefault();
      isDragOver.value = false;
      if (event.dataTransfer) {
        const files = await collectDropFiles(event.dataTransfer);
        files.length && handleFilesChange(files);
      }
    }
    function handleDragEnter(event) {
      if (!props.allowDrag)
        return;
      clearTimeout(dragTimer);
      event.preventDefault();
      isDragOver.value = true;
    }
    function handleDragLeave(event) {
      if (!props.allowDrag)
        return;
      event.preventDefault();
      dragTimer = setTimeout(() => {
        isDragOver.value = false;
      }, 100);
    }
    async function collectDropFiles(dataTransfer) {
      var _a, _b;
      const {
        items,
        files
      } = dataTransfer;
      if (!items.length)
        return [];
      const collectedFiles = [];
      const dirLoop = [];
      const processes = [];
      for (let i = 0, len = items.length; i < len; ++i) {
        const entity = (_b = (_a = items[i]).webkitGetAsEntry) == null ? void 0 : _b.call(_a);
        if (!entity)
          return files;
        if (entity.isFile) {
          collectedFiles.push(files[i]);
        } else {
          dirLoop.push({
            dir: entity,
            prefix: ""
          });
        }
      }
      if (!props.directory || !dirLoop.length)
        return collectedFiles;
      const fileEntries = [];
      let countLimit = props.countLimit - (props.selectToAdd ? fileStates.value.length : 0);
      countLimit = Math.round(countLimit) > 0 ? countLimit : 100;
      const doProcess = () => {
        while (dirLoop.length) {
          const loop = dirLoop.shift();
          const dir = loop.dir;
          const prefix = loop.prefix ? `${loop.prefix}/${dir.name}` : dir.name;
          const reader = dir.createReader();
          processes.push(new Promise((resolve) => {
            reader.readEntries((entries) => {
              entries.forEach((entry) => {
                if (entry.isFile) {
                  fileEntries.push({
                    entry,
                    prefix
                  });
                } else {
                  dirLoop.push({
                    dir: entry,
                    prefix
                  });
                }
              });
              resolve();
            });
          }));
        }
      };
      while (true) {
        doProcess();
        await Promise.all(processes);
        if (!dirLoop.length || fileEntries.length >= countLimit) {
          break;
        }
      }
      if (fileEntries.length > 0) {
        return collectedFiles.concat(await Promise.all(fileEntries.map(({
          entry,
          prefix
        }) => new Promise((resolve) => entry.file((file) => {
          file.path = `${prefix}/${file.name}`;
          resolve(file);
        })))));
      }
      return collectedFiles;
    }
    function renderNormalAction() {
      return !props.allowDrag && !props.disabledClick ? createVNode(Fragment, null, [createVNode(Button, {
        "ref": button,
        "inherit": true,
        "size": size.value,
        "icon": Upload$1,
        "type": props.state,
        "disabled": props.disabled,
        "loading": props.loading,
        "loading-icon": props.loadingIcon,
        "loading-spin": props.loadingSpin
      }, {
        default: () => {
          var _a;
          return [(_a = props.buttonLabel) != null ? _a : locale.value.upload];
        }
      }), slots.tip ? slots.tip() : props.tip && createVNode("p", {
        "class": nh.be("tip")
      }, [props.tip])]) : createVNode("div", {
        "ref": panel,
        "class": [nh.be("drag-panel"), props.disabled && nh.bem("drag-panel", "disabled")],
        "tabindex": 0
      }, [createVNode(Icon, {
        "class": [nh.be("cloud"), props.disabled && nh.bem("cloud", "disabled")],
        "scale": 4
      }, {
        default: () => [createVNode(CloudArrowUp, null, null)]
      }), slots.tip ? slots.tip() : createVNode("p", {
        "class": nh.be("tip")
      }, [props.tip || locale.value.dragOrClick]), createVNode(Icon, {
        "class": nh.be("loading-icon"),
        "spin": props.loadingSpin,
        "pulse": !props.loadingSpin,
        "icon": props.loadingIcon,
        "style": {
          opacity: props.loading ? "100%" : "0%"
        }
      }, null)]);
    }
    function renderImageAction() {
      var _a;
      return createVNode("div", {
        "class": [nh.be("image-action"), props.disabled && nh.bem("image-action", "disabled")]
      }, [slots.default ? slots.default({
        isDragOver: (props.allowDrag || props.disabledClick) && isDragOver.value
      }) : createVNode(Fragment, null, [props.loading ? createVNode(Icon, {
        "class": nh.be("loading-icon"),
        "spin": props.loadingSpin,
        "pulse": !props.loadingSpin,
        "icon": props.loadingIcon,
        "style": {
          marginBottom: "6px"
        }
      }, null) : createVNode(Icon, {
        "class": [nh.be("cloud"), props.disabled && nh.bem("cloud", "disabled")],
        "scale": 1.2,
        "style": {
          marginBottom: "6px"
        }
      }, {
        default: () => [createVNode(Plus, null, null)]
      }), createVNode("span", null, [(_a = props.buttonLabel) != null ? _a : locale.value.upload])])]);
    }
    function renderControl() {
      const HtmlTag = props.image ? "li" : "div";
      return createVNode(HtmlTag, {
        "class": controlClass.value,
        "tabindex": -1,
        "onClick": handleClick,
        "onDrop": handleDrop,
        "onDragover": handleDragEnter,
        "onDragleave": handleDragLeave,
        "onKeydown": handleKeyDown
      }, {
        default: () => [!props.disabledClick && createVNode("input", {
          "ref": input,
          "type": "file",
          "class": nh.be("input"),
          "disabled": props.disabled,
          "multiple": props.multiple,
          "accept": acceptString.value,
          "webkitdirectory": props.directory,
          "onChange": handleInputChange
        }, null), props.image ? renderImageAction() : slots.default ? slots.default({
          isDragOver: (props.allowDrag || props.disabledClick) && isDragOver.value
        }) : renderNormalAction()]
      });
    }
    function renderFileList() {
      return createVNode(UploadList, {
        "inherit": true,
        "files": renderFiles.value,
        "select-to-add": props.selectToAdd,
        "type": props.image ? "thumbnail" : props.listType,
        "icon-renderer": props.iconRenderer,
        "loading-text": props.loadingText,
        "can-preview": props.canPreview,
        "style": props.listStyle,
        "onDelete": handleDelete,
        "onPreview": handlePreview
      }, {
        item: slots.item,
        icon: slots.icon,
        suffix: () => props.image && (!props.maxSize || renderFiles.value.length < props.maxSize) ? renderControl() : null
      });
    }
    return () => createVNode("div", {
      "id": idFor.value,
      "class": className.value
    }, [!props.image && renderControl(), !props.hiddenFiles && renderFileList()]);
  },
  methods: {
    execute: noop,
    handleDelete: noop
  }
});
export { Upload as default };
