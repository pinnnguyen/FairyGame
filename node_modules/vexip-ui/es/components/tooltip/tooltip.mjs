import { isVNode, createTextVNode, defineComponent, toRef, ref, computed, watch, createVNode, mergeProps, Fragment, Transition, withDirectives, vShow } from "vue";
import "../portal/index.mjs";
import "../../common/config/src/index.mjs";
import { placementWhileList, useClickOutside, usePopper, useListener, useSetTimeout } from "@vexip-ui/hooks";
import { isElement } from "@vexip-ui/utils";
import { tooltipProps } from "./props.mjs";
import Portal from "../portal/portal.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const TEXT_VNODE = createTextVNode("").type;
var Tooltip = defineComponent({
  name: "Tooltip",
  components: {
    Portal
  },
  inheritAttrs: true,
  props: tooltipProps,
  emits: ["update:visible"],
  setup(_props, {
    attrs,
    slots,
    emit,
    expose
  }) {
    const nh = useNameHelper("tooltip");
    const props = useProps("tooltip", _props, {
      trigger: {
        default: "hover",
        validator: (value) => ["hover", "click", "focus", "custom"].includes(value)
      },
      wrapper: false,
      noArrow: false,
      transitionName: () => nh.ns("fade"),
      visible: false,
      placement: {
        default: "top",
        validator: (value) => placementWhileList.includes(value)
      },
      outsideClose: true,
      noHover: false,
      tipClass: null,
      tipStyle: null,
      transfer: false,
      disabled: false,
      raw: false,
      delay: 250,
      tipAlive: false,
      reverse: false,
      width: "auto",
      virtual: null
    });
    const placement = toRef(props, "placement");
    const currentVisible = ref(props.visible);
    const rendering = ref(props.visible);
    const transfer = toRef(props, "transfer");
    const triggerWidth = ref(100);
    const originalTrigger = ref();
    const reference = computed(() => {
      var _a, _b;
      const virtual = (_b = (_a = props.virtual) == null ? void 0 : _a.$el) != null ? _b : props.virtual;
      if (virtual) {
        if ("getBoundingClientRect" in virtual) {
          return virtual;
        }
        if ("x" in virtual && "y" in virtual) {
          return {
            getBoundingClientRect: () => ({
              x: virtual.x,
              y: virtual.y,
              left: virtual.x,
              top: virtual.y,
              width: 0,
              height: 0
            })
          };
        }
      }
      return originalTrigger.value;
    });
    const trigger = computed(() => {
      return isElement(reference.value) ? reference.value : null;
    });
    useClickOutside(handleClickOutside, originalTrigger);
    const {
      popper,
      transferTo,
      updatePopper
    } = usePopper({
      placement,
      transfer,
      reference,
      wrapper: originalTrigger
    });
    const tipStyle = computed(() => {
      if (props.width === "auto") {
        return props.tipStyle;
      }
      if (props.width === "trigger") {
        return [{
          width: `${triggerWidth.value}px`
        }, props.tipStyle];
      }
      return [{
        width: `${props.width}px`
      }, props.tipStyle];
    });
    useListener(trigger, "mouseenter", handleTriggerEnter);
    useListener(trigger, "mouseleave", handleTriggerLeave);
    useListener(trigger, "click", handleTriggerClick);
    useListener(trigger, "focus", handleTriggerFocus);
    useListener(trigger, "blur", handleTriggerBlur);
    useListener(popper, "mouseenter", handleTriggerEnter);
    useListener(popper, "mouseleave", handleTriggerLeave);
    watch(() => props.visible, (value) => {
      currentVisible.value = value;
      if (value) {
        rendering.value = true;
        updatePopper();
      }
    });
    watch(() => props.disabled, (value) => {
      if (value) {
        toggleVisible(false);
      }
    });
    expose({
      toggleVisible,
      updatePopper
    });
    function toggleVisible(visible = !currentVisible.value) {
      currentVisible.value = visible;
      if (visible) {
        computeTriggerWidth();
        rendering.value = true;
        updatePopper();
      }
      emitEvent(props.onToggle, visible);
      emit("update:visible", visible);
    }
    function computeTriggerWidth() {
      if (!trigger.value)
        return;
      triggerWidth.value = trigger.value.offsetWidth;
    }
    const {
      timer
    } = useSetTimeout();
    function handleTriggerEnter() {
      if (props.disabled)
        return;
      if (props.trigger === "hover") {
        clearTimeout(timer.hover);
        timer.hover = setTimeout(() => {
          toggleVisible(true);
        }, 250);
      }
      emitEvent(props.onTipEnter);
    }
    function handleTriggerLeave() {
      if (props.disabled)
        return;
      if (props.trigger === "hover") {
        clearTimeout(timer.hover);
        timer.hover = setTimeout(() => {
          toggleVisible(false);
        }, 250);
      }
      emitEvent(props.onTipLeave);
    }
    function handleTriggerClick() {
      if (props.disabled)
        return;
      if (props.trigger === "click") {
        toggleVisible();
      }
    }
    function handleTriggerFocus() {
      if (props.disabled)
        return;
      if (props.trigger === "focus") {
        toggleVisible(true);
      }
    }
    function handleTriggerBlur() {
      if (props.disabled)
        return;
      if (props.trigger === "focus") {
        toggleVisible(false);
      }
    }
    function handleClickOutside() {
      if (props.disabled)
        return;
      emitEvent(props.onClickOutside);
      if (props.outsideClose && props.trigger !== "custom" && currentVisible.value) {
        toggleVisible(false);
        emitEvent(props.onOutsideClose);
      }
    }
    function syncTriggerRef(el) {
      if (el) {
        originalTrigger.value = el.nextElementSibling;
      } else {
        originalTrigger.value = void 0;
      }
    }
    function syncRendering() {
      rendering.value = currentVisible.value;
    }
    return () => {
      var _a;
      const CustomTag = props.wrapper ? props.wrapper === true ? "span" : props.wrapper : null;
      const triggers = (_a = slots.trigger) == null ? void 0 : _a.call(slots);
      const triggerVNode = triggers ? triggers[0] : null;
      const stopPropagation = (event) => {
        event.stopPropagation();
      };
      const renderTrigger = () => {
        if (!triggerVNode)
          return null;
        if (triggerVNode.type === TEXT_VNODE) {
          return CustomTag ? createVNode("span", null, [triggerVNode]) : createVNode("span", attrs, [triggerVNode]);
        }
        if (!CustomTag) {
          triggerVNode.props = mergeProps(triggerVNode.props || {}, attrs);
        }
        return triggerVNode;
      };
      return [triggerVNode && (CustomTag ? createVNode(CustomTag, mergeProps(attrs, {
        "ref": originalTrigger,
        "class": [nh.b(), nh.bs("vars"), props.inherit && nh.bm("inherit")]
      }), _isSlot(triggers) ? triggers : {
        default: () => [triggers]
      }) : createVNode(Fragment, {
        "ref": syncTriggerRef
      }, [renderTrigger()])), !props.disabled && createVNode(Portal, {
        "to": transferTo.value
      }, {
        default: () => [(props.tipAlive || rendering.value) && createVNode(Transition, {
          "appear": true,
          "name": props.transitionName
        }, {
          default: () => {
            var _a2;
            return [withDirectives(createVNode("div", {
              "ref": popper,
              "class": {
                [nh.be("popper")]: true,
                [nh.bs("vars")]: true,
                [nh.bem("popper", "inherit")]: transferTo.value !== "body",
                [nh.bem("popper", props.reverse ? "dark" : "light")]: true,
                [nh.bem("popper", "no-hover")]: props.noHover,
                [nh.bem("popper", "no-arrow")]: props.noArrow
              },
              "role": "tooltip",
              "tabindex": -1,
              "onClick": stopPropagation,
              "onAnimationend": syncRendering,
              "onTransitionend": syncRendering
            }, [createVNode("div", {
              "class": [!props.raw && nh.be("tip"), props.tipClass],
              "role": "tooltip",
              "style": tipStyle.value
            }, [!props.raw && !props.noArrow && createVNode("div", {
              "class": nh.be("arrow")
            }, null), (_a2 = slots.default) == null ? void 0 : _a2.call(slots)])]), [[vShow, currentVisible.value]])];
          }
        })]
      })];
    };
  }
});
export { Tooltip as default };
