import { defineComponent, ref, computed, toRef, watch, onMounted, getCurrentInstance, nextTick, onBeforeUnmount, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode } from "vue";
import "../../common/config/src/index.mjs";
import { isDefined, throttle, USE_TOUCH, boundRange } from "@vexip-ui/utils";
import { scrollbarProps } from "./props.mjs";
import { useTrack } from "./hooks.mjs";
import { ScrollbarType } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const scrollbarPlacements = Object.freeze(["top", "right", "bottom", "left"]);
const _sfc_main = defineComponent({
  name: "Scrollbar",
  props: scrollbarProps,
  emits: [],
  setup(_props) {
    const props = useProps("scrollbar", _props, {
      placement: {
        default: "right",
        validator: (value) => scrollbarPlacements.includes(value)
      },
      scroll: {
        default: 0,
        validator: (value) => value >= 0 && value <= 100,
        static: true
      },
      barLength: {
        default: 35,
        validator: (value) => value > 0 && value < 100
      },
      width: null,
      appear: false,
      fade: 1500,
      barColor: null,
      trackColor: null,
      disabled: false,
      wrapper: null,
      duration: null,
      useTrack: false,
      trackSpeed: {
        default: 2,
        validator: (value) => value > 0 && value < 10
      }
    });
    const nh = useNameHelper("scrollbar");
    const active = ref(false);
    const currentScroll = ref(props.scroll);
    const scrolling = ref(false);
    const contaniner = ref();
    const bar = ref();
    const track = ref();
    let fadeTimer;
    const type = computed(() => {
      return props.placement === "right" || props.placement === "left" ? ScrollbarType.VERTICAL : ScrollbarType.HORIZONTAL;
    });
    const { tracking, handleMouseDown: handleTrackMouseDown } = useTrack({
      currentScroll,
      track,
      bar,
      type,
      trackSpeed: toRef(props, "trackSpeed"),
      barLength: toRef(props, "barLength"),
      disabled: toRef(props, "disabled"),
      handleDown: (scroll) => {
        clearTimeout(fadeTimer);
        emitEvent(props.onScrollStart, scroll);
      },
      handleMove: () => clearTimeout(fadeTimer),
      handleUp: (scroll) => {
        setScrollbarFade();
        emitEvent(props.onScrollEnd, scroll);
      },
      handleScroll: (scroll) => {
        emitEvent(props.onScroll, scroll);
      }
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(props.placement),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("fade")]: props.fade,
          [nh.bm("scrolling")]: scrolling.value,
          [nh.bm("tracking")]: tracking.value,
          [nh.bm("active")]: active.value,
          [nh.bm("disabled")]: props.disabled
        }
      ];
    });
    const style = computed(() => {
      return {
        [nh.cv("bar-bg-color")]: props.barColor,
        [nh.cv("track-bg-color")]: props.trackColor,
        [nh.cv("width")]: props.width ? `${props.width}px` : null
      };
    });
    const barStyle = computed(() => {
      const style2 = {};
      const position = `${(100 - props.barLength) * currentScroll.value / props.barLength}%`;
      const length2 = `${props.barLength}%`;
      if (type.value === ScrollbarType.VERTICAL) {
        style2.height = length2;
        style2.transform = `translate3d(0, ${position}, 0)`;
      } else {
        style2.width = length2;
        style2.transform = `translate3d(${position}, 0, 0)`;
      }
      if (isDefined(props.duration) && props.duration >= 0) {
        style2.transitionDuration = `${props.duration}ms`;
      }
      return style2;
    });
    watch(
      () => props.scroll,
      (value) => {
        currentScroll.value = value;
      }
    );
    if (props.appear) {
      watch(currentScroll, () => {
        clearInterval(fadeTimer);
        active.value = true;
        if (!scrolling.value && !tracking.value) {
          setScrollbarFade();
        }
      });
    }
    const handleWrapperMouseMove = throttle(() => {
      clearTimeout(fadeTimer);
      if (props.disabled) {
        active.value = false;
      } else {
        active.value = true;
        if (!scrolling.value && !tracking.value) {
          setScrollbarFade();
        }
      }
    });
    let wrapperElement;
    onMounted(() => {
      let instance = getCurrentInstance();
      nextTick(() => {
        var _a, _b, _c, _d, _e;
        if (typeof props.wrapper === "string") {
          wrapperElement = document.querySelector(props.wrapper);
        } else {
          wrapperElement = props.wrapper;
        }
        if (!wrapperElement) {
          if (instance == null ? void 0 : instance.parent) {
            wrapperElement = (_a = instance.parent.proxy) == null ? void 0 : _a.$el;
            if (!wrapperElement) {
              wrapperElement = (_c = (_b = contaniner.value) == null ? void 0 : _b.parentElement) != null ? _c : null;
            }
          } else {
            wrapperElement = (_e = (_d = contaniner.value) == null ? void 0 : _d.parentElement) != null ? _e : null;
          }
        }
        if (wrapperElement && props.fade >= 300) {
          wrapperElement.addEventListener("mousemove", handleWrapperMouseMove);
        }
        instance = null;
        if (!props.appear) {
          watch(currentScroll, () => {
            clearInterval(fadeTimer);
            active.value = true;
            setScrollbarFade();
          });
        }
      });
    });
    onBeforeUnmount(() => {
      if (wrapperElement) {
        wrapperElement.removeEventListener("mousemove", handleWrapperMouseMove);
      }
      wrapperElement = null;
      clearTimeout(fadeTimer);
    });
    let length;
    let startAt;
    let cursorAt;
    function handleMouseDown(event) {
      if (event.button !== 0 || props.disabled) {
        return false;
      }
      event.stopPropagation();
      event.preventDefault();
      if (!track.value || !bar.value)
        return false;
      document.addEventListener("pointermove", handleMouseMove);
      document.addEventListener("pointerup", handleMouseUp);
      const rect = track.value.getBoundingClientRect();
      const barRect = bar.value.getBoundingClientRect();
      if (type.value === ScrollbarType.VERTICAL) {
        length = rect.height;
        startAt = barRect.top - rect.top;
        cursorAt = event.clientY;
      } else {
        length = rect.width;
        startAt = barRect.left - rect.left;
        cursorAt = event.clientX;
      }
      clearTimeout(fadeTimer);
      scrolling.value = true;
      emitEvent(props.onScrollStart, currentScroll.value);
    }
    const handleBarMove = throttle((event) => {
      let position;
      if (type.value === ScrollbarType.VERTICAL) {
        position = startAt + event.clientY - cursorAt;
      } else {
        position = startAt + event.clientX - cursorAt;
      }
      currentScroll.value = position / length / (100 - props.barLength) * 1e4;
      verifyScroll();
      emitEvent(props.onScroll, currentScroll.value);
    });
    function handleMouseMove(event) {
      event.stopPropagation();
      if (!USE_TOUCH) {
        event.preventDefault();
      }
      clearTimeout(fadeTimer);
      handleBarMove(event);
    }
    function handleMouseUp(event) {
      event.preventDefault();
      document.removeEventListener("pointermove", handleMouseMove);
      document.removeEventListener("pointerup", handleMouseUp);
      setScrollbarFade();
      scrolling.value = false;
      emitEvent(props.onScrollEnd, currentScroll.value);
    }
    function verifyScroll() {
      currentScroll.value = Math.max(0, Math.min(currentScroll.value, 100));
    }
    function setScrollbarFade() {
      if (props.fade >= 300) {
        fadeTimer = setTimeout(() => {
          active.value = false;
        }, props.fade);
      }
    }
    function handleScroll(scroll) {
      currentScroll.value = boundRange(scroll, 0, 100);
    }
    function disableEvent(event) {
      if (event.cancelable) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
    return {
      props,
      nh,
      currentScroll,
      className,
      style,
      barStyle,
      contaniner,
      bar,
      track,
      handleMouseDown,
      handleTrackMouseDown,
      handleScroll,
      disableEvent
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "contaniner",
    class: normalizeClass(_ctx.className),
    role: "scrollbar",
    style: normalizeStyle(_ctx.style)
  }, [
    createElementVNode("div", {
      ref: "track",
      class: normalizeClass([_ctx.nh.be("track"), _ctx.props.useTrack ? null : _ctx.nh.bem("track", "disabled")]),
      onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.disableEvent && _ctx.disableEvent(...args)),
      onPointerdown: _cache[1] || (_cache[1] = (...args) => _ctx.handleTrackMouseDown && _ctx.handleTrackMouseDown(...args))
    }, null, 34),
    createElementVNode("div", {
      ref: "bar",
      class: normalizeClass(_ctx.nh.be("bar")),
      style: normalizeStyle(_ctx.barStyle),
      onTouchstart: _cache[2] || (_cache[2] = (...args) => _ctx.disableEvent && _ctx.disableEvent(...args)),
      onPointerdown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args))
    }, null, 38)
  ], 6);
}
var Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Scrollbar as default };
