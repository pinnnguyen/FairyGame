import { defineComponent, ref, toRef, computed, watch, nextTick, resolveComponent, openBlock, createElementBlock, Fragment, createElementVNode, mergeProps, renderSlot, createBlock, withCtx, createVNode, Transition, withDirectives, normalizeClass, withModifiers, normalizeStyle, createTextVNode, toDisplayString, vShow, createCommentVNode } from "vue";
import "../portal/index.mjs";
import "../../common/config/src/index.mjs";
import { placementWhileList, usePopper, useSetTimeout } from "@vexip-ui/hooks";
import { getRangeWidth } from "@vexip-ui/utils";
import { ellipsisProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Portal from "../portal/portal.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps } from "../../common/config/src/props.mjs";
const _sfc_main = defineComponent({
  name: "Ellipsis",
  components: {
    Portal
  },
  props: ellipsisProps,
  setup(_props) {
    const nh = useNameHelper("ellipsis");
    const props = useProps("ellipsis", _props, {
      placement: {
        default: "top",
        validator: (value) => placementWhileList.includes(value)
      },
      transfer: "body",
      noHover: false,
      transitionName: () => nh.ns("fade"),
      tooltipTheme: {
        default: "dark",
        validator: (value) => ["light", "dark"].includes(value)
      },
      tipClass: null,
      maxLines: null,
      tipMaxWidth: 500
    });
    const tooltipNh = useNameHelper("tooltip");
    const visible = ref(false);
    const active = ref(false);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const content = ref("");
    const wrapper = ref();
    const { popper, transferTo, updatePopper } = usePopper({
      placement,
      transfer,
      wrapper,
      reference: wrapper
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("multiple")]: props.maxLines
      };
    });
    const ellipsisStyle = computed(() => {
      return props.maxLines > 0 ? { "-webkit-line-clamp": props.maxLines } : "";
    });
    const tipStyle = computed(() => {
      return {
        maxWidth: typeof props.tipMaxWidth === "string" ? parseFloat(props.tipMaxWidth) || props.tipMaxWidth : `${props.tipMaxWidth}px`
      };
    });
    watch(visible, (value) => {
      if (value) {
        updatePopper();
      }
    });
    const { timer } = useSetTimeout();
    function handleTriggerEnter() {
      clearTimeout(timer.hover);
      timer.hover = setTimeout(() => {
        var _a;
        if (!wrapper.value || !wrapper.value.childNodes.length) {
          visible.value = false;
          return;
        }
        if (props.maxLines > 0) {
          const scrollHeight = wrapper.value.scrollHeight;
          const clientHeight = wrapper.value.clientHeight;
          visible.value = scrollHeight > clientHeight;
        } else {
          visible.value = getRangeWidth(wrapper.value) > wrapper.value.getBoundingClientRect().width;
        }
        content.value = visible.value ? (_a = wrapper.value.textContent) != null ? _a : "" : "";
        nextTick(() => {
          active.value = true;
        });
      }, 250);
    }
    function handleTriggerLeave() {
      clearTimeout(timer.hover);
      timer.hover = setTimeout(() => {
        active.value = false;
      });
    }
    return {
      props,
      nh,
      tooltipNh,
      visible,
      active,
      content,
      transferTo,
      className,
      ellipsisStyle,
      tipStyle,
      wrapper,
      popper,
      handleTriggerEnter,
      handleTriggerLeave
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock(Fragment, null, [
    createElementVNode("div", mergeProps({
      ref: "wrapper",
      class: _ctx.className,
      style: _ctx.ellipsisStyle
    }, _ctx.$attrs, {
      onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
      onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
    }), [
      renderSlot(_ctx.$slots, "default")
    ], 16),
    _ctx.visible ? (openBlock(), createBlock(_component_Portal, {
      key: 0,
      to: _ctx.transferTo
    }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          appear: "",
          onAfterLeave: _cache[5] || (_cache[5] = ($event) => _ctx.visible = false)
        }, {
          default: withCtx(() => [
            withDirectives(createElementVNode("div", {
              ref: "popper",
              class: normalizeClass({
                [_ctx.tooltipNh.be("popper")]: true,
                [_ctx.tooltipNh.bs("vars")]: true,
                [_ctx.tooltipNh.bem("popper", "inherit")]: _ctx.transferTo !== "body",
                [_ctx.tooltipNh.bem("popper", _ctx.props.tooltipTheme)]: true,
                [_ctx.tooltipNh.bem("popper", "no-hover")]: _ctx.props.noHover
              }),
              onClick: _cache[2] || (_cache[2] = withModifiers(() => {
              }, ["stop"])),
              onMouseenter: _cache[3] || (_cache[3] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
              onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
            }, [
              createElementVNode("div", {
                class: normalizeClass([_ctx.nh.be("tip"), _ctx.tooltipNh.be("tip"), _ctx.props.tipClass]),
                style: normalizeStyle(_ctx.tipStyle)
              }, [
                createElementVNode("div", {
                  class: normalizeClass(_ctx.tooltipNh.be("arrow"))
                }, null, 2),
                createTextVNode(" " + toDisplayString(_ctx.content), 1)
              ], 6)
            ], 34), [
              [vShow, _ctx.active]
            ])
          ]),
          _: 1
        }, 8, ["name"])
      ]),
      _: 1
    }, 8, ["to"])) : createCommentVNode("", true)
  ], 64);
}
var Ellipsis = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Ellipsis as default };
