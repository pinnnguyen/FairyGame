import { defineComponent, ref, provide, computed, watch, nextTick, onMounted, onBeforeUnmount, toRef, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, withDirectives, createElementVNode, renderSlot, vShow, createBlock, withCtx, createVNode, Fragment, createCommentVNode } from "vue";
import TableHead from "./table-head.mjs";
import TableBody from "./table-body.mjs";
import "../scroll/index.mjs";
import "../scrollbar/index.mjs";
import "../../common/config/src/index.mjs";
import { debounce, isDefined, toNumber, nextFrameOnce, transformListToMap, removeArrayItem } from "@vexip-ui/utils";
import { useSetTimeout } from "@vexip-ui/hooks";
import { tableProps } from "./props.mjs";
import { useStore } from "./store.mjs";
import { DEFAULT_KEY_FIELD, TABLE_STORE, TABLE_ACTION } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Scroll from "../scroll/scroll.mjs";
import Scrollbar from "../scrollbar/scrollbar.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const _sfc_main = defineComponent({
  name: "Table",
  components: {
    Scroll,
    Scrollbar,
    TableHead,
    TableBody
  },
  props: tableProps,
  emits: [],
  setup(_props) {
    var _a;
    const props = useProps("table", _props, {
      columns: {
        default: () => [],
        static: true
      },
      data: {
        default: () => [],
        static: true
      },
      dataKey: DEFAULT_KEY_FIELD,
      width: null,
      height: null,
      rowClass: null,
      rowStyle: null,
      rowAttrs: null,
      stripe: false,
      border: false,
      highlight: false,
      useYBar: false,
      barFade: 1500,
      scrollDeltaY: 36,
      rowDraggable: false,
      rowHeight: null,
      rowMinHeight: {
        default: 36,
        validator: (value) => value > 0
      },
      virtual: false,
      bufferCount: {
        default: 5,
        validator: (value) => value >= 0
      },
      scrollClass: () => ({}),
      expandRenderer: {
        default: null,
        isFunc: true
      },
      currentPage: {
        default: 1,
        validator: (value) => value > 0,
        static: true
      },
      pageSize: 0,
      transparent: false,
      emptyText: null,
      tooltipTheme: {
        default: "dark",
        validator: (value) => ["light", "dark"].includes(value)
      },
      tooltipWidth: 500,
      singleSorter: false,
      singleFilter: false,
      cellClass: null,
      cellStyle: null,
      cellAttrs: null,
      headClass: null,
      headStyle: null,
      headAttrs: null
    });
    const nh = useNameHelper("table");
    const bodyHeight = ref(props.height);
    const xScrollPercent = ref(0);
    const yScrollPercent = ref(0);
    const headHeight = ref(0);
    const indicatorShow = ref(false);
    const templateColumns = ref(/* @__PURE__ */ new Set());
    const tableWidth = ref(null);
    const yScrollEnable = ref(false);
    const wrapper = ref();
    const thead = ref();
    const mainScroll = ref();
    const indicator = ref();
    const scrollbar = ref();
    const locale = useLocale("table");
    const store = useStore({
      columns: props.columns,
      data: props.data,
      rowClass: props.rowClass,
      rowStyle: props.rowStyle,
      rowAttrs: props.rowAttrs,
      cellClass: props.cellClass,
      cellStyle: props.cellStyle,
      cellAttrs: props.cellAttrs,
      headClass: props.headClass,
      headStyle: props.headStyle,
      headAttrs: props.headAttrs,
      dataKey: props.dataKey,
      highlight: props.highlight,
      currentPage: props.currentPage,
      pageSize: props.pageSize,
      rowHeight: props.rowHeight,
      rowMinHeight: props.rowMinHeight,
      virtual: props.virtual,
      rowDraggable: props.rowDraggable,
      emptyText: (_a = props.emptyText) != null ? _a : locale.value.empty,
      tooltipTheme: props.tooltipTheme,
      tooltipWidth: props.tooltipWidth,
      singleSorter: props.singleSorter,
      singleFilter: props.singleFilter,
      expandRenderer: props.expandRenderer
    });
    provide(TABLE_STORE, store);
    provide(TABLE_ACTION, {
      increaseColumn,
      decreaseColumn,
      emitRowEnter,
      emitRowLeave,
      emitRowClick,
      emitRowDblclick,
      emitRowContextmenu,
      emitRowCheck,
      emitAllRowCheck,
      emitRowExpand,
      emitRowFilter,
      emitRowSort,
      handleRowDragStart,
      handleRowDragOver,
      handleRowDrop,
      handleRowDragEnd,
      emitCellEnter,
      emitCellLeave,
      emitCellClick,
      emitCellDblclick,
      emitCellContextmenu,
      emitHeadEnter,
      emitHeadLeave,
      emitHeadClick,
      emitHeadDblclick,
      emitHeadContextmenu
    });
    const { state, getters, mutations } = store;
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("stripe")]: props.stripe,
        [nh.bm("border")]: props.border,
        [nh.bm("highlight")]: props.highlight,
        [nh.bm("use-y-bar")]: props.useYBar,
        [nh.bm("transparent")]: props.transparent,
        [nh.bm("virtual")]: props.virtual
      };
    });
    const style = computed(() => {
      var _a2;
      const width = (_a2 = tableWidth.value) != null ? _a2 : props.width;
      if (width !== null) {
        if (typeof width === "string" && parseFloat(width).toString() !== width) {
          return {
            width
          };
        }
        return {
          width: `${width}px`,
          minWidth: `${width}px`
        };
      }
      return {};
    });
    const useXScroll = computed(() => {
      return !!(props.width && (state.leftFixedColumns.length || state.rightFixedColumns.length));
    });
    const bodyScrollHeight = computed(() => {
      const { totalHeight } = state;
      if (Number.isNaN(totalHeight)) {
        return bodyHeight.value;
      }
      return bodyHeight.value ? Math.min(bodyHeight.value, totalHeight) : bodyHeight.value;
    });
    const barLength = computed(() => {
      const { totalHeight } = state;
      if (bodyScrollHeight.value && totalHeight) {
        return Math.max(Math.min(bodyScrollHeight.value / totalHeight * 100, 99), 5) || 35;
      }
      return 35;
    });
    const allColumns = computed(() => {
      return [...templateColumns.value].concat(props.columns);
    });
    const emptyText = computed(() => {
      var _a2;
      return (_a2 = props.emptyText) != null ? _a2 : locale.value.empty;
    });
    const {
      setColumns,
      setData,
      setPageSize,
      setRowClass,
      setHighlight,
      setCurrentPage,
      setTableWidth,
      setBodyScroll,
      setRenderRows,
      setGlobalRowHeight,
      setRowDraggable,
      setEmptyText,
      setTooltipTheme,
      setTooltipWidth,
      setSingleSorter,
      setSingleFilter,
      setDragging,
      clearSort,
      clearFilter,
      refreshRowIndex,
      clearCheckAll
    } = mutations;
    watch(
      allColumns,
      (value) => {
        setColumns(value);
      },
      { immediate: true, deep: true }
    );
    watch(
      () => props.data,
      (value) => {
        setPageSize(props.pageSize || value.length);
        setData(value);
        refreshPercentScroll();
      },
      { deep: true }
    );
    watch(() => props.width, computeTableWidth);
    watch(
      () => props.height,
      () => {
        nextTick(computeBodyHeight);
      }
    );
    watch(() => props.rowClass, setRowClass);
    watch(() => props.highlight, setHighlight);
    watch(() => props.currentPage, setCurrentPage);
    watch(() => props.pageSize, setPageSize);
    watch(() => props.rowHeight, setGlobalRowHeight);
    watch(() => props.rowDraggable, setRowDraggable);
    watch(emptyText, setEmptyText);
    watch(() => props.tooltipTheme, setTooltipTheme);
    watch(() => props.tooltipWidth, setTooltipWidth);
    watch(() => props.singleSorter, setSingleSorter);
    watch(() => props.singleFilter, setSingleFilter);
    function syncBarScroll() {
      var _a2;
      (_a2 = scrollbar.value) == null ? void 0 : _a2.handleScroll(yScrollPercent.value);
    }
    const handlerResize = debounce(refresh);
    onMounted(() => {
      watch(bodyScrollHeight, refreshPercentScroll);
      refresh();
      window.addEventListener("resize", handlerResize);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("resize", handlerResize);
    });
    function computeTableWidth() {
      const width = props.width;
      if (isDefined(width)) {
        if (typeof width === "string" && parseFloat(width).toString() !== width) {
          tableWidth.value = width;
          nextTick(() => {
            wrapper.value && setTableWidth(wrapper.value.offsetWidth);
          });
        } else {
          const numberWidth = toNumber(width);
          tableWidth.value = `${numberWidth}px`;
          setTableWidth(numberWidth);
        }
      } else {
        nextTick(() => {
          wrapper.value && setTableWidth(wrapper.value.offsetWidth);
        });
      }
    }
    function computeBodyHeight() {
      var _a2;
      const height = props.height;
      if (isDefined(height)) {
        const tableHead = (_a2 = thead.value) == null ? void 0 : _a2.$el;
        if (tableHead) {
          headHeight.value = tableHead.offsetHeight;
          bodyHeight.value = height - headHeight.value;
        } else {
          bodyHeight.value = height - (props.rowHeight || props.rowMinHeight);
        }
      } else {
        bodyHeight.value = void 0;
      }
    }
    function handleBodyScroll({ clientY, percentY }) {
      yScrollPercent.value = percentY;
      setBodyScroll(clientY);
      syncBarScroll();
      emitYScroll(clientY, percentY);
    }
    function handleXScroll({ percentX }) {
      xScrollPercent.value = percentX;
    }
    function handleYScrollEnableChange(able) {
      yScrollEnable.value = able;
    }
    function handleYBarScroll(percent) {
      var _a2;
      const { totalHeight } = state;
      const client = percent * (totalHeight - ((_a2 = bodyScrollHeight.value) != null ? _a2 : 0)) / 100;
      yScrollPercent.value = percent;
      setBodyScroll(client);
      nextFrameOnce(computeRenderRows);
      emitEvent(props.onBodyScroll, { client, percent });
    }
    function emitYScroll(client, percent) {
      nextFrameOnce(computeRenderRows);
      emitEvent(props.onBodyScroll, { client, percent });
    }
    function increaseColumn(column) {
      templateColumns.value.add(column);
    }
    function decreaseColumn(column) {
      templateColumns.value.delete(column);
    }
    function emitRowEnter(payload) {
      emitEvent(props.onRowEnter, payload);
    }
    function emitRowLeave(payload) {
      emitEvent(props.onRowLeave, payload);
    }
    function emitRowClick(payload) {
      emitEvent(props.onRowClick, payload);
    }
    function emitRowDblclick(payload) {
      emitEvent(props.onRowDblclick, payload);
    }
    function emitRowContextmenu(payload) {
      emitEvent(props.onRowContextmenu, payload);
    }
    function emitRowCheck(payload) {
      emitEvent(props.onRowCheck, payload);
    }
    function emitAllRowCheck(checked, partial) {
      emitEvent(props.onRowCheckAll, checked, partial);
    }
    function emitRowExpand(payload) {
      emitEvent(props.onRowExpand, payload);
    }
    function emitRowFilter() {
      const { columns, filters } = state;
      const columnMap = transformListToMap(columns, "key");
      const profiles = Object.keys(filters).filter((key) => filters[key].active).map((key) => {
        const column = columnMap[key];
        return {
          name: column.name,
          key: column.key,
          metaData: column.metaData,
          active: filters[key].active
        };
      });
      emitEvent(
        props.onRowFilter,
        profiles,
        getters.filteredData.map((row) => row.data)
      );
    }
    function emitRowSort() {
      const { columns, sorters } = state;
      const columnMap = transformListToMap(columns, "key");
      const profiles = Object.keys(sorters).filter((key) => sorters[key].type).map((key) => {
        const column = columnMap[key];
        return {
          name: column.name,
          key: column.key,
          metaData: column.metaData,
          type: sorters[key].type
        };
      });
      emitEvent(
        props.onRowSort,
        profiles,
        getters.sortedData.map((row) => row.data)
      );
    }
    let dragState;
    function handleRowDragStart(rowInstance, event) {
      dragState = {
        draggingRow: rowInstance.row,
        tableRect: wrapper.value.getBoundingClientRect()
      };
      setDragging(true);
      emitEvent(props.onRowDragStart, rowInstance.row.data, event);
    }
    function handleRowDragOver(rowInstance, event) {
      if (!dragState || !rowInstance.el)
        return;
      const dropRowRect = rowInstance.el.getBoundingClientRect();
      const tableRect = dragState.tableRect;
      const prevPercent = 0.5;
      const distance = event.clientY - dropRowRect.top;
      const dropRowHeight = dropRowRect.height;
      let dropType = "none";
      let indicatorTop = -9999;
      if (distance < dropRowHeight * prevPercent) {
        dropType = "before";
        indicatorTop = dropRowRect.top - tableRect.top;
      } else {
        dropType = "after";
        indicatorTop = dropRowRect.bottom - tableRect.top;
      }
      indicator.value.style.top = `${indicatorTop - 2}px`;
      dragState.dropType = dropType;
      indicatorShow.value = true;
      emitEvent(props.onRowDragOver, rowInstance.row.data, event);
    }
    function handleRowDrop(rowInstance, event) {
      if (!dragState)
        return;
      const { draggingRow, dropType } = dragState;
      const willDropRow = rowInstance.row;
      if (draggingRow.key === willDropRow.key)
        return;
      const rowData = state.rowData;
      let index = rowData.findIndex((row) => row.key === willDropRow.key);
      if (~index) {
        const originIndex = rowData.findIndex((row) => row.key === draggingRow.key);
        removeArrayItem(rowData, (row) => row.key === draggingRow.key);
        if (originIndex > index && dropType === "after") {
          index += 1;
        } else if (originIndex < index && dropType === "before") {
          index -= 1;
        }
        rowData.splice(index, 0, draggingRow);
        refreshRowIndex();
        emitEvent(props.onRowDrop, rowInstance.row.data, dropType, event);
      }
    }
    function handleRowDragEnd(event) {
      if (!dragState)
        return;
      const { draggingRow } = dragState;
      dragState = null;
      indicatorShow.value = false;
      setDragging(false);
      emitEvent(
        props.onRowDragEnd,
        draggingRow.data,
        state.rowData.map((row) => row.data),
        event
      );
    }
    function emitCellEnter(payload) {
      emitEvent(props.onCellEnter, payload);
    }
    function emitCellLeave(payload) {
      emitEvent(props.onCellLeave, payload);
    }
    function emitCellClick(payload) {
      emitEvent(props.onCellClick, payload);
    }
    function emitCellDblclick(payload) {
      emitEvent(props.onCellDblclick, payload);
    }
    function emitCellContextmenu(payload) {
      emitEvent(props.onCellContextmenu, payload);
    }
    function emitHeadEnter(payload) {
      emitEvent(props.onHeadEnter, payload);
    }
    function emitHeadLeave(payload) {
      emitEvent(props.onHeadLeave, payload);
    }
    function emitHeadClick(payload) {
      emitEvent(props.onHeadClick, payload);
    }
    function emitHeadDblclick(payload) {
      emitEvent(props.onHeadDblclick, payload);
    }
    function emitHeadContextmenu(payload) {
      emitEvent(props.onHeadContextmenu, payload);
    }
    function computeRenderRows() {
      const { totalHeight, bodyScroll, heightBITree } = state;
      const { processedData } = getters;
      const rowCount = processedData.length;
      if (!props.virtual) {
        setRenderRows(0, rowCount);
        return;
      }
      const viewHeight = Math.min(bodyHeight.value || 0, bodyScrollHeight.value || 0);
      if (!viewHeight) {
        setRenderRows(0, 0);
      }
      let viewStart = bodyScroll;
      let viewEnd = bodyScroll + viewHeight;
      if (viewEnd > totalHeight) {
        viewEnd = totalHeight;
        viewStart = viewEnd - viewHeight;
      }
      const start = heightBITree.boundIndex(viewStart);
      const end = heightBITree.boundIndex(viewEnd);
      const renderStart = Math.max(start - props.bufferCount, 0);
      const renderEnd = Math.min(end + props.bufferCount + 1, rowCount);
      setRenderRows(renderStart, renderEnd);
    }
    function refresh() {
      setTimeout(() => {
        computeTableWidth();
        computeBodyHeight();
        refreshPercentScroll();
        nextFrameOnce(computeRenderRows);
      }, 0);
    }
    function syncVerticalScroll() {
      if (mainScroll.value) {
        setBodyScroll(-mainScroll.value.currentScroll.y);
      }
    }
    const { timer } = useSetTimeout();
    function refreshPercentScroll() {
      clearTimeout(timer.scroll);
      timer.scroll = setTimeout(() => {
        var _a2;
        const { totalHeight, bodyScroll } = state;
        yScrollPercent.value = Math.max(
          Math.min(bodyScroll / (totalHeight - ((_a2 = bodyScrollHeight.value) != null ? _a2 : 0) || 1) * 100, 100),
          0
        );
        syncBarScroll();
        nextTick(computeBodyHeight);
        nextFrameOnce(computeRenderRows);
      }, 10);
    }
    function getSelected() {
      const data = state.rowData;
      const selectedData = [];
      for (let i = 0, len = data.length; i < len; ++i) {
        const row = data[i];
        if (row.checked) {
          selectedData.push(row.data);
        }
      }
      return selectedData;
    }
    return {
      props,
      nh,
      bodyHeight,
      xScrollPercent,
      yScrollPercent,
      headHeight,
      indicatorShow,
      leftFixedColumns: toRef(state, "leftFixedColumns"),
      rightFixedColumns: toRef(state, "rightFixedColumns"),
      bodyScroll: toRef(state, "bodyScroll"),
      className,
      style,
      useXScroll,
      barLength,
      bodyScrollHeight,
      totalHeight: toRef(state, "totalHeight"),
      store,
      wrapper,
      thead,
      mainScroll,
      indicator,
      scrollbar,
      handleBodyScroll,
      handleXScroll,
      handleYScrollEnableChange,
      handleYBarScroll,
      syncVerticalScroll,
      clearSort,
      clearFilter,
      clearSelected: clearCheckAll,
      refresh,
      getSelected
    };
  }
});
const _hoisted_1 = ["aria-rowcount"];
const _hoisted_2 = { role: "none" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TableHead = resolveComponent("TableHead");
  const _component_TableBody = resolveComponent("TableBody");
  const _component_Scroll = resolveComponent("Scroll");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    role: "table",
    style: normalizeStyle(_ctx.style),
    "aria-rowcount": _ctx.props.data.length
  }, [
    withDirectives(createElementVNode("div", _hoisted_2, [
      renderSlot(_ctx.$slots, "default")
    ], 512), [
      [vShow, false]
    ]),
    _ctx.useXScroll ? (openBlock(), createBlock(_component_Scroll, {
      key: 0,
      inherit: "",
      "use-x-bar": "",
      mode: "horizontal",
      class: normalizeClass([_ctx.nh.be("wrapper"), _ctx.props.scrollClass.horizontal]),
      "bar-class": _ctx.nh.bem("bar", "horizontal"),
      width: _ctx.props.width,
      "bar-fade": _ctx.props.barFade,
      "delta-x": 50,
      onScroll: _ctx.handleXScroll
    }, {
      default: withCtx(() => [
        createVNode(_component_TableHead, { ref: "thead" }, null, 512),
        createVNode(_component_Scroll, {
          inherit: "",
          class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.major]),
          height: _ctx.bodyScrollHeight,
          "scroll-y": _ctx.bodyScroll,
          onScroll: _ctx.handleBodyScroll,
          onYEnabledChange: _ctx.handleYScrollEnableChange,
          onReady: _ctx.syncVerticalScroll
        }, {
          default: withCtx(() => [
            createVNode(_component_TableBody, null, {
              empty: withCtx(({ isFixed }) => [
                renderSlot(_ctx.$slots, "empty", { isFixed })
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["class", "height", "scroll-y", "onScroll", "onYEnabledChange", "onReady"])
      ]),
      _: 3
    }, 8, ["class", "bar-class", "width", "bar-fade", "onScroll"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createVNode(_component_TableHead, { ref: "thead" }, null, 512),
      createVNode(_component_Scroll, {
        ref: "mainScroll",
        inherit: "",
        class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.major]),
        height: _ctx.bodyScrollHeight,
        "scroll-y": _ctx.bodyScroll,
        "delta-y": _ctx.props.scrollDeltaY,
        onScroll: _ctx.handleBodyScroll,
        onYEnabledChange: _ctx.handleYScrollEnableChange,
        onReady: _ctx.syncVerticalScroll
      }, {
        default: withCtx(() => [
          createVNode(_component_TableBody, null, {
            empty: withCtx(({ isFixed }) => [
              renderSlot(_ctx.$slots, "empty", { isFixed })
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["class", "height", "scroll-y", "delta-y", "onScroll", "onYEnabledChange", "onReady"])
    ], 64)),
    _ctx.leftFixedColumns.length ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass({
        [_ctx.nh.bem("fixed", "left")]: true,
        [_ctx.nh.bem("fixed", "active")]: _ctx.xScrollPercent
      })
    }, [
      createVNode(_component_TableHead, { fixed: "left" }),
      createVNode(_component_Scroll, {
        ref: "mainScroll",
        inherit: "",
        class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.left]),
        height: _ctx.bodyScrollHeight,
        "scroll-y": _ctx.bodyScroll,
        "delta-y": _ctx.props.scrollDeltaY,
        onScroll: _ctx.handleBodyScroll
      }, {
        default: withCtx(() => [
          createVNode(_component_TableBody, { fixed: "left" }, {
            empty: withCtx(({ isFixed }) => [
              renderSlot(_ctx.$slots, "empty", { isFixed })
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["class", "height", "scroll-y", "delta-y", "onScroll"])
    ], 2)) : createCommentVNode("", true),
    _ctx.rightFixedColumns.length ? (openBlock(), createElementBlock("div", {
      key: 3,
      class: normalizeClass({
        [_ctx.nh.bem("fixed", "right")]: true,
        [_ctx.nh.bem("fixed", "active")]: _ctx.xScrollPercent !== 100
      })
    }, [
      createVNode(_component_TableHead, { fixed: "right" }),
      createVNode(_component_Scroll, {
        inherit: "",
        class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.right]),
        height: _ctx.bodyScrollHeight,
        "scroll-y": _ctx.bodyScroll,
        "delta-y": _ctx.props.scrollDeltaY,
        onScroll: _ctx.handleBodyScroll
      }, {
        default: withCtx(() => [
          createVNode(_component_TableBody, { fixed: "right" }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["class", "height", "scroll-y", "delta-y", "onScroll"])
    ], 2)) : createCommentVNode("", true),
    _ctx.props.useYBar && _ctx.bodyScrollHeight ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 4,
      ref: "scrollbar",
      inherit: "",
      placement: "right",
      class: normalizeClass(_ctx.nh.bem("bar", "vertical")),
      fade: _ctx.props.barFade,
      disabled: !!_ctx.bodyHeight && _ctx.totalHeight <= _ctx.bodyHeight,
      "bar-length": _ctx.barLength,
      style: normalizeStyle({ top: `${_ctx.headHeight}px` }),
      onScroll: _ctx.handleYBarScroll
    }, null, 8, ["class", "fade", "disabled", "bar-length", "style", "onScroll"])) : createCommentVNode("", true),
    _ctx.props.rowDraggable ? withDirectives((openBlock(), createElementBlock("div", {
      key: 5,
      ref: "indicator",
      class: normalizeClass(_ctx.nh.be("indicator"))
    }, null, 2)), [
      [vShow, _ctx.indicatorShow]
    ]) : createCommentVNode("", true)
  ], 14, _hoisted_1);
}
var Table = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Table as default };
