import { reactive, computed, watchEffect, markRaw } from "vue";
import { createBITree, debounceMinor, isNull, toNumber, deepClone, sortByProps } from "@vexip-ui/utils";
import { DEFAULT_KEY_FIELD, TABLE_HEAD_KEY } from "./symbol.mjs";
let indexId = 1;
function getIndexId() {
  return `__vtr-${indexId++}`;
}
function defaultIndexLabel(index) {
  return index + 1;
}
function useStore(options) {
  var _a;
  const state = reactive({
    columns: [],
    data: [],
    rowClass: "",
    rowStyle: "",
    rowAttrs: null,
    cellClass: "",
    cellStyle: "",
    cellAttrs: null,
    headClass: "",
    headStyle: "",
    headAttrs: null,
    width: 0,
    dataKey: (_a = options.dataKey) != null ? _a : DEFAULT_KEY_FIELD,
    highlight: false,
    currentPage: 1,
    pageSize: 0,
    rowHeight: options.rowHeight,
    rowMinHeight: options.rowMinHeight || 36,
    virtual: options.virtual,
    rowDraggable: !!options.rowDraggable,
    emptyText: options.emptyText,
    tooltipTheme: options.tooltipTheme,
    tooltipWidth: options.tooltipWidth,
    singleSorter: options.singleSorter,
    singleFilter: options.singleFilter,
    expandRenderer: options.expandRenderer,
    rowData: [],
    rightFixedColumns: [],
    leftFixedColumns: [],
    dataMap: {},
    idMaps: /* @__PURE__ */ new WeakMap(),
    checkedAll: false,
    partial: false,
    widths: {},
    sorters: {},
    filters: {},
    bodyScroll: 0,
    padTop: 0,
    startRow: 0,
    endRow: 0,
    dragging: false,
    heightBITree: null,
    virtualData: [],
    totalHeight: options.rowMinHeight * options.data.length
  });
  setColumns(state, options.columns);
  setData(state, options.data);
  setCurrentPage(state, options.currentPage);
  setPageSize(state, options.pageSize);
  setRowClass(state, options.rowClass);
  setRowStyle(state, options.rowStyle);
  setRowAttrs(state, options.rowAttrs);
  setCellClass(state, options.cellClass);
  setCellStyle(state, options.cellStyle);
  setCellAttrs(state, options.cellAttrs);
  setHeadClass(state, options.headClass);
  setHeadStyle(state, options.headStyle);
  setHeadAttrs(state, options.headAttrs);
  setHighlight(state, options.highlight);
  setVirtual(state, options.virtual);
  const filteredData = computed(() => {
    return filterData(state.filters, state.rowData, state.singleFilter);
  });
  const sortedData = computed(() => {
    return sortData(state.sorters, filteredData.value, state.columns, state.singleSorter);
  });
  const processedData = computed(() => {
    return pageData(state.currentPage, state.pageSize, sortedData.value);
  });
  const disableCheckRows = computed(() => {
    const rowData = processedData.value;
    const selection = state.columns.find((item) => item.type === "selection");
    const disableCheckRows2 = {};
    if (selection && typeof selection.disableRow === "function") {
      const isDisabled = selection.disableRow;
      for (let i = 0, len = rowData.length; i < len; ++i) {
        const row = rowData[i];
        if (isDisabled(row.data)) {
          disableCheckRows2[row.key] = true;
        }
      }
    }
    return disableCheckRows2;
  });
  const disableExpandRows = computed(() => {
    const rowData = processedData.value;
    const expand = state.columns.find((item) => item.type === "expand");
    const disableExpandRows2 = {};
    if (expand && typeof expand.disableRow === "function") {
      const isDisabled = expand.disableRow;
      for (let i = 0, len = rowData.length; i < len; ++i) {
        const row = rowData[i];
        if (isDisabled(row.data)) {
          const key = row.key;
          disableExpandRows2[key] = true;
        }
      }
    }
    return disableExpandRows2;
  });
  watchEffect(() => {
    state.heightBITree = markRaw(
      createBITree(filteredData.value.length, state.rowHeight || state.rowMinHeight)
    );
    updateTotalHeight(state);
  });
  const getters = reactive({
    filteredData,
    sortedData,
    processedData,
    disableCheckRows,
    disableExpandRows
  });
  const mutations = {
    setColumns: debounceMinor(setColumns.bind(null, state)),
    setData: debounceMinor(setData.bind(null, state)),
    setDataKey: setDataKey.bind(null, state),
    setCurrentPage: setCurrentPage.bind(null, state),
    setPageSize: setPageSize.bind(null, state),
    setRowClass: setRowClass.bind(null, state),
    setRowStyle: setRowStyle.bind(null, state),
    setRowAttrs: setRowAttrs.bind(null, state),
    setCellClass: setCellClass.bind(null, state),
    setCellStyle: setCellStyle.bind(null, state),
    setCellAttrs: setCellAttrs.bind(null, state),
    setHeadClass: setHeadClass.bind(null, state),
    setHeadStyle: setHeadStyle.bind(null, state),
    setHeadAttrs: setHeadAttrs.bind(null, state),
    setTableWidth: setTableWidth.bind(null, state),
    setColumnWidth: setColumnWidth.bind(null, state),
    setRowHeight: setRowHeight.bind(null, state),
    setBorderHeight: setBorderHeight.bind(null, state),
    setGlobalRowHeight: setGlobalRowHeight.bind(null, state),
    setMinRowHeight: setMinRowHeight.bind(null, state),
    setVirtual: setVirtual.bind(null, state),
    setRowDraggable: setRowDraggable.bind(null, state),
    setRowExpandHeight: setRowExpandHeight.bind(null, state),
    setBodyScroll: setBodyScroll.bind(null, state),
    setHighlight: setHighlight.bind(null, state),
    setRowHover: setRowHover.bind(null, state),
    setEmptyText: setEmptyText.bind(null, state),
    setTooltipTheme: setTooltipTheme.bind(null, state),
    setTooltipWidth: setTooltipWidth.bind(null, state),
    setSingleSorter: setSingleSorter.bind(null, state),
    setSingleFilter: setSingleFilter.bind(null, state),
    setDragging: setDragging.bind(null, state),
    handleSort: handleSort.bind(null, state),
    clearSort: clearSort.bind(null, state),
    handleFilter: handleFilter.bind(null, state),
    clearFilter: clearFilter.bind(null, state),
    toggleFilterItemActive: toggleFilterItemActive.bind(null, state),
    refreshRowIndex: refreshRowIndex.bind(null, state),
    updateTotalHeight: debounceMinor(updateTotalHeight.bind(null, state)),
    handleCheck: handleCheck.bind(null, state, getters),
    handleCheckAll: handleCheckAll.bind(null, state, getters),
    clearCheckAll: clearCheckAll.bind(null, state, getters),
    setRenderRows: setRenderRows.bind(null, state, getters),
    handleExpand: handleExpand.bind(null, state, getters)
  };
  function setColumns(state2, columns) {
    columns = Array.from(columns).sort((prev, next) => {
      return (prev.order || 0) - (next.order || 0);
    });
    const { widths, sorters, filters } = state2;
    const normalColumns = [];
    const rightFixedColumns = [];
    const leftFixedColumns = [];
    const columnTypes = ["order", "selection", "expand"];
    for (let i = 0, len = columns.length; i < len; ++i) {
      const column = { ...columns[i] };
      if ("type" in column && columnTypes.includes(column.type)) {
        switch (column.type) {
          case "order": {
            column.truthIndex = !!column.truthIndex;
            if (typeof column.orderLabel !== "function") {
              column.orderLabel = defaultIndexLabel;
            }
            if (isNull(column.width))
              column.width = 60;
            break;
          }
          case "selection": {
            column.checkboxSize = column.checkboxSize || "default";
            if (typeof column.disableRow !== "function") {
              column.disableRow = () => false;
            }
            if (isNull(column.width))
              column.width = 40;
            break;
          }
          case "expand": {
            if (typeof column.disableRow !== "function") {
              column.disableRow = () => false;
            }
            if (isNull(column.width))
              column.width = 40;
            break;
          }
        }
      }
      let key = column.key;
      if (isNull(key)) {
        key = getIndexId();
        console.error("[vexip-ui:Table] Table column requires key prop, but missing");
      }
      const fixed = column.fixed;
      widths[key] = column.width || 100;
      sorters[key] = parseSorter(column.sorter);
      filters[key] = parseFilter(column.filter);
      column.key = key;
      if (fixed === true || fixed === "left") {
        leftFixedColumns.push(column);
      } else if (fixed === "right") {
        rightFixedColumns.push(column);
      } else {
        normalColumns.push(column);
      }
    }
    state2.columns = leftFixedColumns.concat(normalColumns, rightFixedColumns);
    if (leftFixedColumns.length) {
      state2.leftFixedColumns = leftFixedColumns;
    }
    if (rightFixedColumns.length) {
      state2.rightFixedColumns = rightFixedColumns;
    }
  }
  function setDataKey(state2, field) {
    const oldDataKey = state2.dataKey;
    if (!isNull(field) && oldDataKey !== field) {
      const { rowData, idMaps } = state2;
      state2.dataKey = field;
      rowData.forEach((row) => {
        let key = row.data[field];
        if (isNull(key)) {
          key = getIndexId();
        }
        row.key = key;
        idMaps.set(row.data, key);
      });
    }
  }
  function setData(state2, data) {
    const clonedData = [];
    const dataMap = {};
    const { dataKey, idMaps } = state2;
    const oldDataMap = state2.dataMap;
    const hidden = !!state2.virtual;
    dataMap[TABLE_HEAD_KEY] = oldDataMap[TABLE_HEAD_KEY] || {
      key: TABLE_HEAD_KEY
    };
    for (let i = 0, len = data.length; i < len; ++i) {
      const item = data[i];
      let key = item[dataKey];
      if (isNull(key)) {
        key = idMaps.get(item);
        if (isNull(key)) {
          key = getIndexId();
        }
      }
      let row;
      if (oldDataMap[key]) {
        row = oldDataMap[key];
        if (row.data !== item) {
          const { checked, height, expanded } = Object.assign(row.data, item);
          row.checked = !isNull(checked) ? !!checked : row.checked;
          row.height = !isNull(height) ? toNumber(height) : row.height;
          row.expanded = !isNull(expanded) ? !!expanded : row.expanded;
        }
      } else {
        const { checked, height, expanded } = item;
        row = {
          key,
          hidden,
          checked: !!checked,
          height: toNumber(height),
          borderHeight: 0,
          expanded: !!expanded,
          hover: false,
          expandHeight: 0,
          index: -1,
          data: item
        };
        idMaps.set(item, key);
      }
      row.index = i;
      clonedData.push(row);
      dataMap[key] = row;
    }
    state2.rowData = clonedData;
    state2.dataMap = dataMap;
    computePartial(state2);
  }
  function setCurrentPage(state2, currentPage) {
    state2.currentPage = currentPage != null ? currentPage : 1;
  }
  function setPageSize(state2, pageSize) {
    state2.pageSize = pageSize || state2.rowData.length;
  }
  function setRowClass(state2, rowClass) {
    state2.rowClass = rowClass != null ? rowClass : "";
  }
  function setRowStyle(state2, rowStyle) {
    state2.rowStyle = rowStyle != null ? rowStyle : "";
  }
  function setRowAttrs(state2, rowAttrs) {
    state2.rowAttrs = rowAttrs != null ? rowAttrs : null;
  }
  function setCellClass(state2, cellClass) {
    state2.cellClass = cellClass != null ? cellClass : "";
  }
  function setCellStyle(state2, cellStyle) {
    state2.cellStyle = cellStyle != null ? cellStyle : "";
  }
  function setCellAttrs(state2, cellAttrs) {
    state2.cellAttrs = cellAttrs != null ? cellAttrs : null;
  }
  function setHeadClass(state2, headClass) {
    state2.headClass = headClass != null ? headClass : "";
  }
  function setHeadStyle(state2, headStyle) {
    state2.headStyle = headStyle != null ? headStyle : "";
  }
  function setHeadAttrs(state2, headAttrs) {
    state2.headAttrs = headAttrs != null ? headAttrs : null;
  }
  function setTableWidth(state2, width) {
    width = toNumber(width);
    const { columns, widths } = state2;
    const hasWidthColumns = [];
    const flexColumns = [];
    let flexWidth = width;
    for (let i = 0, len = columns.length; i < len; ++i) {
      const column = columns[i];
      if (column.width) {
        flexWidth -= column.width;
        hasWidthColumns.push(column);
      } else {
        flexColumns.push(column);
      }
    }
    const flexColumnCount = flexColumns.length;
    let flexUnitWidth = 100;
    if (flexColumnCount) {
      flexUnitWidth = flexWidth / flexColumnCount;
    }
    for (let i = 0; i < flexColumnCount; ++i) {
      const column = flexColumns[i];
      const key = column.key;
      widths[key] = flexUnitWidth;
    }
    state2.width = width;
  }
  function setColumnWidth(state2, key, width) {
    if (state2.widths[key]) {
      state2.widths[key] = width;
    }
  }
  function setRowHeight(state2, key, height) {
    if (state2.dataMap[key] && state2.dataMap[key].height !== height) {
      state2.dataMap[key].height = height;
    }
  }
  function setBorderHeight(state2, key, height) {
    if (state2.dataMap[key]) {
      state2.dataMap[key].borderHeight = height;
    }
  }
  function setGlobalRowHeight(state2, height) {
    state2.rowHeight = height;
  }
  function setMinRowHeight(state2, height) {
    state2.rowMinHeight = height;
  }
  function setRowDraggable(state2, draggable) {
    state2.rowDraggable = !!draggable;
  }
  function setRowExpandHeight(state2, key, height) {
    if (state2.dataMap[key]) {
      state2.dataMap[key].expandHeight = height;
    }
  }
  function setBodyScroll(state2, scroll) {
    state2.bodyScroll = scroll;
  }
  function setHighlight(state2, able) {
    state2.highlight = !!able;
  }
  function setVirtual(state2, virtual) {
    state2.virtual = !!virtual;
  }
  function setRowHover(state2, key, hover) {
    if (state2.dataMap[key]) {
      state2.dataMap[key].hover = hover;
    }
  }
  function setEmptyText(state2, text) {
    state2.emptyText = text;
  }
  function setTooltipTheme(state2, theme) {
    state2.tooltipTheme = theme;
  }
  function setTooltipWidth(state2, theme) {
    state2.tooltipWidth = theme;
  }
  function setSingleSorter(state2, able) {
    state2.singleSorter = !!able;
  }
  function setSingleFilter(state2, able) {
    state2.singleFilter = !!able;
  }
  function setDragging(state2, dragging) {
    state2.dragging = !!dragging;
  }
  function handleSort(state2, key, type) {
    if (state2.sorters[key]) {
      if (state2.singleSorter && type) {
        clearSort(state2);
      }
      state2.sorters[key].type = type;
    }
  }
  function clearSort(state2) {
    const sorters = state2.sorters;
    for (const key of Object.keys(sorters)) {
      sorters[key].type = null;
    }
  }
  function handleFilter(state2, key, active) {
    if (state2.filters[key]) {
      if (state2.singleFilter && (Array.isArray(active) ? active.length : active)) {
        clearFilter(state2);
      }
      state2.filters[key].active = active;
    }
  }
  function clearFilter(state2) {
    const filters = state2.filters;
    for (const key of Object.keys(filters)) {
      filters[key].active = null;
      for (const option of filters[key].options) {
        option.active = false;
      }
    }
  }
  function handleCheck(state2, getters2, key, checked) {
    const { dataMap } = state2;
    const { disableCheckRows: disableCheckRows2 } = getters2;
    if (dataMap[key] && !disableCheckRows2[key]) {
      dataMap[key].checked = !!checked;
    }
    computePartial(state2);
  }
  function handleCheckAll(state2, getters2) {
    const { rowData, checkedAll } = state2;
    const { disableCheckRows: disableCheckRows2 } = getters2;
    let checked = !checkedAll;
    if (Object.keys(disableCheckRows2).length) {
      let partialCheckedAll = true;
      for (const row of rowData) {
        if (!disableCheckRows2[row.key] && !row.checked) {
          partialCheckedAll = false;
          break;
        }
      }
      checked = !partialCheckedAll;
    }
    for (const row of rowData) {
      if (!disableCheckRows2[row.key]) {
        row.checked = checked;
      }
    }
    state2.checkedAll = checked;
    state2.partial = false;
    computePartial(state2);
  }
  function clearCheckAll(state2, getters2) {
    const { rowData } = state2;
    const { disableCheckRows: disableCheckRows2 } = getters2;
    for (const row of rowData) {
      if (!disableCheckRows2[row.key]) {
        row.checked = false;
      }
    }
    state2.checkedAll = false;
    state2.partial = false;
    computePartial(state2);
  }
  function computePartial(state2) {
    const data = state2.rowData;
    let hasChecked = false;
    let hasNotChecked = false;
    let partial = false;
    for (let i = 0, len = data.length; i < len; ++i) {
      const row = data[i];
      if (row.checked) {
        hasChecked = true;
      } else {
        hasNotChecked = true;
      }
      if (hasChecked && hasNotChecked) {
        partial = true;
        break;
      }
    }
    if (hasChecked && !partial) {
      state2.checkedAll = true;
    } else {
      state2.checkedAll = false;
    }
    state2.partial = partial;
  }
  function setRenderRows(state2, getters2, start, end) {
    var _a2;
    const { startRow, endRow, heightBITree, virtualData } = state2;
    if (start === startRow && end === endRow)
      return;
    const { processedData: processedData2 } = getters2;
    virtualData.length = 0;
    if (processedData2[0]) {
      let i = processedData2.length;
      while (i--) {
        const data = processedData2[i];
        data.hidden = !(i >= start && i < end);
        !data.hidden && virtualData.push(data);
      }
      virtualData.reverse();
      state2.padTop = (_a2 = heightBITree == null ? void 0 : heightBITree.sum(start)) != null ? _a2 : 0;
      state2.startRow = start;
      state2.endRow = end;
    }
  }
  function handleExpand(state2, getters2, key, expanded) {
    const { dataMap } = state2;
    const { disableExpandRows: disableExpandRows2 } = getters2;
    if (dataMap[key] && !disableExpandRows2[key]) {
      dataMap[key].expanded = !!expanded;
    }
  }
  function toggleFilterItemActive(state2, options2) {
    const { key, value, active = false, disableOthers = false } = options2;
    if (state2.filters[key]) {
      const filterOptions = state2.filters[key].options;
      if (disableOthers) {
        for (let i = 0, len = filterOptions.length; i < len; ++i) {
          filterOptions[i].active = false;
        }
      }
      const item = filterOptions.find((item2) => item2.value === value);
      if (item) {
        item.active = active;
      }
    }
  }
  function refreshRowIndex(state2) {
    const data = state2.rowData;
    for (let i = 0, len = data.length; i < len; ++i) {
      data[i].index = i;
    }
  }
  function updateTotalHeight(state2) {
    var _a2;
    const { heightBITree, currentPage, pageSize, rowData } = state2;
    if (heightBITree) {
      if (currentPage && pageSize > 0 && pageSize < rowData.length) {
        state2.totalHeight = heightBITree.sum(currentPage * pageSize) - heightBITree.sum((currentPage - 1) * pageSize);
      } else {
        state2.totalHeight = (_a2 = heightBITree.sum()) != null ? _a2 : 0;
      }
    } else {
      state2.totalHeight = 0;
    }
  }
  function parseSorter(sorter = false) {
    const raw = typeof sorter === "boolean" ? { able: sorter } : sorter;
    const { able = false, type = null, order = 0, method = null } = raw;
    return { able, type, order, method };
  }
  function parseFilter(filter = { able: false, options: [] }) {
    var _a2, _b;
    const { able = false, multiple = false, active = null, method = null } = filter;
    const options2 = deepClone((_a2 = filter.options) != null ? _a2 : []);
    const formattedOptions = [];
    for (let i = 0, len = options2.length; i < len; ++i) {
      const item = options2[i];
      const option = typeof item === "string" ? { value: item } : { ...item };
      option.label = (_b = option.label) != null ? _b : option.value.toString();
      let isActive = false;
      if (multiple && Array.isArray(active)) {
        isActive = active.includes(option.value);
      } else if (!isNull(active)) {
        isActive = Object.is(option.value, active);
      }
      option.active = isActive;
      formattedOptions.push(option);
    }
    return { able, options: formattedOptions, multiple, active, method };
  }
  function filterData(filters, data, isSingle) {
    const keys = Object.keys(filters);
    const usedFilter = [];
    const filterData2 = [];
    for (let i = 0, len = keys.length; i < len; ++i) {
      const key = keys[i];
      const filter = filters[key];
      const { able, active, method } = filter;
      if (able && active && typeof method === "function") {
        usedFilter.push(filter);
        if (isSingle)
          break;
      }
    }
    const usedFilterCount = usedFilter.length;
    for (let i = 0, len = data.length; i < len; ++i) {
      const row = data[i];
      let isFilter = true;
      for (let j = 0; j < usedFilterCount; j++) {
        const { active, method } = usedFilter[j];
        isFilter = method(active, row.data);
        if (!isFilter) {
          break;
        }
      }
      if (isFilter) {
        filterData2.push(row);
      }
    }
    return filterData2;
  }
  function sortData(sorters, data, columns, isSingle) {
    const keys = Object.keys(sorters);
    const usedSorter = [];
    for (let i = 0, len = keys.length; i < len; ++i) {
      const key = keys[i];
      const { able, type, order, method } = sorters[key];
      if (able && type) {
        const column = columns.find((item) => item.key === key);
        const accessor = column == null ? void 0 : column.accessor;
        usedSorter.push({
          able,
          key,
          order,
          type,
          method: method != null ? method : void 0,
          accessor(row) {
            if (typeof accessor === "function") {
              return accessor(row.data, row.index);
            }
            return row.data[key];
          }
        });
        if (isSingle)
          break;
      }
    }
    usedSorter.sort((prev, next) => prev.order - next.order);
    return sortByProps(data, usedSorter);
  }
  function pageData(currentPage, pageSize, data) {
    return data.slice((currentPage - 1) * pageSize, currentPage * pageSize);
  }
  return { state, getters, mutations };
}
export { useStore };
