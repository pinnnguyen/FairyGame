import { createApp, markRaw } from "vue";
import Component from "./notice.mjs";
import { toNumber, isNull, destroyObject, isClient, noop, isObject } from "@vexip-ui/utils";
import { CircleInfo, CircleCheck, CircleExclamation, CircleXmark } from "@vexip-ui/icons";
const conveniences = {
  info: {
    icon: CircleInfo
  },
  success: {
    icon: CircleCheck
  },
  warning: {
    icon: CircleExclamation
  },
  error: {
    icon: CircleXmark
  }
};
const placementWhiteList = [
  "top-right",
  "top-left",
  "bottom-right",
  "bottom-left"
];
let count = 1;
function getKey() {
  return `notice-${count++}`;
}
class NoticeManager {
  constructor(options = {}) {
    options = {
      ...options,
      marker: !!options.marker,
      duration: options.duration ? toNumber(options.duration) : 4e3
    };
    this._instance = null;
    this._innerApp = null;
    this._container = null;
    this.name = "Notice";
    this.defaults = {};
    this.config(options);
    this.open = (title, content, duration) => {
      return this._open(null, title, content, duration);
    };
    this.info = (title, content, duration) => {
      return this._open("info", title, content, duration);
    };
    this.success = (title, content, duration) => {
      return this._open("success", title, content, duration);
    };
    this.warning = (title, content, duration) => {
      return this._open("warning", title, content, duration);
    };
    this.error = (title, content, duration) => {
      return this._open("error", title, content, duration);
    };
  }
  judge(state, success, error, duration) {
    if (state) {
      this.success(success, duration);
    } else {
      this.error(error, duration);
    }
  }
  close(key) {
    if (isNull(key)) {
      this.clear();
    } else {
      this._getInstance().remove(key);
    }
  }
  config({ placement, ...others }) {
    if (placement) {
      this._getInstance().placement = placementWhiteList.includes(placement) ? placement : placementWhiteList[0];
    }
    this.defaults = { ...this.defaults, ...others };
  }
  clone() {
    return new NoticeManager(this.defaults);
  }
  clear() {
    this._getInstance().clear();
  }
  destroy() {
    var _a;
    (_a = this._innerApp) == null ? void 0 : _a.unmount();
    destroyObject(this);
  }
  isDestroyed() {
    return false;
  }
  install(app, options = {}) {
    const { property, ...others } = options;
    this.config(others);
    app.config.globalProperties[property || "$notice"] = this;
  }
  _getInstance() {
    if (!this._instance) {
      this._container = document.createElement("div");
      this._innerApp = createApp(Component);
      this._instance = this._innerApp.mount(this._container);
      document.body.appendChild(this._container.firstElementChild);
    }
    return this._instance;
  }
  _open(type, title, content, _duration) {
    var _a, _b;
    if (!isClient) {
      return noop;
    }
    let options;
    if (isObject(title)) {
      options = title;
    } else {
      if (typeof content === "number") {
        options = { title, duration: content };
      } else if (!content) {
        options = { title, duration: _duration };
      } else {
        options = { title, content, duration: _duration };
      }
    }
    const key = (_a = options.key) != null ? _a : getKey();
    const notice = this._getInstance();
    const convenienceOptions = type ? (_b = conveniences[type]) != null ? _b : {} : {};
    let timer;
    const userCloseFn = options.onClose;
    const onClose = () => {
      clearTimeout(timer);
      if (typeof userCloseFn === "function") {
        return userCloseFn();
      }
    };
    const item = Object.assign({}, this.defaults, convenienceOptions, options, {
      key,
      type,
      onClose
    });
    if (item.icon && typeof item.icon !== "function") {
      item.icon = markRaw(item.icon);
    }
    notice.add(item);
    const duration = typeof item.duration === "number" ? item.duration : 4e3;
    if (duration >= 500) {
      timer = setTimeout(() => {
        notice.remove(key);
      }, duration);
    }
    return () => {
      clearTimeout(timer);
      notice.remove(key);
    };
  }
}
const Notice = new NoticeManager();
export { Notice, NoticeManager };
