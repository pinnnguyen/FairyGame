import { defineComponent, ref, computed, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle, Fragment, renderList, renderSlot, createTextVNode, toDisplayString, mergeProps, createCommentVNode, createBlock, withCtx, createVNode } from "vue";
import SliderTrigger from "./slider-trigger.mjs";
import "../form/index.mjs";
import "../../common/config/src/index.mjs";
import { useSetTimeout } from "@vexip-ui/hooks";
import { throttle } from "@vexip-ui/utils";
import { sliderProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
var TriggerType = /* @__PURE__ */ ((TriggerType2) => {
  TriggerType2[TriggerType2["START"] = 0] = "START";
  TriggerType2[TriggerType2["END"] = 1] = "END";
  return TriggerType2;
})(TriggerType || {});
const _sfc_main = defineComponent({
  name: "Slider",
  components: {
    SliderTrigger
  },
  props: sliderProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = startTrigger.value || endTrigger.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("slider", _props, {
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(0),
        static: true
      },
      min: 0,
      max: 100,
      step: {
        default: 1,
        validator: (value) => value > 0 && Math.ceil(value) === value
      },
      vertical: false,
      hideTip: false,
      tipTransfer: null,
      disabled: () => disabled.value,
      loading: () => loading.value,
      loadingLock: false,
      reverse: false,
      range: false,
      markers: () => ({}),
      markerOnly: false
    });
    const nh = useNameHelper("slider");
    const currentValue = ref([0, 0]);
    const sliding = ref([false, false]);
    const triggerType = ref(1);
    const { timer } = useSetTimeout();
    const track = ref();
    const startTrigger = ref();
    const endTrigger = ref();
    const markerPercent = computed(() => {
      return Object.keys(props.markers).map(parseFloat).filter((percent) => {
        return !Number.isNaN(percent) && percent >= 0 && percent <= 100;
      });
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.state)]: props.state !== "default",
        [nh.bm("vertical")]: props.vertical,
        [nh.bm("sliding")]: sliding.value[1] || sliding.value[0],
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("loading")]: props.loading && props.loadingLock,
        [nh.bm("reverse")]: props.reverse,
        [nh.bm("with-marker")]: markerPercent.value.length
      };
    });
    const stepMin = computed(() => Math.round(Math.min(props.min, props.max) / props.step));
    const stepMax = computed(() => Math.round(Math.max(props.min, props.max) / props.step));
    const truthValue = computed(() => {
      return [
        Math.round(currentValue.value[0] * props.step),
        Math.round(currentValue.value[1] * props.step)
      ];
    });
    const total = computed(() => stepMax.value - stepMin.value || 1);
    const triggerPercent = computed(() => {
      return [
        (currentValue.value[0] - stepMin.value) / total.value * 100,
        (currentValue.value[1] - stepMin.value) / total.value * 100
      ];
    });
    const fillerStyle = computed(() => {
      const { vertical, reverse } = props;
      const offset = props.range ? Math.min(triggerPercent.value[0], triggerPercent.value[1]) : 0;
      return {
        transform: `
          translate${vertical ? "Y" : "X"}(${reverse ? "-" : ""}${offset}%)
          translateZ(0)
          scale${vertical ? "Y" : "X"}(${Math.abs(triggerPercent.value[0] - triggerPercent.value[1]) / 100})
        `,
        transformOrigin: `${vertical ? 50 : reverse ? 100 : 0}% ${vertical ? reverse ? 100 : 0 : 50}%`
      };
    });
    const startTriggerStyle = computed(() => {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${triggerPercent.value[0]}%` : "50%",
        [reverse ? "right" : "left"]: vertical ? "50%" : `${triggerPercent.value[0]}%`,
        zIndex: triggerType.value === 0 ? 1 : void 0,
        transform: `translate(${reverse ? "" : "-"}50%, ${reverse ? "" : "-"}50%)`
      };
    });
    const endTriggerStyle = computed(() => {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${triggerPercent.value[1]}%` : "50%",
        [reverse ? "right" : "left"]: vertical ? "50%" : `${triggerPercent.value[1]}%`,
        zIndex: triggerType.value === 1 ? 1 : void 0,
        transform: `translate(${reverse ? "" : "-"}50%, ${reverse ? "" : "-"}50%)`
      };
    });
    parseValue(props.value);
    verifyValue();
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
        verifyValue();
      }
    );
    function parseValue(value) {
      if (props.range) {
        const values = Array.isArray(value) ? value : [value, 100];
        currentValue.value = [values[0] / props.step, values[1] / props.step];
      } else {
        currentValue.value = [stepMin.value, (Array.isArray(value) ? value[0] : value) / props.step];
      }
    }
    function verifyValue() {
      currentValue.value = currentValue.value.map((value) => {
        let computedValue = Math.max(stepMin.value, Math.min(stepMax.value, Math.round(value)));
        if (props.markerOnly && markerPercent.value.length) {
          let nearest = 100;
          let nearestPercent = 0;
          for (const percent of markerPercent.value) {
            const delta = Math.abs((computedValue - stepMin.value) / total.value * 100 - percent);
            if (nearest > delta) {
              nearest = delta;
              nearestPercent = percent;
            }
          }
          computedValue = nearestPercent / 100 * total.value + stepMin.value;
        }
        return computedValue;
      });
    }
    function emitChange() {
      const [start, end] = truthValue.value;
      const value = props.range ? start > end ? [end, start] : [start, end] : end;
      setFieldValue(value);
      emitEvent(props.onChange, value);
      emit("update:value", value);
      validateField();
    }
    let trackRect = null;
    function computeValue(event) {
      if (!trackRect)
        return;
      const vertical = props.vertical;
      const reverse = props.reverse;
      const client = vertical ? event.clientY : event.clientX;
      currentValue.value[triggerType.value] = (reverse ? -1 : 1) * ((client - trackRect[vertical ? reverse ? "bottom" : "top" : reverse ? "right" : "left"]) / trackRect[vertical ? "height" : "width"]) * total.value + stepMin.value;
    }
    let lastValue;
    function isEqualValue(prev, current) {
      if (Array.isArray(prev) && Array.isArray(current)) {
        return prev[0] === current[0] && prev[1] === current[1];
      }
      return prev === current;
    }
    const throttleMove = throttle((event) => {
      if (!trackRect || props.disabled)
        return;
      event.preventDefault();
      computeValue(event);
      verifyValue();
      if (startTrigger.value) {
        startTrigger.value.updateTooltip();
      }
      if (endTrigger.value) {
        endTrigger.value.updateTooltip();
      }
      const [start, end] = truthValue.value;
      const value = props.range ? start > end ? [end, start] : [start, end] : end;
      if (!isEqualValue(lastValue, value)) {
        lastValue = value;
        emitEvent(props.onInput, value);
      }
    });
    function handleTrackDown(event) {
      if (!track.value || props.disabled || props.loading && props.loadingLock)
        return;
      clearTimeout(timer.sliding);
      event.stopPropagation();
      event.preventDefault();
      trackRect = track.value.getBoundingClientRect();
      if (props.range) {
        const { vertical, reverse } = props;
        const client = vertical ? event.clientY : event.clientX;
        const downPercent = (reverse ? trackRect[vertical ? "bottom" : "right"] - client : client - trackRect[vertical ? "top" : "left"]) / trackRect[vertical ? "height" : "width"] * 100;
        triggerType.value = Math.abs(downPercent - triggerPercent.value[0]) < Math.abs(downPercent - triggerPercent.value[1]) ? 0 : 1;
      } else {
        triggerType.value = 1;
      }
      sliding.value[triggerType.value] = true;
      computeValue(event);
      verifyValue();
      document.addEventListener("pointermove", handleMove);
      document.addEventListener("pointerup", handleMoveEnd);
    }
    function handleMove(event) {
      throttleMove(event);
    }
    function handleMoveEnd() {
      trackRect = null;
      document.removeEventListener("pointermove", handleMove);
      document.removeEventListener("pointerup", handleMoveEnd);
      emitChange();
      timer.sliding = setTimeout(() => {
        sliding.value[triggerType.value] = false;
      }, 250);
    }
    function disableEvent(event) {
      if (event.cancelable) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
    function getPointStyle(percent) {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${percent}%` : "50%",
        [reverse ? "right" : "left"]: vertical ? "50%" : `${percent}%`,
        transform: `translate(${reverse ? "" : "-"}50%, ${reverse ? "" : "-"}50%)`
      };
    }
    function getMarkerStyle(percent) {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${percent}%` : void 0,
        [reverse ? "right" : "left"]: vertical ? void 0 : `${percent}%`,
        transform: `translate${vertical ? "Y" : "X"}(${reverse ? "" : "-"}50%)`
      };
    }
    function isPercentInRange(percent) {
      const numberPercent = parseFloat(percent);
      if (Number.isNaN(numberPercent))
        return false;
      if (props.range) {
        const min = Math.min(triggerPercent.value[0], triggerPercent.value[1]);
        const max = Math.max(triggerPercent.value[0], triggerPercent.value[1]);
        return numberPercent >= min && numberPercent <= max;
      } else {
        return numberPercent <= triggerPercent.value[1];
      }
    }
    return {
      props,
      nh,
      idFor,
      sliding,
      markerPercent,
      className,
      truthValue,
      fillerStyle,
      startTriggerStyle,
      endTriggerStyle,
      track,
      startTrigger,
      endTrigger,
      handleTrackDown,
      disableEvent,
      getPointStyle,
      getMarkerStyle,
      isPercentInRange
    };
  }
});
const _hoisted_1 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SliderTrigger = resolveComponent("SliderTrigger");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    tabindex: "-1",
    onPointerdown: _cache[0] || (_cache[0] = (...args) => _ctx.handleTrackDown && _ctx.handleTrackDown(...args)),
    onTouchstart: _cache[1] || (_cache[1] = (...args) => _ctx.disableEvent && _ctx.disableEvent(...args))
  }, [
    createElementVNode("div", {
      ref: "track",
      class: normalizeClass(_ctx.nh.be("track"))
    }, [
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("filler")),
        style: normalizeStyle(_ctx.fillerStyle)
      }, null, 6)
    ], 2),
    _ctx.markerPercent.length ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("points"))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.markers, (_, percent) => {
          return openBlock(), createElementBlock("div", {
            key: percent,
            class: normalizeClass([_ctx.nh.be("point"), _ctx.isPercentInRange(percent) && _ctx.nh.bem("point", "in-range")]),
            style: normalizeStyle(_ctx.getPointStyle(percent))
          }, null, 6);
        }), 128))
      ], 2),
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("markers"))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.markers, (marker, percent) => {
          return openBlock(), createElementBlock(Fragment, { key: percent }, [
            typeof marker === "string" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("marker")),
              style: normalizeStyle(_ctx.getMarkerStyle(percent))
            }, [
              renderSlot(_ctx.$slots, "marker", {
                marker: { label: marker },
                percent,
                inRange: _ctx.isPercentInRange(percent)
              }, () => [
                createTextVNode(toDisplayString(marker), 1)
              ])
            ], 6)) : (openBlock(), createElementBlock("div", mergeProps({
              key: 1,
              class: [_ctx.nh.be("marker"), marker.class],
              style: [
                _ctx.getMarkerStyle(percent),
                marker.style
              ]
            }, marker.attrs), [
              renderSlot(_ctx.$slots, "marker", {
                marker,
                percent,
                inRange: _ctx.isPercentInRange(percent)
              }, () => [
                createTextVNode(toDisplayString(marker.label), 1)
              ])
            ], 16))
          ], 64);
        }), 128))
      ], 2)
    ], 64)) : createCommentVNode("", true),
    _ctx.props.range ? (openBlock(), createBlock(_component_SliderTrigger, {
      key: 1,
      ref: "startTrigger",
      value: _ctx.truthValue[0],
      "tip-transfer": _ctx.props.tipTransfer,
      "hide-tip": _ctx.props.hideTip,
      vertical: _ctx.props.vertical,
      min: _ctx.props.min,
      max: _ctx.props.max,
      disabled: _ctx.props.disabled,
      loading: _ctx.props.loading,
      reverse: _ctx.props.reverse,
      sliding: _ctx.sliding[0],
      style: normalizeStyle(_ctx.startTriggerStyle)
    }, {
      tip: withCtx(({ value: startValue }) => [
        renderSlot(_ctx.$slots, "tip", { value: startValue }, () => [
          createTextVNode(toDisplayString(startValue), 1)
        ])
      ]),
      _: 3
    }, 8, ["value", "tip-transfer", "hide-tip", "vertical", "min", "max", "disabled", "loading", "reverse", "sliding", "style"])) : createCommentVNode("", true),
    createVNode(_component_SliderTrigger, {
      ref: "endTrigger",
      value: _ctx.truthValue[1],
      "tip-transfer": _ctx.props.tipTransfer,
      "hide-tip": _ctx.props.hideTip,
      vertical: _ctx.props.vertical,
      min: _ctx.props.min,
      max: _ctx.props.max,
      disabled: _ctx.props.disabled,
      loading: _ctx.props.loading,
      reverse: _ctx.props.reverse,
      sliding: _ctx.sliding[1],
      style: normalizeStyle(_ctx.endTriggerStyle)
    }, {
      tip: withCtx(({ value: endValue }) => [
        renderSlot(_ctx.$slots, "tip", { value: endValue }, () => [
          createTextVNode(toDisplayString(endValue), 1)
        ])
      ]),
      _: 3
    }, 8, ["value", "tip-transfer", "hide-tip", "vertical", "min", "max", "disabled", "loading", "reverse", "sliding", "style"])
  ], 42, _hoisted_1);
}
var Slider = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Slider as default };
