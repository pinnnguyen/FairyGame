import { defineComponent, inject, ref, computed, provide, watch, onMounted, onBeforeUnmount, toRef, resolveComponent, renderSlot, openBlock, createBlock, mergeProps, withCtx, createElementBlock, createCommentVNode, normalizeClass, normalizeStyle, createVNode, createElementVNode, toDisplayString, createTextVNode, Transition } from "vue";
import "../column/index.mjs";
import "../icon/index.mjs";
import "../tooltip/index.mjs";
import { CircleQuestionR } from "@vexip-ui/icons";
import "../../common/config/src/index.mjs";
import { createEventEmitter, isNull, getRangeWidth, isFunction } from "@vexip-ui/utils";
import { formItemProps } from "./props.mjs";
import { validate } from "./validator.mjs";
import { getValueByPath, setValueByPath } from "./helper.mjs";
import { FORM_PROPS, FORM_ACTIONS, FORM_FIELDS, FIELD_OPTIONS } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Column from "../row/column.mjs";
import Icon from "../icon/icon.mjs";
import Tooltip from "../tooltip/tooltip.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps } from "../../common/config/src/props.mjs";
import { useLocale, makeSentence } from "../../common/config/src/locale/index.mjs";
const _sfc_main = defineComponent({
  name: "FormItem",
  components: {
    Column,
    Icon,
    Tooltip,
    CircleQuestionR
  },
  inheritAttrs: true,
  props: formItemProps,
  setup(_props, { slots }) {
    const nh = useNameHelper("form");
    const props = useProps("formItem", _props, {
      label: {
        default: "",
        static: true
      },
      prop: {
        default: "",
        static: true
      },
      rules: () => [],
      labelWidth: null,
      required: false,
      htmlFor: {
        default: null,
        static: true
      },
      errorTransition: () => nh.ns("fade"),
      defaultValue: {
        default: null,
        static: true
      },
      hideErrorTip: false,
      validateAll: null,
      hideAsterisk: null,
      hideLabel: null,
      action: false,
      help: "",
      pure: false,
      span: 24,
      offset: null,
      push: null,
      pull: null,
      order: null,
      xs: null,
      sm: null,
      md: null,
      lg: null,
      xl: null,
      xxl: null,
      flex: null
    });
    const formProps = inject(FORM_PROPS, {});
    const formActions = inject(FORM_ACTIONS, null);
    const formFields = inject(FORM_FIELDS, null);
    const emitter = createEventEmitter();
    const locale = useLocale("form");
    const initValue = ref(props.defaultValue);
    const isError = ref(false);
    const errorTip = ref("");
    const validating = ref(false);
    const disabledValidate = ref(false);
    const labelWidth = ref(0);
    const labelEl = ref();
    const isRequired = computed(() => formProps.allRequired || props.required);
    const requiredTip = computed(() => {
      return makeSentence(`${props.label || props.prop} ${locale.value.notNullable}`);
    });
    const allRules = computed(() => {
      var _a;
      if (!props.prop)
        return [];
      const requiredRule = isRequired.value ? [{ required: isRequired.value, message: requiredTip.value }] : [];
      const selfRules = Array.isArray(props.rules) ? props.rules : [props.rules];
      let formRules = [];
      if (formProps.rules) {
        formRules = (_a = getValueByPath(formProps.rules, props.prop)) != null ? _a : [];
      }
      formRules = Array.isArray(formRules) ? formRules : [formRules];
      return requiredRule.concat(formRules, selfRules);
    });
    const currentValue = computed(getValue);
    const isValidateAll = computed(() => {
      var _a;
      return isNull(props.validateAll) ? (_a = formProps.validateAll) != null ? _a : false : props.validateAll;
    });
    const useAsterisk = computed(() => {
      if (props.hideAsterisk === true || formProps.hideAsterisk) {
        return false;
      }
      for (const rule of allRules.value) {
        if (rule.required)
          return true;
      }
      return isRequired.value;
    });
    const hideLabel = computed(
      () => props.action || props.hideLabel === true || formProps.hideLabel
    );
    const hasLabel = computed(() => !(hideLabel.value || !(props.label || slots.label)));
    const computedlabelWidth = computed(() => {
      if (formProps.labelAlign) {
        return getLabelWidth(
          formProps.labelAlign === "top" ? 0 : hideLabel.value ? 0 : props.labelWidth || formProps.labelWidth || 80
        );
      }
      return getLabelWidth(hideLabel.value ? 0 : props.labelWidth || 80);
    });
    const className = computed(() => {
      return {
        [nh.be("item")]: true,
        [nh.bs("vars")]: true,
        [nh.bem("item", "inherit")]: formFields || props.inherit,
        [nh.bem("item", "required")]: !formProps.hideAsterisk && useAsterisk.value,
        [nh.bem("item", "error")]: isError.value,
        [nh.bem("item", "action")]: props.action,
        [nh.bem("item", "padding")]: formProps.inline && formProps.labelAlign === "top" && !hasLabel.value
      };
    });
    const controlStyle = computed(() => {
      return {
        width: formProps.labelAlign === "top" ? void 0 : `calc(100% - ${computedlabelWidth.value}px)`,
        marginLeft: hasLabel.value || formProps.labelAlign === "top" ? void 0 : `${computedlabelWidth.value}px`
      };
    });
    const inputValue = computed(() => {
      const value = currentValue.value;
      if (Array.isArray(value) || typeof value === "object") {
        return JSON.stringify(value);
      }
      return value;
    });
    const instances = /* @__PURE__ */ new Set();
    const fieldObject = Object.freeze({
      prop: computed(() => props.prop),
      idFor: computed(() => props.prop),
      state: computed(() => isError.value ? "error" : "default"),
      disabled: computed(() => !!formProps.disabled),
      loading: computed(() => !!formProps.loading),
      size: computed(() => formProps.size || "default"),
      emitter,
      labelWidth,
      validate: validate$1,
      clearError,
      reset,
      getValue,
      setValue,
      sync: (instance) => {
        if (instances.size) {
          console.warn("[vexip-ui:Form]: must only be one control component under FormItem.");
        }
        instances.add(instance);
      },
      unsync: (instance) => {
        instances.delete(instance);
      }
    });
    provide(FIELD_OPTIONS, fieldObject);
    watch(
      () => props.defaultValue,
      (value) => {
        initValue.value = value;
      }
    );
    onMounted(() => {
      const value = currentValue.value;
      if (isNull(initValue.value)) {
        initValue.value = Array.isArray(value) ? Array.from(value) : value;
      }
      if (labelEl.value) {
        labelWidth.value = getRangeWidth(labelEl.value);
      }
      if (formFields) {
        formFields.add(fieldObject);
      }
    });
    onBeforeUnmount(() => {
      if (formFields) {
        formFields.delete(fieldObject);
      }
    });
    function getLabelWidth(width) {
      return width === "auto" ? (formActions == null ? void 0 : formActions.getLabelWidth()) || 80 : width;
    }
    let inited = false;
    function getValue(defaultValue) {
      if (!formProps.model || !props.prop)
        return defaultValue;
      try {
        const value = getValueByPath(formProps.model, props.prop, true);
        inited = true;
        return value;
      } catch (e) {
        if (!inited) {
          setValueByPath(formProps.model, props.prop, defaultValue, false);
          inited = true;
        }
        return defaultValue;
      }
    }
    function setValue(value, strict = false) {
      if (!formProps.model || !props.prop)
        return;
      try {
        return setValueByPath(formProps.model, props.prop, value, strict);
      } catch (e) {
      }
    }
    function validate$1() {
      return handleValidate();
    }
    function clearError() {
      isError.value = false;
      errorTip.value = "";
    }
    function reset() {
      clearError();
      if (!formProps.model || !props.prop)
        return false;
      const value = currentValue.value;
      let resetValue;
      if (Array.isArray(value)) {
        resetValue = Array.isArray(initValue.value) ? Array.from(initValue.value) : [];
      } else {
        resetValue = isFunction(initValue.value) ? initValue.value() : initValue.value;
      }
      if (resetValue !== value) {
        disabledValidate.value = true;
      }
      return setValueByPath(formProps.model, props.prop, resetValue, true);
    }
    async function handleValidate() {
      if (disabledValidate.value) {
        disabledValidate.value = false;
        return handleValidateEnd(null);
      }
      if (!props.prop || !formProps.model || validating.value) {
        return handleValidateEnd(null);
      }
      validating.value = true;
      const value = currentValue.value;
      const useRules = allRules.value;
      const model = formProps.model;
      let errors = await validate(
        useRules,
        value,
        model,
        isValidateAll.value,
        locale.value.validateFail
      );
      errors = errors.length ? errors : null;
      return handleValidateEnd(errors);
    }
    function handleValidateEnd(errors) {
      validating.value = false;
      if (!errors) {
        clearError();
      } else {
        isError.value = true;
        errorTip.value = Array.isArray(errors) ? errors[0] : errors;
      }
      return errors;
    }
    function handleLabelClick() {
      emitter.emit("focus");
    }
    return {
      props,
      nh,
      isError,
      errorTip,
      labelSuffix: toRef(formProps, "labelSuffix"),
      isNative: computed(() => !!(formProps.action && formProps.method)),
      className,
      inputValue,
      useAsterisk,
      hasLabel,
      computedlabelWidth,
      controlStyle,
      labelEl,
      handleLabelClick
    };
  }
});
const _hoisted_1 = ["name", "value"];
const _hoisted_2 = ["for"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CircleQuestionR = resolveComponent("CircleQuestionR");
  const _component_Icon = resolveComponent("Icon");
  const _component_Tooltip = resolveComponent("Tooltip");
  const _component_Column = resolveComponent("Column");
  return _ctx.props.pure ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(_component_Column, mergeProps({ key: 1 }, _ctx.$attrs, {
    class: _ctx.className,
    role: "group",
    tag: "div",
    span: _ctx.props.span,
    offset: _ctx.props.offset,
    push: _ctx.props.push,
    pull: _ctx.props.pull,
    order: _ctx.props.order,
    xs: _ctx.props.xs,
    sm: _ctx.props.sm,
    md: _ctx.props.md,
    lg: _ctx.props.lg,
    xl: _ctx.props.xl,
    xxl: _ctx.props.xxl,
    flex: _ctx.props.flex
  }), {
    default: withCtx(() => [
      _ctx.isNative ? (openBlock(), createElementBlock("input", {
        key: 0,
        type: "hidden",
        name: _ctx.props.prop,
        value: _ctx.inputValue,
        style: { "display": "none" }
      }, null, 8, _hoisted_1)) : createCommentVNode("", true),
      _ctx.hasLabel ? (openBlock(), createElementBlock("label", {
        key: 1,
        ref: "labelEl",
        class: normalizeClass(_ctx.nh.be("label")),
        style: normalizeStyle({ width: `${_ctx.computedlabelWidth}px` }),
        for: _ctx.props.htmlFor || _ctx.props.prop,
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleLabelClick && _ctx.handleLabelClick(...args))
      }, [
        renderSlot(_ctx.$slots, "label", {}, () => [
          _ctx.props.help || _ctx.$slots.help ? (openBlock(), createBlock(_component_Tooltip, {
            key: 0,
            transfer: ""
          }, {
            trigger: withCtx(() => [
              createVNode(_component_Icon, {
                class: normalizeClass(_ctx.nh.be("help"))
              }, {
                default: withCtx(() => [
                  createVNode(_component_CircleQuestionR)
                ]),
                _: 1
              }, 8, ["class"])
            ]),
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "help", {}, () => [
                createElementVNode("div", {
                  class: normalizeClass(_ctx.nh.be("help-tip"))
                }, toDisplayString(_ctx.props.help), 3)
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.props.label + (_ctx.labelSuffix || "")), 1)
        ])
      ], 14, _hoisted_2)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass({
          [_ctx.nh.be("control")]: true,
          [_ctx.nh.bem("control", "no-label")]: !_ctx.hasLabel,
          [_ctx.nh.bem("control", "action")]: _ctx.props.action
        }),
        role: "alert",
        "aria-relevant": "all",
        style: normalizeStyle(_ctx.controlStyle)
      }, [
        renderSlot(_ctx.$slots, "default"),
        createVNode(Transition, {
          name: _ctx.props.errorTransition
        }, {
          default: withCtx(() => [
            !_ctx.props.hideErrorTip && _ctx.isError ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("error-tip"))
            }, [
              renderSlot(_ctx.$slots, "error", { tip: _ctx.errorTip }, () => [
                createTextVNode(toDisplayString(_ctx.errorTip), 1)
              ])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name"])
      ], 6)
    ]),
    _: 3
  }, 16, ["class", "span", "offset", "push", "pull", "order", "xs", "sm", "md", "lg", "xl", "xxl", "flex"]));
}
var FormItem = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { FormItem as default };
