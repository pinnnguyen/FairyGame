import { defineComponent, reactive, computed, provide, resolveComponent, openBlock, createBlock, mergeProps, withCtx, renderSlot } from "vue";
import "../row/index.mjs";
import "../../common/config/src/index.mjs";
import { formProps } from "./props.mjs";
import { FORM_PROPS, FORM_FIELDS, FORM_ACTIONS } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Row from "../row/row.mjs";
import { useProps, createSizeProp } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const submitMethods = Object.freeze(["get", "post", "put", "delete"]);
const labelAligns = Object.freeze(["right", "top", "left"]);
const _sfc_main = defineComponent({
  name: "Form",
  components: {
    Row
  },
  inheritAttrs: true,
  props: formProps,
  setup(_props) {
    const props = useProps("form", _props, {
      method: {
        default: "post",
        validator: (value) => submitMethods.includes(value)
      },
      action: null,
      model: {
        default: () => ({}),
        static: true
      },
      rules: () => ({}),
      labelWidth: "auto",
      labelAlign: {
        default: "right",
        validator: (value) => labelAligns.includes(value)
      },
      allRequired: false,
      labelSuffix: "",
      hideAsterisk: false,
      validateAll: false,
      hideLabel: false,
      disabled: false,
      loading: false,
      size: createSizeProp(),
      inline: false,
      gap: [8, 0],
      justify: "start",
      align: "top"
    });
    const nh = useNameHelper("form");
    const fieldSet = reactive(/* @__PURE__ */ new Set());
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(`label-${props.labelAlign}`),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("inline")]: props.inline
        }
      ];
    });
    const labelWidth = computed(() => {
      return Math.max(...Array.from(fieldSet).map((field) => field.labelWidth.value));
    });
    provide(FORM_PROPS, props);
    provide(FORM_FIELDS, fieldSet);
    provide(FORM_ACTIONS, {
      getLabelWidth,
      validate,
      validateFields,
      reset,
      resetFields,
      clearError,
      clearFieldsError
    });
    function getLabelWidth() {
      if (typeof props.labelWidth === "number") {
        return props.labelWidth;
      }
      return labelWidth.value;
    }
    function getPropMap() {
      const propMap = {};
      for (const field of fieldSet) {
        if (field.prop.value) {
          propMap[field.prop.value] = field;
        }
      }
      return propMap;
    }
    function validate() {
      return validateItems(fieldSet);
    }
    function validateFields(props2) {
      if (!Array.isArray(props2)) {
        props2 = [props2];
      }
      const propMap = getPropMap();
      const fields = /* @__PURE__ */ new Set();
      props2.forEach((prop) => {
        if (propMap[prop]) {
          fields.add(propMap[prop]);
        }
      });
      return validateItems(fields);
    }
    function validateItems(items) {
      const validations = [];
      items.forEach((item) => {
        validations.push(item.validate());
      });
      return new Promise((resolve) => {
        Promise.all(validations).then((errors) => {
          resolve(errors.flat().filter(Boolean));
        });
      });
    }
    function reset() {
      fieldSet.forEach((field) => {
        field.reset();
      });
    }
    function resetFields(props2) {
      if (!Array.isArray(props2)) {
        props2 = [props2];
      }
      const propMap = getPropMap();
      props2.forEach((prop) => {
        if (propMap[prop]) {
          propMap[prop].reset();
        }
      });
    }
    function clearError() {
      fieldSet.forEach((field) => {
        field.clearError();
      });
    }
    function clearFieldsError(props2) {
      if (!Array.isArray(props2)) {
        props2 = [props2];
      }
      const propMap = getPropMap();
      props2.forEach((prop) => {
        if (propMap[prop]) {
          propMap[prop].clearError();
        }
      });
    }
    return {
      props,
      className,
      validate,
      validateFields,
      reset,
      resetFields,
      clearError,
      clearFieldsError
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Row = resolveComponent("Row");
  return openBlock(), createBlock(_component_Row, mergeProps(_ctx.$attrs, {
    class: _ctx.className,
    tag: "form",
    method: _ctx.props.action && _ctx.props.method,
    action: _ctx.props.action,
    gap: _ctx.props.gap,
    justify: _ctx.props.justify,
    align: _ctx.props.align,
    "column-flex": void 0
  }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "method", "action", "gap", "justify", "align"]);
}
var Form = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Form as default };
