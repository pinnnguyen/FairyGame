import { computed, getCurrentInstance, inject, provide, onBeforeUnmount } from "vue";
import { isNull, noop } from "@vexip-ui/utils";
import { FIELD_OPTIONS } from "./symbol.mjs";
function getValueByPath(obj, path, strict = false) {
  if (!obj || !path)
    return null;
  if (typeof path === "string") {
    if (path in obj)
      return obj[path];
    path = path.split(".");
  }
  if (Array.isArray(path) && path.length) {
    const lastKey = path.pop();
    if (!lastKey)
      return null;
    for (let i = 0, len = path.length; i < len; ++i) {
      const key = String(path[i]);
      if (!key)
        break;
      obj = obj[key];
      if (isNull(obj)) {
        if (strict) {
          throw new Error("[vexip-ui:Form] Get value by an invalid path");
        }
        return obj;
      }
    }
    if (strict && isNull(obj[lastKey])) {
      throw new Error("[vexip-ui:Form] Get value by an invalid path");
    }
    return obj[lastKey];
  }
  return null;
}
function setValueByPath(obj, path, value, strict = false) {
  if (!obj || !path)
    return false;
  if (typeof path === "string") {
    if (path in obj) {
      obj[path] = value;
      return true;
    }
    path = path.split(".");
  }
  if (Array.isArray(path) && path.length) {
    const lastKey = path.pop();
    if (!lastKey)
      return false;
    for (let i = 0, len = path.length; i < len; ++i) {
      const key = String(path[i]);
      if (!key) {
        return false;
      }
      if (typeof obj[key] !== "object") {
        if (strict) {
          throw new Error("[vexip-ui:Form] Set value by an invalid path");
        }
        obj[key] = {};
      }
      obj = obj[key];
    }
    if (strict && typeof obj !== "object") {
      throw new Error("[vexip-ui:Form] Set value by an invalid path");
    }
    obj[lastKey] = value;
    return true;
  }
  return false;
}
const defaultProp = computed(() => "");
const defaultState = computed(() => "default");
const defaultFalse = computed(() => false);
const defaultSize = computed(() => "default");
function getEmptyActions() {
  return {
    isField: false,
    idFor: defaultProp,
    state: defaultState,
    disabled: defaultFalse,
    loading: defaultFalse,
    size: defaultSize,
    validateField: noop,
    clearField: noop,
    resetField: noop,
    getFieldValue: (v) => v,
    setFieldValue: noop
  };
}
function useFieldStore(onFocus) {
  const instance = getCurrentInstance();
  if (!instance)
    return getEmptyActions();
  const fieldOptions = inject(FIELD_OPTIONS, null);
  if (!fieldOptions) {
    return getEmptyActions();
  }
  provide(FIELD_OPTIONS, null);
  fieldOptions.sync(instance);
  onFocus && fieldOptions.emitter.on("focus", onFocus);
  onBeforeUnmount(() => {
    fieldOptions.unsync(instance);
    onFocus && fieldOptions.emitter.off("focus", onFocus);
  });
  function clearField(defaultValue) {
    if (!fieldOptions)
      return;
    fieldOptions.setValue(defaultValue);
    fieldOptions.clearError();
  }
  return {
    isField: true,
    idFor: fieldOptions.idFor,
    state: fieldOptions.state,
    disabled: fieldOptions.disabled,
    loading: fieldOptions.loading,
    size: fieldOptions.size,
    validateField: fieldOptions.validate,
    clearField,
    resetField: fieldOptions.reset,
    getFieldValue: fieldOptions.getValue,
    setFieldValue: fieldOptions.setValue
  };
}
export { getValueByPath, setValueByPath, useFieldStore };
