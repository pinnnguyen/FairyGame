import { defineComponent, ref, computed, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle, renderSlot, Fragment, withModifiers, createVNode, renderList } from "vue";
import "../icon/index.mjs";
import "../../common/config/src/index.mjs";
import { useMoving } from "@vexip-ui/hooks";
import { ChevronDown, ChevronUp, ChevronRight, ChevronLeft } from "@vexip-ui/icons";
import { splitProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "Split",
  components: {
    Icon
  },
  props: splitProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const props = useProps("split", _props, {
      value: {
        default: 0.5,
        validator: (value) => value > 0 && value < 1,
        static: true
      },
      min: 0.1,
      max: 0.9,
      vertical: false,
      noTransition: false,
      lazy: false,
      canFull: false
    });
    const nh = useNameHelper("split");
    const currentValue = ref(props.value);
    const currentFull = ref(0);
    const transition = ref(false);
    const wrapper = ref();
    const guide = ref();
    const { target: handler, moving } = useMoving({
      lazy: true,
      capture: false,
      onStart: (state, event) => {
        if (currentFull.value || !wrapper.value || event.button > 0) {
          return false;
        }
        const { min, max, vertical, lazy } = props;
        const outer = wrapper.value[offset.value];
        const computedMin = min <= 1 ? min : min / outer;
        const computedMax = max <= 1 ? max : max / outer;
        state.outer = outer;
        state.min = computedMin;
        state.max = computedMax;
        state.vertical = vertical;
        state.splitLazy = lazy;
        state.start = currentValue.value * outer;
        state.target = currentValue.value;
        if (lazy && guide.value) {
          guide.value.style[position.value[0]] = `${currentValue.value * 100}`;
          guide.value.style.display = "block";
        }
        emitEvent(props.onMoveStart, currentValue.value);
      },
      onMove: (state) => {
        const outer = state.outer;
        const min = state.min;
        const max = state.max;
        const delta = state.vertical ? state.deltaY : state.deltaX;
        const start = state.start;
        const value = Math.min(Math.max(min, (start + delta) / outer), max);
        if (state.splitLazy) {
          if (guide.value) {
            guide.value.style[position.value[0]] = `${value * 100}%`;
          }
          state.target = value;
        } else {
          currentValue.value = value;
        }
        emitEvent(props.onMove, value);
      },
      onEnd: (state) => {
        if (guide.value) {
          guide.value.style.display = "";
        }
        const target = state.target;
        if (state.splitLazy) {
          if (Math.abs(target - currentValue.value) > 0.01) {
            setTransition();
          }
          currentValue.value = target;
        }
        emitEvent(props.onMoveEnd, currentValue.value);
      }
    });
    const className = computed(() => {
      let fullType = "";
      if (currentFull.value) {
        if (props.vertical) {
          fullType = currentFull.value < 0 ? "top" : "bottom";
        } else {
          fullType = currentFull.value < 0 ? "left" : "right";
        }
      }
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.vertical ? "vertical" : "horizontal")]: true,
        [nh.bm("moving")]: moving.value,
        [nh.bm(`${fullType}-full`)]: !!fullType,
        [nh.bm("transition")]: transition.value
      };
    });
    const offset = computed(() => {
      return props.vertical ? "offsetHeight" : "offsetWidth";
    });
    const position = computed(() => {
      return props.vertical ? ["top", "bottom"] : ["left", "right"];
    });
    const leftPaneStyle = computed(() => {
      return {
        [position.value[1]]: currentFull.value < 0 ? "0" : currentFull.value > 0 ? "100%" : `${(1 - currentValue.value) * 100}%`
      };
    });
    const rightPaneStyle = computed(() => {
      return {
        [position.value[0]]: currentFull.value < 0 ? "100%" : currentFull.value > 0 ? "0" : `${currentValue.value * 100}%`
      };
    });
    const triggerStyle = computed(() => {
      return {
        [position.value[0]]: currentFull.value < 0 ? "100%" : currentFull.value > 0 ? "0" : `calc(${currentValue.value * 100}% - var(${nh.cv("handler-size")}) * 0.5)`
      };
    });
    const fullIcons = computed(() => {
      return props.vertical ? [ChevronDown, ChevronUp] : [ChevronRight, ChevronLeft];
    });
    watch(
      () => props.value,
      (value) => {
        if (value.toFixed(5) !== currentValue.value.toFixed(5)) {
          currentValue.value = value;
          setTransition();
        }
      }
    );
    watch(currentValue, (value) => {
      emitEvent(props.onChange, value);
      emit("update:value", value);
      if (guide.value) {
        guide.value.style[position.value[0]] = `${value * 100}%`;
      }
    });
    watch(currentFull, (value) => {
      setTransition();
      if (value) {
        let type;
        if (props.vertical) {
          type = value < 0 ? "top" : "bottom";
        } else {
          type = value < 0 ? "left" : "right";
        }
        emitEvent(props.onFull, type);
      } else {
        emitEvent(props.onReset);
      }
    });
    function setTransition() {
      transition.value = !props.noTransition && !moving.value;
    }
    function removeTransition() {
      transition.value = false;
    }
    function handleFull(type) {
      if (!props.canFull) {
        return;
      }
      if (currentFull.value) {
        currentFull.value = 0;
      } else {
        currentFull.value = type;
      }
    }
    return {
      props,
      nh,
      className,
      position,
      leftPaneStyle,
      rightPaneStyle,
      triggerStyle,
      fullIcons,
      wrapper,
      guide,
      handler,
      removeTransition,
      handleFull
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onTransitionend: _cache[4] || (_cache[4] = (...args) => _ctx.removeTransition && _ctx.removeTransition(...args))
  }, [
    createElementVNode("div", {
      class: normalizeClass([_ctx.nh.be("panel"), _ctx.nh.bem("panel", _ctx.props.vertical ? "top" : "left")]),
      style: normalizeStyle(_ctx.leftPaneStyle)
    }, [
      renderSlot(_ctx.$slots, "left")
    ], 6),
    createElementVNode("div", {
      class: normalizeClass([_ctx.nh.be("panel"), _ctx.nh.bem("panel", _ctx.props.vertical ? "bottom" : "right")]),
      style: normalizeStyle(_ctx.rightPaneStyle)
    }, [
      renderSlot(_ctx.$slots, "right")
    ], 6),
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("trigger")),
      style: normalizeStyle(_ctx.triggerStyle)
    }, [
      createElementVNode("div", {
        ref: "handler",
        class: normalizeClass(_ctx.nh.be("handler"))
      }, [
        _ctx.props.canFull ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createElementVNode("button", {
            class: normalizeClass([_ctx.nh.be("button"), _ctx.nh.bem("button", `${_ctx.props.vertical ? "top" : "left"}-full`)]),
            onPointerdown: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"])),
            onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.handleFull(-1), ["left"]))
          }, [
            createVNode(_component_Icon, {
              icon: _ctx.fullIcons[0],
              scale: 0.6
            }, null, 8, ["icon", "scale"])
          ], 34),
          createElementVNode("button", {
            class: normalizeClass([
              _ctx.nh.be("button"),
              _ctx.nh.bem("button", `${_ctx.props.vertical ? "bottom" : "right"}-full`)
            ]),
            onPointerdown: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop"])),
            onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.handleFull(1), ["left"]))
          }, [
            createVNode(_component_Icon, {
              icon: _ctx.fullIcons[1],
              scale: 0.6
            }, null, 8, ["icon", "scale"])
          ], 34)
        ], 64)) : renderSlot(_ctx.$slots, "handler", { key: 1 }, () => [
          (openBlock(), createElementBlock(Fragment, null, renderList(6, (n) => {
            return createElementVNode("span", {
              key: n,
              class: normalizeClass(_ctx.nh.be("pointer"))
            }, null, 2);
          }), 64))
        ])
      ], 2)
    ], 6),
    createElementVNode("div", {
      ref: "guide",
      class: normalizeClass(_ctx.nh.be("guide"))
    }, null, 2)
  ], 34);
}
var Split = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Split as default };
