import { defineComponent, ref, computed, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, renderSlot, createVNode, createCommentVNode, createElementVNode, Transition, withCtx, withModifiers, Fragment } from "vue";
import "../icon/index.mjs";
import "../form/index.mjs";
import { useHover, useModifier } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { isNull, toFixed, toNumber, plus, minus, boundRange, debounce, throttle } from "@vexip-ui/utils";
import { CaretUp, CaretDown, CircleXmark, Spinner } from "@vexip-ui/icons";
import { numberInputProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const isNullOrNaN = (value) => isNull(value) || Number.isNaN(value);
const _sfc_main = defineComponent({
  name: "NumberInput",
  components: {
    Icon,
    CaretUp,
    CaretDown,
    CircleXmark
  },
  props: numberInputProps,
  emits: ["update:value"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(focus);
    const props = useProps("numberInput", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      formatter: {
        default: null,
        isFunc: true
      },
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      min: -Infinity,
      max: Infinity,
      placeholder: null,
      autofocus: false,
      spellcheck: false,
      autocomplete: false,
      precision: 0,
      readonly: false,
      step: 1,
      ctrlStep: 100,
      shiftStep: 10,
      altStep: 0.1,
      disabled: () => disabled.value,
      inputClass: null,
      debounce: false,
      clearable: false,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      sync: false,
      controlType: "right"
    });
    const nh = useNameHelper("number-input");
    const focused = ref(false);
    const currentValue = ref(props.value);
    const inputting = ref(false);
    const inputControl = ref();
    const { wrapper, isHover } = useHover();
    useModifier({
      target: inputControl,
      passive: false,
      onKeyDown: (event, modifier) => {
        emitEvent(props.onKeyDown, event);
        if (modifier.up || modifier.down) {
          event.preventDefault();
          changeStep(
            modifier.up ? "plus" : "minus",
            event.ctrlKey ? "ctrl" : event.shiftKey ? "shift" : event.altKey ? "alt" : void 0
          );
          modifier.resetAll();
        } else if (modifier.enter) {
          event.preventDefault();
          emitChangeEvent("change");
          modifier.resetAll();
        }
      },
      onKeyUp: (event) => {
        emitEvent(props.onKeyUp, event);
        if (event.key === "Enter") {
          handleEnter();
        }
      }
    });
    let lastValue = props.value;
    const className = computed(() => {
      const [display, fade] = (props.controlType || "right").split("-");
      return [
        nh.b(),
        nh.ns("input-vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("focused")]: focused.value,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading && props.loadingLock,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm(`control-${display}`)]: display !== "right",
          [nh.bm("control-fade")]: fade
        }
      ];
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const hasSuffix = computed(() => {
      return !!(slots.suffix || props.suffix);
    });
    const inputStyle = computed(() => {
      return {
        paddingLeft: hasPrefix.value ? "2em" : "",
        paddingRight: hasSuffix.value ? "2em" : ""
      };
    });
    const preciseNumber = computed(() => {
      return !inputting.value && typeof currentValue.value === "number" && props.precision > 0 ? toFixed(currentValue.value, props.precision) : currentValue.value;
    });
    const formattedValue = computed(() => {
      var _a;
      if (typeof preciseNumber.value !== "number")
        return (_a = preciseNumber.value) != null ? _a : "";
      return typeof props.formatter === "function" ? props.formatter(preciseNumber.value) : preciseNumber.value.toString();
    });
    const plusDisabled = computed(() => {
      return !isNullOrNaN(currentValue.value) && currentValue.value >= props.max;
    });
    const minusDisabled = computed(() => {
      return !isNullOrNaN(currentValue.value) && currentValue.value <= props.min;
    });
    const hasValue = computed(() => {
      return currentValue.value || currentValue.value === 0;
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && hasValue.value;
    });
    const inputValue = computed(() => {
      if (Number.isNaN(currentValue.value)) {
        return "";
      }
      return focused.value ? preciseNumber.value : formattedValue.value;
    });
    const isReadonly = computed(() => props.loading && props.loadingLock || props.readonly);
    const controlFade = computed(() => {
      var _a;
      return (_a = props.controlType) == null ? void 0 : _a.endsWith("fade");
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = isNull(value) ? NaN : value;
        lastValue = currentValue.value;
      }
    );
    function focus() {
      inputControl.value && inputControl.value.focus();
    }
    function handleFocus(event) {
      focused.value = true;
      inputting.value = true;
      emitEvent(props.onFocus, event);
    }
    function handleBlur(event) {
      focused.value = false;
      setTimeout(() => {
        if (!focused.value) {
          inputting.value = false;
          emitEvent(props.onBlur, event);
          emitChangeEvent("change");
        }
      }, 120);
    }
    function plusNumber(event) {
      if (plusDisabled.value) {
        return;
      }
      !focused.value && focus();
      changeStep(
        "plus",
        event.ctrlKey ? "ctrl" : event.shiftKey ? "shift" : event.altKey ? "alt" : void 0
      );
    }
    function minusNumber(event) {
      if (minusDisabled.value) {
        return;
      }
      !focused.value && focus();
      changeStep(
        "minus",
        event.ctrlKey ? "ctrl" : event.shiftKey ? "shift" : event.altKey ? "alt" : void 0
      );
    }
    function changeStep(type, modifier) {
      if (props.disabled || props.loading && props.loadingLock) {
        return;
      }
      let value = currentValue.value || 0;
      let step;
      switch (modifier) {
        case "ctrl":
          step = props.ctrlStep;
          break;
        case "shift":
          step = props.shiftStep;
          break;
        case "alt":
          step = props.altStep;
          break;
        default:
          step = props.step;
      }
      const stringValue = value.toString().trim();
      if (stringValue.endsWith(".")) {
        value = toNumber(stringValue.slice(0, -1));
      }
      if (type === "plus") {
        value = plus(value, step);
      } else {
        value = minus(value, step);
      }
      setValue(value, "input");
    }
    function handleChange(event) {
      const type = event.type;
      const stringValue = event.target.value;
      let value = stringValue;
      if (!/^-?[0-9]*\.?[0-9]*$/.test(stringValue)) {
        const floatValue = parseFloat(stringValue);
        if (Number.isNaN(floatValue)) {
          value = "";
        } else {
          value = floatValue.toString();
        }
        event.target.value = value;
      }
      inputting.value = type === "input";
      setValue(toNumber(value), type);
    }
    function setValue(value, type) {
      if (type !== "input") {
        currentValue.value = boundRange(value, props.min, props.max);
      } else {
        currentValue.value = value;
      }
      emitChangeEvent(type);
    }
    function emitChangeEvent(type) {
      type = type === "input" ? "input" : "change";
      if (type === "change") {
        if (lastValue === currentValue.value)
          return;
        lastValue = currentValue.value;
        setFieldValue(currentValue.value);
        emitEvent(props.onChange, currentValue.value);
        if (!props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      } else {
        emitEvent(props.onInput, currentValue.value);
        if (props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      }
    }
    function handleClear() {
      setValue(NaN, "change");
      if (props.sync) {
        emit("update:value", currentValue.value);
        validateField();
      }
      emitEvent(props.onClear);
      clearField();
    }
    function handleEnter() {
      emitEvent(props.onEnter);
    }
    function handlePrefixClick(event) {
      emitEvent(props.onPrefixClick, event);
    }
    function handleSuffixClick(event) {
      emitEvent(props.onSuffixClick, event);
    }
    function handleKeyPress(event) {
      emitEvent(props.onKeyPress, event);
    }
    const handleInput = props.debounce ? debounce(handleChange) : throttle(handleChange);
    return {
      props,
      nh,
      locale: useLocale("input"),
      idFor,
      focused,
      isHover,
      className,
      hasPrefix,
      hasSuffix,
      inputStyle,
      preciseNumber,
      formattedValue,
      plusDisabled,
      minusDisabled,
      hasValue,
      showClear,
      inputValue,
      isReadonly,
      controlFade,
      wrapper,
      input: inputControl,
      handleFocus,
      handleBlur,
      plusNumber,
      minusNumber,
      handleInput,
      handleChange,
      handleClear,
      handlePrefixClick,
      handleSuffixClick,
      handleKeyPress
    };
  }
});
const _hoisted_1 = ["id"];
const _hoisted_2 = ["value", "autofocus", "autocomplete", "spellcheck", "disabled", "readonly", "placeholder", "aria-valuenow", "aria-valuemin", "aria-valuemax"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_Icon = resolveComponent("Icon");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_CaretUp = resolveComponent("CaretUp");
  const _component_CaretDown = resolveComponent("CaretDown");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[12] || (_cache[12] = ($event) => {
      var _a2;
      return (_a2 = _ctx.input) == null ? void 0 : _a2.focus();
    })
  }, [
    _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
      style: normalizeStyle({ color: _ctx.props.prefixColor }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handlePrefixClick && _ctx.handlePrefixClick(...args))
    }, [
      renderSlot(_ctx.$slots, "prefix", {}, () => [
        createVNode(_component_Icon, {
          icon: _ctx.props.prefix
        }, null, 8, ["icon"])
      ])
    ], 6)) : createCommentVNode("", true),
    createElementVNode("input", {
      ref: "input",
      type: "text",
      class: normalizeClass([_ctx.nh.be("control"), _ctx.inputClass]),
      value: _ctx.inputValue,
      autofocus: _ctx.props.autofocus,
      autocomplete: _ctx.props.autocomplete ? "on" : "off",
      spellcheck: _ctx.props.spellcheck,
      disabled: _ctx.props.disabled,
      readonly: _ctx.isReadonly,
      placeholder: (_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder,
      role: "spinbutton",
      "aria-valuenow": _ctx.preciseNumber,
      "aria-valuemin": _ctx.props.min !== -Infinity ? _ctx.props.min : void 0,
      "aria-valuemax": _ctx.props.max !== Infinity ? _ctx.props.max : void 0,
      onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onKeypress: _cache[3] || (_cache[3] = (...args) => _ctx.handleKeyPress && _ctx.handleKeyPress(...args)),
      onInput: _cache[4] || (_cache[4] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
      onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 42, _hoisted_2),
    _ctx.hasSuffix ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
      style: normalizeStyle({
        color: _ctx.props.suffixColor,
        opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
      }),
      onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleSuffixClick && _ctx.handleSuffixClick(...args))
    }, [
      renderSlot(_ctx.$slots, "suffix", {}, () => [
        createVNode(_component_Icon, {
          icon: _ctx.props.suffix
        }, null, 8, ["icon"])
      ])
    ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
    }, null, 2)) : createCommentVNode("", true),
    createVNode(Transition, {
      name: _ctx.nh.ns("fade"),
      appear: ""
    }, {
      default: withCtx(() => [
        _ctx.showClear ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
          onClick: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
        }, [
          createVNode(_component_Icon, null, {
            default: withCtx(() => [
              createVNode(_component_CircleXmark)
            ]),
            _: 1
          })
        ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
        }, [
          createVNode(_component_Icon, {
            spin: _ctx.props.loadingSpin,
            pulse: !_ctx.props.loadingSpin,
            icon: _ctx.props.loadingIcon
          }, null, 8, ["spin", "pulse", "icon"])
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["name"]),
    _ctx.props.controlType !== "none" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("plus")),
        onClick: _cache[8] || (_cache[8] = (...args) => _ctx.plusNumber && _ctx.plusNumber(...args)),
        onMousedown: _cache[9] || (_cache[9] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createVNode(_component_Icon, { scale: 0.8 }, {
          default: withCtx(() => [
            createVNode(_component_CaretUp)
          ]),
          _: 1
        }, 8, ["scale"])
      ], 34),
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("minus")),
        onClick: _cache[10] || (_cache[10] = (...args) => _ctx.minusNumber && _ctx.minusNumber(...args)),
        onMousedown: _cache[11] || (_cache[11] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createVNode(_component_Icon, { scale: 0.8 }, {
          default: withCtx(() => [
            createVNode(_component_CaretDown)
          ]),
          _: 1
        }, 8, ["scale"])
      ], 34)
    ], 64)) : createCommentVNode("", true)
  ], 10, _hoisted_1);
}
var NumberInput = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { NumberInput as default };
