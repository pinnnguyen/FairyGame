import { defineComponent, ref, watch, onMounted, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, normalizeClass, createVNode, withCtx, renderSlot, createBlock, withModifiers, createCommentVNode, createElementVNode, createTextVNode, toDisplayString } from "vue";
import "../checkbox/index.mjs";
import "../icon/index.mjs";
import "../option/index.mjs";
import "../virtual-list/index.mjs";
import { ChevronRight, Spinner, ArrowsRotate, Check } from "@vexip-ui/icons";
import "../../common/config/src/index.mjs";
import { useModifier } from "@vexip-ui/hooks";
import { boundRange } from "@vexip-ui/utils";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Checkbox from "../checkbox/checkbox.mjs";
import Icon from "../icon/icon.mjs";
import Option from "../option/option.mjs";
import VirtualList from "../virtual-list/virtual-list.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "CascaderPanel",
  components: {
    Checkbox,
    Icon,
    Option,
    VirtualList,
    ChevronRight,
    Spinner,
    ArrowsRotate
  },
  props: {
    options: {
      type: Array,
      default: () => []
    },
    openedId: {
      type: Number,
      default: null
    },
    values: {
      type: Array,
      default: () => []
    },
    ready: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    checkIcon: {
      type: Object,
      default: Check
    },
    isAsync: {
      type: Boolean,
      default: false
    },
    merged: {
      type: Boolean,
      default: false
    },
    noCascaded: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: false
    }
  },
  emits: ["select", "check", "hover", "open", "back", "close"],
  setup(props, { emit }) {
    const nh = useNameHelper("cascader");
    const currentHitting = ref(-1);
    const list = ref();
    const { target: wrapper } = useModifier({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down) {
          event.preventDefault();
          if (currentHitting.value < 0) {
            currentHitting.value = props.options.findIndex(isSelected);
            if (currentHitting.value < 0) {
              currentHitting.value = 0;
            }
            return;
          }
          currentHitting.value = boundRange(
            findEnabledIndex(currentHitting.value + (modifier.up ? -1 : 1), modifier.up ? -1 : 1),
            0,
            props.options.length - 1
          );
          ensureOptionInView(currentHitting.value, modifier.up ? "top" : "bottom");
        } else if (modifier.left || modifier.right) {
          event.preventDefault();
          if (modifier.right) {
            const option = props.options[currentHitting.value];
            if (option && hasChildren(option)) {
              emit("open", option);
            }
          } else {
            emit("back");
          }
        } else if (modifier.enter || modifier.space) {
          event.preventDefault();
          event.stopPropagation();
          const option = props.options[currentHitting.value];
          if (option) {
            if (props.multiple) {
              handleToggleCheck(option);
            } else {
              handleSelect(option, currentHitting.value);
            }
          }
        } else if (modifier.escape) {
          emit("close");
        }
      }
    });
    let listHeight = 0;
    let hoverTimer;
    watch(
      () => props.ready,
      (value) => {
        var _a;
        requestAnimationFrame(computeListHeight);
        if (value) {
          (_a = list.value) == null ? void 0 : _a.refresh();
          currentHitting.value = props.options.findIndex(isSelected);
        } else {
          currentHitting.value = -1;
        }
      }
    );
    onMounted(() => {
      requestAnimationFrame(computeListHeight);
    });
    onBeforeUnmount(handleMouseLeave);
    function hasChildren(option) {
      var _a;
      return !!(option.hasChild || ((_a = option.children) == null ? void 0 : _a.length));
    }
    function isSelected(option) {
      return hasChildren(option) && option.id === props.openedId || props.values.includes(option.fullValue);
    }
    function isCheckboxDisabled(option) {
      return option.disabled || !props.merged && props.multiple && props.isAsync && hasChildren(option) && !option.childrenLoaded;
    }
    function handleSelect(option, index) {
      if (option.disabled)
        return;
      currentHitting.value = index;
      if (props.multiple || props.noCascaded) {
        hasChildren(option) ? emit("select", option) : handleToggleCheck(option);
      } else {
        emit("select", option);
      }
    }
    function handleToggleCheck(option) {
      !isCheckboxDisabled(option) && emit("check", option);
    }
    function handleMouseEnter(option) {
      clearTimeout(hoverTimer);
      hoverTimer = setTimeout(() => {
        !option.disabled && emit("hover", option);
      }, 250);
    }
    function handleMouseLeave() {
      clearTimeout(hoverTimer);
    }
    function computeListHeight() {
      var _a;
      const el = (_a = list.value) == null ? void 0 : _a.wrapper;
      if (el) {
        const style = getComputedStyle(el);
        const paddingTop = parseInt(style.paddingTop);
        const paddingBottom = parseInt(style.paddingBottom);
        listHeight = el.offsetHeight - paddingTop - paddingBottom;
      }
    }
    function queryEnabledIndex(index, step) {
      var _a;
      const options = props.options;
      step = step / Math.abs(step);
      while ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index += step;
        if (index < 0 || index >= options.length)
          break;
      }
      return index;
    }
    function findEnabledIndex(index, sign = 1) {
      var _a;
      const options = props.options;
      if ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index = queryEnabledIndex(index, sign);
        if (sign > 0 ? index >= options.length : index < 0) {
          index = queryEnabledIndex(index, -sign);
          if (sign > 0 ? index < 0 : index >= options.length)
            index = -1;
        }
      }
      return index;
    }
    function ensureOptionInView(index, direction) {
      const option = props.options[index];
      const optionHeight = 32;
      if (!option || !list.value)
        return;
      if (direction === "bottom") {
        const target = (index + 1) * optionHeight;
        if (list.value.scrollOffset + listHeight < target) {
          list.value.scrollTo(target - listHeight);
        }
      } else {
        const target = index * optionHeight;
        if (list.value.scrollOffset > target) {
          list.value.scrollTo(target);
        }
      }
    }
    return {
      nh,
      currentHitting,
      wrapper,
      list,
      hasChildren,
      isSelected,
      isCheckboxDisabled,
      handleSelect,
      handleToggleCheck,
      handleMouseEnter,
      handleMouseLeave,
      computeListHeight
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Spinner = resolveComponent("Spinner");
  const _component_Icon = resolveComponent("Icon");
  const _component_ArrowsRotate = resolveComponent("ArrowsRotate");
  const _component_ChevronRight = resolveComponent("ChevronRight");
  const _component_Option = resolveComponent("Option");
  const _component_VirtualList = resolveComponent("VirtualList");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("panel")),
    tabindex: "-1",
    onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
  }, [
    createVNode(_component_VirtualList, {
      ref: "list",
      inherit: "",
      items: _ctx.options,
      "item-size": 32,
      height: "100%",
      "id-key": "id",
      "items-attrs": {
        class: [
          _ctx.nh.be("options"),
          _ctx.multiple ? _ctx.nh.bem("options", "multiple") : null,
          _ctx.noCascaded ? _ctx.nh.bem("options", "no-cascaded") : null
        ],
        role: "listbox"
      },
      onResize: _ctx.computeListHeight
    }, {
      default: withCtx(({ item, index }) => [
        createVNode(_component_Option, {
          class: normalizeClass({
            [_ctx.nh.ns("option--error")]: item.error
          }),
          value: item.value,
          label: item.label,
          disabled: item.disabled,
          selected: _ctx.isSelected(item),
          hitting: index === _ctx.currentHitting,
          onSelect: ($event) => _ctx.handleSelect(item, index),
          onMouseenter: ($event) => _ctx.handleMouseEnter(item)
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {
              option: item,
              index,
              selected: _ctx.isSelected(item),
              canCheck: _ctx.isCheckboxDisabled(item),
              hasChild: _ctx.hasChildren(item)
            }, () => [
              _ctx.multiple || _ctx.noCascaded ? (openBlock(), createBlock(_component_Checkbox, {
                key: 0,
                inherit: "",
                class: normalizeClass(_ctx.nh.be("checkbox")),
                checked: item.checked,
                control: _ctx.hasChildren(item),
                partial: item.partial,
                disabled: _ctx.isCheckboxDisabled(item),
                size: "small",
                onClick: withModifiers(($event) => _ctx.handleToggleCheck(item), ["prevent", "stop"])
              }, null, 8, ["class", "checked", "control", "partial", "disabled", "onClick"])) : createCommentVNode("", true),
              createElementVNode("span", {
                class: normalizeClass(_ctx.nh.be("label"))
              }, [
                renderSlot(_ctx.$slots, "label", {
                  option: item,
                  index,
                  selected: _ctx.isSelected(item),
                  canCheck: _ctx.isCheckboxDisabled(item),
                  hasChild: _ctx.hasChildren(item),
                  handleSelect: () => _ctx.handleSelect(item, index)
                }, () => [
                  createTextVNode(toDisplayString(item.label), 1)
                ])
              ], 2),
              createElementVNode("div", {
                class: normalizeClass(_ctx.nh.be("icon"))
              }, [
                item.loading ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  pulse: ""
                }, {
                  default: withCtx(() => [
                    createVNode(_component_Spinner)
                  ]),
                  _: 1
                })) : item.error ? (openBlock(), createBlock(_component_Icon, { key: 1 }, {
                  default: withCtx(() => [
                    createVNode(_component_ArrowsRotate)
                  ]),
                  _: 1
                })) : _ctx.hasChildren(item) ? (openBlock(), createBlock(_component_Icon, { key: 2 }, {
                  default: withCtx(() => [
                    createVNode(_component_ChevronRight)
                  ]),
                  _: 1
                })) : !_ctx.multiple && !_ctx.noCascaded && _ctx.checkIcon && _ctx.values.includes(item.fullValue) ? (openBlock(), createBlock(_component_Icon, {
                  key: 3,
                  icon: _ctx.checkIcon
                }, null, 8, ["icon"])) : createCommentVNode("", true)
              ], 2)
            ])
          ]),
          _: 2
        }, 1032, ["class", "value", "label", "disabled", "selected", "hitting", "onSelect", "onMouseenter"])
      ]),
      _: 3
    }, 8, ["items", "items-attrs", "onResize"])
  ], 34);
}
var CascaderPanel = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { CascaderPanel as default };
