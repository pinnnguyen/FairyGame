import { defineComponent, inject, ref, computed, provide, reactive, watch, nextTick, resolveComponent, openBlock, createElementBlock, Fragment, mergeProps, withModifiers, renderSlot, createElementVNode, normalizeClass, normalizeStyle, createBlock, withCtx, createVNode, createCommentVNode, createTextVNode, toDisplayString, renderList, normalizeProps, guardReactiveProps } from "vue";
import "../checkbox/index.mjs";
import "../collapse-transition/index.mjs";
import "../icon/index.mjs";
import "../renderer/index.mjs";
import "../../common/config/src/index.mjs";
import { useModifier } from "@vexip-ui/hooks";
import { noop, isNull } from "@vexip-ui/utils";
import { ChevronRight, Spinner } from "@vexip-ui/icons";
import { TREE_STATE, TREE_NODE_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Checkbox from "../checkbox/checkbox.mjs";
import CollapseTransition from "../collapse/collapse-transition.mjs";
import Icon from "../icon/icon.mjs";
import Renderer from "../renderer/renderer.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "TreeNode",
  components: {
    Checkbox,
    CollapseTransition,
    Icon,
    Renderer,
    ChevronRight,
    Spinner
  },
  inheritAttrs: false,
  props: {
    node: {
      type: Object,
      default: () => ({})
    },
    data: {
      type: Object,
      default: () => ({})
    },
    arrow: {
      type: [Boolean, String],
      default: "auto",
      validator: (value) => typeof value === "boolean" || value === "auto"
    },
    checkbox: {
      type: Boolean,
      default: null
    },
    appear: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: true
    },
    selected: {
      type: Boolean,
      default: false
    },
    expanded: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    labelKey: {
      type: String,
      default: "label"
    },
    checked: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    loaded: {
      type: Boolean,
      default: false
    },
    partial: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    indent: {
      type: [String, Number],
      default: "16px"
    },
    draggable: {
      type: Boolean,
      default: false
    },
    floorSelect: {
      type: Boolean,
      default: false
    },
    matched: {
      type: Boolean,
      default: true
    },
    childMatched: {
      type: Boolean,
      default: false
    },
    upperMatched: {
      type: Boolean,
      default: false
    },
    nodeProps: {
      type: Function,
      default: noop
    }
  },
  setup(props) {
    const treeState = inject(TREE_STATE);
    const parentState = inject(TREE_NODE_STATE);
    const nh = useNameHelper("tree");
    const nodeElement = ref();
    const arrowElement = ref();
    useModifier({
      target: nodeElement,
      passive: false,
      onKeyDown: (event, modifier) => {
        var _a;
        const prevent = () => {
          event.preventDefault();
          event.stopPropagation();
        };
        if (modifier.up || modifier.down) {
          prevent();
          treeState.handleHittingChange(modifier.up ? "up" : "down");
        } else if (modifier.left || modifier.right) {
          prevent();
          const hasChild = ((_a = props.node.children) == null ? void 0 : _a.length) > 0;
          if (modifier.right && props.expanded && hasChild) {
            treeState.handleHittingChange("down");
          } else if (modifier.left && (!props.expanded || !hasChild)) {
            treeState.handleNodeHitting(parentState.el);
          } else {
            handleToggleExpand(modifier.right);
          }
        } else if (hasCheckbox.value && modifier.space) {
          prevent();
          handleToggleCheck();
        } else if (modifier.enter) {
          prevent();
          handleToggleSelect();
        }
      }
    });
    const loaded = ref(props.loaded);
    const dragging = ref(false);
    const isDragOver = ref(false);
    const focused = ref(false);
    const isDisabled = computed(() => parentState.disabled || props.disabled);
    const isReadonly = computed(() => parentState.readonly || props.readonly);
    const depth = computed(() => parentState.depth + 1);
    const secondary = computed(() => !props.matched && (props.childMatched || props.upperMatched));
    const className = computed(() => {
      return {
        [nh.be("node")]: true,
        [nh.bem("node", "selected")]: props.selected,
        [nh.bem("node", "expanded")]: props.expanded,
        [nh.bem("node", "disabled")]: isDisabled.value,
        [nh.bem("node", "readonly")]: isReadonly.value,
        [nh.bem("node", "secondary")]: secondary.value,
        [nh.bem("node", "dragging")]: dragging.value,
        [nh.bem("node", "drag-over")]: isDragOver.value
      };
    });
    const contentStyle = computed(() => {
      let indent = props.indent;
      if (typeof indent === "number") {
        indent = `${indent}px`;
      }
      return {
        paddingLeft: depth.value ? depth.value === 1 ? indent : `calc(${depth.value} * ${indent})` : 0
      };
    });
    const showChildren = computed(() => {
      var _a;
      return props.expanded && ((_a = props.node.children) == null ? void 0 : _a.length) > 0;
    });
    const hasArrow = computed(() => {
      var _a;
      const arrow = props.arrow;
      let arrowSign = "auto";
      let asyncLoad = false;
      if (isNull(arrow) || arrow === "auto") {
        if (treeState) {
          arrowSign = treeState.arrow;
          asyncLoad = treeState.boundAsyncLoad;
        }
      } else {
        arrowSign = arrow;
      }
      return arrowSign === "auto" ? !!((_a = props.node.children) == null ? void 0 : _a.length) || !loaded.value && asyncLoad : !!arrowSign;
    });
    const hasCheckbox = computed(() => {
      const checkbox = props.checkbox;
      return isNull(checkbox) ? treeState.checkbox : checkbox;
    });
    const renderer = computed(() => treeState.renderer);
    const suffixCheckbox = computed(() => treeState.suffixCheckbox);
    provide(
      TREE_NODE_STATE,
      reactive({
        el: nodeElement,
        depth,
        disabled: isDisabled,
        readonly: isReadonly
      })
    );
    watch(
      () => props.loaded,
      (value) => {
        loaded.value = value;
      }
    );
    function updateVisible() {
      treeState.updateVisibleNodeEls();
    }
    function setValue(key, value) {
      props.node[key] = value;
    }
    function handleClick() {
      treeState.handleNodeClick(props.node);
    }
    function handleToggleCheck(able = !props.checked) {
      if (isDisabled.value)
        return;
      setValue("checked", able);
      setValue("partial", false);
      nextTick(() => {
        treeState.computeCheckedState(props.node, able);
      });
    }
    async function handleToggleExpand(able = !props.expanded) {
      if (props.loading || isDisabled.value)
        return;
      if (able && treeState.boundAsyncLoad && !loaded.value) {
        setValue("loading", true);
        const result = await treeState.handleAsyncLoad(props.node);
        asyncLoadCallback(result);
      } else {
        setValue("expanded", able);
        if (able) {
          treeState.handleNodeExpand(props.node);
        } else {
          treeState.handleNodeReduce(props.node);
        }
      }
    }
    function handleToggleSelect(able = !props.selected) {
      if (isDisabled.value)
        return;
      if (props.floorSelect) {
        return handleToggleExpand();
      }
      setValue("selected", !isReadonly.value && able);
      if (isReadonly.value || able) {
        treeState.handleNodeSelect(props.node);
      } else {
        treeState.handleNodeCancel(props.node);
      }
    }
    function handleLabelClick() {
      treeState.handleLabelClick(props.node);
      handleToggleSelect();
    }
    function asyncLoadCallback(success = true) {
      setValue("loading", false);
      setValue("expanded", success !== false);
      if (success) {
        loaded.value = true;
        treeState.handleNodeExpand(props.node);
      }
    }
    function getNodeState() {
      return {
        el: nodeElement.value,
        arrow: arrowElement.value,
        node: props.node
      };
    }
    function handleDragStart() {
      if (!props.draggable)
        return;
      dragging.value = true;
      treeState.handleNodeDragStart(getNodeState());
    }
    function handleDragOver(event) {
      if (!props.draggable || !treeState.dragging)
        return;
      event.stopPropagation();
      event.preventDefault();
      isDragOver.value = true;
      treeState.handleNodeDragOver(getNodeState(), event);
    }
    function handleDragLeave(event) {
      if (!props.draggable)
        return;
      event.preventDefault();
      isDragOver.value = false;
    }
    function handleDrop(event) {
      if (!props.draggable || !treeState.dragging)
        return;
      event.stopPropagation();
      event.preventDefault();
      isDragOver.value = false;
      treeState.handleNodeDrop(getNodeState());
    }
    function handleDragEnd(event) {
      if (!props.draggable || !treeState.dragging)
        return;
      event.stopPropagation();
      dragging.value = false;
      treeState.handleNodeDragEnd(getNodeState());
    }
    function getNodeChildren(node) {
      return node.children;
    }
    return {
      nh,
      dragging,
      focused,
      isDisabled,
      isReadonly,
      depth,
      secondary,
      className,
      contentStyle,
      showChildren,
      hasArrow,
      hasCheckbox,
      renderer,
      suffixCheckbox,
      wrapper: nodeElement,
      arrowEl: arrowElement,
      updateVisible,
      handleClick,
      handleToggleCheck,
      handleToggleExpand,
      handleToggleSelect,
      handleLabelClick,
      handleDragStart,
      handleDragOver,
      handleDragLeave,
      handleDrop,
      handleDragEnd,
      getNodeChildren
    };
  }
});
const _hoisted_1 = ["draggable", "aria-disabled", "aria-grabbed"];
const _hoisted_2 = ["aria-hidden"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Spinner = resolveComponent("Spinner");
  const _component_Icon = resolveComponent("Icon");
  const _component_ChevronRight = resolveComponent("ChevronRight");
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Renderer = resolveComponent("Renderer");
  const _component_TreeNode = resolveComponent("TreeNode", true);
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.visible && (_ctx.matched || _ctx.childMatched) ? (openBlock(), createElementBlock("li", mergeProps({
      key: 0,
      ref: "wrapper"
    }, _ctx.$attrs, {
      class: _ctx.className,
      draggable: _ctx.draggable,
      tabindex: "-1",
      "aria-disabled": _ctx.isDisabled,
      "aria-grabbed": _ctx.draggable && _ctx.dragging ? "true" : void 0,
      onClick: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["left"])),
      onFocus: _cache[5] || (_cache[5] = ($event) => _ctx.focused = true),
      onBlur: _cache[6] || (_cache[6] = ($event) => _ctx.focused = false),
      onDragstart: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
      onDragover: _cache[8] || (_cache[8] = (...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args)),
      onDragleave: _cache[9] || (_cache[9] = (...args) => _ctx.handleDragLeave && _ctx.handleDragLeave(...args)),
      onDragend: _cache[10] || (_cache[10] = (...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args)),
      onDrop: _cache[11] || (_cache[11] = (...args) => _ctx.handleDrop && _ctx.handleDrop(...args))
    }), [
      renderSlot(_ctx.$slots, "default", {
        data: _ctx.node.data,
        node: _ctx.node,
        depth: _ctx.depth,
        focused: _ctx.focused,
        toggleCheck: _ctx.handleToggleCheck,
        toggleExpand: _ctx.handleToggleExpand,
        toggleSelect: _ctx.handleToggleSelect
      }, () => {
        var _a;
        return [
          createElementVNode("div", {
            class: normalizeClass(_ctx.nh.be("content")),
            style: normalizeStyle(_ctx.contentStyle)
          }, [
            createElementVNode("span", {
              ref: "arrowEl",
              class: normalizeClass({
                [_ctx.nh.be("arrow")]: true,
                [_ctx.nh.bem("arrow", "transparent")]: !_ctx.loading && !_ctx.hasArrow,
                [_ctx.nh.bem("arrow", "expanded")]: _ctx.expanded
              }),
              "aria-hidden": !_ctx.loading && !_ctx.hasArrow,
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.handleToggleExpand(), ["stop"]))
            }, [
              _ctx.loading ? (openBlock(), createBlock(_component_Icon, {
                key: 0,
                pulse: ""
              }, {
                default: withCtx(() => [
                  createVNode(_component_Spinner)
                ]),
                _: 1
              })) : (openBlock(), createBlock(_component_Icon, { key: 1 }, {
                default: withCtx(() => [
                  createVNode(_component_ChevronRight)
                ]),
                _: 1
              }))
            ], 10, _hoisted_2),
            _ctx.hasCheckbox && !_ctx.suffixCheckbox ? (openBlock(), createBlock(_component_Checkbox, {
              key: 0,
              inherit: "",
              class: normalizeClass(_ctx.nh.be("checkbox")),
              "tab-index": -1,
              control: _ctx.hasArrow,
              checked: _ctx.checked,
              disabled: _ctx.isDisabled,
              partial: _ctx.partial,
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.handleToggleCheck(), ["prevent", "stop"]))
            }, null, 8, ["class", "control", "checked", "disabled", "partial"])) : createCommentVNode("", true),
            createElementVNode("div", {
              class: normalizeClass({
                [_ctx.nh.be("label")]: true,
                [_ctx.nh.bem("label", "focused")]: _ctx.focused,
                [_ctx.nh.bem("label", "selected")]: _ctx.selected,
                [_ctx.nh.bem("label", "disabled")]: _ctx.isDisabled,
                [_ctx.nh.bem("label", "readonly")]: _ctx.isReadonly,
                [_ctx.nh.bem("label", "is-floor")]: _ctx.floorSelect && ((_a = _ctx.node.children) == null ? void 0 : _a.length),
                [_ctx.nh.bem("label", "secondary")]: _ctx.secondary
              }),
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.handleLabelClick())
            }, [
              _ctx.renderer ? (openBlock(), createBlock(_component_Renderer, {
                key: 0,
                renderer: _ctx.renderer,
                data: { node: _ctx.node, depth: _ctx.depth, data: _ctx.node.data }
              }, null, 8, ["renderer", "data"])) : renderSlot(_ctx.$slots, "label", {
                key: 1,
                data: _ctx.node.data,
                node: _ctx.node,
                depth: _ctx.depth,
                focused: _ctx.focused
              }, () => [
                createTextVNode(toDisplayString(_ctx.data[_ctx.labelKey]), 1)
              ])
            ], 2),
            _ctx.hasCheckbox && _ctx.suffixCheckbox ? (openBlock(), createBlock(_component_Checkbox, {
              key: 1,
              inherit: "",
              class: normalizeClass([_ctx.nh.be("checkbox"), _ctx.nh.bem("checkbox", "suffix")]),
              "tab-index": -1,
              control: _ctx.hasArrow,
              checked: _ctx.checked,
              disabled: _ctx.isDisabled,
              partial: _ctx.partial,
              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.handleToggleCheck(), ["prevent", "stop"]))
            }, null, 8, ["class", "control", "checked", "disabled", "partial"])) : createCommentVNode("", true)
          ], 6)
        ];
      })
    ], 16, _hoisted_1)) : createCommentVNode("", true),
    createVNode(_component_CollapseTransition, {
      appear: _ctx.appear,
      onAfterEnter: _ctx.updateVisible,
      onAfterLeave: _ctx.updateVisible
    }, {
      default: withCtx(() => [
        _ctx.showChildren ? (openBlock(), createElementBlock("ul", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("list"))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.node.children, (item, index) => {
            return openBlock(), createBlock(_component_TreeNode, mergeProps({ key: index }, _ctx.nodeProps(item.data, item), {
              node: item,
              data: item.data,
              arrow: item.arrow,
              checkbox: item.checkbox,
              appear: _ctx.appear,
              visible: item.visible,
              selected: item.selected,
              expanded: item.expanded,
              disabled: item.disabled,
              "label-key": _ctx.labelKey,
              checked: item.checked,
              loading: item.loading,
              loaded: item.loaded,
              partial: item.partial,
              readonly: item.readonly,
              indent: _ctx.indent,
              draggable: _ctx.draggable,
              "floor-select": _ctx.floorSelect,
              matched: item.matched,
              "child-matched": item.childMatched,
              "upper-matched": item.upperMatched,
              "node-props": _ctx.nodeProps
            }), {
              default: withCtx((payload) => [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(payload)))
              ]),
              label: withCtx((payload) => [
                renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(payload)))
              ]),
              _: 2
            }, 1040, ["node", "data", "arrow", "checkbox", "appear", "visible", "selected", "expanded", "disabled", "label-key", "checked", "loading", "loaded", "partial", "readonly", "indent", "draggable", "floor-select", "matched", "child-matched", "upper-matched", "node-props"]);
          }), 128))
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["appear", "onAfterEnter", "onAfterLeave"])
  ], 64);
}
var TreeNode = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { TreeNode as default };
