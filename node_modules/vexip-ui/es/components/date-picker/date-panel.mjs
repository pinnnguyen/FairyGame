import { defineComponent, ref, computed, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, Fragment, renderList, toDisplayString, createCommentVNode, createElementVNode, createVNode, withCtx, withDirectives, vShow, withModifiers, createTextVNode, createBlock } from "vue";
import TimeWheel from "./time-wheel.mjs";
import "../button/index.mjs";
import "../calendar-panel/index.mjs";
import "../icon/index.mjs";
import { useHover } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { toDate, range } from "@vexip-ui/utils";
import { AngleRight, AngleLeft, AnglesRight, AnglesLeft } from "@vexip-ui/icons";
import { datePickerTypes } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Button from "../button/button.mjs";
import CalendarPanel from "../calendar/calendar-panel.mjs";
import Icon from "../icon/icon.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "DatePanel",
  components: {
    Button,
    CalendarPanel,
    Icon,
    TimeWheel,
    AngleRight,
    AngleLeft,
    AnglesRight,
    AnglesLeft
  },
  props: {
    type: {
      default: "date",
      validator: (value) => {
        return datePickerTypes.includes(value);
      }
    },
    enabled: {
      type: Object,
      default: () => ({})
    },
    startValue: {
      type: Object,
      default: () => ({})
    },
    endValue: {
      type: Object,
      default: () => ({})
    },
    valueType: {
      type: String,
      default: "start"
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    column: {
      type: String,
      default: "date"
    },
    confirmText: {
      type: String,
      default: null
    },
    cancelText: {
      type: String,
      default: null
    },
    today: {
      type: [Number, String, Date],
      default: () => new Date()
    },
    disabledDate: {
      type: Function,
      default: () => false
    },
    noAction: {
      type: Boolean,
      default: false
    },
    steps: {
      type: Array,
      default: () => [1, 1, 1]
    },
    isRange: {
      type: Boolean,
      default: false
    },
    startActivated: {
      type: Object,
      default: () => ({})
    },
    endActivated: {
      type: Object,
      default: () => ({})
    },
    min: {
      type: [Number, String, Date],
      default: null
    },
    max: {
      type: [Number, String, Date],
      default: null
    },
    disabledTime: {
      type: Object,
      default: () => ({})
    },
    hasError: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click", "shortcut", "toggle-col", "change", "cancel", "confirm", "hover", "type-change"],
  setup(props, { emit }) {
    const today = toDate(props.today);
    const currentPane = ref("date");
    const calendarYear = ref(today.getFullYear());
    const calendarMonth = ref(today.getMonth() + 1);
    const hoveredYear = ref(0);
    const hoveredMonth = ref(0);
    const yearRange = ref([]);
    const calendar = ref();
    const { isHover } = useHover(calendar);
    const locale = computed(() => {
      return { ...useLocale("calendar").value, ...useLocale("datePicker").value };
    });
    const startActivated = computed(() => {
      const activated2 = props.startActivated;
      return activated2.year && activated2.month && activated2.date;
    });
    const endActivated = computed(() => {
      const activated2 = props.endActivated;
      return activated2.year && activated2.month && activated2.date;
    });
    const isDatetime = computed(() => {
      return props.type === "datetime";
    });
    const dateValue = computed(() => {
      return props.valueType === "start" ? props.startValue : props.endValue;
    });
    const activated = computed(() => {
      return props.valueType === "start" ? props.startActivated : props.endActivated;
    });
    const calendarRange = computed(() => {
      return props.isRange && (props.valueType === "start" && endActivated.value || props.valueType === "end" && startActivated.value);
    });
    const calendarValue = computed(() => {
      return calendarRange.value ? [
        startActivated.value ? getStringValue("start") : "",
        endActivated.value ? getStringValue("end") : ""
      ] : props.valueType === "start" ? startActivated.value ? getStringValue(props.valueType) : "" : endActivated.value ? getStringValue(props.valueType) : "";
    });
    watch(
      () => props.column,
      (value) => {
        if (value === "year" || value === "month" || value === "date") {
          currentPane.value = value;
          refreshCalendar();
        }
      },
      { immediate: true }
    );
    watch(
      calendarYear,
      (value) => {
        yearRange.value = range(12, Math.floor(value / 10) * 10, 1);
      },
      { immediate: true }
    );
    watch(isHover, (value) => {
      if (value) {
        toggleColumn(currentPane.value);
      }
    });
    function getStringValue(type) {
      const value = type === "start" ? props.startValue : props.endValue;
      return `${value.year}-${value.month}-${value.date}`;
    }
    function getMonthLabel(index) {
      return locale.value[`month${index}`];
    }
    function togglePane(type) {
      currentPane.value = type;
      toggleColumn(type);
    }
    function adjustCalendar(type, amount) {
      if (type === "year") {
        calendarYear.value += amount;
      } else {
        calendarMonth.value += amount;
        const date = new Date(calendarYear.value, calendarMonth.value - 1, 1);
        calendarYear.value = date.getFullYear();
        calendarMonth.value = date.getMonth() + 1;
      }
    }
    function handleClick(event) {
      emit("click", event);
    }
    function handleShortcut(index) {
      let { value, name } = props.shortcuts[index];
      if (typeof value === "function") {
        value = value();
      }
      emit("shortcut", name, value);
    }
    function handleSelectDate(date) {
      emitChange("year", date.getFullYear());
      emitChange("month", date.getMonth() + 1);
      emitChange("date", date.getDate());
    }
    function handleSelectYear(year) {
      if (isDisabledYear(year))
        return;
      calendarYear.value = year;
      emitChange("year", year);
      if (props.type !== "year") {
        togglePane("month");
      }
    }
    function handleSelectMonth(month) {
      if (isDisabledMonth(month))
        return;
      calendarMonth.value = month;
      emitChange("year", calendarYear.value);
      emitChange("month", month);
      if (props.type !== "month") {
        togglePane("date");
      }
    }
    function toggleColumn(type) {
      emit("toggle-col", type);
    }
    function emitChange(type, value) {
      emit("change", type, value);
    }
    function handleDoublePrevClick() {
      if (currentPane.value === "year") {
        yearRange.value = range(12, yearRange.value[0] - 10, 1);
      } else {
        adjustCalendar("year", -1);
      }
    }
    function handleDoubleNextClick() {
      if (currentPane.value === "year") {
        yearRange.value = range(12, yearRange.value[10], 1);
      } else {
        adjustCalendar("year", 1);
      }
    }
    function handleCancel() {
      emit("cancel");
    }
    function handleConfirm() {
      emit("confirm");
    }
    function handleHoverDate(date) {
      emit("hover", date);
    }
    function isSelectedYear(year) {
      if (!year)
        return false;
      return props.startActivated.year && props.startValue.year === year || props.endActivated.year && props.endValue.year === year;
    }
    function isSelectedMonth(month) {
      if (!month)
        return false;
      const monthYear = 100 * calendarYear.value + month;
      return props.startActivated.month && 100 * props.startValue.year + props.startValue.month === monthYear || props.endActivated.month && 100 * props.endValue.year + props.endValue.month === monthYear;
    }
    function isDisabledYear(year) {
      if (props.isRange) {
        if (props.valueType === "end" && props.startActivated.year && year < props.startValue.year) {
          return true;
        }
        if (props.valueType === "start" && props.endActivated.year && props.endValue.year < year) {
          return true;
        }
      }
      if (props.type === "year") {
        return props.disabledDate(new Date(year, 0));
      }
      for (let i = 1; i <= 12; ++i) {
        if (!isDisabledMonth(i, year)) {
          return false;
        }
      }
      return true;
    }
    function isDisabledMonth(month, year = calendarYear.value) {
      if (props.type === "year")
        return false;
      if (props.isRange) {
        const monthYear = year * 100 + month;
        if (props.valueType === "end" && props.startActivated.month && monthYear < 100 * props.startValue.year + props.startValue.month) {
          return true;
        }
        if (props.valueType === "start" && props.endActivated.month && monthYear > 100 * props.endValue.year + props.endValue.month) {
          return true;
        }
      }
      if (props.type === "month") {
        return props.disabledDate(new Date(year, month - 1));
      }
      const current = new Date(year, month - 1);
      const end = new Date(year, month, 0);
      const dayCount = end.getDate();
      for (let i = 1; i <= dayCount; ++i) {
        current.setDate(i);
        if (!props.disabledDate(current)) {
          return false;
        }
      }
      return true;
    }
    function handleYearHover(year) {
      hoveredYear.value = isDisabledYear(year) ? 0 : year;
    }
    function handleMonthHover(month) {
      hoveredMonth.value = isDisabledMonth(month) ? 0 : month;
    }
    function isYearInRange(year) {
      if (!calendarRange.value || !hoveredYear.value && !props.startActivated.year && !props.endActivated.year) {
        return false;
      }
      if (props.valueType === "start" && !props.endActivated.year || props.valueType === "end" && !props.startActivated.year) {
        return false;
      }
      const startYear = props.startValue.year;
      const endYear = props.endValue.year;
      let min;
      let max;
      if (!hoveredYear.value && props.startActivated.year && props.endActivated.year) {
        min = Math.min(startYear, endYear);
        max = Math.max(startYear, endYear);
      } else if (hoveredYear.value) {
        if (!props.startActivated.year && !props.endActivated.year)
          return false;
        if (!props.startActivated.year || !props.endActivated.year) {
          const selectedYear = props.startActivated.year ? startYear : endYear;
          min = Math.min(hoveredYear.value, selectedYear);
          max = Math.max(hoveredYear.value, selectedYear);
        } else {
          const minYear = Math.min(startYear, endYear);
          const maxYear = Math.max(startYear, endYear);
          min = Math.min(hoveredYear.value, minYear);
          max = Math.max(hoveredYear.value, maxYear);
        }
      } else {
        return false;
      }
      return year >= min && year <= max;
    }
    function isMonthInRange(month) {
      if (!calendarRange.value || !hoveredMonth.value && !props.startActivated.month && !props.endActivated.month) {
        return false;
      }
      if (props.valueType === "start" && !props.endActivated.month || props.valueType === "end" && !props.startActivated.month) {
        return false;
      }
      const startMonthYear = 100 * props.startValue.year + props.startValue.month;
      const endMonthYear = 100 * props.endValue.year + props.endValue.month;
      let min;
      let max;
      if (!hoveredMonth.value && props.startActivated.month && props.endActivated.month) {
        min = Math.min(startMonthYear, endMonthYear);
        max = Math.max(startMonthYear, endMonthYear);
      } else if (hoveredMonth.value) {
        if (!props.startActivated.month && !props.endActivated.month)
          return false;
        const hoveredMonthYear = 100 * calendarYear.value + hoveredMonth.value;
        if (!props.startActivated.month || !props.endActivated.month) {
          const selectedMonthYear = props.startActivated.month ? startMonthYear : endMonthYear;
          min = Math.min(hoveredMonthYear, selectedMonthYear);
          max = Math.max(hoveredMonthYear, selectedMonthYear);
        } else {
          const minMonthYear = Math.min(startMonthYear, endMonthYear);
          const maxMonthYear = Math.max(startMonthYear, endMonthYear);
          min = Math.min(hoveredMonthYear, minMonthYear);
          max = Math.max(hoveredMonthYear, maxMonthYear);
        }
      } else {
        return false;
      }
      const monthYear = 100 * calendarYear.value + month;
      return monthYear >= min && monthYear <= max;
    }
    function refreshCalendar() {
      const today2 = toDate(props.today);
      if (props.valueType === "start") {
        calendarYear.value = props.startActivated.year ? props.startValue.year : today2.getFullYear();
        calendarMonth.value = props.startActivated.month ? props.startValue.month : today2.getMonth() + 1;
      } else {
        calendarYear.value = props.endActivated.year ? props.endValue.year : today2.getFullYear();
        calendarMonth.value = props.endActivated.month ? props.endValue.month : today2.getMonth() + 1;
      }
    }
    return {
      nh: useNameHelper("date-picker"),
      locale,
      currentPane,
      calendarYear,
      calendarMonth,
      yearRange,
      monthRange: range(12, 1, 1),
      hoveredYear,
      hoveredMonth,
      isDatetime,
      dateValue,
      activated,
      calendarValue,
      calendarRange,
      calendar,
      getMonthLabel,
      togglePane,
      adjustCalendar,
      handleClick,
      handleShortcut,
      handleSelectDate,
      handleSelectYear,
      handleSelectMonth,
      toggleColumn,
      emitChange,
      handleDoublePrevClick,
      handleDoubleNextClick,
      handleCancel,
      handleConfirm,
      handleHoverDate,
      isSelectedYear,
      isSelectedMonth,
      isDisabledYear,
      isDisabledMonth,
      handleYearHover,
      handleMonthHover,
      isYearInRange,
      isMonthInRange,
      refreshCalendar
    };
  }
});
const _hoisted_1 = ["title", "onClick"];
const _hoisted_2 = { style: { "display": "flex" } };
const _hoisted_3 = ["onClick", "onMouseenter"];
const _hoisted_4 = ["onClick", "onMouseenter"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AnglesLeft = resolveComponent("AnglesLeft");
  const _component_Icon = resolveComponent("Icon");
  const _component_AngleLeft = resolveComponent("AngleLeft");
  const _component_AngleRight = resolveComponent("AngleRight");
  const _component_AnglesRight = resolveComponent("AnglesRight");
  const _component_CalendarPanel = resolveComponent("CalendarPanel");
  const _component_TimeWheel = resolveComponent("TimeWheel");
  const _component_Button = resolveComponent("Button");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.nh.be("panel")),
    onClick: _cache[8] || (_cache[8] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.shortcuts.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("list"), _ctx.nh.bem("list", "sub")])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (item, index) => {
        return openBlock(), createElementBlock("div", {
          key: index,
          class: normalizeClass(_ctx.nh.be("shortcut")),
          title: item.name,
          onClick: ($event) => _ctx.handleShortcut(index)
        }, toDisplayString(item.name), 11, _hoisted_1);
      }), 128))
    ], 2)) : createCommentVNode("", true),
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      createElementVNode("div", _hoisted_2, [
        createElementVNode("div", null, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.nh.be("header"))
          }, [
            createElementVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("prev-year")]),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleDoublePrevClick && _ctx.handleDoublePrevClick(...args))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AnglesLeft)
                ]),
                _: 1
              })
            ], 2),
            withDirectives(createElementVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("prev-month")]),
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.adjustCalendar("month", -1))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AngleLeft)
                ]),
                _: 1
              })
            ], 2), [
              [vShow, _ctx.currentPane === "date"]
            ]),
            createElementVNode("div", {
              key: "year",
              class: normalizeClass(_ctx.nh.be("year")),
              onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.togglePane("year"), ["stop"]))
            }, [
              _ctx.currentPane === "year" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(`${_ctx.yearRange[0]}${_ctx.locale.year} - ${_ctx.yearRange[9]}${_ctx.locale.year}`), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(`${_ctx.calendarYear}${_ctx.locale.year}`), 1)
              ], 64))
            ], 2),
            withDirectives(createElementVNode("div", {
              class: normalizeClass(_ctx.nh.be("month")),
              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.togglePane("month"), ["stop"]))
            }, toDisplayString(_ctx.getMonthLabel(_ctx.calendarMonth)), 3), [
              [vShow, _ctx.currentPane === "date"]
            ]),
            withDirectives(createElementVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("next-month")]),
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.adjustCalendar("month", 1))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AngleRight)
                ]),
                _: 1
              })
            ], 2), [
              [vShow, _ctx.currentPane === "date"]
            ]),
            createElementVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("next-year")]),
              onClick: _cache[5] || (_cache[5] = (...args) => _ctx.handleDoubleNextClick && _ctx.handleDoubleNextClick(...args))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AnglesRight)
                ]),
                _: 1
              })
            ], 2)
          ], 2),
          createElementVNode("div", {
            ref: "calendar",
            class: normalizeClass(_ctx.nh.be("calendar"))
          }, [
            _ctx.currentPane === "year" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("year-pane")),
              onMouseleave: _cache[6] || (_cache[6] = ($event) => _ctx.hoveredYear = 0)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.yearRange, (item, index) => {
                return openBlock(), createElementBlock("div", {
                  key: index,
                  class: normalizeClass({
                    [_ctx.nh.be("year-item")]: true,
                    [_ctx.nh.bem("year-item", "selected")]: _ctx.isSelectedYear(item),
                    [_ctx.nh.bem("year-item", "next")]: index > 9,
                    [_ctx.nh.bem("year-item", "disabled")]: _ctx.isDisabledYear(item),
                    [_ctx.nh.bem("year-item", "in-range")]: _ctx.isYearInRange(item)
                  }),
                  onClick: withModifiers(($event) => _ctx.handleSelectYear(item), ["stop"]),
                  onMouseenter: ($event) => _ctx.handleYearHover(item)
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(_ctx.nh.be("year-label"))
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.nh.be("year-label-inner"))
                    }, toDisplayString(item), 3)
                  ], 2)
                ], 42, _hoisted_3);
              }), 128))
            ], 34)) : _ctx.currentPane === "month" ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(_ctx.nh.be("month-pane")),
              onMouseleave: _cache[7] || (_cache[7] = ($event) => _ctx.hoveredMonth = 0)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.monthRange, (index) => {
                return openBlock(), createElementBlock("div", {
                  key: index,
                  class: normalizeClass({
                    [_ctx.nh.be("month-item")]: true,
                    [_ctx.nh.bem("month-item", "selected")]: _ctx.isSelectedMonth(index),
                    [_ctx.nh.bem("month-item", "disabled")]: _ctx.isDisabledMonth(index),
                    [_ctx.nh.bem("month-item", "in-range")]: _ctx.isMonthInRange(index)
                  }),
                  onClick: withModifiers(($event) => _ctx.handleSelectMonth(index), ["stop"]),
                  onMouseenter: ($event) => _ctx.handleMonthHover(index)
                }, [
                  createElementVNode("div", {
                    class: normalizeClass(_ctx.nh.be("month-label"))
                  }, [
                    createElementVNode("div", {
                      class: normalizeClass(_ctx.nh.be("month-label-inner"))
                    }, toDisplayString(_ctx.getMonthLabel(index)), 3)
                  ], 2)
                ], 42, _hoisted_4);
              }), 128))
            ], 34)) : (openBlock(), createBlock(_component_CalendarPanel, {
              key: 2,
              inherit: "",
              value: _ctx.calendarValue,
              year: _ctx.calendarYear,
              month: _ctx.calendarMonth,
              "disabled-date": _ctx.disabledDate,
              "is-range": _ctx.calendarRange,
              "value-type": _ctx.valueType,
              min: _ctx.min,
              max: _ctx.max,
              onSelect: _ctx.handleSelectDate,
              onHover: _ctx.handleHoverDate
            }, null, 8, ["value", "year", "month", "disabled-date", "is-range", "value-type", "min", "max", "onSelect", "onHover"]))
          ], 2)
        ]),
        _ctx.isDatetime ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("time-wheel"))
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.nh.be("header"))
          }, null, 2),
          createVNode(_component_TimeWheel, {
            hour: _ctx.dateValue.hour,
            minute: _ctx.dateValue.minute,
            second: _ctx.dateValue.second,
            candidate: 3,
            steps: _ctx.steps,
            "disabled-time": _ctx.disabledTime,
            onToggleCol: _ctx.toggleColumn,
            onChange: _ctx.emitChange
          }, null, 8, ["hour", "minute", "second", "steps", "disabled-time", "onToggleCol", "onChange"])
        ], 2)) : createCommentVNode("", true)
      ]),
      !_ctx.noAction ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("action"))
      }, [
        createVNode(_component_Button, {
          inherit: "",
          text: "",
          size: "small",
          onClick: _ctx.handleCancel
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.cancelText || _ctx.locale.cancel), 1)
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_Button, {
          inherit: "",
          type: "primary",
          size: "small",
          disabled: _ctx.hasError,
          onClick: _ctx.handleConfirm
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.confirmText || _ctx.locale.confirm), 1)
          ]),
          _: 1
        }, 8, ["disabled", "onClick"])
      ], 2)) : createCommentVNode("", true)
    ], 2)
  ], 2);
}
var DatePanel = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { DatePanel as default };
