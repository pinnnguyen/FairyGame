import { defineComponent, toRef, ref, computed, watch, reactive, nextTick, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, withKeys, withModifiers, normalizeStyle, renderSlot, createVNode, createCommentVNode, Fragment, withCtx, Transition, renderList, toDisplayString, createBlock, createTextVNode } from "vue";
import TimeControl from "./time-control.mjs";
import TimeWheel from "./time-wheel.mjs";
import "../button/index.mjs";
import "../icon/index.mjs";
import "../portal/index.mjs";
import "../form/index.mjs";
import { placementWhileList, useSetTimeout, useClickOutside, usePopper, useHover } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { format, USE_TOUCH, doubleDigits, boundRange } from "@vexip-ui/utils";
import { CircleXmark, ArrowRightArrowLeft, Spinner, ClockR } from "@vexip-ui/icons";
import { timePickerProps } from "./props.mjs";
import { useTimeBound, useColumn } from "./helper.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Button from "../button/button.mjs";
import Icon from "../icon/icon.mjs";
import Portal from "../portal/portal.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const TIME_REG = /^((?:\d{1,2}))((?::\d{1,2}))?((?::\d{1,2}))?$/;
const _sfc_main = defineComponent({
  name: "TimePicker",
  components: {
    Button,
    Icon,
    Portal,
    TimeControl,
    TimeWheel,
    CircleXmark,
    ArrowRightArrowLeft
  },
  props: timePickerProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const initValue = format(Date.now(), "HH:mm:ss");
    const nh = useNameHelper("time-picker");
    const props = useProps("timePicker", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      visible: false,
      placement: {
        default: "bottom-start",
        validator: (value) => placementWhileList.includes(value)
      },
      transfer: false,
      format: "HH:mm:ss",
      separator: ":",
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      filler: {
        default: "-",
        validator: (value) => value.length === 1
      },
      noFiller: false,
      clearable: false,
      noAction: false,
      noArrow: false,
      pointer: USE_TOUCH,
      candidate: {
        default: 3,
        validator: (value) => [0, 1, 2, 3].includes(value)
      },
      steps: () => [1, 1, 1],
      labels: () => ({}),
      shortcuts: () => [],
      isRange: false,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      confirmText: null,
      cancelText: null,
      ctrlSteps: () => [5, 5, 5],
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      exchange: false,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      min: null,
      max: null
    });
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const currentVisible = ref(props.visible);
    const focused = ref(false);
    const lastValue = ref("");
    const startState = createTimeState();
    const endState = createTimeState();
    const currentState = ref("start");
    const { timer } = useSetTimeout();
    const wrapper = useClickOutside(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = usePopper({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = useHover(reference);
    const { isTimeDisabled } = useTimeBound(toRef(props, "min"), toRef(props, "max"));
    const startInput = ref();
    const endInput = ref();
    const className = computed(() => {
      return [
        nh.b(),
        nh.ns("input-vars"),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("no-hour")]: !startState.enabled.hour,
          [nh.bm("no-minute")]: !startState.enabled.minute,
          [nh.bm("no-second")]: !startState.enabled.second,
          [nh.bm("visible")]: currentVisible.value,
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm("is-range")]: props.isRange
        }
      ];
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--focused`]: focused.value,
        [`${baseCls}--${props.state}`]: props.state !== "default"
      };
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const currentValue = computed(() => {
      const values = [startState, endState].map((state2) => {
        return Object.values(state2.timeValue).map(doubleDigits).join(":");
      });
      return props.isRange ? values : values[0];
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && !!lastValue.value;
    });
    const startError = computed(() => {
      const { hour, minute, second } = startState.timeValue;
      return isTimeDisabled.hour(hour) || isTimeDisabled.minute(hour, minute) || isTimeDisabled.second(hour, minute, second);
    });
    const endError = computed(() => {
      if (!props.isRange)
        return false;
      const { hour, minute, second } = endState.timeValue;
      return isTimeDisabled.hour(hour) || isTimeDisabled.minute(hour, minute) || isTimeDisabled.second(hour, minute, second);
    });
    parseValue(props.value, false);
    if (props.noFiller) {
      lastValue.value = getStringValue();
    }
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
      }
    );
    watch(() => props.format, parseFormat, { immediate: true });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        updatePopper();
      } else {
        emitChange();
      }
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(focused, (value) => {
      if (value) {
        emitEvent(props.onFocus);
      } else {
        emitEvent(props.onBlur);
      }
    });
    watch(currentState, (value) => {
      if (currentVisible.value) {
        emitEvent(props.onChangeCol, getCurrentState().column, value);
      }
    });
    watch(
      () => startState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "start") {
          emitEvent(props.onChangeCol, value, "start");
        }
      }
    );
    watch(
      () => endState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "end") {
          emitEvent(props.onChangeCol, value, "end");
        }
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
          handleBlur();
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    function createTimeState() {
      const { currentColumn, enabled, resetColumn, enterColumn: enterColumn2 } = useColumn([
        "hour",
        "minute",
        "second"
      ]);
      const timeValue = reactive({
        hour: 0,
        minute: 0,
        second: 0
      });
      const activated = reactive({
        hour: false,
        minute: false,
        second: false
      });
      return reactive({
        column: currentColumn,
        enabled,
        activated,
        timeValue,
        resetColumn,
        enterColumn: enterColumn2
      });
    }
    function getCurrentState() {
      return currentState.value === "start" ? startState : endState;
    }
    function parseValue(value, updateActivated = true) {
      if (!Array.isArray(value)) {
        value = [value, value];
      }
      for (let i = 0; i < 2; ++i) {
        const match = TIME_REG.exec(value[i] || initValue);
        const state2 = i === 0 ? startState : endState;
        const { activated, timeValue } = state2;
        if (match) {
          if (updateActivated) {
            activated.hour = !!match[1];
            activated.minute = !!match[2];
            activated.second = !!match[3];
          }
          const hour = parseInt(match[1]);
          const minute = match[2] ? parseInt(match[2].slice(1)) : 0;
          const second = match[3] ? parseInt(match[3].slice(1)) : 0;
          const date = new Date(2e3, 1, 1, hour, minute, second);
          timeValue.hour = date.getHours();
          timeValue.minute = date.getMinutes();
          timeValue.second = date.getSeconds();
        } else {
          timeValue.hour = 0;
          timeValue.minute = 0;
          timeValue.second = 0;
          if (updateActivated) {
            activated.hour = false;
            activated.minute = false;
            activated.second = false;
          }
        }
        if (!props.isRange)
          break;
      }
    }
    function parseFormat() {
      [startState, endState].forEach((state2) => {
        state2.enabled.hour = props.format.includes("H");
        state2.enabled.minute = props.format.includes("m");
        state2.enabled.second = props.format.includes("s");
      });
    }
    function toggleActivated(value) {
      [startState, endState].forEach((state2) => {
        Object.keys(state2.activated).forEach((type) => {
          state2.activated[type] = value;
        });
      });
    }
    function getStringValue() {
      return Array.isArray(currentValue.value) ? currentValue.value.join("|") : currentValue.value;
    }
    function verifyTime() {
      if (startError.value || props.isRange && endError.value) {
        if (lastValue.value) {
          parseValue(lastValue.value.split("|"));
        } else {
          parseValue(props.value);
        }
      }
    }
    function emitChange() {
      verifyTime();
      if (lastValue.value !== getStringValue()) {
        lastValue.value = getStringValue();
        toggleActivated(true);
        setFieldValue(currentValue.value);
        emitEvent(props.onChange, currentValue.value);
        emit("update:value", currentValue.value);
        validateField();
      }
    }
    function handleFocused() {
      if (props.disabled)
        return;
      focused.value = true;
      timer.focus = setTimeout(() => {
        var _a, _b;
        if (focused.value) {
          if (currentState.value === "start") {
            (_a = startInput.value) == null ? void 0 : _a.focus();
          } else {
            (_b = endInput.value) == null ? void 0 : _b.focus();
          }
        }
      }, 120);
    }
    function handleBlur() {
      var _a, _b;
      clearTimeout(timer.focus);
      focused.value = false;
      (_a = startInput.value) == null ? void 0 : _a.blur();
      (_b = endInput.value) == null ? void 0 : _b.blur();
    }
    function showPanel(event) {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      const target = event.target;
      const lastVisible = currentVisible.value;
      currentVisible.value = true;
      handleFocused();
      if (!lastVisible && wrapper.value && target) {
        const units = Array.from(wrapper.value.querySelectorAll(`.${nh.be("unit")}`));
        if (!units.some((unit) => unit === target || unit.contains(target))) {
          emitEvent(props.onChangeCol, getCurrentState().column, currentState.value);
        }
      }
    }
    function finishInput() {
      currentVisible.value = false;
      startState.resetColumn();
      endState.resetColumn();
    }
    function handleClear() {
      if (props.clearable) {
        lastValue.value = "";
        finishInput();
        nextTick(() => {
          parseValue("");
          emitEvent(props.onChange, currentValue.value);
          emit("update:value", currentValue.value);
          emitEvent(props.onClear);
          clearField(currentValue.value);
          nextTick(() => {
            toggleActivated(false);
          });
        });
      }
    }
    function handleWheelChange(type) {
      if (currentVisible.value) {
        getCurrentState().activated[type] = true;
      }
    }
    function handleInputFocus(type) {
      getCurrentState().column = type;
    }
    function handleInput(value) {
      const state2 = getCurrentState();
      handleInputNumber(state2.column, value);
      if (state2.column !== "second" && state2.timeValue[state2.column] >= 10) {
        state2.enterColumn("next", false);
      }
    }
    function handleInputNumber(type, number) {
      const state2 = getCurrentState();
      const prev = state2.timeValue[type];
      if ((props.noFiller || state2.activated[type]) && prev > 0 && prev < 10) {
        state2.timeValue[type] = prev * 10 + number;
      } else {
        state2.timeValue[type] = number;
      }
      verifyValue(type);
      state2.activated[type] = true;
      emitEvent(props.onInput, type, state2.timeValue[type]);
    }
    function verifyValue(type) {
      const timeValue = getCurrentState().timeValue;
      timeValue[type] = boundRange(timeValue[type], 0, type === "hour" ? 23 : 59);
      timeValue[type] = Math.round(timeValue[type] / getStep(type)) * getStep(type);
    }
    function handlePlus(ctrlKey) {
      const state2 = getCurrentState();
      const type = state2.column;
      if (state2.enabled[type]) {
        state2.timeValue[type] += ctrlKey ? getCtrlStep(type) : getStep(type);
        verifyValue(type);
        emitEvent(props.onPlus, type, state2.timeValue[type]);
      }
    }
    function handleMinus(ctrlKey) {
      const state2 = getCurrentState();
      const type = state2.column;
      if (state2.enabled[type]) {
        state2.timeValue[type] -= ctrlKey ? getCtrlStep(type) : getStep(type);
        verifyValue(type);
        emitEvent(props.onMinus, type, state2.timeValue[type]);
      }
    }
    function getStep(type) {
      return props.steps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function getCtrlStep(type) {
      return props.ctrlSteps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function handleEnter() {
      finishInput();
      emitEvent(props.onEnter);
    }
    function handleCancel() {
      parseValue(props.value);
      finishInput();
      emitEvent(props.onCancel);
    }
    function handleShortcut(index) {
      let { value, name } = props.shortcuts[index];
      if (typeof value === "function") {
        value = value();
      }
      parseValue(value);
      emitEvent(props.onShortcut, name, value);
      finishInput();
    }
    function toggleCurrentState(type) {
      currentState.value = type;
    }
    function enterColumn(type) {
      if (props.isRange) {
        const state2 = getCurrentState();
        const currentColumn = state2.column;
        state2.enterColumn(type, false);
        if (currentColumn === state2.column) {
          const isStart = currentState.value === "start";
          const otherState = isStart ? endState : startState;
          otherState.resetColumn(type === "prev" ? "second" : "hour", type === "prev");
          toggleCurrentState(isStart ? "end" : "start");
        }
      } else {
        startState.enterColumn(type);
      }
    }
    function handleStartInput(type) {
      toggleCurrentState("start");
      handleInputFocus(type);
    }
    function handleEndInput(type) {
      toggleCurrentState("end");
      handleInputFocus(type);
    }
    function exchangeValue() {
      Object.keys(startState.timeValue).forEach((type) => {
        const temp = endState.timeValue[type];
        endState.timeValue[type] = startState.timeValue[type];
        startState.timeValue[type] = temp;
      });
    }
    function handleExchangeClick(event) {
      if (props.exchange) {
        !currentVisible.value && event.stopPropagation();
        exchangeValue();
      }
    }
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      finishInput();
      handleBlur();
    }
    function handlePanelClosed() {
      const { hour, minute } = startState.enabled;
      handleStartInput(hour ? "hour" : minute ? "minute" : "second");
    }
    return {
      ClockR,
      props,
      nh,
      locale: useLocale("timePicker"),
      idFor,
      isHover,
      currentVisible,
      focused,
      transferTo,
      lastValue,
      startState,
      endState,
      currentState,
      currentValue,
      className,
      selectorClass,
      hasPrefix,
      showClear,
      isTimeDisabled,
      startError,
      endError,
      wrapper,
      reference,
      popper,
      start: startInput,
      end: endInput,
      handleFocused,
      showPanel,
      handleClear,
      handleShortcut,
      handleWheelChange,
      handleInputFocus,
      handleInput,
      handlePlus,
      handleMinus,
      handleEnter,
      finishInput,
      handleCancel,
      toggleCurrentState,
      enterColumn,
      handleStartInput,
      handleEndInput,
      handleExchangeClick,
      handlePanelClosed,
      focus: handleFocused,
      blur: handleBlur,
      updatePopper
    };
  }
});
const _hoisted_1 = ["id"];
const _hoisted_2 = ["title", "onClick"];
const _hoisted_3 = { style: { "display": "flex" } };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_TimeControl = resolveComponent("TimeControl");
  const _component_ArrowRightArrowLeft = resolveComponent("ArrowRightArrowLeft");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_TimeWheel = resolveComponent("TimeWheel");
  const _component_Button = resolveComponent("Button");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[14] || (_cache[14] = (...args) => _ctx.showPanel && _ctx.showPanel(...args))
  }, [
    createElementVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.showPanel && _ctx.showPanel(...args), ["prevent"]), ["space"]))
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        createVNode(_component_TimeControl, {
          ref: "start",
          "unit-type": _ctx.currentState === "start" ? _ctx.startState.column : void 0,
          enabled: _ctx.startState.enabled,
          activated: _ctx.startState.activated,
          "time-value": _ctx.startState.timeValue,
          steps: _ctx.props.steps,
          "ctrl-steps": _ctx.props.ctrlSteps,
          focused: _ctx.focused,
          visible: _ctx.currentVisible,
          separator: _ctx.props.separator,
          filler: _ctx.props.filler,
          "no-filler": _ctx.props.noFiller,
          labels: _ctx.props.labels,
          "has-error": _ctx.startError,
          onInput: _ctx.handleInput,
          onPlus: _ctx.handlePlus,
          onMinus: _ctx.handleMinus,
          onEnter: _ctx.handleEnter,
          onCancel: _ctx.handleCancel,
          onUnitFocus: _ctx.handleStartInput,
          onPrevUnit: _cache[0] || (_cache[0] = ($event) => _ctx.enterColumn("prev")),
          onNextUnit: _cache[1] || (_cache[1] = ($event) => _ctx.enterColumn("next"))
        }, null, 8, ["unit-type", "enabled", "activated", "time-value", "steps", "ctrl-steps", "focused", "visible", "separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"]),
        _ctx.props.isRange ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createElementVNode("div", {
            class: normalizeClass([_ctx.nh.be("exchange"), _ctx.props.exchange ? _ctx.nh.bem("exchange", "enabled") : ""]),
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleExchangeClick && _ctx.handleExchangeClick(...args))
          }, [
            renderSlot(_ctx.$slots, "exchange", {}, () => [
              createVNode(_component_Icon, { style: { "padding-top": "1px" } }, {
                default: withCtx(() => [
                  createVNode(_component_ArrowRightArrowLeft)
                ]),
                _: 1
              })
            ])
          ], 2),
          createVNode(_component_TimeControl, {
            ref: "end",
            "unit-type": _ctx.currentState === "end" ? _ctx.endState.column : void 0,
            enabled: _ctx.endState.enabled,
            activated: _ctx.endState.activated,
            "time-value": _ctx.endState.timeValue,
            steps: _ctx.props.steps,
            "ctrl-steps": _ctx.props.ctrlSteps,
            focused: _ctx.focused,
            visible: _ctx.currentVisible,
            separator: _ctx.props.separator,
            filler: _ctx.props.filler,
            "no-filler": _ctx.props.noFiller,
            labels: _ctx.props.labels,
            "has-error": _ctx.endError,
            onInput: _ctx.handleInput,
            onPlus: _ctx.handlePlus,
            onMinus: _ctx.handleMinus,
            onEnter: _ctx.handleEnter,
            onCancel: _ctx.handleCancel,
            onUnitFocus: _ctx.handleEndInput,
            onPrevUnit: _cache[3] || (_cache[3] = ($event) => _ctx.enterColumn("prev")),
            onNextUnit: _cache[4] || (_cache[4] = ($event) => _ctx.enterColumn("next"))
          }, null, 8, ["unit-type", "enabled", "activated", "time-value", "steps", "ctrl-steps", "focused", "visible", "separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"])
        ], 64)) : createCommentVNode("", true)
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.suffix || _ctx.ClockR
          }, null, 8, ["icon"])
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          !_ctx.props.disabled && _ctx.props.clearable && _ctx.isHover && _ctx.lastValue ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onAfterLeave: _ctx.handlePanelClosed
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[13] || (_cache[13] = withModifiers((...args) => _ctx.handleFocused && _ctx.handleFocused(...args), ["stop"]))
            }, [
              createElementVNode("div", {
                class: normalizeClass(_ctx.nh.be("panel"))
              }, [
                _ctx.props.shortcuts.length ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass([_ctx.nh.be("list"), _ctx.nh.bem("list", "sub")])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.shortcuts, (item, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(_ctx.nh.be("shortcut")),
                      title: item.name,
                      onClick: ($event) => _ctx.handleShortcut(index)
                    }, toDisplayString(item.name), 11, _hoisted_2);
                  }), 128))
                ], 2)) : createCommentVNode("", true),
                createElementVNode("div", {
                  class: normalizeClass(_ctx.nh.be("list"))
                }, [
                  createElementVNode("div", _hoisted_3, [
                    createVNode(_component_TimeWheel, {
                      hour: _ctx.startState.timeValue.hour,
                      "onUpdate:hour": _cache[7] || (_cache[7] = ($event) => _ctx.startState.timeValue.hour = $event),
                      minute: _ctx.startState.timeValue.minute,
                      "onUpdate:minute": _cache[8] || (_cache[8] = ($event) => _ctx.startState.timeValue.minute = $event),
                      second: _ctx.startState.timeValue.second,
                      "onUpdate:second": _cache[9] || (_cache[9] = ($event) => _ctx.startState.timeValue.second = $event),
                      "no-arrow": _ctx.props.noArrow,
                      candidate: _ctx.props.candidate,
                      steps: _ctx.props.steps,
                      pointer: _ctx.props.pointer,
                      "disabled-time": _ctx.isTimeDisabled,
                      onChange: _ctx.handleWheelChange,
                      onToggleCol: _ctx.handleStartInput
                    }, null, 8, ["hour", "minute", "second", "no-arrow", "candidate", "steps", "pointer", "disabled-time", "onChange", "onToggleCol"]),
                    _ctx.isRange ? (openBlock(), createBlock(_component_TimeWheel, {
                      key: 0,
                      hour: _ctx.endState.timeValue.hour,
                      "onUpdate:hour": _cache[10] || (_cache[10] = ($event) => _ctx.endState.timeValue.hour = $event),
                      minute: _ctx.endState.timeValue.minute,
                      "onUpdate:minute": _cache[11] || (_cache[11] = ($event) => _ctx.endState.timeValue.minute = $event),
                      second: _ctx.endState.timeValue.second,
                      "onUpdate:second": _cache[12] || (_cache[12] = ($event) => _ctx.endState.timeValue.second = $event),
                      "no-arrow": _ctx.props.noArrow,
                      candidate: _ctx.props.candidate,
                      steps: _ctx.props.steps,
                      pointer: _ctx.props.pointer,
                      "disabled-time": _ctx.isTimeDisabled,
                      onChange: _ctx.handleWheelChange,
                      onToggleCol: _ctx.handleEndInput
                    }, null, 8, ["hour", "minute", "second", "no-arrow", "candidate", "steps", "pointer", "disabled-time", "onChange", "onToggleCol"])) : createCommentVNode("", true)
                  ]),
                  !_ctx.props.noAction ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(_ctx.nh.be("action"))
                  }, [
                    createVNode(_component_Button, {
                      inherit: "",
                      text: "",
                      size: "small",
                      onClick: withModifiers(_ctx.handleCancel, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_Button, {
                      inherit: "",
                      type: "primary",
                      size: "small",
                      disabled: _ctx.startError || _ctx.endError,
                      onClick: withModifiers(_ctx.finishInput, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
                      ]),
                      _: 1
                    }, 8, ["disabled", "onClick"])
                  ], 2)) : createCommentVNode("", true)
                ], 2)
              ], 2)
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name", "onAfterLeave"])
      ]),
      _: 1
    }, 8, ["to"])
  ], 10, _hoisted_1);
}
var TimePicker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { TimePicker as default };
