import { reactive, ref, computed } from "vue";
import { toNumber } from "@vexip-ui/utils";
import { DisabledType } from "./symbol.mjs";
const numberKeys = Array.from({ length: 10 }, (_, i) => i);
function isNumberKey(key, num) {
  return key === `Digit${num}` || key === `Numpad${num}` || key === `${num}`;
}
function handleKeyEnter(event) {
  const key = event.code || event.key;
  let type = null;
  let isMatch = false;
  switch (key) {
    case "Tab": {
      isMatch = true;
      type = event.shiftKey ? "prev" : "next";
      break;
    }
    case "ArrowRight": {
      isMatch = true;
      type = "next";
      break;
    }
    case "Backspace":
    case "Delete":
    case "ArrowLeft": {
      isMatch = true;
      type = "prev";
      break;
    }
    case "ArrowUp": {
      isMatch = true;
      type = "up";
      break;
    }
    case "ArrowDown": {
      isMatch = true;
      type = "down";
      break;
    }
    case "Space":
    case " ":
    case "Enter":
    case "NumpadEnter": {
      isMatch = true;
      type = "ok";
      break;
    }
    case "Escape": {
      isMatch = true;
      type = "esc";
      break;
    }
  }
  if (isMatch) {
    event.preventDefault();
    event.stopPropagation();
  } else {
    const inputtedNumber = numberKeys.findIndex((num) => isNumberKey(key, num));
    if (~inputtedNumber) {
      type = inputtedNumber;
      event.preventDefault();
      event.stopPropagation();
    }
  }
  return type;
}
function useColumn(colTypes, currentColumn = ref(colTypes[0])) {
  const columnTypes = Array.from(colTypes);
  const columnCount = columnTypes.length;
  const enabled = reactive(
    columnTypes.reduce((prev, current) => {
      prev[current] = false;
      return prev;
    }, {})
  );
  function findEnabledColumn(types) {
    var _a;
    currentColumn.value = (_a = types.find((type) => enabled[type])) != null ? _a : currentColumn.value;
  }
  function resetColumn(type, reverse = false) {
    const types = reverse ? Array.from(columnTypes).reverse() : columnTypes;
    const index = types.findIndex((column) => column === type);
    if (~index) {
      findEnabledColumn(types.slice(index, columnCount).concat(types.slice(0, index)));
    } else {
      findEnabledColumn(types);
    }
  }
  function enterColumn(type, canLoop = true) {
    for (let i = 0; i < columnCount; ++i) {
      if (currentColumn.value === columnTypes[i]) {
        const rawTypes = type === "prev" ? Array.from(columnTypes).reverse() : columnTypes;
        const nextIndex = (type === "prev" ? columnCount - i : i + 1) % columnCount;
        const types = canLoop ? rawTypes.slice(nextIndex, columnCount).concat(rawTypes.slice(0, nextIndex)) : nextIndex ? rawTypes.slice(nextIndex, columnCount) : [];
        findEnabledColumn(types);
        break;
      }
    }
  }
  return {
    currentColumn,
    enabled,
    resetColumn,
    enterColumn
  };
}
const defaultMin = [0, 0, 0];
const defaultMax = [23, 59, 59];
function useTimeBound(originMin, originMax) {
  const minUnits = computed(() => {
    return originMin.value ? originMin.value.split(":").map(toNumber) : defaultMin;
  });
  const maxUnits = computed(() => {
    return originMax.value ? originMax.value.split(":").map(toNumber) : defaultMax;
  });
  const reversed = computed(() => {
    const min = minUnits.value;
    const max = maxUnits.value;
    for (let i = 0; i < 3; ++i) {
      if (min[i] < max[i])
        return false;
      if (min[i] > max[i])
        return true;
    }
    return false;
  });
  const isTimeDisabled = {
    hour: isHourDisabled,
    minute: (hour, minute) => isMinuteDisabled(hour, minute) !== DisabledType.FALSE,
    second: (hour, minute, second) => isSecondDisabled(hour, minute, second) !== DisabledType.FALSE
  };
  function isHourDisabled(hour) {
    const min = minUnits.value[0] || defaultMin[0];
    const max = maxUnits.value[0] || defaultMax[0];
    return reversed.value ? hour > max && hour < min : hour < min || hour > max;
  }
  function isMinuteDisabled(hour, minute) {
    if (isHourDisabled(hour))
      return DisabledType.UPSTREAM;
    if (minUnits.value[0] === maxUnits.value[0] && hour === minUnits.value[0]) {
      const min = minUnits.value[1] || defaultMin[1];
      const max = maxUnits.value[1] || defaultMax[1];
      if (reversed.value ? minute > max && minute < min : minute < min || minute > max) {
        return DisabledType.TRUE;
      }
    }
    if (hour === minUnits.value[0]) {
      const min = minUnits.value[1] || defaultMin[1];
      if (minute < min)
        return DisabledType.AT_MIN_TRUE;
    }
    if (hour === maxUnits.value[0]) {
      const max = maxUnits.value[1] || defaultMax[1];
      if (minute > max)
        return DisabledType.AT_MAX_TRUE;
    }
    return DisabledType.FALSE;
  }
  function isSecondDisabled(hour, minute, second) {
    if (isMinuteDisabled(hour, minute) !== DisabledType.FALSE)
      return DisabledType.UPSTREAM;
    if (minUnits.value[0] === maxUnits.value[0] && hour === minUnits.value[0] && minUnits.value[1] === maxUnits.value[1] && minute === minUnits.value[1]) {
      const min = minUnits.value[2] || defaultMin[2];
      const max = maxUnits.value[2] || defaultMax[2];
      if (reversed.value ? second > max && second < min : second < min || second > max) {
        return DisabledType.TRUE;
      }
    }
    if (hour === minUnits.value[0] && minute === minUnits.value[1]) {
      const min = minUnits.value[2] || defaultMin[2];
      if (second < min)
        return DisabledType.AT_MIN_TRUE;
    }
    if (hour === maxUnits.value[0] && minute === maxUnits.value[1]) {
      const max = maxUnits.value[2] || defaultMax[2];
      if (second > max)
        return DisabledType.AT_MAX_TRUE;
    }
    return DisabledType.FALSE;
  }
  return {
    minUnits,
    maxUnits,
    reversed,
    isTimeDisabled
  };
}
export { handleKeyEnter, useColumn, useTimeBound };
