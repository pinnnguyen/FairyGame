import { defineComponent, toRef, ref, computed, nextTick, watch, reactive, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, withKeys, withModifiers, normalizeStyle, renderSlot, createVNode, createCommentVNode, Fragment, withCtx, Transition } from "vue";
import DateControl from "./date-control.mjs";
import DatePanel from "./date-panel.mjs";
import "../icon/index.mjs";
import "../portal/index.mjs";
import "../form/index.mjs";
import { placementWhileList, useSetTimeout, useClickOutside, usePopper, useHover } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { toFalse, doubleDigits, startOfMonth, differenceDays, getTime, toDate, boundRange, isLeepYear } from "@vexip-ui/utils";
import { CircleXmark, ArrowRightArrowLeft, Spinner, CalendarR } from "@vexip-ui/icons";
import { datePickerProps } from "./props.mjs";
import { useTimeBound, useColumn } from "./helper.mjs";
import { datePickerTypes } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import Portal from "../portal/portal.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
const invalidDate = new Date("");
const _sfc_main = defineComponent({
  name: "DatePicker",
  components: {
    DateControl,
    DatePanel,
    Icon,
    Portal,
    CircleXmark,
    ArrowRightArrowLeft
  },
  props: datePickerProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("date-picker");
    const props = useProps("datePicker", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      type: {
        default: "date",
        validator: (value) => datePickerTypes.includes(value)
      },
      visible: false,
      placement: {
        default: "bottom-start",
        validator: (value) => placementWhileList.includes(value)
      },
      transfer: false,
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      format: "yyyy-MM-dd HH:mm:ss",
      filler: {
        default: "-",
        validator: (value) => value.length === 1
      },
      noFiller: false,
      clearable: false,
      noAction: false,
      labels: () => ({}),
      dateSeparator: "/",
      timeSeparator: ":",
      shortcuts: () => [],
      disabledDate: {
        default: toFalse,
        isFunc: true
      },
      steps: () => [1, 1, 1],
      ctrlSteps: () => [5, 5, 5],
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      confirmText: null,
      cancelText: null,
      today: {
        default: () => new Date(),
        validator: (value) => !Number.isNaN(new Date(value))
      },
      isRange: false,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      min: null,
      max: null
    });
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const currentVisible = ref(props.visible);
    const focused = ref(false);
    const startState = createDateState();
    const endState = createDateState();
    const currentState = ref("start");
    const lastValue = ref("");
    const { timer } = useSetTimeout();
    const wrapper = useClickOutside(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = usePopper({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = useHover(reference);
    const startInput = ref();
    const endInput = ref();
    const datePanel = ref();
    const className = computed(() => {
      return [
        nh.b(),
        nh.ns("input-vars"),
        nh.bs("vars"),
        nh.bm(props.type),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("no-hour")]: !startState.enabled.hour,
          [nh.bm("no-minute")]: !startState.enabled.minute,
          [nh.bm("no-second")]: !startState.enabled.second,
          [nh.bm("visible")]: currentVisible.value,
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm("is-range")]: props.isRange
        }
      ];
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--focused`]: focused.value,
        [`${baseCls}--${props.state}`]: props.state !== "default"
      };
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const currentValue = computed(() => {
      const values = [startState, endState].map((state2) => {
        const values2 = Object.values(state2.dateValue).map(doubleDigits);
        return `${values2.slice(0, 3).join("-")} ${values2.slice(3).join(":")}`;
      });
      return props.isRange ? values : values[0];
    });
    const startActivated = computed(() => {
      const activated = startState.activated;
      return activated.year && activated.month && activated.date;
    });
    const endActivated = computed(() => {
      const activated = endState.activated;
      return activated.year && activated.month && activated.date;
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && !!lastValue.value;
    });
    const min = computed(() => {
      if (props.min) {
        const date = rawValueToDate(props.min, invalidDate);
        if (Number.isNaN(+date))
          return -Infinity;
        date.setHours(0, 0, 0, 0);
        return date;
      }
      return -Infinity;
    });
    const max = computed(() => {
      if (props.max) {
        let date = rawValueToDate(props.max, invalidDate);
        if (Number.isNaN(+date))
          return Infinity;
        if (props.type !== "datetime") {
          date.setHours(23, 59, 59, 999);
          if (props.type === "year") {
            date.setMonth(11);
            date.setDate(31);
          } else if (props.type === "month") {
            date.setMonth(date.getMonth() + 1);
            date = startOfMonth(date);
            date.setDate(date.getDate() - 1);
          }
        }
        return +date;
      }
      return Infinity;
    });
    const reversed = computed(() => {
      if (Number.isNaN(min.value) || Number.isNaN(max.value)) {
        return false;
      }
      return min.value > max.value;
    });
    const startMinTime = computed(() => {
      if (props.type === "datetime" && props.min && !differenceDays(props.min, startState.getDate())) {
        return getTime(props.min);
      }
      return "";
    });
    const startMaxTime = computed(() => {
      if (props.type === "datetime" && props.max && !differenceDays(props.max, startState.getDate())) {
        return getTime(props.max);
      }
      return "";
    });
    const endMinTime = computed(() => {
      if (props.type === "datetime" && props.isRange && props.min && !differenceDays(props.min, startState.getDate())) {
        return getTime(props.min);
      }
      return "";
    });
    const endMaxTime = computed(() => {
      if (props.type === "datetime" && props.isRange && props.max && !differenceDays(props.max, startState.getDate())) {
        return getTime(props.max);
      }
      return "";
    });
    const startReversed = computed(() => {
      if (!props.isRange)
        return false;
      const startValue = startState.dateValue;
      const endValue = endState.dateValue;
      let types;
      if (props.type === "year") {
        types = ["year"];
      } else if (props.type === "month") {
        types = ["year", "month"];
      } else if (props.type === "date") {
        types = ["year", "month", "date"];
      } else {
        types = ["year", "month", "date", "hour", "minute", "second"];
      }
      for (const type of types) {
        if (startValue[type] < endValue[type])
          return false;
        if (startValue[type] > endValue[type])
          return true;
      }
      return false;
    });
    const startTimeBound = useTimeBound(startMinTime, startMaxTime);
    const endTimeBound = useTimeBound(endMinTime, endMaxTime);
    const isTimeDisabled = computed(() => {
      return currentState.value === "start" ? startTimeBound.isTimeDisabled : endTimeBound.isTimeDisabled;
    });
    const startError = computed(() => {
      const { hour, minute, second } = startState.dateValue;
      const { isTimeDisabled: isTimeDisabled2 } = startTimeBound;
      return startReversed.value || isDateDisabled(startState.getDate()) || isTimeDisabled2.hour(hour) || isTimeDisabled2.minute(hour, minute) || isTimeDisabled2.second(hour, minute, second);
    });
    const endError = computed(() => {
      if (!props.isRange)
        return false;
      const { hour, minute, second } = endState.dateValue;
      const { isTimeDisabled: isTimeDisabled2 } = endTimeBound;
      return startReversed.value || isDateDisabled(endState.getDate()) || isTimeDisabled2.hour(hour) || isTimeDisabled2.minute(hour, minute) || isTimeDisabled2.second(hour, minute, second);
    });
    startState.enabled.year = true;
    endState.enabled.year = true;
    nextTick(() => {
      startState.resetColumn("date");
      endState.resetColumn("date");
    });
    watch(() => props.type, parseFormat);
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
      },
      { immediate: true }
    );
    watch(
      () => props.type,
      (value) => {
        const hasMonth = value !== "year";
        const hasDate = hasMonth && value !== "month";
        startState.enabled.month = hasMonth;
        endState.enabled.month = hasMonth;
        startState.enabled.date = hasDate;
        endState.enabled.date = hasDate;
      },
      { immediate: true }
    );
    watch(() => props.format, parseFormat, { immediate: true });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        updatePopper();
      } else {
        emitChange();
      }
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(focused, (value) => {
      if (value) {
        emitEvent(props.onFocus);
      } else {
        emitEvent(props.onBlur);
      }
    });
    watch(currentState, (value) => {
      if (currentVisible.value) {
        emitEvent(props.onChangeCol, getCurrentState().column, value);
      }
    });
    watch(
      () => startState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "start") {
          emitEvent(props.onChangeCol, value, "start");
        }
      }
    );
    watch(
      () => endState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "end") {
          emitEvent(props.onChangeCol, value, "end");
        }
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
          handleBlur();
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    function createDateState() {
      const noFiller = props.noFiller;
      const { currentColumn, enabled, resetColumn, enterColumn: enterColumn2 } = useColumn([
        "year",
        "month",
        "date",
        "hour",
        "minute",
        "second"
      ]);
      const dateValue = reactive({
        year: 1970,
        month: 1,
        date: 1,
        hour: 0,
        minute: 0,
        second: 0
      });
      const activated = reactive({
        year: noFiller,
        month: noFiller,
        date: noFiller,
        hour: noFiller,
        minute: noFiller,
        second: noFiller
      });
      return reactive({
        column: currentColumn,
        enabled,
        activated,
        dateValue,
        resetColumn,
        enterColumn: enterColumn2,
        setDate: (date) => {
          dateValue.year = date.getFullYear();
          dateValue.month = date.getMonth() + 1;
          dateValue.date = date.getDate();
          dateValue.hour = date.getHours();
          dateValue.minute = date.getMinutes();
          dateValue.second = date.getSeconds();
        },
        getDate: () => {
          return new Date(
            dateValue.year,
            dateValue.month - 1,
            dateValue.date,
            dateValue.hour,
            dateValue.minute,
            dateValue.second
          );
        }
      });
    }
    function getCurrentState() {
      return currentState.value === "start" ? startState : endState;
    }
    function rawValueToDate(value, defaultValue = new Date(props.today)) {
      let date;
      if (typeof value === "number") {
        if (props.type === "year") {
          if (value < 3e3) {
            date = new Date(value, 1);
          } else {
            date = toDate(value);
          }
        } else if (props.type === "month") {
          if (value < 3e5) {
            const year = Math.floor(value / 100);
            const month = value - year * 100;
            date = new Date(year, month - 1);
          } else {
            date = toDate(value);
          }
        } else {
          date = toDate(value);
        }
      } else {
        date = toDate(value);
      }
      if (Number.isNaN(date.getTime())) {
        date = defaultValue;
      }
      return date;
    }
    function parseValue(value) {
      var _a;
      if (!Array.isArray(value)) {
        value = [value, value];
      }
      for (let i = 0; i < 2; ++i) {
        const date = rawValueToDate((_a = value[i]) != null ? _a : "");
        const state2 = i === 0 ? startState : endState;
        state2.setDate(date);
        if (!props.isRange)
          break;
      }
    }
    function parseFormat() {
      const isDatetime = props.type === "datetime";
      [startState, endState].forEach((state2) => {
        state2.enabled.hour = false;
        state2.enabled.minute = false;
        state2.enabled.second = false;
        if (isDatetime && props.format.length) {
          const length = props.format.length;
          let inQuotation = false;
          for (let i = 0; i < length; ++i) {
            const char = props.format.charAt(i);
            if (char === "'") {
              inQuotation = !inQuotation;
            } else if (!inQuotation) {
              switch (char) {
                case "H":
                  state2.enabled.hour = true;
                  break;
                case "m":
                  state2.enabled.minute = true;
                  break;
                case "s":
                  state2.enabled.second = true;
                  break;
              }
            }
          }
        }
      });
    }
    function toggleActivated(value, type) {
      const states = type ? type === "start" ? [startState] : [endState] : [startState, endState];
      states.forEach((state2) => {
        Object.keys(state2.activated).forEach((type2) => {
          state2.activated[type2] = value;
        });
      });
    }
    function getStringValue() {
      return Array.isArray(currentValue.value) ? currentValue.value.join("|") : currentValue.value;
    }
    function isDateDisabled(date) {
      if (typeof props.disabledDate === "function") {
        if (props.disabledDate(date)) {
          return true;
        }
      }
      const time = date.getTime();
      if (reversed.value) {
        if (time > max.value && time < min.value) {
          return true;
        }
      } else {
        if (time < min.value || time > max.value) {
          return true;
        }
      }
      return false;
    }
    function verifyDate() {
      if (startError.value || props.isRange && endError.value) {
        if (lastValue.value) {
          parseValue(lastValue.value.split("|"));
        } else {
          parseValue(props.value);
        }
      }
    }
    function emitChange() {
      verifyDate();
      if (lastValue.value !== getStringValue()) {
        lastValue.value = getStringValue();
        const values = Array.isArray(currentValue.value) ? currentValue.value : [currentValue.value];
        const emitValues = [];
        for (let i = 0; i < 2; ++i) {
          if (props.type === "year") {
            emitValues[i] = i === 0 ? startState.dateValue.year : endState.dateValue.year;
          } else if (props.type !== "datetime") {
            emitValues[i] = values[i].split(" ")[0];
          } else {
            emitValues[i] = values[i];
          }
          if (!props.isRange)
            break;
        }
        const emitValue = props.isRange ? emitValues : emitValues[0];
        toggleActivated(true);
        setFieldValue(emitValue);
        emitEvent(props.onChange, emitValue);
        emit("update:value", emitValue);
        validateField();
      }
    }
    function finishInput() {
      currentVisible.value = false;
      startState.resetColumn("date");
      endState.resetColumn("date");
    }
    function verifyValue(type) {
      const dateValue = getCurrentState().dateValue;
      switch (type) {
        case "year": {
          dateValue.year = boundRange(dateValue.year, 1970, 9999);
          break;
        }
        case "month": {
          dateValue.month = boundRange(dateValue.month, 1, 12);
          break;
        }
        case "date": {
          const month = dateValue.month;
          let lastDay;
          if (month < 7) {
            if (month !== 2) {
              lastDay = 30 + month % 2;
            } else {
              if (isLeepYear(dateValue.year)) {
                lastDay = 29;
              } else {
                lastDay = 28;
              }
            }
          } else {
            lastDay = 31 - month % 2;
          }
          dateValue.date = boundRange(dateValue.date, 1, lastDay);
          break;
        }
        case "hour":
        case "minute":
        case "second": {
          dateValue[type] = boundRange(dateValue[type], 0, type === "hour" ? 23 : 59);
          dateValue[type] = Math.round(dateValue[type] / getStep(type)) * getStep(type);
        }
      }
    }
    function handleFocused() {
      if (props.disabled)
        return;
      focused.value = true;
      timer.focus = setTimeout(() => {
        var _a, _b;
        if (focused.value) {
          if (currentState.value === "start") {
            (_a = startInput.value) == null ? void 0 : _a.focus();
          } else {
            (_b = endInput.value) == null ? void 0 : _b.focus();
          }
        }
      }, 120);
    }
    function handleBlur() {
      var _a, _b;
      clearTimeout(timer.focus);
      focused.value = false;
      (_a = startInput.value) == null ? void 0 : _a.blur();
      (_b = endInput.value) == null ? void 0 : _b.blur();
    }
    function showPanel(event) {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      const target = event.target;
      const lastVisible = currentVisible.value;
      currentVisible.value = true;
      handleFocused();
      if (!lastVisible && wrapper.value && target) {
        const units = Array.from(wrapper.value.querySelectorAll(`.${nh.be("unit")}`));
        if (!units.some((unit) => unit === target || unit.contains(target))) {
          emitEvent(props.onChangeCol, getCurrentState().column, currentState.value);
        }
      }
    }
    function handleInput(value) {
      const state2 = getCurrentState();
      handleInputNumber(state2.column, value);
      if (state2.column === "year" ? state2.dateValue.year >= 1e3 : state2.dateValue[state2.column] >= 10) {
        state2.enterColumn("next", false);
      }
    }
    function handleInputNumber(type, number) {
      const state2 = getCurrentState();
      const prev = state2.dateValue[type];
      if ((props.noFiller || state2.activated[type]) && prev > 0 && prev < (type === "year" ? 1e3 : 10)) {
        state2.dateValue[type] = prev * 10 + number;
      } else {
        state2.dateValue[type] = number;
        setActivated(type);
      }
      type !== "year" && verifyValue(type);
      emitEvent(props.onInput, type, state2.dateValue[type]);
    }
    function setActivated(type) {
      const activated = getCurrentState().activated;
      if (type === "date") {
        activated.year = true;
        activated.month = true;
      } else if (type === "month") {
        activated.year = true;
      } else if (type === "minute") {
        activated.hour = true;
      } else if (type === "second") {
        activated.hour = true;
        activated.minute = true;
      }
      activated[type] = true;
    }
    function handleInputFocus(type) {
      getCurrentState().column = type;
    }
    function isTimeType(type) {
      return ["hour", "minute", "second"].includes(type);
    }
    function handleAdjust(adjustType, ctrlKey) {
      var _a;
      const isPlus = adjustType === "plus";
      const sign = isPlus ? 1 : -1;
      const state2 = getCurrentState();
      const type = state2.column;
      if (state2.enabled[type]) {
        if (isTimeType(type)) {
          state2.dateValue[type] += sign * (ctrlKey ? getCtrlStep(type) : getStep(type));
        } else {
          if (ctrlKey) {
            if (type === "year") {
              state2.dateValue.year += sign * 10;
            } else {
              state2.dateValue[type === "date" ? "month" : "year"] += sign;
            }
          } else {
            state2.dateValue[type] += sign;
          }
          computeDate();
          updateDateActivated(type);
        }
        verifyValue(type);
        emitEvent(props[isPlus ? "onPlus" : "onMinus"], type, state2.dateValue[type]);
        (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
      }
    }
    function handlePlus(ctrlKey) {
      handleAdjust("plus", ctrlKey);
    }
    function handleMinus(ctrlKey) {
      handleAdjust("minus", ctrlKey);
    }
    function computeDate() {
      const dateValue = getCurrentState().dateValue;
      const date = new Date(dateValue.year, dateValue.month - 1, dateValue.date);
      dateValue.year = date.getFullYear();
      dateValue.month = date.getMonth() + 1;
      dateValue.date = date.getDate();
    }
    function handleEnter() {
      finishInput();
      emitEvent(props.onEnter);
    }
    function handleCancel() {
      parseValue(props.value);
      finishInput();
      emitEvent(props.onCancel);
    }
    function resetValue() {
      [startState, endState].forEach((state2) => {
        state2.dateValue.year = 1970;
        state2.dateValue.month = 1;
        state2.dateValue.date = 1;
        state2.dateValue.hour = 0;
        state2.dateValue.minute = 0;
        state2.dateValue.second = 0;
      });
      lastValue.value = "";
    }
    function handleClear() {
      if (props.clearable) {
        finishInput();
        nextTick(() => {
          const emitValue = props.isRange ? [] : null;
          resetValue();
          emitEvent(props.onChange, emitValue);
          emit("update:value", emitValue);
          emitEvent(props.onClear);
          clearField(emitValue);
          nextTick(() => {
            toggleActivated(false);
          });
        });
      }
    }
    function handleShortcut(name, value) {
      parseValue(value);
      emitEvent(props.onShortcut, name, value);
      finishInput();
    }
    function getStep(type) {
      return props.steps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function getCtrlStep(type) {
      return props.ctrlSteps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function handlePanelChange(type, value) {
      getCurrentState().dateValue[type] = value;
      updateDateActivated(type);
      verifyRangeValue();
    }
    function updateDateActivated(type) {
      const state2 = getCurrentState();
      if (type === "month") {
        state2.activated.year = true;
      } else if (type === "date") {
        state2.activated.year = true;
        state2.activated.month = true;
      }
      state2.activated[type] = true;
    }
    function verifyRangeValue() {
      if (!props.isRange)
        return;
      const startDate = startState.getDate();
      const endDate = endState.getDate();
      if (startDate.getTime() > endDate.getTime()) {
        if (currentState.value === "start") {
          startState.setDate(endDate);
        } else {
          endState.setDate(startDate);
        }
      }
    }
    function toggleCurrentState(type) {
      currentState.value = type;
    }
    function enterColumn(type) {
      if (props.isRange) {
        const state2 = getCurrentState();
        const currentColumn = state2.column;
        state2.enterColumn(type, false);
        if (currentColumn === state2.column) {
          const isStart = currentState.value === "start";
          const otherState = isStart ? endState : startState;
          otherState.resetColumn(type === "prev" ? "second" : "year", type === "prev");
          toggleCurrentState(isStart ? "end" : "start");
        }
      } else {
        startState.enterColumn(type);
      }
    }
    function handleStartInput(type) {
      toggleCurrentState("start");
      handleInputFocus(type);
      nextTick(() => {
        var _a;
        (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
      });
    }
    function handleEndInput(type) {
      toggleCurrentState("end");
      handleInputFocus(type);
      nextTick(() => {
        var _a;
        (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
      });
    }
    function handlePaneConfirm() {
      if (!props.isRange) {
        handleEnter();
      } else {
        if (currentState.value === "start" && !endActivated.value) {
          toggleActivated(true, "start");
          currentState.value = "end";
        } else if (currentState.value === "end" && !startActivated.value) {
          toggleActivated(true, "end");
          currentState.value = "start";
        } else {
          handleEnter();
        }
      }
    }
    function handlePaneHide() {
      var _a;
      (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
    }
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      finishInput();
      handleBlur();
    }
    return {
      CalendarR,
      startMinTime,
      startMaxTime,
      props,
      nh,
      idFor,
      currentVisible,
      focused,
      transferTo,
      isHover,
      startState,
      endState,
      lastValue,
      currentState,
      className,
      selectorClass,
      hasPrefix,
      startActivated,
      endActivated,
      showClear,
      startError,
      endError,
      wrapper,
      reference,
      popper,
      start: startInput,
      end: endInput,
      panel: datePanel,
      isTimeDisabled,
      isDateDisabled,
      handleFocused,
      showPanel,
      handleInput,
      handleInputFocus,
      handlePlus,
      handleMinus,
      handleEnter,
      handleCancel,
      handleClear,
      handleShortcut,
      handlePanelChange,
      finishInput,
      toggleCurrentState,
      enterColumn,
      handleStartInput,
      handleEndInput,
      handlePaneConfirm,
      handlePaneHide,
      focus: handleFocused,
      blur: handleBlur,
      updatePopper
    };
  }
});
const _hoisted_1 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_DateControl = resolveComponent("DateControl");
  const _component_ArrowRightArrowLeft = resolveComponent("ArrowRightArrowLeft");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_DatePanel = resolveComponent("DatePanel");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[7] || (_cache[7] = (...args) => _ctx.showPanel && _ctx.showPanel(...args))
  }, [
    createElementVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.showPanel && _ctx.showPanel(...args), ["prevent"]), ["space"]))
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        createVNode(_component_DateControl, {
          ref: "start",
          "unit-type": _ctx.currentState === "start" ? _ctx.startState.column : "",
          enabled: _ctx.startState.enabled,
          activated: _ctx.startState.activated,
          "date-value": _ctx.startState.dateValue,
          steps: _ctx.props.steps,
          "ctrl-steps": _ctx.props.ctrlSteps,
          focused: _ctx.focused,
          visible: _ctx.currentVisible,
          "date-separator": _ctx.props.dateSeparator,
          "time-separator": _ctx.props.timeSeparator,
          filler: _ctx.props.filler,
          "no-filler": _ctx.props.noFiller,
          labels: _ctx.props.labels,
          "has-error": _ctx.startError,
          onInput: _ctx.handleInput,
          onPlus: _ctx.handlePlus,
          onMinus: _ctx.handleMinus,
          onEnter: _ctx.handlePaneConfirm,
          onCancel: _ctx.handleCancel,
          onUnitFocus: _ctx.handleStartInput,
          onPrevUnit: _cache[0] || (_cache[0] = ($event) => _ctx.enterColumn("prev")),
          onNextUnit: _cache[1] || (_cache[1] = ($event) => _ctx.enterColumn("next"))
        }, null, 8, ["unit-type", "enabled", "activated", "date-value", "steps", "ctrl-steps", "focused", "visible", "date-separator", "time-separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"]),
        _ctx.props.isRange ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.nh.be("exchange"))
          }, [
            renderSlot(_ctx.$slots, "exchange", {}, () => [
              createVNode(_component_Icon, { style: { "padding-top": "1px" } }, {
                default: withCtx(() => [
                  createVNode(_component_ArrowRightArrowLeft)
                ]),
                _: 1
              })
            ])
          ], 2),
          createVNode(_component_DateControl, {
            ref: "end",
            "unit-type": _ctx.currentState === "end" ? _ctx.endState.column : "",
            enabled: _ctx.endState.enabled,
            activated: _ctx.endState.activated,
            "date-value": _ctx.endState.dateValue,
            steps: _ctx.props.steps,
            "ctrl-steps": _ctx.props.ctrlSteps,
            focused: _ctx.focused,
            visible: _ctx.currentVisible,
            "date-separator": _ctx.props.dateSeparator,
            "time-separator": _ctx.props.timeSeparator,
            filler: _ctx.props.filler,
            "no-filler": _ctx.props.noFiller,
            labels: _ctx.props.labels,
            "has-error": _ctx.endError,
            onInput: _ctx.handleInput,
            onPlus: _ctx.handlePlus,
            onMinus: _ctx.handleMinus,
            onEnter: _ctx.handlePaneConfirm,
            onCancel: _ctx.handleCancel,
            onUnitFocus: _ctx.handleEndInput,
            onPrevUnit: _cache[2] || (_cache[2] = ($event) => _ctx.enterColumn("prev")),
            onNextUnit: _cache[3] || (_cache[3] = ($event) => _ctx.enterColumn("next"))
          }, null, 8, ["unit-type", "enabled", "activated", "date-value", "steps", "ctrl-steps", "focused", "visible", "date-separator", "time-separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"])
        ], 64)) : createCommentVNode("", true)
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.suffix || _ctx.CalendarR
          }, null, 8, ["icon"])
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.showClear ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onAfterLeave: _ctx.handlePaneHide
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.ns("calendar-vars"),
                _ctx.nh.ns("time-picker-vars"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.handleFocused && _ctx.handleFocused(...args), ["stop"]))
            }, [
              createVNode(_component_DatePanel, {
                ref: "panel",
                type: _ctx.props.type,
                column: (_ctx.currentState === "start" ? _ctx.startState : _ctx.endState).column,
                "start-value": _ctx.startState.dateValue,
                "end-value": _ctx.endState.dateValue,
                "start-activated": _ctx.startState.activated,
                "end-activated": _ctx.endState.activated,
                "value-type": _ctx.currentState,
                shortcuts: _ctx.props.shortcuts,
                "confirm-text": _ctx.props.confirmText,
                "cancel-text": _ctx.props.cancelText,
                today: _ctx.props.today,
                "no-action": _ctx.props.noAction,
                steps: _ctx.props.steps,
                "is-range": _ctx.props.isRange,
                min: _ctx.props.min,
                max: _ctx.props.max,
                "disabled-date": _ctx.isDateDisabled,
                "disabled-time": _ctx.isTimeDisabled,
                "has-error": _ctx.startError || _ctx.endError,
                onShortcut: _ctx.handleShortcut,
                onChange: _ctx.handlePanelChange,
                onToggleCol: _ctx.handleInputFocus,
                onCancel: _ctx.handleCancel,
                onConfirm: _ctx.handlePaneConfirm
              }, null, 8, ["type", "column", "start-value", "end-value", "start-activated", "end-activated", "value-type", "shortcuts", "confirm-text", "cancel-text", "today", "no-action", "steps", "is-range", "min", "max", "disabled-date", "disabled-time", "has-error", "onShortcut", "onChange", "onToggleCol", "onCancel", "onConfirm"])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name", "onAfterLeave"])
      ]),
      _: 1
    }, 8, ["to"])
  ], 10, _hoisted_1);
}
var DatePicker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { DatePicker as default };
