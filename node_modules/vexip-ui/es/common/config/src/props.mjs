import { computed, unref, inject, provide, watch, reactive } from "vue";
import { mergeObjects, isObject, has, isFunction, isNull } from "@vexip-ui/utils";
const PROVIDED_PROPS = "__vxp-provided-props";
const eventPropRE = /^on[A-Z]/;
function configProps(props, app) {
  if (app) {
    app.provide(
      PROVIDED_PROPS,
      computed(() => unref(props))
    );
  } else {
    const upstreamProps = inject(PROVIDED_PROPS, null);
    const providedProps = computed(() => {
      if (!(upstreamProps == null ? void 0 : upstreamProps.value)) {
        return unref(props);
      }
      return mergeObjects(upstreamProps.value, unref(props));
    });
    provide(PROVIDED_PROPS, providedProps);
  }
}
function useProps(name, sourceProps, config = {}) {
  const providedProps = inject(
    PROVIDED_PROPS,
    null
  );
  const commonProps = computed(() => {
    var _a, _b;
    return (_b = (_a = providedProps == null ? void 0 : providedProps.value) == null ? void 0 : _a.default) != null ? _b : {};
  });
  const configProps2 = computed(() => {
    var _a, _b;
    return (_b = (_a = providedProps == null ? void 0 : providedProps.value) == null ? void 0 : _a[name]) != null ? _b : {};
  });
  const keys = Object.keys(sourceProps);
  const props = {};
  keys.forEach((key) => {
    const defs = config[key];
    const propOptions = isObject(defs) && has(defs, "default") ? defs : { default: defs };
    const validator = isFunction(propOptions.validator) ? propOptions.validator : null;
    const defaultValue = propOptions.default;
    const isFunc = isNull(propOptions.isFunc) ? eventPropRE.test(String(key)) : propOptions.isFunc;
    const getValue = (value) => !isFunc && isFunction(value) ? value() : value;
    const getDefault = () => !isFunc && isFunction(defaultValue) ? defaultValue() : defaultValue;
    validator && watch(
      () => sourceProps[key],
      (value) => {
        const result = validator(value);
        if (result === false) {
          console.warn(
            `${toWarnPrefix(name)}: an invaild value is set to '${key}' prop`
          );
        }
      }
    );
    if (propOptions.static) {
      props[key] = computed(() => {
        var _a;
        return (_a = sourceProps[key]) != null ? _a : getDefault();
      });
    } else {
      props[key] = computed(() => {
        if (isNull(sourceProps[key])) {
          if (!isNull(configProps2.value[key])) {
            return getValue(configProps2.value[key]);
          }
          if (!isNull(commonProps.value[key])) {
            return getValue(commonProps.value[key]);
          }
          return getDefault();
        }
        return sourceProps[key];
      });
    }
  });
  return reactive(props);
}
function toWarnPrefix(name) {
  return `[vexip-ui:${name.charAt(0).toLocaleUpperCase() + name.substring(1)}]`;
}
const booleanProp = {
  type: Boolean,
  default: null
};
const booleanStringProp = {
  type: [Boolean, String],
  default: null
};
const booleanNumberProp = {
  type: [Boolean, Number],
  default: null
};
function buildProps(props) {
  const common = {
    inherit: booleanProp
  };
  return Object.freeze({ ...common, ...props });
}
function omitProps(props, keys, extra) {
  const omittedKeys = new Set(keys);
  return Object.freeze(
    Object.assign(
      Object.keys(props).reduce((prev, current) => {
        if (!omittedKeys.has(current)) {
          prev[current] = props[current];
        }
        return prev;
      }, {}),
      extra || {}
    )
  );
}
const sizeProp = String;
function createSizeProp(defaultValue = "default") {
  return {
    default: () => unref(defaultValue),
    validator(value) {
      return ["small", "default", "large"].includes(value);
    }
  };
}
const stateProp = String;
function createStateProp(defaultValue = "default") {
  return {
    default: () => unref(defaultValue),
    validator(value) {
      return ["default", "success", "error", "warning"].includes(value);
    }
  };
}
const classProp = [String, Object, Array];
const styleProp = [String, Object, Array];
const eventTypes = [Function, Array];
function eventProp() {
  return eventTypes;
}
function emitEvent(handlers, ...args) {
  if (Array.isArray(handlers)) {
    for (let i = 0, len = handlers.length; i < len; ++i) {
      const handler = handlers[i];
      typeof handler === "function" && handlers[i](...args);
    }
  } else {
    typeof handlers === "function" && handlers(...args);
  }
}
export { PROVIDED_PROPS, booleanNumberProp, booleanProp, booleanStringProp, buildProps, classProp, configProps, createSizeProp, createStateProp, emitEvent, eventProp, omitProps, sizeProp, stateProp, styleProp, useProps };
