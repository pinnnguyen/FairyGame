import {
  $,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  $18,
  $19,
  $2,
  $20,
  $21,
  $22,
  $23,
  $24,
  $25,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $n,
  $o,
  An,
  Ao,
  Ar,
  B,
  C,
  C2,
  C3,
  C4,
  C5,
  Co,
  CollapseTransition,
  Do,
  Dt,
  En,
  Fe,
  Fn,
  Fr,
  Ft,
  Ge,
  Gn,
  H,
  Ho,
  Icon,
  Io,
  Je,
  Jn,
  Ke,
  L,
  L2,
  L3,
  Ln,
  M,
  MENU_ITEM_STATE,
  MENU_STATE,
  MenuGroup,
  MenuItem,
  Mo,
  Mr,
  N,
  No,
  On,
  Or,
  Pn,
  Portal,
  Qe,
  Qt,
  R,
  Renderer,
  Rn,
  Rr,
  S,
  Sn,
  Tooltip,
  Tr,
  Tt,
  V,
  Wo,
  Ye,
  Yn,
  Zt,
  _e,
  _export_sfc,
  _o,
  _r,
  bn,
  booleanNumberProp,
  booleanProp,
  booleanStringProp,
  br,
  buildProps,
  classProp,
  cn,
  collapsePanelProps,
  collapseProps,
  configLocale,
  configNamespace,
  configProps,
  configZIndex,
  cr,
  createSizeProp,
  createStateProp,
  dn,
  emitEvent,
  eventProp,
  fn,
  ft,
  getCountWord,
  getCountWordOnly,
  gn,
  gr,
  gt,
  h as h2,
  h2 as h3,
  h3 as h4,
  h4 as h5,
  h5 as h6,
  jo,
  jt,
  kn,
  kr,
  kt,
  l,
  lr,
  m,
  makeSentence,
  me,
  menuProps,
  mn,
  omitProps,
  pr,
  qe,
  qo,
  qt,
  sizeProp,
  sn,
  stateProp,
  styleProp,
  u,
  u2,
  u3,
  u4,
  u5,
  u6,
  u7,
  un,
  useLocale,
  useNameHelper,
  useProps,
  useZIndex,
  ut,
  v,
  v2,
  v3,
  v4,
  we,
  wr,
  x,
  x10,
  x11,
  x12,
  x13,
  x14,
  x15,
  x16,
  x17,
  x18,
  x19,
  x2,
  x20,
  x21,
  x22,
  x23,
  x3,
  x4,
  x5,
  x6,
  x7,
  x8,
  x9,
  y,
  yn,
  yr,
  z,
  zt
} from "./chunk-HCLTFEDK.js";
import "./chunk-I3GPVWOK.js";
import {
  Comment,
  Fragment,
  Transition,
  computed,
  createApp,
  createBaseVNode,
  createBlock,
  createCommentVNode,
  createElementBlock,
  createSlots,
  createTextVNode,
  createVNode,
  defineComponent,
  getCurrentInstance,
  guardReactiveProps,
  h,
  inject,
  isVNode,
  markRaw,
  mergeProps,
  nextTick,
  normalizeClass,
  normalizeProps,
  normalizeStyle,
  onBeforeMount,
  onBeforeUnmount,
  onBeforeUpdate,
  onMounted,
  onUpdated,
  openBlock,
  provide,
  reactive,
  ref,
  render,
  renderList,
  renderSlot,
  resolveComponent,
  resolveDynamicComponent,
  toDisplayString,
  toRef,
  toRefs,
  unref,
  vShow,
  watch,
  watchEffect,
  withCtx,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-PTUCGQPZ.js";
import "./chunk-7NEK6ARH.js";

// node_modules/vexip-ui/es/components/alert/props.mjs
var alertProps = buildProps({
  type: String,
  title: String,
  colorfulText: booleanProp,
  icon: {
    type: [Boolean, Object],
    default: null
  },
  closable: booleanProp,
  iconColor: String,
  noBorder: booleanProp,
  banner: booleanProp,
  manual: booleanProp,
  scroll: booleanProp,
  scrollSpeed: Number,
  onClose: eventProp(),
  onHide: eventProp(),
  onScrollEnd: eventProp()
});

// node_modules/vexip-ui/es/components/alert/alert.mjs
var predefinedIcons = {
  default: x9,
  info: x3,
  success: x2,
  warning: $19,
  error: u
};
var alertTypes = Object.freeze(["default", "info", "success", "warning", "error"]);
var _sfc_main = defineComponent({
  name: "Alert",
  components: {
    CollapseTransition,
    Icon,
    Xmark: L2
  },
  props: alertProps,
  emits: [],
  setup(_props, { slots }) {
    const props = useProps("alert", _props, {
      type: {
        default: "info",
        validator: (value) => alertTypes.includes(value)
      },
      title: "",
      colorfulText: false,
      icon: false,
      closable: false,
      iconColor: "",
      noBorder: false,
      banner: false,
      manual: false,
      scroll: false,
      scrollSpeed: 1
    });
    const nh = useNameHelper("alert");
    const closed = ref(false);
    const hidden = ref(false);
    const scrollDuration = ref(0);
    const scrollOffset = ref(0);
    const scrollWidth = ref(0);
    const content = ref();
    const scroll = ref();
    const hasTitle = computed(() => {
      return !!(props.title || slots.title);
    });
    const hasIcon = computed(() => {
      return !!(props.icon || slots.icon);
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.type)]: props.type,
        [nh.bm("colorful-text")]: props.colorfulText,
        [nh.bm("has-title")]: hasTitle.value,
        [nh.bm("has-icon")]: hasIcon.value,
        [nh.bm("closable")]: props.closable,
        [nh.bm("no-border")]: !props.banner && props.noBorder,
        [nh.bm("banner")]: props.banner
      };
    });
    const iconComp = computed(() => {
      var _a;
      if (typeof props.icon === "boolean") {
        return (_a = predefinedIcons[props.type]) != null ? _a : null;
      }
      return props.icon;
    });
    const scrollStyle = computed(() => {
      return {
        width: `${scrollWidth.value}px`,
        transitionDuration: `${scrollDuration.value}ms`,
        transform: `translateX(${scrollOffset.value}px)`
      };
    });
    watch(
      () => props.scroll,
      (value) => {
        value && startScroll();
      }
    );
    onMounted(() => {
      props.scroll && startScroll();
    });
    function handleClose() {
      if (!props.manual) {
        closed.value = true;
      }
      emitEvent(props.onClose);
    }
    function handleAfterLeave() {
      emitEvent(props.onHide);
      hidden.value = true;
    }
    function startScroll() {
      if (content.value && scroll.value) {
        const contentRect = content.value.getBoundingClientRect();
        const rangeWidth = lr(scroll.value);
        const duration = (contentRect.width + rangeWidth) * 12 / (Math.max(props.scrollSpeed, 0) || 1);
        scrollDuration.value = 0;
        scrollOffset.value = contentRect.width;
        scrollWidth.value = rangeWidth;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            scrollDuration.value = duration;
            scrollOffset.value = -rangeWidth;
          });
        });
      }
    }
    function handleScrollEnd() {
      emitEvent(props.onScrollEnd);
      requestAnimationFrame(startScroll);
    }
    return {
      props,
      nh,
      closed,
      hidden,
      content,
      scrollEl: scroll,
      hasTitle,
      hasIcon,
      className,
      iconComp,
      scrollStyle,
      handleClose,
      handleAfterLeave,
      handleScrollEnd
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return !_ctx.hidden ? (openBlock(), createBlock(_component_CollapseTransition, {
    key: 0,
    "fade-effect": "",
    onAfterLeave: _ctx.handleAfterLeave
  }, {
    default: withCtx(() => [
      !_ctx.closed ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.className),
        role: "alert"
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("wrapper"))
        }, [
          _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("title"))
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 2)) : createCommentVNode("", true),
          createBaseVNode("div", {
            ref: "content",
            class: normalizeClass([_ctx.nh.be("content"), _ctx.props.scroll && _ctx.nh.bem("content", "scroll")])
          }, [
            _ctx.props.scroll ? (openBlock(), createElementBlock("span", {
              key: 0,
              ref: "scrollEl",
              class: normalizeClass(_ctx.nh.be("scroll")),
              style: normalizeStyle(_ctx.scrollStyle),
              onTransitionend: _cache[0] || (_cache[0] = (...args) => _ctx.handleScrollEnd && _ctx.handleScrollEnd(...args))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 38)) : renderSlot(_ctx.$slots, "default", { key: 1 })
          ], 2)
        ], 2),
        _ctx.props.closable ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("close")),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
        }, [
          renderSlot(_ctx.$slots, "close", {}, () => [
            createVNode(_component_Icon, { label: "close" }, {
              default: withCtx(() => [
                createVNode(_component_Xmark)
              ]),
              _: 1
            })
          ])
        ], 2)) : createCommentVNode("", true),
        _ctx.hasIcon ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("icon"))
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_Icon, {
              icon: _ctx.iconComp,
              scale: _ctx.hasTitle ? 2 : 1,
              style: normalizeStyle({ color: _ctx.props.iconColor })
            }, null, 8, ["icon", "scale", "style"])
          ])
        ], 2)) : createCommentVNode("", true)
      ], 2)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["onAfterLeave"])) : createCommentVNode("", true);
}
var Alert = _export_sfc(_sfc_main, [["render", _sfc_render]]);

// node_modules/vexip-ui/es/components/anchor/symbol.mjs
var baseIndentWidth = 14;
var LINK_STATE = Symbol("ANCHOR_LINK_STATE");
var ANCHOR_STATE = Symbol("ANCHOR_STATE");

// node_modules/vexip-ui/es/components/anchor/anchor-link.mjs
var _sfc_main2 = defineComponent({
  name: "AnchorLink",
  props: {
    to: {
      type: String,
      default: ""
    },
    title: {
      type: String,
      default: ""
    },
    children: {
      type: Array,
      default: () => []
    }
  },
  setup(props) {
    const anchorState = inject(ANCHOR_STATE, null);
    const parentLinkState = inject(LINK_STATE, null);
    const nh = useNameHelper("anchor");
    const indent = ref((parentLinkState == null ? void 0 : parentLinkState.indent) ? (parentLinkState == null ? void 0 : parentLinkState.indent) + 1 : 1);
    const active = ref(false);
    const link = ref();
    const state = reactive({
      el: link,
      to: toRef(props, "to"),
      active,
      indent
    });
    const linkClass = computed(() => {
      return {
        [nh.be("link")]: true,
        [nh.bem("link", "active")]: state.active
      };
    });
    const linkStyle = computed(() => {
      return {
        paddingLeft: `${baseIndentWidth * indent.value}px`
      };
    });
    provide(LINK_STATE, state);
    if (anchorState) {
      watch(
        () => anchorState.currentActive,
        (value) => {
          active.value = value === props.to;
        }
      );
      onMounted(() => {
        anchorState.increaseLink(state);
      });
      onBeforeUnmount(() => {
        anchorState.decreaseLink(state);
      });
    }
    function handleSelect() {
      if (anchorState) {
        anchorState.handleActive(props.to);
      }
    }
    return {
      nh,
      linkClass,
      linkStyle,
      link,
      handleSelect
    };
  }
});
var _hoisted_1 = ["href", "title"];
function _sfc_render2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AnchorLink = resolveComponent("AnchorLink", true);
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.nh.be("item"))
  }, [
    createBaseVNode("a", {
      ref: "link",
      class: normalizeClass(_ctx.linkClass),
      href: _ctx.to,
      style: normalizeStyle(_ctx.linkStyle),
      title: _ctx.title,
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleSelect && _ctx.handleSelect(...args), ["prevent"]))
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 14, _hoisted_1),
    _ctx.$slots.group || _ctx.children && _ctx.children.length ? (openBlock(), createElementBlock("ul", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      renderSlot(_ctx.$slots, "group", {}, () => [
        _ctx.children && _ctx.children.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.children, (child) => {
          return openBlock(), createBlock(_component_AnchorLink, {
            key: child.to,
            to: child.to,
            title: child.title,
            children: child.children
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(child.label), 1)
            ]),
            _: 2
          }, 1032, ["to", "title", "children"]);
        }), 128)) : createCommentVNode("", true)
      ])
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
var AnchorLink = _export_sfc(_sfc_main2, [["render", _sfc_render2]]);

// node_modules/vexip-ui/es/components/anchor/props.mjs
var anchorProps = buildProps({
  active: String,
  viewer: [String, Object, Function],
  offset: Number,
  marker: booleanProp,
  scrollDuration: Number,
  markerTransition: String,
  options: Array,
  bindHash: booleanProp,
  forceActive: booleanProp,
  onChange: eventProp()
});

// node_modules/vexip-ui/es/components/anchor/helper.mjs
function animateScrollTo(el, from, to, duration, callback) {
  const distance = to - from;
  const step = Math.ceil(distance / duration * 16);
  if (!distance)
    return;
  if (duration <= 0) {
    el.scrollTo(0, to);
    return;
  }
  let current = from;
  const scroll = () => {
    if (!distance)
      return;
    current = current + step;
    if ((to - current) / distance <= 0) {
      current = to;
    }
    el.scrollTo(0, current);
    if (current === to) {
      typeof callback === "function" && callback();
    } else {
      requestAnimationFrame(scroll);
    }
  };
  scroll();
}

// node_modules/vexip-ui/es/components/anchor/anchor.mjs
var _sfc_main3 = defineComponent({
  name: "Anchor",
  components: {
    AnchorLink
  },
  props: anchorProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const nh = useNameHelper("anchor");
    const props = useProps("anchor", _props, {
      active: {
        default: "",
        static: true
      },
      viewer: {
        default: null,
        static: true
      },
      offset: 8,
      marker: false,
      scrollDuration: 500,
      markerTransition: () => nh.ns("fade"),
      options: {
        default: () => [],
        static: true
      },
      bindHash: false,
      forceActive: false
    });
    const currentActive = ref(props.active);
    const animating = ref(false);
    const markerTop = ref(0);
    const linkStates = /* @__PURE__ */ new Set();
    const wrapper = ref();
    let timer2;
    let isRawViewer = false;
    let container = null;
    let scroller = null;
    if (V && !currentActive.value && props.bindHash) {
      currentActive.value = decodeURIComponent(location.hash);
    }
    provide(
      ANCHOR_STATE,
      reactive({
        currentActive,
        increaseLink,
        decreaseLink,
        handleActive
      })
    );
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    watch(currentActive, (value) => {
      emitEvent(props.onChange, value);
      emit("update:active", value);
    });
    watch(() => props.viewer, updateContainer);
    onMounted(() => {
      updateContainer();
      computeMarkerPoisiton();
    });
    onBeforeUnmount(() => {
      removeListener();
      clearTimeout(timer2);
    });
    function increaseLink(state) {
      linkStates.add(state);
      state.active = currentActive.value === state.to;
    }
    function decreaseLink(state) {
      linkStates.delete(state);
    }
    const instance = getCurrentInstance();
    function updateContainer() {
      removeListener();
      nextTick(() => {
        var _a, _b, _c, _d;
        const viewer = props.viewer;
        let _container = null;
        let refName = "scroll";
        if (typeof viewer === "string") {
          if (viewer.startsWith("ref:")) {
            refName = viewer.substring(4);
            refName = refName || "scroll";
          } else if (["window", "document", "body"].includes(viewer)) {
            _container = document.body;
          } else if (viewer === "root") {
            _container = instance.root;
          } else {
            _container = document.querySelector(viewer);
          }
        } else if (typeof viewer === "function") {
          _container = viewer();
        } else if (sn(viewer)) {
          _container = viewer;
        }
        if (sn(_container)) {
          isRawViewer = true;
        } else {
          isRawViewer = false;
        }
        if (!isRawViewer) {
          _container = _container;
          _container = isVNode(_container == null ? void 0 : _container.vnode) ? _container : instance.parent;
          while (_container) {
            const name = (_a = _container.type) == null ? void 0 : _a.name;
            if (name === "Scroll" || name === "NativeScroll") {
              scroller = _container.proxy;
              break;
            }
            const refTemp = (_b = _container.refs) == null ? void 0 : _b[refName];
            if (refTemp) {
              if (sn(refTemp)) {
                isRawViewer = true;
                container = refTemp;
              } else {
                scroller = refTemp;
              }
              break;
            }
            _container = _container.parent;
          }
          if (scroller) {
            scroller.addScrollListener(handleContainerScroll);
            container = scroller.$el;
          } else if (!container) {
            isRawViewer = true;
            container = (_d = (_c = instance.parent) == null ? void 0 : _c.proxy) == null ? void 0 : _d.$el;
          }
          if (isRawViewer && container) {
            container.addEventListener("scroll", handleContainerScroll);
          }
        } else {
          container = _container;
          container.addEventListener("scroll", handleContainerScroll);
        }
      });
    }
    function computeCurrentLink(scrollTop) {
      if (!linkStates.size || !container)
        return;
      const containerTop = container.offsetTop;
      const offsetList = [];
      let offset = scrollTop + props.offset;
      if (isRawViewer) {
        offset += containerTop;
      }
      linkStates.forEach((state) => {
        const id2 = state.to;
        if (!id2.startsWith("#"))
          return;
        const element = document.querySelector(id2);
        if (element) {
          offsetList.push({
            link: id2,
            offset: element.offsetTop
          });
        }
      });
      offsetList.sort((prev, next) => prev.offset - next.offset);
      offsetList.push({
        link: "",
        offset: Infinity
      });
      let currentLink = "";
      for (let i = 0, len = offsetList.length - 1; i < len; ++i) {
        const current = offsetList[i];
        const next = offsetList[i + 1];
        if (current.offset <= offset && next.offset > offset) {
          currentLink = current.link;
          break;
        }
      }
      currentActive.value = currentLink;
    }
    function handleContainerScroll(event) {
      if (animating.value)
        return;
      const scrollTop = isRawViewer ? event.target.scrollTop : event.clientY;
      computeCurrentLink(scrollTop);
      computeMarkerPoisiton();
    }
    function removeListener() {
      if (scroller) {
        scroller.removeScrollListener(handleContainerScroll);
        scroller = null;
      }
      if (container) {
        container.removeEventListener("scroll", handleContainerScroll);
      }
    }
    function handleActive(link) {
      if (!props.forceActive && link === currentActive.value || !link.startsWith("#") || link.length < 2) {
        return;
      }
      const element = document.querySelector(link);
      if (!element)
        return;
      clearTimeout(timer2);
      animating.value = true;
      const elementTop = element.offsetTop;
      const duration = Math.max(props.scrollDuration, 0);
      if (isRawViewer && container) {
        const from = container.scrollTop;
        const to = Math.min(
          elementTop - container.offsetTop - props.offset,
          container.scrollHeight - container.offsetHeight
        );
        animateScrollTo(container, from, to, duration, () => {
          timer2 = setTimeout(() => {
            animating.value = false;
          }, 10);
        });
        computeCurrentLink(to);
        computeMarkerPoisiton();
      } else if (scroller) {
        const [min, max] = scroller.getYScrollLimit();
        const clientY = Math.max(Math.min(elementTop - props.offset, max), min);
        scroller.scrollTo(0, clientY, duration);
        timer2 = setTimeout(() => {
          animating.value = false;
        }, duration + 10);
        computeCurrentLink(clientY);
        computeMarkerPoisiton();
      } else {
        animating.value = false;
      }
      if (V && props.bindHash && location) {
        location.hash = encodeURIComponent(currentActive.value.replace(/^#/, ""));
      }
    }
    function computeMarkerPoisiton() {
      var _a, _b;
      const currentLink = Array.from(linkStates).find(
        (state) => state.to && state.to === currentActive.value
      );
      if (currentLink == null ? void 0 : currentLink.el) {
        const linkRect = currentLink.el.getBoundingClientRect();
        const wrapperTop = (_b = (_a = wrapper.value) == null ? void 0 : _a.getBoundingClientRect().top) != null ? _b : 0;
        markerTop.value = linkRect.top - wrapperTop + linkRect.height / 2 + 0.5;
      }
    }
    return {
      props,
      nh,
      currentActive,
      markerTop,
      wrapper
    };
  }
});
function _sfc_render3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AnchorLink = resolveComponent("AnchorLink");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass({
      [_ctx.nh.b()]: true,
      [_ctx.nh.bs("vars")]: true,
      [_ctx.nh.bm("inherit")]: _ctx.props.inherit,
      [_ctx.nh.bm("no-marker")]: !_ctx.props.marker
    })
  }, [
    createBaseVNode("ul", {
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.options, (link) => {
          return openBlock(), createBlock(_component_AnchorLink, {
            key: link.to,
            to: link.to,
            title: link.title,
            children: link.children
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(link.label), 1)
            ]),
            _: 2
          }, 1032, ["to", "title", "children"]);
        }), 128))
      ])
    ], 2),
    createVNode(Transition, {
      appear: "",
      name: _ctx.props.markerTransition
    }, {
      default: withCtx(() => [
        _ctx.props.marker && _ctx.currentActive ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("marker")),
          style: normalizeStyle({ top: `${_ctx.markerTop}px` })
        }, [
          renderSlot(_ctx.$slots, "marker", {}, () => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.nh.be("pointer"))
            }, null, 2)
          ])
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["name"])
  ], 2);
}
var Anchor = _export_sfc(_sfc_main3, [["render", _sfc_render3]]);

// node_modules/vexip-ui/es/components/option/option.mjs
var _sfc_main4 = defineComponent({
  name: "Option",
  props: {
    value: {
      type: [String, Number],
      default: null
    },
    label: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    divided: {
      type: Boolean,
      default: false
    },
    noTitle: {
      type: Boolean,
      default: false
    },
    hitting: {
      type: Boolean,
      default: false
    },
    noHover: {
      type: Boolean,
      default: false
    },
    selected: {
      type: Boolean,
      default: false
    },
    onSelect: eventProp()
  },
  emits: [],
  setup(props) {
    const nh = useNameHelper("option");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("selected")]: !props.disabled && props.selected,
        [nh.bm("divided")]: props.divided,
        [nh.bm("hitting")]: props.hitting,
        [nh.bm("no-hover")]: props.noHover
      };
    });
    function handleSelect() {
      if (props.disabled)
        return;
      emitEvent(props.onSelect);
    }
    return {
      className,
      handleSelect
    };
  }
});
var _hoisted_12 = ["title", "aria-disabled", "aria-selected"];
function _sfc_render4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    title: _ctx.noTitle ? void 0 : String(_ctx.value),
    role: "option",
    "aria-disabled": _ctx.disabled ? "true" : void 0,
    "aria-selected": _ctx.selected,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleSelect && _ctx.handleSelect(...args))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createTextVNode(toDisplayString(_ctx.label || _ctx.value), 1)
    ])
  ], 10, _hoisted_12);
}
var Option = _export_sfc(_sfc_main4, [["render", _sfc_render4]]);

// node_modules/vexip-ui/es/components/tag/props.mjs
var tagProps = buildProps({
  size: sizeProp,
  type: String,
  border: booleanProp,
  closable: booleanProp,
  color: String,
  simple: booleanProp,
  circle: booleanProp,
  onClose: eventProp()
});

// node_modules/vexip-ui/es/components/tag/tag.mjs
var tagTypes = Object.freeze([
  "default",
  "primary",
  "info",
  "success",
  "error",
  "warning",
  "lime",
  "pink",
  "magenta",
  "tomato",
  "orange",
  "cyan",
  "navy",
  "gold",
  "purple"
]);
var _sfc_main5 = defineComponent({
  name: "Tag",
  components: {
    Icon,
    Xmark: L2
  },
  props: tagProps,
  emits: [],
  setup(_props) {
    const props = useProps("tag", _props, {
      size: createSizeProp(),
      type: {
        default: "default",
        validator: (value) => tagTypes.includes(value)
      },
      border: false,
      closable: false,
      simple: false,
      circle: false
    });
    const nh = useNameHelper("tag");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.size)]: props.size !== "default",
        [nh.bm(props.type)]: props.type !== "default",
        [nh.bm("border")]: props.border,
        [nh.bm("simple")]: props.simple,
        [nh.bm("circle")]: props.circle
      };
    });
    const style = computed(() => {
      if (props.color) {
        const baseColor = N(props.color);
        const base = baseColor.toString();
        return nh.cvm({
          color: "var(--vxp-color-white)",
          "bg-color": base,
          "b-color": base,
          "close-color": "var(--vxp-color-white)",
          ...props.simple || props.border ? {
            color: base,
            "close-color": base
          } : {},
          ...props.simple ? {
            "bg-color": yn(baseColor, 0.2).toString()
          } : {}
        });
      }
      return {};
    });
    function handleClose() {
      if (props.closable) {
        emitEvent(props.onClose);
      }
    }
    return {
      props,
      nh,
      className,
      style,
      handleClose
    };
  }
});
function _sfc_render5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.style)
  }, [
    createBaseVNode("span", null, [
      renderSlot(_ctx.$slots, "default")
    ]),
    _ctx.props.closable ? (openBlock(), createElementBlock("button", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("close")),
      onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClose && _ctx.handleClose(...args), ["left", "stop"]))
    }, [
      createVNode(_component_Icon, { label: "close" }, {
        default: withCtx(() => [
          createVNode(_component_Xmark)
        ]),
        _: 1
      })
    ], 2)) : createCommentVNode("", true)
  ], 6);
}
var Tag = _export_sfc(_sfc_main5, [["render", _sfc_render5]]);

// node_modules/vexip-ui/es/components/scrollbar/props.mjs
var scrollbarProps = buildProps({
  placement: String,
  scroll: Number,
  barLength: Number,
  width: Number,
  appear: booleanProp,
  fade: Number,
  barColor: String,
  trackColor: String,
  disabled: booleanProp,
  wrapper: [String, Object],
  duration: Number,
  useTrack: booleanProp,
  trackSpeed: Number,
  onScrollStart: eventProp(),
  onScroll: eventProp(),
  onScrollEnd: eventProp()
});

// node_modules/vexip-ui/es/components/scrollbar/symbol.mjs
var ScrollbarType = ((ScrollbarType2) => {
  ScrollbarType2[ScrollbarType2["HORIZONTAL"] = 0] = "HORIZONTAL";
  ScrollbarType2[ScrollbarType2["VERTICAL"] = 1] = "VERTICAL";
  return ScrollbarType2;
})(ScrollbarType || {});

// node_modules/vexip-ui/es/components/scrollbar/hooks.mjs
function useTrack({
  currentScroll = ref(0),
  trackSpeed = ref(2),
  track = ref(null),
  bar = ref(null),
  tracking = ref(false),
  type = ref(ScrollbarType.VERTICAL),
  barLength = ref(35),
  disabled = ref(false),
  handleDown = cn,
  handleMove = cn,
  handleUp = cn,
  handleScroll = cn
}) {
  let length;
  let startAt;
  let cursorAt;
  let targetScroll;
  let forward = true;
  let processing = false;
  function animateMoveBar() {
    if (!tracking.value)
      return;
    processing = true;
    const speedRate = computeSpeedRate(targetScroll, currentScroll.value);
    let changed = false;
    if (forward) {
      if (currentScroll.value < targetScroll) {
        currentScroll.value += speedRate * trackSpeed.value;
        changed = true;
      }
    } else if (currentScroll.value > targetScroll) {
      currentScroll.value -= speedRate * trackSpeed.value;
      changed = true;
    }
    if (changed) {
      verifyScroll();
      handleScroll(currentScroll.value);
    }
    if (tracking.value && forward ? currentScroll.value < targetScroll : currentScroll.value > targetScroll) {
      requestAnimationFrame(animateMoveBar);
    } else {
      processing = false;
    }
  }
  function handleMouseDown(event) {
    if (disabled.value || event.button > 0) {
      return false;
    }
    event.stopPropagation();
    event.preventDefault();
    if (!track.value || !bar.value)
      return false;
    document.addEventListener("pointermove", handleMouseMove);
    document.addEventListener("pointerup", handleMouseUp);
    const rect = track.value.getBoundingClientRect();
    const barRect = bar.value.getBoundingClientRect();
    let position;
    if (type.value === ScrollbarType.VERTICAL) {
      length = rect.height;
      startAt = barRect.top - rect.top;
      cursorAt = barRect.top;
      position = startAt + event.clientY - cursorAt;
    } else {
      length = rect.width;
      startAt = barRect.left - rect.left;
      cursorAt = barRect.left;
      position = startAt + event.clientX - cursorAt;
    }
    targetScroll = Math.max(
      0,
      Math.min(position / length / (100 - barLength.value / 2) * 1e4, 100)
    );
    forward = targetScroll >= currentScroll.value;
    tracking.value = true;
    handleDown(currentScroll.value);
    animateMoveBar();
  }
  const handleTrackMove = br((event) => {
    let position;
    if (type.value === ScrollbarType.VERTICAL) {
      position = startAt + event.clientY - cursorAt;
    } else {
      position = startAt + event.clientX - cursorAt;
    }
    targetScroll = Math.max(
      0,
      Math.min(position / length / (100 - barLength.value / 2) * 1e4, 100)
    );
    !processing && animateMoveBar();
  });
  function handleMouseMove(event) {
    event.stopPropagation();
    if (!Fe) {
      event.preventDefault();
    }
    handleMove(currentScroll.value);
    handleTrackMove(event);
  }
  function handleMouseUp(event) {
    event.preventDefault();
    document.removeEventListener("pointermove", handleMouseMove);
    document.removeEventListener("pointerup", handleMouseUp);
    tracking.value = false;
    handleUp(currentScroll.value);
  }
  function verifyScroll() {
    currentScroll.value = Math.max(0, Math.min(currentScroll.value, 100));
  }
  return {
    trackSpeed,
    track,
    bar,
    tracking,
    barLength,
    disabled,
    handleMouseDown
  };
}
function computeSpeedRate(start, end) {
  const span = Math.abs(start - end);
  for (let i = 0; i < 5; ++i) {
    if (span < (i + 1) * 20) {
      return 1 + 0.25 * i;
    }
  }
  return 2;
}

// node_modules/vexip-ui/es/components/scrollbar/scrollbar.mjs
var scrollbarPlacements = Object.freeze(["top", "right", "bottom", "left"]);
var _sfc_main6 = defineComponent({
  name: "Scrollbar",
  props: scrollbarProps,
  emits: [],
  setup(_props) {
    const props = useProps("scrollbar", _props, {
      placement: {
        default: "right",
        validator: (value) => scrollbarPlacements.includes(value)
      },
      scroll: {
        default: 0,
        validator: (value) => value >= 0 && value <= 100,
        static: true
      },
      barLength: {
        default: 35,
        validator: (value) => value > 0 && value < 100
      },
      width: null,
      appear: false,
      fade: 1500,
      barColor: null,
      trackColor: null,
      disabled: false,
      wrapper: null,
      duration: null,
      useTrack: false,
      trackSpeed: {
        default: 2,
        validator: (value) => value > 0 && value < 10
      }
    });
    const nh = useNameHelper("scrollbar");
    const active = ref(false);
    const currentScroll = ref(props.scroll);
    const scrolling = ref(false);
    const contaniner = ref();
    const bar = ref();
    const track = ref();
    let fadeTimer;
    const type = computed(() => {
      return props.placement === "right" || props.placement === "left" ? ScrollbarType.VERTICAL : ScrollbarType.HORIZONTAL;
    });
    const { tracking, handleMouseDown: handleTrackMouseDown } = useTrack({
      currentScroll,
      track,
      bar,
      type,
      trackSpeed: toRef(props, "trackSpeed"),
      barLength: toRef(props, "barLength"),
      disabled: toRef(props, "disabled"),
      handleDown: (scroll) => {
        clearTimeout(fadeTimer);
        emitEvent(props.onScrollStart, scroll);
      },
      handleMove: () => clearTimeout(fadeTimer),
      handleUp: (scroll) => {
        setScrollbarFade();
        emitEvent(props.onScrollEnd, scroll);
      },
      handleScroll: (scroll) => {
        emitEvent(props.onScroll, scroll);
      }
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(props.placement),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("fade")]: props.fade,
          [nh.bm("scrolling")]: scrolling.value,
          [nh.bm("tracking")]: tracking.value,
          [nh.bm("active")]: active.value,
          [nh.bm("disabled")]: props.disabled
        }
      ];
    });
    const style = computed(() => {
      return {
        [nh.cv("bar-bg-color")]: props.barColor,
        [nh.cv("track-bg-color")]: props.trackColor,
        [nh.cv("width")]: props.width ? `${props.width}px` : null
      };
    });
    const barStyle = computed(() => {
      const style2 = {};
      const position = `${(100 - props.barLength) * currentScroll.value / props.barLength}%`;
      const length2 = `${props.barLength}%`;
      if (type.value === ScrollbarType.VERTICAL) {
        style2.height = length2;
        style2.transform = `translate3d(0, ${position}, 0)`;
      } else {
        style2.width = length2;
        style2.transform = `translate3d(${position}, 0, 0)`;
      }
      if (y(props.duration) && props.duration >= 0) {
        style2.transitionDuration = `${props.duration}ms`;
      }
      return style2;
    });
    watch(
      () => props.scroll,
      (value) => {
        currentScroll.value = value;
      }
    );
    if (props.appear) {
      watch(currentScroll, () => {
        clearInterval(fadeTimer);
        active.value = true;
        if (!scrolling.value && !tracking.value) {
          setScrollbarFade();
        }
      });
    }
    const handleWrapperMouseMove = br(() => {
      clearTimeout(fadeTimer);
      if (props.disabled) {
        active.value = false;
      } else {
        active.value = true;
        if (!scrolling.value && !tracking.value) {
          setScrollbarFade();
        }
      }
    });
    let wrapperElement;
    onMounted(() => {
      let instance = getCurrentInstance();
      nextTick(() => {
        var _a, _b, _c, _d, _e2;
        if (typeof props.wrapper === "string") {
          wrapperElement = document.querySelector(props.wrapper);
        } else {
          wrapperElement = props.wrapper;
        }
        if (!wrapperElement) {
          if (instance == null ? void 0 : instance.parent) {
            wrapperElement = (_a = instance.parent.proxy) == null ? void 0 : _a.$el;
            if (!wrapperElement) {
              wrapperElement = (_c = (_b = contaniner.value) == null ? void 0 : _b.parentElement) != null ? _c : null;
            }
          } else {
            wrapperElement = (_e2 = (_d = contaniner.value) == null ? void 0 : _d.parentElement) != null ? _e2 : null;
          }
        }
        if (wrapperElement && props.fade >= 300) {
          wrapperElement.addEventListener("mousemove", handleWrapperMouseMove);
        }
        instance = null;
        if (!props.appear) {
          watch(currentScroll, () => {
            clearInterval(fadeTimer);
            active.value = true;
            setScrollbarFade();
          });
        }
      });
    });
    onBeforeUnmount(() => {
      if (wrapperElement) {
        wrapperElement.removeEventListener("mousemove", handleWrapperMouseMove);
      }
      wrapperElement = null;
      clearTimeout(fadeTimer);
    });
    let length;
    let startAt;
    let cursorAt;
    function handleMouseDown(event) {
      if (event.button !== 0 || props.disabled) {
        return false;
      }
      event.stopPropagation();
      event.preventDefault();
      if (!track.value || !bar.value)
        return false;
      document.addEventListener("pointermove", handleMouseMove);
      document.addEventListener("pointerup", handleMouseUp);
      const rect = track.value.getBoundingClientRect();
      const barRect = bar.value.getBoundingClientRect();
      if (type.value === ScrollbarType.VERTICAL) {
        length = rect.height;
        startAt = barRect.top - rect.top;
        cursorAt = event.clientY;
      } else {
        length = rect.width;
        startAt = barRect.left - rect.left;
        cursorAt = event.clientX;
      }
      clearTimeout(fadeTimer);
      scrolling.value = true;
      emitEvent(props.onScrollStart, currentScroll.value);
    }
    const handleBarMove = br((event) => {
      let position;
      if (type.value === ScrollbarType.VERTICAL) {
        position = startAt + event.clientY - cursorAt;
      } else {
        position = startAt + event.clientX - cursorAt;
      }
      currentScroll.value = position / length / (100 - props.barLength) * 1e4;
      verifyScroll();
      emitEvent(props.onScroll, currentScroll.value);
    });
    function handleMouseMove(event) {
      event.stopPropagation();
      if (!Fe) {
        event.preventDefault();
      }
      clearTimeout(fadeTimer);
      handleBarMove(event);
    }
    function handleMouseUp(event) {
      event.preventDefault();
      document.removeEventListener("pointermove", handleMouseMove);
      document.removeEventListener("pointerup", handleMouseUp);
      setScrollbarFade();
      scrolling.value = false;
      emitEvent(props.onScrollEnd, currentScroll.value);
    }
    function verifyScroll() {
      currentScroll.value = Math.max(0, Math.min(currentScroll.value, 100));
    }
    function setScrollbarFade() {
      if (props.fade >= 300) {
        fadeTimer = setTimeout(() => {
          active.value = false;
        }, props.fade);
      }
    }
    function handleScroll(scroll) {
      currentScroll.value = Fn(scroll, 0, 100);
    }
    function disableEvent(event) {
      if (event.cancelable) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
    return {
      props,
      nh,
      currentScroll,
      className,
      style,
      barStyle,
      contaniner,
      bar,
      track,
      handleMouseDown,
      handleTrackMouseDown,
      handleScroll,
      disableEvent
    };
  }
});
function _sfc_render6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "contaniner",
    class: normalizeClass(_ctx.className),
    role: "scrollbar",
    style: normalizeStyle(_ctx.style)
  }, [
    createBaseVNode("div", {
      ref: "track",
      class: normalizeClass([_ctx.nh.be("track"), _ctx.props.useTrack ? null : _ctx.nh.bem("track", "disabled")]),
      onTouchstart: _cache[0] || (_cache[0] = (...args) => _ctx.disableEvent && _ctx.disableEvent(...args)),
      onPointerdown: _cache[1] || (_cache[1] = (...args) => _ctx.handleTrackMouseDown && _ctx.handleTrackMouseDown(...args))
    }, null, 34),
    createBaseVNode("div", {
      ref: "bar",
      class: normalizeClass(_ctx.nh.be("bar")),
      style: normalizeStyle(_ctx.barStyle),
      onTouchstart: _cache[2] || (_cache[2] = (...args) => _ctx.disableEvent && _ctx.disableEvent(...args)),
      onPointerdown: _cache[3] || (_cache[3] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args))
    }, null, 38)
  ], 6);
}
var Scrollbar = _export_sfc(_sfc_main6, [["render", _sfc_render6]]);

// node_modules/vexip-ui/es/components/resize-observer/props.mjs
var resizeObserverProps = buildProps({
  throttle: booleanNumberProp,
  onResize: eventProp()
});

// node_modules/vexip-ui/es/components/resize-observer/resize-observer.mjs
var ResizeObserver = defineComponent({
  name: "ResizeObserver",
  props: resizeObserverProps,
  setup(_props, { slots }) {
    const props = useProps("resizeObserver", _props, {
      throttle: {
        default: false,
        validator: (value) => typeof value === "boolean" || value > 0
      }
    });
    const { observeResize, unobserveResize } = Ho();
    let observed = false;
    function handleResize(entry) {
      emitEvent(props.onResize, entry);
    }
    const throttleResize = props.throttle ? br(handleResize, typeof props.throttle === "boolean" ? 16 : props.throttle) : handleResize;
    onMounted(() => {
      var _a, _b;
      const el = (_b = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy) == null ? void 0 : _b.$el;
      if (el == null ? void 0 : el.nextElementSibling) {
        if (el.nextElementSibling !== el.nextSibling && el.nodeType === 3 && el.nodeValue !== "") {
          return;
        }
        observeResize(el.nextElementSibling, throttleResize);
        observed = true;
      }
    });
    onBeforeUnmount(() => {
      var _a, _b;
      if (observed) {
        const el = (_b = (_a = getCurrentInstance()) == null ? void 0 : _a.proxy) == null ? void 0 : _b.$el;
        if (el == null ? void 0 : el.nextElementSibling) {
          unobserveResize(el.nextElementSibling);
        }
      }
    });
    return () => renderSlot(slots, "default");
  }
});

// node_modules/vexip-ui/es/components/native-scroll/props.mjs
var nativeScrollProps = buildProps({
  scrollClass: classProp,
  scrollStyle: styleProp,
  mode: String,
  width: [Number, String],
  height: [Number, String],
  disabled: booleanProp,
  pointer: booleanProp,
  scrollX: Number,
  scrollY: Number,
  useXBar: booleanProp,
  useYBar: booleanProp,
  barFade: Number,
  barClass: classProp,
  autoplay: booleanNumberProp,
  playWaiting: Number,
  onBeforeScroll: Function,
  appear: booleanProp,
  barDuration: Number,
  useBarTrack: booleanProp,
  wrapperTag: String,
  onResize: eventProp(),
  onXEnabledChange: eventProp(),
  onYEnabledChange: eventProp(),
  onWheel: eventProp(),
  onScrollStart: eventProp(),
  onScroll: eventProp(),
  onScrollEnd: eventProp(),
  onBarScrollStart: eventProp(),
  onBarScroll: eventProp(),
  onBarScrollEnd: eventProp()
});

// node_modules/vexip-ui/es/components/native-scroll/helper.mjs
function animateScrollTo2(options) {
  const { el, xFrom = 0, xTo = 0, yFrom = 0, yTo = 0, duration = 500, callback = null } = options;
  if (!el)
    return;
  const xDistance = xTo - xFrom;
  const yDistance = yTo - yFrom;
  if (!xDistance && !yDistance)
    return;
  const xStep = Math.ceil(xDistance / duration * 16);
  const yStep = Math.ceil(yDistance / duration * 16);
  let currentX = xFrom;
  let currentY = yFrom;
  const scroll = () => {
    currentX += xStep;
    currentY += yStep;
    if (xDistance && (xTo - currentX) / xDistance <= 0) {
      currentX = xTo;
    }
    if (yDistance && (yTo - currentY) / yDistance <= 0) {
      currentY = yTo;
    }
    el.scrollTo(currentX, currentY);
    if ((!xDistance || currentX === xTo) && (!yDistance || currentY === yTo)) {
      typeof callback === "function" && callback();
    } else {
      requestAnimationFrame(scroll);
    }
  };
  scroll();
}

// node_modules/vexip-ui/es/components/native-scroll/hooks.mjs
function useScrollWrapper({
  mode,
  disabled,
  appear,
  scrollX,
  scrollY,
  onResize,
  onBeforeRefresh,
  onAfterRefresh
}) {
  const contentElement = ref();
  const content = reactive({
    el: contentElement,
    scrollWidth: 0,
    offsetWidth: 0,
    scrollHeight: 0,
    offsetHeight: 0
  });
  const xScrollLimit = computed(() => {
    return content.el ? content.scrollWidth - content.offsetWidth : 0;
  });
  const yScrollLimit = computed(() => {
    return content.el ? content.scrollHeight - content.offsetHeight : 0;
  });
  const enableXScroll = computed(() => {
    return !disabled.value && mode.value !== "vertical" && !!content.el && content.scrollWidth > content.offsetWidth;
  });
  const enableYScroll = computed(() => {
    return !disabled.value && mode.value !== "horizontal" && !!content.el && content.scrollHeight > content.offsetHeight;
  });
  const xBarLength = computed(() => {
    if (content.el) {
      return Fn(content.offsetWidth / (content.scrollWidth || 1) * 100, 5, 99);
    }
    return 35;
  });
  const yBarLength = computed(() => {
    if (content.el) {
      return Fn(content.offsetHeight / (content.scrollHeight || 1) * 100, 5, 99);
    }
    return 35;
  });
  watch(contentElement, () => {
    computeContentSize();
  });
  watch(scrollX, (value) => {
    setScrollX(value);
  });
  watch(scrollY, (value) => {
    setScrollY(value);
  });
  const currentScroll = reactive({
    x: 0,
    y: 0
  });
  function setScrollX(value) {
    currentScroll.x = Fn(value, 0, xScrollLimit.value);
    if (content.el) {
      content.el.scrollLeft = currentScroll.x;
    }
  }
  function setScrollY(value) {
    currentScroll.y = Fn(value, 0, yScrollLimit.value);
    if (content.el) {
      content.el.scrollTop = currentScroll.y;
    }
  }
  const percentX = ref(0);
  const percentY = ref(0);
  const { isMounted } = Io();
  function computeContentSize() {
    if (!content.el || Dt(content.el))
      return;
    content.scrollWidth = content.el.scrollWidth;
    content.offsetWidth = content.el.offsetWidth;
    content.scrollHeight = content.el.scrollHeight;
    content.offsetHeight = content.el.offsetHeight;
    if (mode.value !== "vertical") {
      setScrollX(!isMounted.value && appear.value ? scrollX.value : currentScroll.x || 0);
    }
    if (mode.value !== "horizontal") {
      setScrollY(!isMounted.value && appear.value ? scrollY.value : currentScroll.y || 0);
    }
    computePercent();
  }
  function computePercent() {
    if (content.el) {
      percentX.value = An(currentScroll.x / (xScrollLimit.value || 1), 100, 2);
      percentY.value = An(currentScroll.y / (yScrollLimit.value || 1), 100, 2);
    }
  }
  function handleResize(entity) {
    refresh();
    onResize == null ? void 0 : onResize(entity);
  }
  onMounted(() => {
    refresh();
    if (appear.value) {
      scrollTo(scrollX.value, scrollY.value);
    }
  });
  function refresh() {
    if (typeof onBeforeRefresh === "function") {
      onBeforeRefresh();
    }
    computeContentSize();
    setTimeout(() => {
      if (typeof onAfterRefresh === "function") {
        onAfterRefresh();
      }
    }, 0);
  }
  function scrollTo(clientX, clientY, duration) {
    return new Promise((resolve) => {
      if (!content.el)
        return;
      if (!enableXScroll.value || Math.abs(currentScroll.x - clientX) < 0.01) {
        clientX = currentScroll.x;
      }
      if (!enableYScroll.value || Math.abs(currentScroll.y - clientY) < 0.01) {
        clientY = currentScroll.y;
      }
      animateScrollTo2({
        duration,
        el: content.el,
        xFrom: currentScroll.x,
        xTo: Fn(clientX, 0, xScrollLimit.value),
        yFrom: currentScroll.y,
        yTo: Fn(clientY, 0, yScrollLimit.value),
        callback: resolve
      });
    });
  }
  function scrollBy(deltaX, deltaY, duration) {
    return scrollTo(currentScroll.x + deltaX, currentScroll.y + deltaY, duration);
  }
  function scrollToElement(el, duration, offset = 0) {
    if (!content.el)
      return Promise.resolve();
    if (typeof el === "string") {
      el = content.el.querySelector(el);
    }
    if (!sn(el))
      return Promise.resolve();
    const wrapperRect = content.el.getBoundingClientRect();
    const elRect = el.getBoundingClientRect();
    let clientX = 0;
    let clientY = 0;
    if (mode.value !== "vertical") {
      clientX = elRect.left - wrapperRect.left + offset;
    }
    if (mode.value !== "horizontal") {
      clientY = elRect.top - wrapperRect.top + offset;
    }
    return scrollTo(clientX, clientY, duration);
  }
  return {
    contentElement,
    currentScroll,
    percentX,
    percentY,
    xScrollLimit,
    yScrollLimit,
    enableXScroll,
    enableYScroll,
    xBarLength,
    yBarLength,
    handleResize,
    setScrollX,
    setScrollY,
    computePercent,
    refresh,
    scrollTo,
    scrollBy,
    scrollToElement
  };
}

// node_modules/vexip-ui/es/components/native-scroll/native-scroll.mjs
var scrollModes = Object.freeze(["horizontal", "vertical", "both"]);
var MOVE_EVENT = "mousemove";
var UP_EVENT = "mouseup";
var _sfc_main7 = defineComponent({
  name: "NativeScroll",
  components: {
    Scrollbar,
    ResizeObserver
  },
  props: nativeScrollProps,
  emits: [],
  setup(_props) {
    const props = useProps("nativeScroll", _props, {
      scrollClass: null,
      scrollStyle: () => ({}),
      mode: {
        default: "vertical",
        validator: (value) => scrollModes.includes(value)
      },
      width: "",
      height: "",
      disabled: false,
      pointer: false,
      scrollX: {
        default: 0,
        static: true
      },
      scrollY: {
        default: 0,
        static: true
      },
      useXBar: false,
      useYBar: false,
      barFade: 1500,
      barClass: null,
      autoplay: false,
      playWaiting: 500,
      onBeforeScroll: {
        default: null,
        isFunc: true
      },
      appear: false,
      barDuration: null,
      useBarTrack: false,
      wrapperTag: "div"
    });
    const emitter = gr();
    const nh = useNameHelper("native-scroll");
    const usingBar = ref(false);
    const scrolling = ref(false);
    const {
      contentElement,
      currentScroll,
      percentX,
      percentY,
      xScrollLimit,
      yScrollLimit,
      enableXScroll,
      enableYScroll,
      xBarLength,
      yBarLength,
      handleResize,
      setScrollX,
      setScrollY,
      computePercent,
      refresh,
      scrollTo,
      scrollBy,
      scrollToElement
    } = useScrollWrapper({
      mode: toRef(props, "mode"),
      disabled: toRef(props, "disabled"),
      appear: toRef(props, "appear"),
      width: toRef(props, "width"),
      height: toRef(props, "height"),
      scrollX: toRef(props, "scrollX"),
      scrollY: toRef(props, "scrollY"),
      onResize: (entry) => {
        emitEvent(props.onResize, entry);
      },
      onBeforeRefresh: stopAutoplay,
      onAfterRefresh: startAutoplay
    });
    const canPlay = ref(false);
    const canAutoplay = computed(() => {
      return props.mode !== "both" && (Ke(props.autoplay) || props.autoplay > 1e3) && (props.mode === "horizontal" && enableXScroll.value || props.mode === "vertical" && enableYScroll.value);
    });
    watch(
      () => props.autoplay,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    watch(
      () => props.playWaiting,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    let playTimer;
    let startTimer;
    let endTimer;
    onBeforeUnmount(stopAutoplay);
    function startAutoplay() {
      if (!canAutoplay.value || !contentElement.value)
        return;
      stopAutoplay();
      const mode = props.mode;
      const distance = mode === "horizontal" ? "offsetWidth" : "offsetHeight";
      const limit = mode === "horizontal" ? xScrollLimit : yScrollLimit;
      const prop = mode === "horizontal" ? "x" : "y";
      const waiting = props.playWaiting < 20 ? 20 : props.playWaiting;
      const setScroll = mode === "horizontal" ? setScrollX : setScrollY;
      let playSpeed = 0.5;
      if (typeof props.autoplay === "number") {
        playSpeed = contentElement.value[distance] / props.autoplay * 16;
      }
      const scroll = () => {
        setScroll(currentScroll[prop] + playSpeed);
        if (currentScroll[prop] >= limit.value) {
          setScroll(limit.value);
          canPlay.value = false;
          computePercent();
          syncBarScroll();
          endTimer = setTimeout(() => {
            scrollTo(0, 0, 500);
            startTimer = setTimeout(() => {
              canPlay.value = true;
              scroll();
            }, 500 + waiting);
          }, waiting);
        } else {
          computePercent();
          syncBarScroll();
          if (canPlay.value) {
            requestAnimationFrame(scroll);
          }
        }
      };
      playTimer = setTimeout(() => {
        canPlay.value = true;
        scroll();
      }, waiting);
    }
    function stopAutoplay() {
      canPlay.value = false;
      clearTimeout(playTimer);
      clearTimeout(startTimer);
      clearTimeout(endTimer);
    }
    const className = computed(() => {
      return [
        nh.b(),
        nh.bm(props.mode),
        {
          [nh.bm("inherit")]: props.inherit
        }
      ];
    });
    const style = computed(() => {
      const { width, height } = props;
      return {
        width: width ? typeof width === "string" ? Number.isNaN(Number(width)) ? width : `${Number(width)}px` : `${width}px` : void 0,
        height: height ? typeof height === "string" ? Number.isNaN(Number(height)) ? height : `${Number(height)}px` : `${height}px` : void 0
      };
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        props.scrollClass,
        {
          [nh.bem("wrapper", "scrolling")]: scrolling.value,
          [nh.bem("wrapper", "using-bar")]: usingBar.value
        }
      ];
    });
    watch(enableXScroll, (value) => {
      emitEvent(props.onXEnabledChange, value);
    });
    watch(enableYScroll, (value) => {
      emitEvent(props.onYEnabledChange, value);
    });
    const xBar = ref();
    const yBar = ref();
    function syncBarScroll() {
      var _a, _b;
      (_a = xBar.value) == null ? void 0 : _a.handleScroll(percentX.value);
      (_b = yBar.value) == null ? void 0 : _b.handleScroll(percentY.value);
    }
    function handleMouseDown(event) {
      if (!props.pointer || event.button !== 0 || Fe) {
        return false;
      }
      handlePointerDown(event);
    }
    let xScrollStartAt = 0;
    let yScrollStartAt = 0;
    let cursorXPosition = 0;
    let cursorYPosition = 0;
    function handlePointerDown(event) {
      if (!enableXScroll.value && !enableYScroll.value) {
        return false;
      }
      event.preventDefault();
      prepareScroll();
      xScrollStartAt = currentScroll.x;
      yScrollStartAt = currentScroll.y;
      cursorXPosition = event.clientX;
      cursorYPosition = event.clientY;
      document.addEventListener(MOVE_EVENT, handlePointerMove);
      document.addEventListener(UP_EVENT, handlePointerUp);
      emitEvent(props.onScrollStart, {
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handlePointerMove(event) {
      var _a;
      event.stopPropagation();
      event.preventDefault();
      const signX = event.clientX - cursorXPosition > 0 ? 1 : -1;
      const signY = event.clientY - cursorYPosition > 0 ? 1 : -1;
      if (((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX, signY })) === false) {
        return false;
      }
      scrolling.value = true;
      if (enableXScroll.value) {
        setScrollX(xScrollStartAt - (event.clientX - cursorXPosition));
      }
      if (enableYScroll.value) {
        setScrollY(yScrollStartAt - (event.clientY - cursorYPosition));
      }
      computePercent();
      syncBarScroll();
      emitScrollEvent(props.mode);
    }
    function handlePointerUp() {
      document.removeEventListener(MOVE_EVENT, handlePointerMove);
      document.removeEventListener(UP_EVENT, handlePointerUp);
      emitEvent(props.onScrollEnd, {
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      startAutoplay();
    }
    function handleWheel(event, type) {
      var _a;
      const isVerticalScroll = enableYScroll.value && type === "vertical";
      const isHorizontalScroll = enableXScroll.value && type === "horizontal";
      const sign = event.deltaY > 0 ? 1 : -1;
      emitEvent(props.onWheel, event, type);
      if ((isVerticalScroll || isHorizontalScroll) && ((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX: sign, signY: sign })) !== false) {
        const maxLimit = isVerticalScroll ? yScrollLimit.value : xScrollLimit.value;
        const scroll = isVerticalScroll ? currentScroll.y : currentScroll.x;
        if (sign > 0 ? scroll < maxLimit : scroll > 0) {
          event.stopPropagation();
          return false;
        }
      }
    }
    function handleScroll(event, type) {
      var _a;
      event.stopPropagation();
      event.preventDefault();
      if (contentElement.value) {
        const signX = contentElement.value.scrollLeft - currentScroll.x > 0 ? 1 : -1;
        const signY = contentElement.value.scrollTop - currentScroll.y > 0 ? 1 : -1;
        if (((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX, signY })) === false) {
          contentElement.value.scrollTop = currentScroll.y;
          contentElement.value.scrollLeft = currentScroll.x;
          return;
        }
        currentScroll.y = contentElement.value.scrollTop;
        currentScroll.x = contentElement.value.scrollLeft;
      }
      computePercent();
      syncBarScroll();
      emitScrollEvent(type);
    }
    function prepareScroll() {
      stopAutoplay();
    }
    function handleBarScrollStart(type) {
      usingBar.value = true;
      emitEvent(props.onBarScrollStart, {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleBarScrollEnd(type) {
      usingBar.value = false;
      emitEvent(props.onBarScrollEnd, {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleXBarScroll(percent) {
      percentX.value = percent;
      setScrollX(percent * xScrollLimit.value / 100);
      emitEvent(props.onBarScroll, {
        type: "horizontal",
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("horizontal");
    }
    function handleYBarScroll(percent) {
      percentY.value = percent;
      setScrollY(percent * yScrollLimit.value / 100);
      emitEvent(props.onBarScroll, {
        type: "vertical",
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("vertical");
    }
    function emitScrollEvent(type) {
      emitEvent(props.onScroll, {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitter.emit("scroll", {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function getXScrollLimit() {
      return [0, xScrollLimit.value];
    }
    function getYScrollLimit() {
      return [0, yScrollLimit.value];
    }
    function addScrollListener(listener) {
      emitter.on("scroll", listener);
    }
    function removeScrollListener(listener) {
      emitter.off("scroll", listener);
    }
    return {
      props,
      nh,
      percentX,
      percentY,
      currentScroll,
      xScrollLimit,
      yScrollLimit,
      className,
      style,
      wrapperClass,
      xBarLength,
      yBarLength,
      enableXScroll,
      enableYScroll,
      wrapper: ref(),
      content: contentElement,
      xBar,
      yBar,
      handleResize,
      handleMouseDown,
      handleScroll,
      handleWheel,
      handleBarScrollStart,
      handleBarScrollEnd,
      handleXBarScroll,
      handleYBarScroll,
      refresh,
      scrollTo,
      scrollBy,
      scrollToElement,
      getXScrollLimit,
      getYScrollLimit,
      addScrollListener,
      removeScrollListener
    };
  }
});
function _sfc_render7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.style),
    onMousedown: _cache[6] || (_cache[6] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args)),
    onWheel: [
      _cache[7] || (_cache[7] = withModifiers(($event) => _ctx.handleWheel($event, "vertical"), ["exact"])),
      _cache[8] || (_cache[8] = withModifiers(($event) => _ctx.handleWheel($event, "horizontal"), ["shift"]))
    ]
  }, [
    createVNode(_component_ResizeObserver, {
      throttle: "",
      "on-resize": _ctx.handleResize
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.props.wrapperTag || "div"), {
          ref: "content",
          class: normalizeClass(_ctx.wrapperClass),
          style: normalizeStyle(_ctx.props.scrollStyle),
          onScroll: [
            _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.handleScroll($event, "vertical"), ["exact"])),
            _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.handleScroll($event, "horizontal"), ["shift"]))
          ]
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 40, ["class", "style"]))
      ]),
      _: 3
    }, 8, ["on-resize"]),
    _ctx.props.useXBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 0,
      ref: "xBar",
      inherit: "",
      placement: "bottom",
      class: normalizeClass([_ctx.nh.bem("bar", "horizontal"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.xBarLength,
      disabled: !_ctx.enableXScroll,
      appear: _ctx.props.appear,
      duration: _ctx.props.barDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[2] || (_cache[2] = ($event) => _ctx.handleBarScrollStart("horizontal")),
      onScroll: _ctx.handleXBarScroll,
      onScrollEnd: _cache[3] || (_cache[3] = ($event) => _ctx.handleBarScrollEnd("horizontal"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "appear", "duration", "use-track", "onScroll"])) : createCommentVNode("", true),
    _ctx.props.useYBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 1,
      ref: "yBar",
      inherit: "",
      placement: "right",
      class: normalizeClass([_ctx.nh.bem("bar", "vertical"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.yBarLength,
      disabled: !_ctx.enableYScroll,
      appear: _ctx.props.appear,
      duration: _ctx.props.barDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[4] || (_cache[4] = ($event) => _ctx.handleBarScrollStart("vertical")),
      onScroll: _ctx.handleYBarScroll,
      onScrollEnd: _cache[5] || (_cache[5] = ($event) => _ctx.handleBarScrollEnd("vertical"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "appear", "duration", "use-track", "onScroll"])) : createCommentVNode("", true)
  ], 38);
}
var NativeScroll = _export_sfc(_sfc_main7, [["render", _sfc_render7]]);

// node_modules/vexip-ui/es/components/virtual-list/props.mjs
var virtualListProps = buildProps({
  items: Array,
  itemSize: Number,
  itemFixed: Boolean,
  idKey: String,
  defaultKeyAt: [Number, String, Symbol],
  bufferSize: Number,
  listTag: String,
  itemsTag: String,
  itemsAttrs: Object,
  onScroll: eventProp(),
  onResize: eventProp()
});

// node_modules/vexip-ui/es/components/virtual-list/virtual-list.mjs
var VirtualList = defineComponent({
  name: "VirtualList",
  components: {
    NativeScroll,
    ResizeObserver
  },
  inheritAttrs: false,
  props: virtualListProps,
  emits: [],
  setup(_props, {
    slots,
    attrs,
    expose
  }) {
    const props = useProps("virtualList", _props, {
      items: {
        default: () => [],
        static: true
      },
      itemSize: 36,
      itemFixed: false,
      idKey: "id",
      defaultKeyAt: null,
      bufferSize: 5,
      listTag: "div",
      itemsTag: "ul",
      itemsAttrs: null
    });
    const nh = useNameHelper("virtual-list");
    const {
      items,
      itemSize,
      itemFixed,
      idKey,
      bufferSize
    } = toRefs(props);
    const scroll = ref();
    const list = ref();
    const wrapper = computed(() => {
      var _a, _b;
      return (_b = (_a = scroll.value) == null ? void 0 : _a.content) != null ? _b : null;
    });
    const {
      indexMap,
      scrollOffset,
      visibleItems,
      listStyle,
      itemsStyle,
      handleScroll,
      handleResize,
      handleItemResize,
      scrollTo,
      scrollBy,
      scrollToKey,
      scrollToIndex,
      ensureIndexInView,
      ensureKeyInView
    } = _o({
      items,
      itemSize,
      itemFixed,
      idKey,
      bufferSize,
      wrapper,
      defaultKeyAt: props.defaultKeyAt,
      autoResize: false
    });
    expose({
      scroll,
      wrapper,
      list,
      scrollOffset,
      scrollTo,
      scrollBy,
      scrollToKey,
      scrollToIndex,
      ensureIndexInView,
      ensureKeyInView,
      refresh
    });
    watch(() => props.items.length, () => {
      nextTick(refresh);
    });
    function onScroll(payload) {
      handleScroll();
      emitEvent(props.onScroll, payload);
    }
    function onResize(entry) {
      handleResize(entry);
      emitEvent(props.onResize, entry);
    }
    function refresh() {
      var _a;
      (_a = scroll.value) == null ? void 0 : _a.refresh();
    }
    return () => {
      const keyField = props.idKey;
      const itemFixed2 = props.itemFixed;
      const keyIndexMap = indexMap.value;
      const itemSlot = slots.default;
      const {
        class: itemsClass,
        style: itemsOtherStyle,
        ...itemsAttrs
      } = props.itemsAttrs || {};
      const ListTag = props.listTag || "div";
      const ItemsTag = props.itemsTag || "ul";
      let renderingItems = visibleItems.value;
      if (false) {
        renderingItems = props.items;
      }
      return createVNode(NativeScroll, mergeProps({
        "ref": scroll,
        "inherit": props.inherit,
        "class": nh.b(),
        "use-y-bar": true,
        "scroll-y": scrollOffset.value
      }, attrs, {
        "onScroll": onScroll,
        "onResize": onResize
      }), {
        default: () => [createVNode(ResizeObserver, {
          "throttle": true,
          "onResize": refresh
        }, {
          default: () => [createVNode(ListTag, {
            "ref": list,
            "class": nh.be("list"),
            "style": listStyle.value
          }, {
            default: () => [createVNode(ItemsTag, mergeProps(itemsAttrs, {
              "class": [nh.be("items"), itemsClass],
              "style": [itemsStyle.value, itemsOtherStyle]
            }), {
              default: () => {
                var _a;
                return [itemSlot && props.items.length ? renderingItems.map((item) => {
                  const key = item[keyField];
                  const index = keyIndexMap.get(key);
                  const vnode = itemSlot({
                    item,
                    index
                  })[0];
                  if (itemFixed2) {
                    vnode.key = key;
                    return vnode;
                  }
                  const onResize2 = handleItemResize.bind(null, key);
                  return createVNode(ResizeObserver, {
                    "key": key,
                    "throttle": true,
                    "onResize": onResize2
                  }, {
                    default: () => vnode
                  });
                }) : (_a = slots.empty) == null ? void 0 : _a.call(slots)];
              }
            })]
          })]
        })]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/row/props.mjs
var rowProps = buildProps({
  tag: String,
  gap: [Number, Array],
  justify: String,
  align: String,
  columnFlex: {
    type: [Boolean, Object],
    default: null
  }
});
var mediaProp = [Number, Object];
var columnProps = buildProps({
  tag: String,
  span: Number,
  offset: Number,
  push: Number,
  pull: Number,
  order: Number,
  xs: mediaProp,
  sm: mediaProp,
  md: mediaProp,
  lg: mediaProp,
  xl: mediaProp,
  xxl: mediaProp,
  flex: [Number, String],
  useFlex: {
    type: [Boolean, Object],
    default: null
  }
});

// node_modules/vexip-ui/es/components/row/symbol.mjs
var breakPoints = Object.freeze(["xs", "sm", "md", "lg", "xl", "xxl"]);
var ROW_STATE = Symbol("ROW_STATE");

// node_modules/vexip-ui/es/components/row/row.mjs
var justifyList = Object.freeze([
  "start",
  "end",
  "center",
  "space-around",
  "space-between",
  "space-evenly"
]);
var alignList = Object.freeze(["top", "middle", "bottom", "stretch"]);
var Row = defineComponent({
  name: "Row",
  props: rowProps,
  setup(_props, { slots }) {
    const props = useProps("row", _props, {
      tag: "div",
      gap: 0,
      justify: {
        default: "start",
        validator: (value) => justifyList.includes(value)
      },
      align: {
        default: "top",
        validator: (value) => alignList.includes(value)
      },
      columnFlex: false
    });
    const nh = useNameHelper("row");
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(props.justify),
        nh.bm(props.align),
        {
          [nh.bm("inherit")]: props.inherit
        }
      ];
    });
    const style = computed(() => {
      if (!props.gap)
        return null;
      if (typeof props.gap === "number") {
        return {
          [nh.cv("h-gap")]: `${props.gap}px`
        };
      }
      if (Array.isArray(props.gap)) {
        const [horizontal, vertical] = props.gap;
        return {
          [nh.cv("h-gap")]: `${horizontal}px`,
          [nh.cv("v-gap")]: `${vertical}px`
        };
      }
      return null;
    });
    const columnFlex = computed(() => {
      if (props.columnFlex === true) {
        return {
          justify: "start",
          align: "top"
        };
      } else if (props.columnFlex) {
        return {
          justify: "start",
          align: "top",
          ...props.columnFlex
        };
      }
      return false;
    });
    provide(
      ROW_STATE,
      reactive({
        columnFlex,
        gap: toRef(props, "gap")
      })
    );
    return () => h(
      props.tag || "div",
      {
        class: className.value,
        style: style.value
      },
      {
        default: () => slots.default && slots.default()
      }
    );
  }
});

// node_modules/vexip-ui/es/components/form/props.mjs
var formProps = buildProps({
  method: String,
  action: String,
  model: Object,
  rules: Object,
  labelWidth: [Number, String],
  labelAlign: String,
  allRequired: booleanProp,
  labelSuffix: String,
  hideAsterisk: booleanProp,
  validateAll: booleanProp,
  hideLabel: booleanProp,
  disabled: booleanProp,
  loading: booleanProp,
  size: sizeProp,
  inline: booleanProp,
  gap: [Number, Array],
  justify: String,
  align: String
});
var mediaProp2 = [Number, Object];
var formItemProps = buildProps({
  label: String,
  prop: String,
  rules: [Object, Array],
  labelWidth: Number,
  required: booleanProp,
  htmlFor: String,
  errorTransition: String,
  defaultValue: Object,
  hideErrorTip: booleanProp,
  validateAll: booleanProp,
  hideAsterisk: booleanProp,
  hideLabel: booleanProp,
  action: booleanProp,
  help: String,
  pure: booleanProp,
  span: Number,
  offset: Number,
  push: Number,
  pull: Number,
  order: Number,
  xs: mediaProp2,
  sm: mediaProp2,
  md: mediaProp2,
  lg: mediaProp2,
  xl: mediaProp2,
  xxl: mediaProp2,
  flex: [Number, String]
});
var formSubmitProps = buildProps({
  size: sizeProp,
  type: String,
  label: String,
  dashed: booleanProp,
  text: booleanProp,
  simple: booleanProp,
  ghost: booleanProp,
  disabled: booleanProp,
  circle: booleanProp,
  loadingIcon: Object,
  loadingSpin: booleanProp,
  icon: Object,
  color: String,
  buttonType: String,
  block: booleanProp,
  tag: String,
  onBeforeSubmit: Function,
  onSubmit: eventProp(),
  onError: eventProp()
});
var formResetProps = buildProps({
  size: sizeProp,
  type: String,
  label: String,
  dashed: booleanProp,
  text: booleanProp,
  simple: booleanProp,
  ghost: booleanProp,
  disabled: booleanProp,
  loading: booleanProp,
  circle: booleanProp,
  loadingIcon: Object,
  loadingSpin: booleanProp,
  icon: Object,
  color: String,
  buttonType: String,
  block: booleanProp,
  tag: String,
  onBeforeReset: Function,
  onReset: eventProp()
});

// node_modules/vexip-ui/es/components/form/symbol.mjs
var FORM_PROPS = Symbol("FORM_PROPS");
var FORM_FIELDS = Symbol("FORM_FIELDS");
var FORM_ACTIONS = Symbol("FORM_ACTIONS");
var FIELD_OPTIONS = Symbol("FIELD_OPTIONS");

// node_modules/vexip-ui/es/components/form/form.mjs
var submitMethods = Object.freeze(["get", "post", "put", "delete"]);
var labelAligns = Object.freeze(["right", "top", "left"]);
var _sfc_main8 = defineComponent({
  name: "Form",
  components: {
    Row
  },
  inheritAttrs: true,
  props: formProps,
  setup(_props) {
    const props = useProps("form", _props, {
      method: {
        default: "post",
        validator: (value) => submitMethods.includes(value)
      },
      action: null,
      model: {
        default: () => ({}),
        static: true
      },
      rules: () => ({}),
      labelWidth: "auto",
      labelAlign: {
        default: "right",
        validator: (value) => labelAligns.includes(value)
      },
      allRequired: false,
      labelSuffix: "",
      hideAsterisk: false,
      validateAll: false,
      hideLabel: false,
      disabled: false,
      loading: false,
      size: createSizeProp(),
      inline: false,
      gap: [8, 0],
      justify: "start",
      align: "top"
    });
    const nh = useNameHelper("form");
    const fieldSet = reactive(/* @__PURE__ */ new Set());
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(`label-${props.labelAlign}`),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("inline")]: props.inline
        }
      ];
    });
    const labelWidth = computed(() => {
      return Math.max(...Array.from(fieldSet).map((field) => field.labelWidth.value));
    });
    provide(FORM_PROPS, props);
    provide(FORM_FIELDS, fieldSet);
    provide(FORM_ACTIONS, {
      getLabelWidth,
      validate: validate2,
      validateFields,
      reset,
      resetFields,
      clearError,
      clearFieldsError
    });
    function getLabelWidth() {
      if (typeof props.labelWidth === "number") {
        return props.labelWidth;
      }
      return labelWidth.value;
    }
    function getPropMap() {
      const propMap = {};
      for (const field of fieldSet) {
        if (field.prop.value) {
          propMap[field.prop.value] = field;
        }
      }
      return propMap;
    }
    function validate2() {
      return validateItems(fieldSet);
    }
    function validateFields(props2) {
      if (!Array.isArray(props2)) {
        props2 = [props2];
      }
      const propMap = getPropMap();
      const fields = /* @__PURE__ */ new Set();
      props2.forEach((prop) => {
        if (propMap[prop]) {
          fields.add(propMap[prop]);
        }
      });
      return validateItems(fields);
    }
    function validateItems(items) {
      const validations = [];
      items.forEach((item) => {
        validations.push(item.validate());
      });
      return new Promise((resolve) => {
        Promise.all(validations).then((errors) => {
          resolve(errors.flat().filter(Boolean));
        });
      });
    }
    function reset() {
      fieldSet.forEach((field) => {
        field.reset();
      });
    }
    function resetFields(props2) {
      if (!Array.isArray(props2)) {
        props2 = [props2];
      }
      const propMap = getPropMap();
      props2.forEach((prop) => {
        if (propMap[prop]) {
          propMap[prop].reset();
        }
      });
    }
    function clearError() {
      fieldSet.forEach((field) => {
        field.clearError();
      });
    }
    function clearFieldsError(props2) {
      if (!Array.isArray(props2)) {
        props2 = [props2];
      }
      const propMap = getPropMap();
      props2.forEach((prop) => {
        if (propMap[prop]) {
          propMap[prop].clearError();
        }
      });
    }
    return {
      props,
      className,
      validate: validate2,
      validateFields,
      reset,
      resetFields,
      clearError,
      clearFieldsError
    };
  }
});
function _sfc_render8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Row = resolveComponent("Row");
  return openBlock(), createBlock(_component_Row, mergeProps(_ctx.$attrs, {
    class: _ctx.className,
    tag: "form",
    method: _ctx.props.action && _ctx.props.method,
    action: _ctx.props.action,
    gap: _ctx.props.gap,
    justify: _ctx.props.justify,
    align: _ctx.props.align,
    "column-flex": void 0
  }), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 16, ["class", "method", "action", "gap", "justify", "align"]);
}
var Form = _export_sfc(_sfc_main8, [["render", _sfc_render8]]);

// node_modules/vexip-ui/es/components/form/helper.mjs
function getValueByPath(obj, path, strict = false) {
  if (!obj || !path)
    return null;
  if (typeof path === "string") {
    if (path in obj)
      return obj[path];
    path = path.split(".");
  }
  if (Array.isArray(path) && path.length) {
    const lastKey = path.pop();
    if (!lastKey)
      return null;
    for (let i = 0, len = path.length; i < len; ++i) {
      const key = String(path[i]);
      if (!key)
        break;
      obj = obj[key];
      if (qe(obj)) {
        if (strict) {
          throw new Error("[vexip-ui:Form] Get value by an invalid path");
        }
        return obj;
      }
    }
    if (strict && qe(obj[lastKey])) {
      throw new Error("[vexip-ui:Form] Get value by an invalid path");
    }
    return obj[lastKey];
  }
  return null;
}
function setValueByPath(obj, path, value, strict = false) {
  if (!obj || !path)
    return false;
  if (typeof path === "string") {
    if (path in obj) {
      obj[path] = value;
      return true;
    }
    path = path.split(".");
  }
  if (Array.isArray(path) && path.length) {
    const lastKey = path.pop();
    if (!lastKey)
      return false;
    for (let i = 0, len = path.length; i < len; ++i) {
      const key = String(path[i]);
      if (!key) {
        return false;
      }
      if (typeof obj[key] !== "object") {
        if (strict) {
          throw new Error("[vexip-ui:Form] Set value by an invalid path");
        }
        obj[key] = {};
      }
      obj = obj[key];
    }
    if (strict && typeof obj !== "object") {
      throw new Error("[vexip-ui:Form] Set value by an invalid path");
    }
    obj[lastKey] = value;
    return true;
  }
  return false;
}
var defaultProp = computed(() => "");
var defaultState = computed(() => "default");
var defaultFalse = computed(() => false);
var defaultSize = computed(() => "default");
function getEmptyActions() {
  return {
    isField: false,
    idFor: defaultProp,
    state: defaultState,
    disabled: defaultFalse,
    loading: defaultFalse,
    size: defaultSize,
    validateField: cn,
    clearField: cn,
    resetField: cn,
    getFieldValue: (v5) => v5,
    setFieldValue: cn
  };
}
function useFieldStore(onFocus) {
  const instance = getCurrentInstance();
  if (!instance)
    return getEmptyActions();
  const fieldOptions = inject(FIELD_OPTIONS, null);
  if (!fieldOptions) {
    return getEmptyActions();
  }
  provide(FIELD_OPTIONS, null);
  fieldOptions.sync(instance);
  onFocus && fieldOptions.emitter.on("focus", onFocus);
  onBeforeUnmount(() => {
    fieldOptions.unsync(instance);
    onFocus && fieldOptions.emitter.off("focus", onFocus);
  });
  function clearField(defaultValue) {
    if (!fieldOptions)
      return;
    fieldOptions.setValue(defaultValue);
    fieldOptions.clearError();
  }
  return {
    isField: true,
    idFor: fieldOptions.idFor,
    state: fieldOptions.state,
    disabled: fieldOptions.disabled,
    loading: fieldOptions.loading,
    size: fieldOptions.size,
    validateField: fieldOptions.validate,
    clearField,
    resetField: fieldOptions.reset,
    getFieldValue: fieldOptions.getValue,
    setFieldValue: fieldOptions.setValue
  };
}

// node_modules/vexip-ui/es/components/form/validator.mjs
var DEFAULT_MESSAGE = "Validate failed";
var N_100_200 = "1\\d\\d|2([0-4]\\d|5[0-5])";
var IPV4_FIRST = `[1-9](\\d)?|${N_100_200}`;
var IPV4_UNIT = `\\d{1,2}|${N_100_200}`;
var IPV4_REG = `(?:${IPV4_FIRST})\\.(?:${IPV4_UNIT})\\.(?:${IPV4_UNIT})\\.(?:${IPV4_UNIT})`;
var HOST_REG = "(?:[a-zA-Z0-9][\\w-]*\\.)?(?:[a-zA-Z0-9][\\w-]*)(?:\\.[a-zA-Z]+){1,2}";
var PARAM_REG = "(?:(?:[\\/]+[^\\?\\.]+)+)?(?:[\\/]*)?(\\?([^&\\.]+=[^&\\.]*)(&[^&\\.]+=[^&\\.]*)*)?(#.*)?";
var URL_REG = new RegExp(
  `^(?:[a-z]{2,5}:(\\/+)?)?\\/\\/((?:${IPV4_REG})|(?:${HOST_REG}))(?:${PARAM_REG})?$`
);
var EMAIL_REG = /^(?:[a-zA-Z0-9][\w-]*)@(?:[a-zA-Z0-9][\w-]*)(?:\.[a-zA-Z]+){1,2}$/;
var TYPE_LIST = /* @__PURE__ */ new Set([
  "string",
  "number",
  "boolean",
  "int",
  "float",
  "array",
  "object",
  "date",
  "url",
  "color",
  "email"
]);
async function validate(rules, value, model, validateAll = true, defaultMsg = DEFAULT_MESSAGE) {
  if (!Array.isArray(rules)) {
    rules = [rules];
  }
  const errors = [];
  for (const rule of rules) {
    const { message = defaultMsg, validator } = rule;
    if (typeof validator === "function") {
      let result;
      try {
        result = validator(value, model);
        if (Je(result)) {
          result = await result;
        }
      } catch (error) {
        result = error instanceof Error ? error.message : error;
      }
      if (result !== true) {
        const errorMessage = typeof result === "string" ? result : message;
        errors.push(errorMessage);
        if (!validateAll)
          break;
      }
    }
    if (rule.required && !validateRequirement(value)) {
      errors.push(message);
      if (!validateAll)
        break;
    }
    if (y(value) && value !== "") {
      if (rule.enums && !validateEnumeration(value, rule.enums)) {
        errors.push(message);
        if (!validateAll)
          break;
      }
      if (rule.type && !validateType(value, rule.type, rule)) {
        errors.push(message);
        if (!validateAll)
          break;
      }
    }
  }
  return errors;
}
function validateRequirement(value) {
  return !(!y(value) || value.toString().trim() === "" || Array.isArray(value) && !value.length || L(value) && !Object.keys(value).length);
}
function validateEnumeration(value, options) {
  if (!Array.isArray(options) || !options.length)
    return true;
  if (Array.isArray(value)) {
    const enumSet = new Set(options);
    for (const item of value) {
      if (!enumSet.has(item)) {
        return false;
      }
    }
    return true;
  } else {
    return options.includes(value);
  }
}
function validateType(value, type, options = {}) {
  if (!TYPE_LIST.has(type))
    return true;
  switch (type) {
    case "string":
      return validateString(value, options.length, options.range);
    case "number":
      return validateNumber(value, options.strict, options.length, options.range);
    case "boolean":
      return validateBoolean(value, options.strict);
    case "int":
      return validateInt(value, options.strict, options.length, options.range);
    case "float":
      return validateFloat(value, options.strict, options.length, options.range);
    case "array":
      return Array.isArray(value);
    case "object":
      return L(value);
    case "date":
      return validateDate(value, options.strict);
    case "url":
      return validateUrl(value);
    case "color":
      return typeof value === "string" && gn(value);
    case "email":
      return validateEmail(value);
  }
}
function validateString(value, length, range) {
  if (typeof value !== "string")
    return false;
  if (y(length) && value.length !== length) {
    return false;
  }
  if (Array.isArray(range)) {
    const [min, max] = range;
    if (min && value.length < min)
      return false;
    if (max && value.length > max)
      return false;
  }
  return true;
}
function validateNumber(value, strict, length, range) {
  if (strict) {
    if (typeof value !== "number")
      return false;
  } else {
    value = Number(value);
    if (Number.isNaN(value))
      return false;
  }
  const number = value;
  if (y(length) && number.toString().length !== length) {
    return false;
  }
  if (Array.isArray(range)) {
    const [min, max] = range;
    if (y(min) && number < min)
      return false;
    if (y(max) && number > max)
      return false;
  }
  return true;
}
function validateBoolean(value, strict) {
  if (!strict) {
    if (typeof value === "string") {
      return value === "true" || value === "false";
    }
    if (typeof value === "number") {
      return value === 1 || value === 0;
    }
  }
  return typeof value === "boolean";
}
function validateInt(value, strict, length, range) {
  if (validateNumber(value, strict, length, range)) {
    const number = En(value);
    return Math.ceil(number) === number;
  }
  return false;
}
function validateFloat(value, strict, length, range) {
  if (validateNumber(value, strict, length, range)) {
    const number = En(value);
    return strict ? Math.ceil(number) !== number : number.toString().includes(".");
  }
  return false;
}
function validateDate(value, strict) {
  if (strict && !(value instanceof Date)) {
    return false;
  }
  try {
    l(value);
  } catch (e) {
    return false;
  }
  return true;
}
function validateUrl(value) {
  return typeof value === "string" && URL_REG.test(value);
}
function validateEmail(value) {
  return typeof value === "string" && EMAIL_REG.test(value);
}

// node_modules/vexip-ui/es/components/select/props.mjs
var selectProps = buildProps({
  size: sizeProp,
  state: stateProp,
  visible: booleanProp,
  options: Array,
  disabled: booleanProp,
  transitionName: String,
  outsideClose: booleanProp,
  placeholder: String,
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  noSuffix: booleanProp,
  value: [String, Number, Array],
  multiple: booleanProp,
  clearable: booleanProp,
  maxListHeight: Number,
  listClass: classProp,
  placement: String,
  transfer: booleanStringProp,
  optionCheck: booleanProp,
  emptyText: String,
  staticSuffix: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  keyConfig: Object,
  filter: {
    type: [Boolean, Function],
    default: null
  },
  ignoreCase: booleanProp,
  creatable: booleanProp,
  transparent: booleanProp,
  onFocus: eventProp(),
  onBlur: eventProp(),
  onToggle: eventProp(),
  onSelect: eventProp(),
  onCancel: eventProp(),
  onChange: eventProp(),
  onClickOutside: eventProp(),
  onOutsideClose: eventProp(),
  onClear: eventProp()
});

// node_modules/vexip-ui/es/components/select/select.mjs
var defaultKeyConfig = {
  value: "value",
  label: "label",
  disabled: "disabled",
  divided: "divided",
  noTitle: "noTitle",
  group: "group",
  children: "children"
};
function isSameValue(newValue, oldValue) {
  const isNewArray = Array.isArray(newValue);
  const isOldArray = Array.isArray(oldValue);
  if (isNewArray !== isOldArray)
    return false;
  if (isNewArray && isOldArray) {
    if (newValue.length !== oldValue.length)
      return false;
    for (let i = 0, len = newValue.length; i < len; ++i) {
      if (newValue[i] !== oldValue[i])
        return false;
    }
    return true;
  }
  if (qe(newValue))
    return qe(oldValue);
  return newValue === oldValue;
}
var _sfc_main9 = defineComponent({
  name: "Select",
  components: {
    Icon,
    Option,
    Portal,
    Tag,
    VirtualList,
    Check: x,
    CircleXmark: u,
    ChevronDown: $15
  },
  props: selectProps,
  emits: ["update:value", "update:visible", "update:label"],
  setup(_props, { emit, slots }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("select");
    const props = useProps("select", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      visible: {
        default: false,
        static: true
      },
      options: {
        default: () => [],
        static: true
      },
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      outsideClose: true,
      placeholder: null,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      multiple: false,
      clearable: false,
      maxListHeight: 300,
      listClass: null,
      placement: {
        default: "bottom",
        validator: (value) => Wo.includes(value)
      },
      transfer: false,
      optionCheck: false,
      emptyText: null,
      staticSuffix: false,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      keyConfig: () => ({}),
      filter: false,
      ignoreCase: false,
      creatable: false,
      transparent: false
    });
    const locale = useLocale("select");
    const currentVisible = ref(props.visible);
    const currentLabels = ref([]);
    const currentValues = ref([]);
    const currentIndex = ref(-1);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const listHeight = ref();
    const baseOptions = ref([]);
    const currentFilter = ref("");
    const anchorWidth = ref(0);
    const userOptions = ref([]);
    const { isMounted } = Io();
    const dynamicOption = reactive({
      disabled: false,
      divided: false,
      noTitle: false,
      value: "",
      label: "",
      group: false,
      depth: 0,
      parent: null,
      hidden: false,
      hitting: true,
      data: ""
    });
    const optionValues = reactive(/* @__PURE__ */ new Set());
    const optionStates = computed(() => userOptions.value.concat(baseOptions.value));
    const visibleOptions = computed(() => optionStates.value.filter((state2) => !state2.hidden));
    const keyConfig = computed(() => ({ ...defaultKeyConfig, ...props.keyConfig }));
    let optionValueMap = /* @__PURE__ */ new Map();
    let emittedValue = props.value;
    const updateTrigger = ref(0);
    watchEffect(() => {
      props.keyConfig.value;
      props.keyConfig.label;
      props.keyConfig.disabled;
      props.keyConfig.divided;
      props.keyConfig.noTitle;
      props.options;
      updateTrigger.value++;
    });
    watch(updateTrigger, initOptionState, { immediate: true });
    function initOptionState() {
      var _a, _b;
      const {
        value: valueKey,
        label: labelKey,
        disabled: disabledKey,
        divided: dividedKey,
        noTitle: noTitleKey,
        group: groupKey,
        children: childrenKey
      } = keyConfig.value;
      const oldMap = optionValueMap;
      const map = /* @__PURE__ */ new Map();
      const states = [];
      const loop = props.options.map((option) => ({ option, depth: 0, parent: null })).reverse();
      optionValues.clear();
      for (const option of userOptions.value) {
        map.set(option.value, option);
        optionValues.add(option.value);
      }
      while (loop.length) {
        const { option, depth, parent } = loop.pop();
        const rawOption = typeof option === "string" ? { [valueKey]: option } : option;
        const group = !!rawOption[groupKey];
        const value = rawOption[valueKey];
        if (!group && qe(value))
          return;
        const label = rawOption[labelKey] || String(value);
        const {
          [disabledKey]: disabled2 = false,
          [dividedKey]: divided = false,
          [noTitleKey]: noTitle = false,
          [childrenKey]: children = null
        } = rawOption;
        const oldState = oldMap.get(rawOption.value);
        const optionState = reactive({
          disabled: disabled2,
          divided,
          noTitle,
          value,
          label,
          group,
          depth,
          parent,
          hidden: (_a = oldState == null ? void 0 : oldState.hidden) != null ? _a : false,
          hitting: (_b = oldState == null ? void 0 : oldState.hitting) != null ? _b : false,
          data: option
        });
        states.push(optionState);
        if (!group) {
          map.set(value, optionState);
          optionValues.add(String(value));
        }
        if (Array.isArray(children) && children.length) {
          loop.push(
            ...children.map((child) => {
              return { option: child, depth: depth + 1, parent: optionState };
            }).reverse()
          );
        }
      }
      optionValueMap = map;
      baseOptions.value = states;
      initValueAndLabel(emittedValue);
    }
    const wrapper = Do(handleClickOutside);
    const input = ref();
    const device = ref();
    const virtualList = ref();
    const { reference, popper, transferTo, updatePopper } = qo({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = Co(reference);
    No({
      target: wrapper,
      passive: false,
      onKeyDown: (event, modifier) => {
        if (!currentVisible.value) {
          if (modifier.space) {
            event.preventDefault();
            event.stopPropagation();
            toggleVisible();
          }
          return;
        }
        if (modifier.up || modifier.down) {
          event.preventDefault();
          event.stopPropagation();
          const options = visibleOptions.value;
          const length = options.length;
          if (!length)
            return;
          const step = modifier.down ? 1 : -1;
          let index = (Math.max(-1, currentIndex.value + step) + length) % length;
          let option = options[index];
          for (let i = 0; (option.disabled || option.group) && i < length; ++i) {
            index += step;
            index = (index + length) % length;
            option = options[index];
          }
          updateHitting(index);
          modifier.resetAll();
        } else if (modifier.enter) {
          event.preventDefault();
          event.stopPropagation();
          if (currentIndex.value >= 0) {
            handleSelect(totalOptions.value[currentIndex.value]);
          } else if (showDynamic.value) {
            handleSelect(dynamicOption);
          } else {
            currentVisible.value = false;
          }
          modifier.resetAll();
        } else if (modifier.tab || modifier.escape) {
          currentVisible.value = false;
          modifier.resetAll();
        }
      }
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("multiple")]: props.multiple,
        [nh.bm("filter")]: props.filter
      };
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--focused`]: !props.disabled && currentVisible.value,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--${props.state}`]: props.state !== "default",
        [`${baseCls}--has-prefix`]: hasPrefix.value,
        [`${baseCls}--has-suffix`]: !props.noSuffix,
        [`${baseCls}--transparent`]: props.transparent
      };
    });
    const hasValue = computed(() => !qe(currentValues.value[0]));
    const hasPrefix = computed(() => !!(slots.prefix || props.prefix));
    const showDynamic = computed(() => {
      return !!(props.filter && props.creatable && dynamicOption.value && !optionValues.has(dynamicOption.value));
    });
    const totalOptions = computed(() => {
      return showDynamic.value ? [dynamicOption].concat(visibleOptions.value) : visibleOptions.value;
    });
    const normalOptions = computed(() => optionStates.value.filter((option) => !option.group));
    const optionParentMap = computed(() => {
      const options = normalOptions.value;
      const map = /* @__PURE__ */ new Map();
      for (let i = 0, len = options.length; i < len; ++i) {
        const option = options[i];
        if (option.parent) {
          map.set(option.value, option.parent);
        }
      }
      return map;
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && hasValue.value;
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        initHittingIndex();
        requestAnimationFrame(() => {
          updatePopper();
          if (wrapper.value && popper.value) {
            popper.value.style.minWidth = `${wrapper.value.offsetWidth}px`;
          }
        });
        setTimeout(() => {
          if (virtualList.value && !qe(currentValues.value[0])) {
            virtualList.value.ensureKeyInView(currentValues.value[0]);
          }
        }, 32);
      }
      syncInputValue();
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(
      () => props.value,
      (value) => {
        if (!emittedValue || isSameValue(value, emittedValue)) {
          emittedValue = value;
          initValueAndLabel(value);
        }
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    watch(currentFilter, (value) => {
      dynamicOption.value = value;
      dynamicOption.label = value;
      dynamicOption.data = value;
      filterOptions(value);
    });
    onMounted(syncInputValue);
    function initValueAndLabel(value) {
      if (qe(value)) {
        currentValues.value = [];
        currentLabels.value = [];
        return;
      }
      const normalizedValue = !Array.isArray(value) ? [value] : value;
      const valueSet = new Set(normalizedValue);
      const selectedValues = [];
      const selectedLabels = [];
      valueSet.forEach((value2) => {
        const option = optionValueMap.get(value2);
        if (option) {
          selectedValues.push(option.value);
          selectedLabels.push(option.label);
        }
      });
      currentValues.value = selectedValues;
      currentLabels.value = selectedLabels;
      initHittingIndex();
      filterOptions(currentFilter.value);
    }
    function initHittingIndex() {
      const value = currentValues.value[0];
      if (qe(value)) {
        updateHitting(-1);
      } else {
        if (!isMounted.value)
          return;
        updateHitting(visibleOptions.value.findIndex((option) => option.value === value));
      }
    }
    function updateHitting(hitting, ensureInView = true) {
      currentIndex.value = hitting;
      let index = -1;
      visibleOptions.value.forEach((option) => {
        if (!option.hidden) {
          index += 1;
          option.hitting = hitting === index;
        } else {
          option.hitting = false;
        }
      });
      if (ensureInView && currentVisible.value && virtualList.value) {
        virtualList.value.ensureIndexInView(hitting);
      }
    }
    function isSelected(option) {
      if (props.multiple) {
        return currentValues.value.includes(option.value);
      }
      return currentValues.value[0] === option.value;
    }
    function filterOptions(value) {
      const filter = props.filter;
      if (!filter)
        return;
      if (!value) {
        optionStates.value.forEach((state2) => {
          state2.hidden = false;
        });
      } else {
        optionStates.value.forEach((state2) => {
          state2.hidden = true;
        });
        if (typeof filter === "function") {
          normalOptions.value.forEach((state2) => {
            state2.hidden = !filter(value, state2);
          });
        } else {
          if (props.ignoreCase) {
            const ignoreCaseValue = value.toString().toLocaleLowerCase();
            normalOptions.value.forEach((state2) => {
              var _a;
              state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().toLocaleLowerCase().includes(ignoreCaseValue));
            });
          } else {
            normalOptions.value.forEach((state2) => {
              var _a;
              state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().includes(value == null ? void 0 : value.toString()));
            });
          }
        }
        const parentMap = optionParentMap.value;
        normalOptions.value.forEach((option) => {
          if (!option.hidden && option.parent) {
            let parent = parentMap.get(option.value) || null;
            while (parent && parent.hidden) {
              parent.hidden = false;
              parent = parent.parent;
            }
          }
        });
      }
      updateHitting(currentIndex.value);
    }
    function handleTagClose(value) {
      handleSelect(optionValueMap.get(value));
    }
    function handleSelect(option) {
      if (!option)
        return;
      const selected = isSelected(option);
      const value = option.value;
      if (selected) {
        if (userOptions.value.find((item) => item.value === value)) {
          kr(userOptions.value, (item) => item.value === value);
          optionValueMap.delete(value);
        }
      } else {
        if (!props.multiple) {
          userOptions.value.length = 0;
        }
        if (dynamicOption.value && value === dynamicOption.value) {
          const newOption = { ...dynamicOption };
          userOptions.value.push(newOption);
          optionValueMap.set(value, newOption);
        }
      }
      emitEvent(props[props.multiple && selected ? "onCancel" : "onSelect"], value, option.data);
      handleChange(option);
      if (props.multiple) {
        currentFilter.value = "";
        syncInputValue();
        updatePopper();
      } else {
        currentVisible.value = false;
      }
    }
    function handleChange(option) {
      if (props.multiple) {
        if (isSelected(option)) {
          const index = currentValues.value.findIndex((v5) => v5 === option.value);
          if (~index) {
            currentValues.value.splice(index, 1);
            currentLabels.value.splice(index, 1);
          }
        } else {
          currentValues.value.push(option.value);
          currentLabels.value.push(option.label);
        }
        emittedValue = Array.from(currentValues.value);
        setFieldValue(emittedValue);
        emitEvent(
          props.onChange,
          emittedValue,
          emittedValue.map((value) => {
            var _a, _b;
            return (_b = (_a = optionValueMap.get(value)) == null ? void 0 : _a.data) != null ? _b : "";
          })
        );
        emit("update:value", emittedValue);
        emit("update:label", currentLabels.value);
        validateField();
      } else {
        const prevValue = currentValues.value[0];
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
        currentValues.value.push(option.value);
        currentLabels.value.push(option.label);
        if (prevValue !== option.value) {
          emittedValue = option.value;
          setFieldValue(emittedValue);
          emitEvent(props.onChange, emittedValue, option.data);
          emit("update:value", emittedValue);
          emit("update:label", currentLabels.value[0]);
          validateField();
        }
      }
    }
    function toggleVisible() {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      currentVisible.value = !currentVisible.value;
    }
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      if (props.outsideClose && currentVisible.value) {
        currentVisible.value = false;
        emitEvent(props.onOutsideClose);
      }
    }
    function handleClear() {
      if (props.clearable) {
        for (const option of userOptions.value) {
          optionValueMap.delete(option.value);
        }
        userOptions.value.length = 0;
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
        emittedValue = props.multiple ? [] : "";
        emitEvent(props.onChange, emittedValue, props.multiple ? [] : "");
        emit("update:value", emittedValue);
        emitEvent(props.onClear);
        clearField(emittedValue);
        updatePopper();
      }
    }
    function handleFocus(event) {
      emitEvent(props.onFocus, event);
    }
    function handleBlur(event) {
      emitEvent(props.onFocus, event);
    }
    function syncInputValue() {
      if (!input.value)
        return;
      const visible = currentVisible.value;
      if (props.multiple) {
        input.value.value = "";
      } else {
        input.value.value = visible ? "" : currentLabels.value[0] || "";
      }
      visible ? input.value.focus() : input.value.blur();
    }
    function handleFilterInput() {
      if (!input.value)
        return;
      currentFilter.value = input.value.value;
      if (showDynamic.value || currentIndex.value !== -1) {
        currentIndex.value = 0;
      } else {
        currentIndex.value = visibleOptions.value.findIndex(
          (option) => String(option.value) === currentFilter.value
        );
      }
      requestAnimationFrame(() => {
        if (props.multiple && device.value) {
          anchorWidth.value = lr(device.value);
        }
        updatePopper();
      });
    }
    function handleBackspace(event) {
      if (!input.value)
        return;
      if (event.key === "Backspace" && !input.value.value && !qe(currentValues.value.at(-1))) {
        event.stopPropagation();
        handleTagClose(currentValues.value.at(-1));
      }
    }
    return {
      props,
      nh,
      locale,
      idFor,
      currentVisible,
      currentValues,
      currentLabels,
      transferTo,
      listHeight,
      optionStates,
      isHover,
      currentFilter,
      anchorWidth,
      className,
      selectorClass,
      hasValue,
      hasPrefix,
      visibleOptions,
      totalOptions,
      showClear,
      normalOptions,
      optionParentMap,
      wrapper,
      reference,
      popper,
      input,
      device,
      virtualList,
      isSelected,
      filterOptions,
      updateHitting,
      handleTagClose,
      handleSelect,
      toggleVisible,
      handleClear,
      handleFocus,
      handleBlur,
      handleFilterInput,
      handleBackspace
    };
  }
});
var _hoisted_13 = ["id", "aria-disabled"];
var _hoisted_2 = ["disabled"];
var _hoisted_3 = ["disabled", "placeholder"];
var _hoisted_4 = ["title"];
function _sfc_render9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Tag = resolveComponent("Tag");
  const _component_ChevronDown = resolveComponent("ChevronDown");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_Check = resolveComponent("Check");
  const _component_Option = resolveComponent("Option");
  const _component_VirtualList = resolveComponent("VirtualList");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    "aria-disabled": _ctx.props.disabled ? "true" : void 0,
    onClick: _cache[8] || (_cache[8] = (...args) => _ctx.toggleVisible && _ctx.toggleVisible(...args))
  }, [
    createBaseVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        renderSlot(_ctx.$slots, "control", {}, () => {
          var _a, _b, _c;
          return [
            _ctx.props.multiple ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentValues, (item, index) => {
                return openBlock(), createBlock(_component_Tag, {
                  key: index,
                  inherit: "",
                  class: normalizeClass(_ctx.nh.be("tag")),
                  closable: "",
                  onClick: withModifiers(_ctx.toggleVisible, ["stop"]),
                  onClose: ($event) => _ctx.handleTagClose(item)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.currentLabels[index]), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "onClick", "onClose"]);
              }), 128)),
              _ctx.props.filter ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(_ctx.nh.be("anchor")),
                style: normalizeStyle({
                  width: `${_ctx.anchorWidth}px`
                })
              }, [
                createBaseVNode("input", {
                  ref: "input",
                  class: normalizeClass([_ctx.nh.be("input"), _ctx.nh.bem("input", "multiple")]),
                  disabled: _ctx.props.disabled,
                  autocomplete: "off",
                  tabindex: "-1",
                  role: "combobox",
                  "aria-autocomplete": "list",
                  onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleFilterInput && _ctx.handleFilterInput(...args)),
                  onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.handleBackspace && _ctx.handleBackspace(...args))
                }, null, 42, _hoisted_2),
                createBaseVNode("span", {
                  ref: "device",
                  class: normalizeClass(_ctx.nh.be("device")),
                  "aria-hidden": "true"
                }, toDisplayString(_ctx.currentFilter), 3)
              ], 6)) : createCommentVNode("", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              _ctx.props.filter ? (openBlock(), createElementBlock("input", {
                key: 0,
                ref: "input",
                class: normalizeClass(_ctx.nh.be("input")),
                disabled: _ctx.props.disabled,
                placeholder: _ctx.currentLabels[0] || ((_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder),
                autocomplete: "off",
                tabindex: "-1",
                role: "combobox",
                "aria-autocomplete": "list",
                onInput: _cache[2] || (_cache[2] = (...args) => _ctx.handleFilterInput && _ctx.handleFilterInput(...args))
              }, null, 42, _hoisted_3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(_ctx.currentLabels[0]), 1)
              ], 64))
            ], 64)),
            (_ctx.props.multiple || !_ctx.props.filter) && (!_ctx.currentVisible || !_ctx.currentFilter) && ((_b = _ctx.props.placeholder) != null ? _b : _ctx.locale.placeholder) && !_ctx.hasValue ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass(_ctx.nh.be("placeholder"))
            }, toDisplayString((_c = _ctx.props.placeholder) != null ? _c : _ctx.locale.placeholder), 3)) : createCommentVNode("", true)
          ];
        })
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          _ctx.props.suffix ? (openBlock(), createBlock(_component_Icon, {
            key: 0,
            icon: _ctx.props.suffix,
            class: normalizeClass({
              [_ctx.nh.be("arrow")]: !_ctx.props.staticSuffix
            })
          }, null, 8, ["icon", "class"])) : (openBlock(), createBlock(_component_Icon, {
            key: 1,
            class: normalizeClass(_ctx.nh.be("arrow"))
          }, {
            default: withCtx(() => [
              createVNode(_component_ChevronDown)
            ]),
            _: 1
          }, 8, ["class"]))
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.showClear ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onAfterLeave: _cache[7] || (_cache[7] = ($event) => _ctx.currentFilter = "")
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[6] || (_cache[6] = withModifiers(() => {
              }, ["stop"]))
            }, [
              createVNode(_component_VirtualList, {
                ref: "virtualList",
                inherit: "",
                class: normalizeClass([_ctx.nh.be("list"), _ctx.props.listClass]),
                style: normalizeStyle({
                  height: _ctx.listHeight,
                  maxHeight: `${_ctx.props.maxListHeight}px`
                }),
                items: _ctx.totalOptions,
                "item-size": 32,
                "use-y-bar": "",
                height: "100%",
                "id-key": "value",
                "items-attrs": {
                  class: [_ctx.nh.be("options"), _ctx.props.optionCheck ? _ctx.nh.bem("options", "has-check") : ""],
                  role: "listbox",
                  ariaLabel: "options"
                }
              }, {
                default: withCtx(({ item: option, index }) => [
                  option.group ? (openBlock(), createElementBlock("li", {
                    key: 0,
                    class: normalizeClass([_ctx.nh.ns("option-vars"), _ctx.nh.be("group")]),
                    title: option.label
                  }, [
                    renderSlot(_ctx.$slots, "group", {
                      option,
                      index
                    }, () => [
                      createBaseVNode("div", {
                        class: normalizeClass([_ctx.nh.be("label"), _ctx.nh.bem("label", "group")]),
                        style: normalizeStyle({ paddingLeft: `${option.depth * 6}px` })
                      }, toDisplayString(option.label), 7)
                    ])
                  ], 10, _hoisted_4)) : (openBlock(), createBlock(_component_Option, {
                    key: 1,
                    label: option.label,
                    value: option.value,
                    disabled: option.disabled,
                    divided: option.divided,
                    "no-title": option.noTitle,
                    hitting: option.hitting,
                    selected: _ctx.isSelected(option),
                    "no-hover": "",
                    onSelect: ($event) => _ctx.handleSelect(option),
                    onMousemove: ($event) => _ctx.updateHitting(index, false)
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "default", {
                        option,
                        index,
                        selected: _ctx.isSelected(option)
                      }, () => [
                        createBaseVNode("span", {
                          class: normalizeClass(_ctx.nh.be("label")),
                          style: normalizeStyle({ paddingLeft: `${option.depth * 6}px` })
                        }, toDisplayString(option.label), 7),
                        _ctx.props.optionCheck ? (openBlock(), createBlock(Transition, {
                          key: 0,
                          name: _ctx.nh.ns("fade"),
                          appear: ""
                        }, {
                          default: withCtx(() => [
                            _ctx.isSelected(option) ? (openBlock(), createBlock(_component_Icon, {
                              key: 0,
                              class: normalizeClass(_ctx.nh.be("check"))
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_Check)
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("", true)
                          ]),
                          _: 2
                        }, 1032, ["name"])) : createCommentVNode("", true)
                      ])
                    ]),
                    _: 2
                  }, 1032, ["label", "value", "disabled", "divided", "no-title", "hitting", "selected", "onSelect", "onMousemove"]))
                ]),
                empty: withCtx(() => [
                  createBaseVNode("div", {
                    class: normalizeClass(_ctx.nh.be("empty"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => {
                      var _a;
                      return [
                        createTextVNode(toDisplayString((_a = _ctx.props.emptyText) != null ? _a : _ctx.locale.empty), 1)
                      ];
                    })
                  ], 2)
                ]),
                _: 3
              }, 8, ["class", "style", "items", "items-attrs"])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name"])
      ]),
      _: 3
    }, 8, ["to"])
  ], 10, _hoisted_13);
}
var Select = _export_sfc(_sfc_main9, [["render", _sfc_render9]]);

// node_modules/vexip-ui/es/components/auto-complete/props.mjs
var autoCompleteProps = buildProps({
  size: sizeProp,
  state: stateProp,
  transfer: booleanStringProp,
  value: [String, Number],
  options: Array,
  filter: {
    type: [Boolean, Function],
    default: null
  },
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  placeholder: String,
  disabled: booleanProp,
  transitionName: String,
  dropDisabled: booleanProp,
  placement: String,
  clearable: booleanProp,
  ignoreCase: booleanProp,
  autofocus: booleanProp,
  spellcheck: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  transparent: booleanProp,
  keyConfig: Object,
  onSelect: eventProp(),
  onInput: eventProp(),
  onChange: eventProp(),
  onToggle: eventProp(),
  onEnter: eventProp(),
  onClear: eventProp()
});

// node_modules/vexip-ui/es/components/auto-complete/auto-complete.mjs
var _sfc_main10 = defineComponent({
  name: "AutoComplete",
  components: {
    Icon,
    Select
  },
  props: autoCompleteProps,
  emits: ["update:value"],
  setup(_props, { slots, emit }) {
    const select = ref();
    const control = ref();
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = control.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("auto-complete");
    const props = useProps("autoComplete", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      transfer: false,
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      options: {
        default: () => [],
        static: true
      },
      filter: false,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      placeholder: null,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      dropDisabled: false,
      placement: {
        default: "bottom",
        validator: (value) => Wo.includes(value)
      },
      clearable: false,
      ignoreCase: false,
      autofocus: false,
      spellcheck: false,
      keyConfig: () => ({}),
      loading: () => loading.value,
      loadingIcon: null,
      loadingLock: false,
      loadingSpin: false,
      transparent: false
    });
    const currentValue = ref(props.value);
    const currentIndex = ref(-1);
    const visible = ref(false);
    let changed = false;
    let lastValue = props.value;
    let lastInput = String(lastValue);
    const optionStates = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.optionStates) || [];
    });
    const normalOptions = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.normalOptions) || [];
    });
    const filteredOptions = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.visibleOptions) || [];
    });
    const hasPrefix = computed(() => !!(slots.prefix || props.prefix));
    const hasSuffix = computed(() => !!(slots.suffix || props.suffix));
    const optionParentMap = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.optionParentMap) || /* @__PURE__ */ new Map();
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
        lastValue = value;
        lastInput = String(value);
        if (control.value) {
          control.value.value = String(value);
        }
      }
    );
    watch(currentIndex, computeHitting);
    watch(visible, (value) => {
      var _a, _b;
      if (!value) {
        currentIndex.value = -1;
        (_a = control.value) == null ? void 0 : _a.blur();
      } else {
        (_b = control.value) == null ? void 0 : _b.focus();
      }
    });
    watchEffect(() => {
      if (props.filter) {
        const value = currentValue.value;
        if (qe(value)) {
          optionStates.value.forEach((state2) => {
            state2.hidden = false;
          });
        } else {
          optionStates.value.forEach((state2) => {
            state2.hidden = true;
          });
          if (typeof props.filter === "function") {
            const filter = props.filter;
            normalOptions.value.forEach((state2) => {
              state2.hidden = !filter(value, state2);
            });
          } else {
            if (props.ignoreCase) {
              const ignoreCaseValue = value == null ? void 0 : value.toString().toLocaleLowerCase();
              normalOptions.value.forEach((state2) => {
                var _a;
                state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().toLocaleLowerCase().includes(ignoreCaseValue));
              });
            } else {
              normalOptions.value.forEach((state2) => {
                var _a;
                state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().includes(value == null ? void 0 : value.toString()));
              });
            }
          }
          const parentMap = optionParentMap.value;
          normalOptions.value.forEach((option) => {
            if (!option.hidden && option.parent) {
              let parent = parentMap.get(option.value) || null;
              while (parent && parent.hidden) {
                parent.hidden = false;
                parent = parent.parent;
              }
            }
          });
        }
        computeHitting();
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (control.value && !qe(currentValue.value)) {
          control.value.value = String(currentValue.value);
        }
      });
    });
    function computeHitting() {
      const hitting = currentIndex.value;
      let index = -1;
      optionStates.value.forEach((state2) => {
        if (!state2.hidden) {
          index += 1;
          state2.hitting = hitting === index;
          if (state2.hitting) {
            if (control.value) {
              control.value.value = String(state2.value);
            }
          }
        } else {
          state2.hitting = false;
        }
      });
      if (control.value && hitting < 0) {
        control.value.value = lastInput;
      }
    }
    function handleSelect(value, data) {
      if (qe(value)) {
        return;
      }
      const prevValue = currentValue.value;
      currentValue.value = value;
      emitEvent(props.onSelect, value, data);
      if (value !== prevValue) {
        changed = true;
        handleChange();
      } else {
        visible.value = false;
      }
    }
    function handleInput(event) {
      const value = typeof event === "string" ? event : event.target.value;
      visible.value = !props.dropDisabled;
      currentValue.value = value;
      changed = true;
      lastInput = value;
      if (currentIndex.value !== -1) {
        currentIndex.value = 0;
      }
      emitEvent(props.onInput, value);
    }
    function handleChange() {
      if (!changed || currentValue.value === lastValue)
        return;
      changed = false;
      lastValue = currentValue.value;
      lastInput = String(lastValue);
      const option = optionStates.value.find((option2) => option2.value === lastValue);
      setFieldValue(currentValue.value);
      emitEvent(props.onChange, currentValue.value, (option == null ? void 0 : option.data) || null);
      emit("update:value", currentValue.value);
      validateField();
      visible.value = false;
      if (control.value) {
        control.value.value = String(lastValue);
        control.value.blur();
      }
    }
    function handleToggle() {
      testOptionCanDrop();
      emitEvent(props.onToggle, visible.value);
      if (!visible.value) {
        currentIndex.value = -1;
      }
    }
    function testOptionCanDrop() {
      if (!filteredOptions.value.length || props.dropDisabled) {
        visible.value = false;
      }
    }
    function handleKeyDown(event) {
      const key = event.code || event.key;
      if (key === "ArrowDown" || key === "ArrowUp") {
        event.preventDefault();
        event.stopPropagation();
        const options = filteredOptions.value;
        const length = options.length;
        if (!length)
          return;
        const step = key === "ArrowDown" ? 1 : -1;
        let index = (currentIndex.value + step) % length;
        let option = options[index];
        for (let i = 0; (option.disabled || option.group) && i < length; ++i) {
          index += step;
          index = (index + length) % length;
          option = options[index];
        }
        currentIndex.value = index;
      } else {
        if (["Space", " "].includes(key)) {
          event.stopPropagation();
        }
        if (!["Enter", "ArrowLeft", "ArrowRight"].includes(key)) {
          currentIndex.value = -1;
        }
      }
    }
    function handleEnter() {
      var _a;
      if (filteredOptions.value.length) {
        const option = filteredOptions.value[currentIndex.value === -1 ? 0 : currentIndex.value];
        handleSelect(option.value, option.data);
      } else {
        handleChange();
      }
      emitEvent(props.onEnter, currentValue.value);
      (_a = control.value) == null ? void 0 : _a.blur();
      visible.value = false;
    }
    function handleClear() {
      if (props.clearable) {
        const prevValue = currentValue.value;
        currentValue.value = "";
        visible.value = false;
        if (!qe(prevValue) && prevValue !== currentValue.value) {
          changed = true;
        }
        handleChange();
        emitEvent(props.onClear);
        nextTick(clearField);
      }
    }
    return {
      props,
      nh,
      locale: useLocale("input"),
      idFor,
      currentValue,
      currentIndex,
      visible,
      hasPrefix,
      hasSuffix,
      select,
      control,
      handleSelect,
      handleInput,
      handleChange,
      handleToggle,
      handleKeyDown,
      handleEnter,
      handleClear
    };
  }
});
var _hoisted_14 = ["autofocus", "spellcheck", "disabled", "placeholder", "readonly"];
function _sfc_render10(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Select = resolveComponent("Select");
  return openBlock(), createBlock(_component_Select, {
    id: _ctx.idFor,
    ref: "select",
    visible: _ctx.visible,
    "onUpdate:visible": _cache[3] || (_cache[3] = ($event) => _ctx.visible = $event),
    class: normalizeClass(_ctx.nh.b()),
    inherit: _ctx.props.inherit,
    "list-class": _ctx.nh.be("list"),
    value: _ctx.currentValue,
    size: _ctx.props.size,
    state: _ctx.props.state,
    clearable: _ctx.props.clearable,
    "transition-name": _ctx.props.transitionName,
    disabled: _ctx.props.disabled,
    transfer: _ctx.props.transfer,
    placement: _ctx.props.placement,
    "prefix-color": _ctx.props.prefixColor,
    "suffix-color": _ctx.props.suffixColor,
    "no-suffix": !_ctx.hasSuffix,
    placeholder: _ctx.props.placeholder,
    options: _ctx.props.options,
    "key-config": _ctx.props.keyConfig,
    loading: _ctx.props.loading,
    "loading-icon": _ctx.props.loadingIcon,
    "loading-lock": _ctx.props.loadingLock,
    "loading-spin": _ctx.props.loadingSpin,
    transparent: _ctx.transparent,
    onToggle: _ctx.handleToggle,
    onSelect: _ctx.handleSelect,
    onClear: _ctx.handleClear,
    onFocus: _cache[4] || (_cache[4] = ($event) => {
      var _a;
      return (_a = _ctx.control) == null ? void 0 : _a.focus();
    }),
    onBlur: _cache[5] || (_cache[5] = ($event) => {
      var _a;
      return (_a = _ctx.control) == null ? void 0 : _a.blur();
    }),
    onOutsideClose: _ctx.handleChange
  }, createSlots({
    control: withCtx(() => [
      renderSlot(_ctx.$slots, "control", {
        value: _ctx.currentValue,
        onInput: _ctx.handleInput,
        onChange: _ctx.handleChange,
        onEnter: _ctx.handleEnter,
        onClear: _ctx.handleClear
      }, () => {
        var _a;
        return [
          createBaseVNode("input", {
            ref: "control",
            class: normalizeClass(_ctx.nh.be("input")),
            autofocus: _ctx.props.autofocus,
            spellcheck: _ctx.props.spellcheck,
            disabled: _ctx.props.disabled,
            placeholder: (_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder,
            readonly: _ctx.props.loading && _ctx.props.loadingLock,
            autocomplete: "off",
            tabindex: "-1",
            role: "combobox",
            "aria-autocomplete": "list",
            onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys((...args) => _ctx.handleEnter && _ctx.handleEnter(...args), ["enter"])),
              _cache[2] || (_cache[2] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
            ]
          }, null, 42, _hoisted_14)
        ];
      })
    ]),
    default: withCtx(({ option, index, selected }) => [
      renderSlot(_ctx.$slots, "default", {
        option,
        index,
        selected
      })
    ]),
    group: withCtx(({ option, index }) => [
      renderSlot(_ctx.$slots, "group", {
        option,
        index
      })
    ]),
    _: 2
  }, [
    _ctx.hasPrefix ? {
      name: "prefix",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ]),
      key: "0"
    } : void 0,
    _ctx.hasSuffix ? {
      name: "suffix",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.suffix
          }, null, 8, ["icon"])
        ])
      ]),
      key: "1"
    } : void 0
  ]), 1032, ["id", "visible", "class", "inherit", "list-class", "value", "size", "state", "clearable", "transition-name", "disabled", "transfer", "placement", "prefix-color", "suffix-color", "no-suffix", "placeholder", "options", "key-config", "loading", "loading-icon", "loading-lock", "loading-spin", "transparent", "onToggle", "onSelect", "onClear", "onOutsideClose"]);
}
var AutoComplete = _export_sfc(_sfc_main10, [["render", _sfc_render10]]);

// node_modules/vexip-ui/es/components/avatar/props.mjs
var avatarProps = buildProps({
  size: [Number, String],
  src: String,
  icon: Object,
  circle: booleanProp,
  alt: String,
  fit: String,
  srcSet: String,
  gap: Number,
  iconScale: Number,
  fallbackSrc: String,
  color: String,
  background: String,
  onError: eventProp(),
  onClick: eventProp()
});
var avatarGroupProps = buildProps({
  size: [Number, String],
  options: Object,
  circle: booleanProp,
  max: Number,
  showTip: booleanProp,
  tipTrigger: String,
  vertical: booleanProp,
  offset: Number,
  restColor: String,
  restBackground: String
});

// node_modules/vexip-ui/es/components/avatar/symbol.mjs
var GROUP_STATE = Symbol("GROUP_STATE");

// node_modules/vexip-ui/es/components/avatar/avatar.mjs
var objectFitValues = Object.freeze(["fill", "contain", "cover", "none", "scale-down"]);
var _sfc_main11 = defineComponent({
  name: "Avatar",
  components: {
    Icon,
    ResizeObserver
  },
  props: avatarProps,
  emits: [],
  setup(_props) {
    const props = useProps("avatar", _props, {
      size: "default",
      src: {
        default: "",
        static: true
      },
      icon: null,
      circle: false,
      alt: "",
      fit: {
        default: "cover",
        validator: (value) => objectFitValues.includes(value)
      },
      srcSet: "",
      gap: 4,
      iconScale: 1.4,
      fallbackSrc: "",
      color: null,
      background: null
    });
    const groupState = inject(GROUP_STATE, null);
    const nh = useNameHelper("avatar");
    const loadFail = ref(false);
    const fallbackFail = ref(false);
    const wrapper = ref();
    const text = ref();
    const size = computed(() => {
      var _a;
      return (_a = groupState == null ? void 0 : groupState.size) != null ? _a : props.size;
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(size.value)]: typeof size.value !== "number" && size.value !== "default",
        [nh.bm("circle")]: props.circle
      };
    });
    const style = computed(() => {
      const style2 = {
        [nh.cv("color")]: props.color,
        [nh.cv("bg-color")]: props.background,
        [nh.cv("image-fit")]: props.fit
      };
      if (typeof size.value === "number") {
        style2[nh.cv("size")] = `${size.value}px`;
      }
      return style2;
    });
    watch(
      () => props.src,
      () => {
        loadFail.value = false;
        fallbackFail.value = false;
        scaleText();
      }
    );
    watch(
      () => props.fallbackSrc,
      () => {
        fallbackFail.value = false;
        scaleText();
      }
    );
    watch(() => props.gap, scaleText);
    function handleError(event) {
      loadFail.value = true;
      emitEvent(props.onError, event);
    }
    let lastText = null;
    function scaleText() {
      const avatarEl = wrapper.value;
      const textEl = text.value;
      if (avatarEl && textEl && (lastText === null || lastText !== textEl.textContent)) {
        lastText = textEl.textContent;
        const { offsetWidth: avatarWidth, offsetHeight: avatarHeight } = avatarEl;
        const { offsetWidth: textWidth, offsetHeight: textHeight } = textEl;
        const padding = props.gap * 2;
        const ratio = Math.min(
          (avatarWidth - padding) / (textWidth || 1),
          (avatarHeight - padding) / (textHeight || 1),
          1
        );
        textEl.style.transform = `scale(${ratio})`;
      }
    }
    function handleClick(event) {
      emitEvent(props.onClick, event);
    }
    return {
      props,
      nh,
      loadFail,
      fallbackFail,
      wrapper,
      text,
      className,
      style,
      handleError,
      scaleText,
      handleClick
    };
  }
});
var _hoisted_15 = ["src", "alt", "srcset"];
var _hoisted_22 = ["src", "alt"];
function _sfc_render11(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.style),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    (_ctx.props.src || _ctx.props.srcSet) && !_ctx.loadFail ? (openBlock(), createElementBlock("img", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("image")),
      src: _ctx.props.src,
      alt: _ctx.props.alt,
      srcset: _ctx.props.srcSet,
      onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args))
    }, null, 42, _hoisted_15)) : _ctx.loadFail && _ctx.props.fallbackSrc && !_ctx.fallbackFail ? (openBlock(), createElementBlock("img", {
      key: 1,
      class: normalizeClass(_ctx.nh.be("image")),
      src: _ctx.props.fallbackSrc,
      alt: _ctx.props.alt,
      onError: _cache[1] || (_cache[1] = ($event) => _ctx.fallbackFail = true)
    }, null, 42, _hoisted_22)) : _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
      key: 2,
      class: normalizeClass(_ctx.nh.be("icon")),
      icon: _ctx.icon,
      scale: _ctx.props.iconScale
    }, null, 8, ["class", "icon", "scale"])) : (openBlock(), createBlock(_component_ResizeObserver, {
      key: 3,
      "on-resize": _ctx.scaleText
    }, {
      default: withCtx(() => [
        createBaseVNode("span", {
          ref: "text",
          class: normalizeClass(_ctx.nh.be("text"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 8, ["on-resize"]))
  ], 6);
}
var Avatar = _export_sfc(_sfc_main11, [["render", _sfc_render11]]);

// node_modules/vexip-ui/es/components/avatar/avatar-group.mjs
var _sfc_main12 = defineComponent({
  name: "AvatarGroup",
  components: {
    Avatar,
    Tooltip
  },
  props: avatarGroupProps,
  setup(_props) {
    const props = useProps("avatarGroup", _props, {
      size: "default",
      options: {
        default: () => [],
        static: true
      },
      circle: false,
      max: null,
      showTip: false,
      tipTrigger: "hover",
      vertical: false,
      offset: null,
      restColor: null,
      restBackground: null
    });
    const nh = useNameHelper("avatar-group");
    const renderAvatars = ref([]);
    const restAvatars = ref([]);
    watchEffect(() => {
      const size = props.options.length;
      if (props.max > 0 && size > props.max) {
        renderAvatars.value = props.options.slice(0, props.max - 1);
        restAvatars.value = props.options.slice(props.max - 1);
      } else {
        renderAvatars.value = Array.from(props.options);
        restAvatars.value = [];
      }
    });
    provide(GROUP_STATE, props);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("avatar-vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.size)]: typeof props.size !== "number" && props.size !== "default",
        [nh.bm("circle")]: props.circle,
        [nh.bm("vertical")]: props.vertical
      };
    });
    const style = computed(() => {
      const style2 = {};
      if (typeof props.offset === "number") {
        style2[nh.cv("offset")] = `${props.offset}px`;
      }
      return style2;
    });
    return {
      props,
      nh,
      renderAvatars,
      restAvatars,
      className,
      style
    };
  }
});
function _sfc_render12(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Avatar = resolveComponent("Avatar");
  const _component_Tooltip = resolveComponent("Tooltip");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "group",
    style: normalizeStyle(_ctx.style)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderAvatars, (option, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: normalizeClass(_ctx.nh.be("item"))
      }, [
        renderSlot(_ctx.$slots, "default", {
          option,
          index
        }, () => [
          createVNode(_component_Avatar, {
            inherit: "",
            src: option.src,
            icon: option.icon,
            alt: option.alt,
            fit: option.fit,
            "src-set": option.srcSet,
            gap: option.gap,
            "icon-scale": option.iconScale,
            "fallback-src": option.fallbackSrc
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(option.text), 1)
            ]),
            _: 2
          }, 1032, ["src", "icon", "alt", "fit", "src-set", "gap", "icon-scale", "fallback-src"])
        ])
      ], 2);
    }), 128)),
    _ctx.restAvatars.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("item"), _ctx.nh.bem("item", "rest")])
    }, [
      _ctx.props.showTip ? (openBlock(), createBlock(_component_Tooltip, {
        key: 0,
        inherit: "",
        trigger: _ctx.props.tipTrigger,
        "tip-class": _ctx.nh.be("rest")
      }, {
        trigger: withCtx(() => [
          renderSlot(_ctx.$slots, "rest", {
            options: _ctx.restAvatars,
            count: _ctx.restAvatars.length
          }, () => [
            createVNode(_component_Avatar, {
              inherit: "",
              color: _ctx.props.restColor,
              background: _ctx.props.restBackground
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(`+${_ctx.restAvatars.length}`), 1)
              ]),
              _: 1
            }, 8, ["color", "background"])
          ])
        ]),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "tip", {
            options: _ctx.restAvatars,
            count: _ctx.restAvatars.length
          }, () => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.restAvatars, (option, index) => {
              return openBlock(), createBlock(_component_Avatar, {
                key: index,
                inherit: "",
                src: option.src,
                icon: option.icon,
                alt: option.alt,
                fit: option.fit,
                "src-set": option.srcSet,
                gap: option.gap,
                "icon-scale": option.iconScale,
                "fallback-src": option.fallbackSrc
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(option.text), 1)
                ]),
                _: 2
              }, 1032, ["src", "icon", "alt", "fit", "src-set", "gap", "icon-scale", "fallback-src"]);
            }), 128))
          ])
        ]),
        _: 3
      }, 8, ["trigger", "tip-class"])) : renderSlot(_ctx.$slots, "rest", {
        key: 1,
        options: _ctx.restAvatars,
        count: _ctx.restAvatars.length
      }, () => [
        createVNode(_component_Avatar, {
          inherit: "",
          color: _ctx.props.restColor,
          background: _ctx.props.restBackground
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(`+${_ctx.restAvatars.length}`), 1)
          ]),
          _: 1
        }, 8, ["color", "background"])
      ])
    ], 2)) : createCommentVNode("", true)
  ], 6);
}
var AvatarGroup = _export_sfc(_sfc_main12, [["render", _sfc_render12]]);

// node_modules/vexip-ui/es/components/badge/props.mjs
var badgeProps = buildProps({
  content: [Number, String],
  max: Number,
  disabled: booleanProp,
  isDot: booleanProp,
  type: String,
  color: String,
  onBadgeClick: eventProp()
});

// node_modules/vexip-ui/es/components/badge/badge.mjs
var badgeTypes = Object.freeze([
  "error",
  "primary",
  "success",
  "warning",
  "info",
  "disabled"
]);
var _sfc_main13 = defineComponent({
  name: "Badge",
  props: badgeProps,
  emits: [],
  setup(_props, { slots }) {
    const props = useProps("badge", _props, {
      content: {
        default: null,
        static: true
      },
      max: 0,
      disabled: false,
      isDot: false,
      type: {
        default: "error",
        validator: (value) => badgeTypes.includes(value)
      },
      color: null
    });
    const nh = useNameHelper("badge");
    const hasSlot = computed(() => {
      return !!slots.default;
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("not-wrapper")]: !hasSlot.value,
        [nh.bm("is-dot")]: props.isDot
      };
    });
    const renderContent = computed(() => {
      if (props.isDot)
        return "";
      if (typeof props.content === "number" && props.max > 0) {
        return props.content > props.max ? `${props.max}+` : props.content;
      }
      return props.content;
    });
    const transitionName = computed(() => {
      return hasSlot.value ? nh.bs("badge-zoom") : nh.bs("zoom");
    });
    const title = computed(() => {
      return props.content || props.content === 0 ? props.content.toString() : void 0;
    });
    const showSub = computed(() => {
      return !props.disabled && (props.content || props.content === 0 || props.isDot);
    });
    function handleBadgeClick(event) {
      emitEvent(props.onBadgeClick, event);
    }
    return {
      props,
      nh,
      hasSlot,
      className,
      renderContent,
      transitionName,
      title,
      showSub,
      handleBadgeClick
    };
  }
});
var _hoisted_16 = ["title"];
function _sfc_render13(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className)
  }, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(Transition, { name: _ctx.transitionName }, {
      default: withCtx(() => [
        withDirectives(createBaseVNode("sup", {
          class: normalizeClass({
            [_ctx.nh.be("content")]: true,
            [_ctx.nh.bem("content", "fixed")]: _ctx.hasSlot,
            [_ctx.nh.bem("content", _ctx.props.type)]: _ctx.props.type !== "error"
          }),
          style: normalizeStyle({ backgroundColor: _ctx.props.color }),
          title: _ctx.title,
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleBadgeClick && _ctx.handleBadgeClick(...args))
        }, [
          renderSlot(_ctx.$slots, "content", {}, () => [
            createTextVNode(toDisplayString(_ctx.renderContent), 1)
          ])
        ], 14, _hoisted_16), [
          [vShow, _ctx.showSub]
        ])
      ]),
      _: 3
    }, 8, ["name"])
  ], 2);
}
var Badge = _export_sfc(_sfc_main13, [["render", _sfc_render13]]);

// node_modules/vexip-ui/es/components/breadcrumb/symbol.mjs
var BREADCRUMB_STATE = Symbol("BREADCRUMB_STATE");

// node_modules/vexip-ui/es/components/breadcrumb/breadcrumb-item.mjs
var _sfc_main14 = defineComponent({
  name: "BreadcrumbItem",
  components: {
    Renderer
  },
  props: {
    label: {
      type: [String, Number],
      default: null
    },
    onSelect: eventProp(),
    onSeparatorClick: eventProp()
  },
  emits: [],
  setup(props) {
    const breadcrumbState = inject(BREADCRUMB_STATE, null);
    const currentLabel = ref(props.label);
    const separator = ref("/");
    const separatorRenderer = ref(null);
    watch(
      () => props.label,
      (value) => {
        currentLabel.value = value;
        breadcrumbState == null ? void 0 : breadcrumbState.refreshLabels();
      }
    );
    if (breadcrumbState) {
      const state = reactive({
        label: currentLabel
      });
      watch(
        () => breadcrumbState.separator,
        (value) => {
          separator.value = value;
        },
        { immediate: true }
      );
      watch(
        () => breadcrumbState.separatorRenderer,
        (value) => {
          separatorRenderer.value = value;
        },
        { immediate: true }
      );
      breadcrumbState.increaseItem(state);
      onBeforeUnmount(() => {
        breadcrumbState.decreaseItem(state);
      });
    }
    function handleClick() {
      emitEvent(props.onSelect, currentLabel.value);
      breadcrumbState == null ? void 0 : breadcrumbState.handleSelect(currentLabel.value);
    }
    function handleSeparatorClick() {
      emitEvent(props.onSeparatorClick, currentLabel.value);
      breadcrumbState == null ? void 0 : breadcrumbState.handleSeparatorClick(currentLabel.value);
    }
    return {
      nh: useNameHelper("breadcrumb"),
      currentLabel,
      separator,
      separatorRenderer,
      isFunction: gt,
      handleClick,
      handleSeparatorClick
    };
  }
});
function _sfc_render14(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.nh.be("item"))
  }, [
    createBaseVNode("a", {
      class: normalizeClass(_ctx.nh.be("label")),
      tabindex: "0",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
      onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["enter"]))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 34),
    createBaseVNode("span", {
      class: normalizeClass(_ctx.nh.be("separator")),
      role: "separator",
      onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleSeparatorClick && _ctx.handleSeparatorClick(...args))
    }, [
      renderSlot(_ctx.$slots, "separator", {}, () => [
        _ctx.isFunction(_ctx.separatorRenderer) ? (openBlock(), createBlock(_component_Renderer, {
          key: 0,
          renderer: _ctx.separatorRenderer,
          data: { label: _ctx.currentLabel }
        }, null, 8, ["renderer", "data"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(_ctx.separator), 1)
        ], 64))
      ])
    ], 2)
  ], 2);
}
var BreadcrumbItem = _export_sfc(_sfc_main14, [["render", _sfc_render14]]);

// node_modules/vexip-ui/es/components/breadcrumb/props.mjs
var breadcrumbProps = buildProps({
  separator: String,
  border: booleanProp,
  options: Array,
  onSelect: eventProp(),
  onSeparatorClick: eventProp()
});

// node_modules/vexip-ui/es/components/breadcrumb/breadcrumb.mjs
var _sfc_main15 = defineComponent({
  name: "Breadcrumb",
  components: {
    BreadcrumbItem
  },
  props: breadcrumbProps,
  emits: [],
  setup(_props, { slots }) {
    const props = useProps("breadcrumb", _props, {
      separator: "/",
      border: false,
      options: {
        default: () => [],
        static: true
      }
    });
    const nh = useNameHelper("breadcrumb");
    const itemStates = /* @__PURE__ */ new Set();
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("border")]: props.border
      };
    });
    const normalizedOptions = computed(() => {
      return props.options.map((option) => {
        if (typeof option === "string") {
          return { label: option };
        }
        return option;
      });
    });
    const refreshLabels = Mr(() => {
      Array.from(itemStates).forEach((item, index) => {
        if (qe(item.label)) {
          item.label = index + 1;
        }
      });
    });
    const state = reactive({
      separator: toRef(props, "separator"),
      separatorRenderer: null,
      increaseItem,
      decreaseItem,
      handleSelect,
      refreshLabels,
      handleSeparatorClick
    });
    provide(BREADCRUMB_STATE, state);
    watch(
      () => slots.separator,
      (value) => {
        state.separatorRenderer = value ? (data) => value(data) : null;
      },
      { immediate: true }
    );
    function increaseItem(item) {
      itemStates.add(item);
      refreshLabels();
    }
    function decreaseItem(item) {
      itemStates.delete(item);
      refreshLabels();
    }
    function handleSelect(label) {
      emitEvent(props.onSelect, label);
    }
    function handleSeparatorClick(label) {
      emitEvent(props.onSeparatorClick, label);
    }
    return {
      props,
      className,
      normalizedOptions,
      callIfFunc: Fr
    };
  }
});
function _sfc_render15(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BreadcrumbItem = resolveComponent("BreadcrumbItem");
  return openBlock(), createElementBlock("ol", {
    class: normalizeClass(_ctx.className)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.normalizedOptions, (option) => {
        return openBlock(), createBlock(_component_BreadcrumbItem, {
          key: option.label,
          label: option.label
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(option.name ? _ctx.callIfFunc(option.name) : option.label), 1)
          ]),
          _: 2
        }, 1032, ["label"]);
      }), 128))
    ])
  ], 2);
}
var Breadcrumb = _export_sfc(_sfc_main15, [["render", _sfc_render15]]);

// node_modules/vexip-ui/es/components/bubble/props.mjs
var bubbleProps = buildProps({
  placement: String,
  background: String,
  shadow: booleanStringProp,
  contentClass: classProp
});

// node_modules/vexip-ui/es/components/bubble/bubble.mjs
var _sfc_main16 = defineComponent({
  name: "Bubble",
  props: bubbleProps,
  setup(_props) {
    const props = useProps("bubble", _props, {
      placement: {
        default: "right",
        validator: (value) => Wo.includes(value)
      },
      background: "",
      shadow: false,
      contentClass: null
    });
    const nh = useNameHelper("bubble");
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(props.placement),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("background")]: props.background,
          [nh.bm("shadow")]: props.shadow
        }
      ];
    });
    const contentStyle = computed(() => {
      const style = {
        backgroundColor: props.background
      };
      if (typeof props.shadow === "string") {
        style.boxShadow = `0 0 4px ${props.shadow}`;
      }
      return style;
    });
    const arrowStyle = computed(() => {
      const position = props.placement.split("-").shift();
      return {
        [`border-${position}-color`]: props.background
      };
    });
    return {
      props,
      nh,
      className,
      contentStyle,
      arrowStyle
    };
  }
});
function _sfc_render16(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className)
  }, [
    createBaseVNode("div", {
      class: normalizeClass([_ctx.nh.be("content"), _ctx.props.contentClass]),
      style: normalizeStyle(_ctx.contentStyle)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("arrow")),
        style: normalizeStyle(_ctx.arrowStyle)
      }, null, 6),
      renderSlot(_ctx.$slots, "default")
    ], 6)
  ], 2);
}
var Bubble = _export_sfc(_sfc_main16, [["render", _sfc_render16]]);

// node_modules/vexip-ui/es/components/button/props.mjs
var buttonProps = buildProps({
  size: sizeProp,
  type: String,
  dashed: booleanProp,
  text: booleanProp,
  simple: booleanProp,
  ghost: booleanProp,
  disabled: booleanProp,
  loading: booleanProp,
  circle: booleanProp,
  loadingIcon: Object,
  loadingSpin: booleanProp,
  icon: Object,
  color: String,
  buttonType: String,
  block: booleanProp,
  tag: String,
  noPulse: booleanProp,
  badge: [String, Number],
  onClick: eventProp()
});
var buttonGroupProps = buildProps({
  size: sizeProp,
  type: String,
  circle: booleanProp
});

// node_modules/vexip-ui/es/components/button/symbol.mjs
var GROUP_STATE2 = Symbol("GROUP_STATE");
var buttonTypes = Object.freeze(["default", "primary", "info", "success", "warning", "error"]);

// node_modules/vexip-ui/es/components/button/button.mjs
var Button = defineComponent({
  name: "Button",
  props: buttonProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const fieldActions = inject(FIELD_OPTIONS, null);
    const props = useProps("button", _props, {
      size: createSizeProp(fieldActions ? fieldActions.size : void 0),
      type: {
        default: null,
        validator: (value) => buttonTypes.includes(value)
      },
      dashed: false,
      text: false,
      simple: false,
      ghost: false,
      disabled: () => fieldActions ? fieldActions.disabled.value : false,
      loading: () => fieldActions ? fieldActions.loading.value : false,
      circle: false,
      loadingIcon: h4,
      loadingSpin: false,
      icon: null,
      color: null,
      buttonType: {
        default: "button",
        validator: (value) => ["button", "submit", "reset"].includes(value)
      },
      block: false,
      tag: "button",
      noPulse: false,
      badge: null
    });
    const groupState = inject(GROUP_STATE2, null);
    const nh = useNameHelper("button");
    const pulsing = ref(false);
    const isIconOnly = computed(() => {
      return !slots.default;
    });
    const type = computed(() => {
      var _a, _b;
      return (_b = (_a = props.type) != null ? _a : groupState == null ? void 0 : groupState.type) != null ? _b : "default";
    });
    const size = computed(() => {
      var _a;
      return (_a = groupState == null ? void 0 : groupState.size) != null ? _a : props.size;
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(type.value)]: type.value !== "default",
        [nh.bm("simple")]: !props.ghost && props.simple,
        [nh.bm("ghost")]: props.ghost,
        [nh.bm("text")]: props.text,
        [nh.bm("dashed")]: props.dashed,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("loading")]: props.loading,
        [nh.bm("circle")]: props.circle,
        [nh.bm("icon-only")]: isIconOnly.value,
        [nh.bm(size.value)]: size.value !== "default",
        [nh.bm("pulsing")]: pulsing.value
      };
    });
    const colorMap = computed(() => {
      if (props.color) {
        const rootStyle2 = getComputedStyle(document.documentElement);
        const black = N(rootStyle2.getPropertyValue(nh.nv("color-black")) || "#000");
        const white = N(rootStyle2.getPropertyValue(nh.nv("color-white")) || "#fff");
        const baseColor = N(props.color);
        return {
          base: baseColor.toString(),
          light2: bn(white, baseColor, 0.2).toString(),
          dark1: bn(black, baseColor, 0.1).toString(),
          opacity1: yn(baseColor, 0.9).toString(),
          opacity3: yn(baseColor, 0.7).toString(),
          opacity4: yn(baseColor, 0.6).toString(),
          opacity7: yn(baseColor, 0.3).toString(),
          opacity8: yn(baseColor, 0.2).toString(),
          white8: yn(white, 0.2).toString(),
          white9: yn(white, 0.1).toString()
        };
      }
      return null;
    });
    const style = computed(() => {
      if (colorMap.value) {
        const {
          base,
          light2,
          dark1,
          opacity1,
          opacity3,
          opacity4,
          opacity7,
          opacity8,
          white8,
          white9
        } = colorMap.value;
        const {
          cvm,
          gnv
        } = nh;
        if (props.ghost) {
          return cvm({
            color: base,
            "color-hover": base,
            "color-focus": base,
            "color-active": base,
            "color-disabled": base,
            "bg-color": "transparent",
            "bg-color-hover": white9,
            "bg-color-focus": white9,
            "bg-color-active": white8,
            "bg-color-disabled": "transparent",
            "b-color": base,
            "b-color-hover": light2,
            "b-color-focus": light2,
            "b-color-active": dark1,
            "b-color-disabled": gnv("content-color-disabled"),
            "pulse-s-color": dark1
          });
        }
        if (props.simple) {
          return cvm({
            color: base,
            "color-hover": base,
            "color-focus": gnv("color-white"),
            "color-active": gnv("color-white"),
            "color-disabled": gnv("content-color-disabled"),
            "bg-color": opacity8,
            "bg-color-hover": opacity7,
            "bg-color-focus": opacity1,
            "bg-color-active": opacity1,
            "bg-color-disabled": gnv("fill-color-background"),
            "b-color": opacity4,
            "b-color-hover": opacity4,
            "b-color-focus": opacity3,
            "b-color-active": opacity3,
            "b-color-disabled": gnv("border-color-light-1"),
            "pulse-s-color": dark1
          });
        }
        if (props.text || props.dashed) {
          return cvm({
            ...props.dashed ? {
              "b-color": base,
              "b-color-hover": light2,
              "b-color-focus": light2,
              "b-color-active": dark1,
              "pulse-s-color": dark1
            } : {},
            color: base,
            "color-hover": light2,
            "color-focus": light2,
            "color-active": dark1,
            "color-disabled": opacity4
          });
        }
        return cvm({
          color: gnv("color-white"),
          "color-hover": gnv("color-white"),
          "color-focus": gnv("color-white"),
          "color-active": gnv("color-white"),
          "color-disabled": gnv("content-color-disabled"),
          "bg-color": base,
          "bg-color-hover": light2,
          "bg-color-focus": light2,
          "bg-color-active": dark1,
          "bg-color-disabled": gnv("fill-color-background"),
          "b-color": base,
          "b-color-hover": light2,
          "b-color-focus": light2,
          "b-color-active": dark1,
          "b-color-disabled": gnv("border-color-light-1"),
          "pulse-s-color": dark1
        });
      }
      return {};
    });
    function handleClick(event) {
      if (props.disabled || props.loading || event.button)
        return;
      if (!props.noPulse) {
        pulsing.value = false;
        requestAnimationFrame(() => {
          pulsing.value = true;
        });
      }
      emitEvent(props.onClick, event);
    }
    function handleAnimationEnd() {
      pulsing.value = false;
    }
    function renderLoadingIcon() {
      return createVNode("div", {
        "class": [nh.be("icon"), nh.bem("icon", "loading")]
      }, [slots.loading ? slots.loading() : props.loadingSpin ? createVNode(Icon, {
        "spin": true,
        "icon": props.loadingIcon
      }, null) : createVNode(Icon, {
        "pulse": true,
        "icon": props.loadingIcon
      }, null)]);
    }
    function renderSingleIcon() {
      return props.loading ? renderLoadingIcon() : createVNode("div", {
        "class": nh.be("icon")
      }, [slots.icon ? slots.icon() : props.icon ? createVNode(Icon, {
        "icon": props.icon
      }, null) : null]);
    }
    function renderCollapseIcon() {
      if (props.icon || slots.icon) {
        return props.loading ? renderLoadingIcon() : createVNode("div", {
          "class": nh.be("icon")
        }, [slots.icon ? slots.icon() : createVNode(Icon, {
          "icon": props.icon
        }, null)]);
      }
      return createVNode(CollapseTransition, {
        "appear": true,
        "horizontal": true,
        "fade-effect": true
      }, {
        default: () => [props.loading && renderLoadingIcon()]
      });
    }
    function renderBadge() {
      const badgeType = props.disabled ? "disabled" : props.type === "default" ? "error" : props.type;
      return createVNode(Badge, {
        "inherit": true,
        "class": [nh.be("badge"), nh.bem("badge", badgeType)],
        "content": props.badge,
        "type": badgeType
      }, null);
    }
    return () => {
      const Button2 = props.tag || "button";
      return createVNode(Button2, {
        "type": props.buttonType,
        "class": className.value,
        "role": "button",
        "style": style.value,
        "disabled": props.disabled,
        "onClick": handleClick,
        "onAnimationend": handleAnimationEnd
      }, {
        default: () => [isIconOnly.value ? renderSingleIcon() : renderCollapseIcon(), !isIconOnly.value && slots.default ? slots.default() : null, !isIconOnly.value && (props.badge || props.badge === 0) ? renderBadge() : null]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/button/button-group.mjs
var _sfc_main17 = defineComponent({
  name: "ButtonGroup",
  props: buttonGroupProps,
  setup(_props) {
    const props = useProps("buttonGroup", _props, {
      size: null,
      type: {
        default: "default",
        validator: (value) => buttonTypes.includes(value)
      },
      circle: false
    });
    const nh = useNameHelper("button-group");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("circle")]: props.circle
      };
    });
    provide(GROUP_STATE2, props);
    return {
      className
    };
  }
});
function _sfc_render17(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "group"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var ButtonGroup = _export_sfc(_sfc_main17, [["render", _sfc_render17]]);

// node_modules/vexip-ui/es/components/calendar/props.mjs
var calendarProps = buildProps({
  value: [Number, String, Date],
  year: Number,
  month: Number,
  weekDays: Array,
  weekStart: Number,
  today: [Number, String, Date],
  disabledDate: Function,
  onSelect: eventProp()
});
var calendarPanelProps = buildProps({
  value: [Number, String, Date, Array],
  year: Number,
  month: Number,
  weekDays: Array,
  weekStart: Number,
  today: [Number, String, Date],
  disabledDate: Function,
  isRange: booleanProp,
  valueType: String,
  min: [Number, String, Date],
  max: [Number, String, Date],
  onSelect: eventProp(),
  onHover: eventProp()
});

// node_modules/vexip-ui/es/components/calendar/calendar-panel.mjs
var _sfc_main18 = defineComponent({
  name: "CalendarPanel",
  props: calendarPanelProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const props = useProps("calendarBase", _props, {
      value: {
        default: null,
        static: true
      },
      year: () => new Date().getFullYear(),
      month: {
        default: () => new Date().getMonth() + 1,
        validator: (value) => value > 0 && value <= 12
      },
      weekDays: {
        default: null,
        validator: (value) => !value || value.length === 0 || value.length === 7
      },
      weekStart: {
        default: 0,
        validator: (value) => value >= 0 && value < 7
      },
      today: {
        default: () => new Date(),
        validator: (value) => !Number.isNaN(+new Date(value))
      },
      disabledDate: {
        default: fn,
        isFunc: true
      },
      isRange: false,
      valueType: {
        default: "start",
        validator: (value) => value === "start" || value === "end"
      },
      min: null,
      max: null
    });
    const startValue = ref(null);
    const endValue = ref(null);
    const dateRange = ref([]);
    const hoveredDate = ref(null);
    const { wrapper, isHover } = Co();
    const locale = useLocale("calendar");
    const min = computed(() => props.min ? +ft(props.min) : -Infinity);
    const max = computed(() => props.max ? +Yn(props.max) : Infinity);
    const reversed = computed(() => {
      if (Number.isNaN(min.value) || Number.isNaN(max.value)) {
        return false;
      }
      return min.value > max.value;
    });
    const updateDateRange = Mr(setDateRange);
    parseValue(props.value);
    setDateRange();
    watch(() => props.value, parseValue);
    watch(() => props.year, updateDateRange);
    watch(() => props.month, updateDateRange);
    watch(isHover, (value) => {
      if (!value) {
        hoveredDate.value = null;
      }
    });
    watch(hoveredDate, (value) => {
      emitEvent(props.onHover, value);
    });
    function getWeekLabel(index) {
      var _a;
      return ((_a = props.weekDays) == null ? void 0 : _a[index]) || locale.value[`week${index || 7}`];
    }
    function setDateRange() {
      dateRange.value = Ln(
        ut(new Date(props.year, props.month - 1, 1), props.weekStart),
        42
      );
    }
    function parseValue(value) {
      var _a;
      if (!Array.isArray(value)) {
        value = [value, value];
      }
      for (let i = 0; i < 2; ++i) {
        const date = new Date((_a = value[i]) != null ? _a : "");
        if (i === 0) {
          startValue.value = Number.isNaN(+date) ? null : date;
        } else {
          endValue.value = Number.isNaN(+date) ? null : date;
        }
        if (!props.isRange)
          break;
      }
    }
    function isSelected(date) {
      if (!date || !startValue.value && !endValue.value) {
        return false;
      }
      return !!(startValue.value && !me(date, startValue.value) || endValue.value && !me(date, endValue.value));
    }
    function disabledDate(date) {
      if (typeof props.disabledDate === "function") {
        if (props.disabledDate(date)) {
          return true;
        }
      }
      const time = date.getTime();
      if (reversed.value) {
        if (time > max.value && time < min.value) {
          return true;
        }
      } else {
        if (time < min.value || time > max.value) {
          return true;
        }
      }
      return false;
    }
    function isDisabled(date) {
      if (!props.isRange) {
        return disabledDate(date);
      }
      if (props.valueType === "end" && startValue.value && me(startValue.value, date) < 0) {
        return true;
      }
      if (props.valueType === "start" && endValue.value && me(date, endValue.value) < 0) {
        return true;
      }
      return disabledDate(date);
    }
    function isHovered(date) {
      if (!date || !hoveredDate.value) {
        return false;
      }
      return !me(date, hoveredDate.value);
    }
    function isPrevMonth(date) {
      const { year, month } = props;
      const dateYear = date.getFullYear();
      const dateMonth = date.getMonth();
      return dateYear < year || dateYear === year && dateMonth < month - 1;
    }
    function isNextMonth(date) {
      const { year, month } = props;
      const dateYear = date.getFullYear();
      const dateMonth = date.getMonth();
      return dateYear > year || dateYear === year && dateMonth > month - 1;
    }
    function isToday(date) {
      return me(date, props.today) === 0;
    }
    function handleClick(date) {
      if (!isDisabled(date)) {
        if (props.valueType) {
          startValue.value = date;
        } else {
          endValue.value = date;
        }
        emitEvent(props.onSelect, date);
        emit("update:value", date);
      }
    }
    function handleHover(date) {
      hoveredDate.value = isDisabled(date) ? null : date;
    }
    function isInRange(date) {
      var _a;
      if (!hoveredDate.value && !startValue.value && !endValue.value) {
        return false;
      }
      let min2;
      let max2;
      if (!hoveredDate.value && startValue.value && endValue.value) {
        const startTime = startValue.value.getTime();
        const endTime = endValue.value.getTime();
        min2 = Math.min(startTime, endTime);
        max2 = Math.max(startTime, endTime);
      } else if (hoveredDate.value) {
        if (!startValue.value && !endValue.value)
          return false;
        const hoveredTime = hoveredDate.value.getTime();
        if (!startValue.value || !endValue.value) {
          const selectedTime = ((_a = startValue.value) != null ? _a : endValue.value).getTime();
          min2 = Math.min(hoveredTime, selectedTime);
          max2 = Math.max(hoveredTime, selectedTime);
        } else {
          const startTime = startValue.value.getTime();
          const endTime = endValue.value.getTime();
          const minTime = Math.min(startTime, endTime);
          const maxTime = Math.max(startTime, endTime);
          min2 = Math.min(hoveredTime, minTime);
          max2 = Math.max(hoveredTime, maxTime);
        }
      } else {
        return false;
      }
      return date.getTime() >= min2 && date.getTime() <= max2;
    }
    return {
      props,
      nh: useNameHelper("calendar"),
      startValue,
      endValue,
      dateRange,
      hoveredDate,
      body: wrapper,
      getWeekLabel,
      isSelected,
      isHovered,
      isPrevMonth,
      isNextMonth,
      isDisabled,
      isToday,
      handleClick,
      handleHover,
      isInRange
    };
  }
});
var _hoisted_17 = ["onMouseenter"];
var _hoisted_23 = ["onClick", "onKeydown"];
function _sfc_render18(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.nh.be("panel"), _ctx.nh.bs("vars"), _ctx.props.inherit && _ctx.nh.bem("panel", "inherit")])
  }, [
    renderSlot(_ctx.$slots, "header"),
    createBaseVNode("div", {
      class: normalizeClass([_ctx.nh.be("row"), _ctx.nh.bem("row", "week")])
    }, [
      (openBlock(), createElementBlock(Fragment, null, renderList(7, (week) => {
        return createBaseVNode("div", {
          key: week,
          class: normalizeClass([_ctx.nh.be("cell"), _ctx.nh.be("cell-week")])
        }, [
          renderSlot(_ctx.$slots, "week", {
            index: week - 1,
            label: _ctx.getWeekLabel((week - 1 + _ctx.props.weekStart) % 7),
            week: (week - 1 + _ctx.props.weekStart) % 7
          }, () => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.nh.be("index"))
            }, toDisplayString(_ctx.getWeekLabel((week - 1 + _ctx.props.weekStart) % 7)), 3)
          ])
        ], 2);
      }), 64))
    ], 2),
    createBaseVNode("div", {
      ref: "body",
      class: normalizeClass(_ctx.nh.be("body"))
    }, [
      (openBlock(), createElementBlock(Fragment, null, renderList(6, (row) => {
        return createBaseVNode("div", {
          key: row,
          class: normalizeClass(_ctx.nh.be("row"))
        }, [
          (openBlock(), createElementBlock(Fragment, null, renderList(7, (cell) => {
            return createBaseVNode("div", {
              key: (row - 1) * 7 + cell,
              class: normalizeClass(_ctx.nh.be("cell")),
              onMouseenter: ($event) => _ctx.handleHover(_ctx.dateRange[(row - 1) * 7 + cell - 1])
            }, [
              renderSlot(_ctx.$slots, "item", {
                selected: _ctx.isSelected(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                hovered: _ctx.isHovered(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                date: _ctx.dateRange[(row - 1) * 7 + cell - 1],
                isPrev: _ctx.isPrevMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                isNext: _ctx.isNextMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                isToday: _ctx.isToday(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                disabled: _ctx.isDisabled(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                inRange: _ctx.props.isRange && _ctx.isInRange(_ctx.dateRange[(row - 1) * 7 + cell - 1])
              }, () => [
                createBaseVNode("div", {
                  class: normalizeClass({
                    [_ctx.nh.be("index")]: true,
                    [_ctx.nh.bem("index", "selected")]: _ctx.isSelected(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "prev")]: _ctx.isPrevMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "next")]: _ctx.isNextMonth(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "today")]: _ctx.isToday(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "disabled")]: _ctx.isDisabled(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                    [_ctx.nh.bem("index", "in-range")]: _ctx.props.isRange && _ctx.isInRange(_ctx.dateRange[(row - 1) * 7 + cell - 1])
                  }),
                  tabindex: "0",
                  onClick: ($event) => _ctx.handleClick(_ctx.dateRange[(row - 1) * 7 + cell - 1]),
                  onKeydown: [
                    withKeys(withModifiers(($event) => _ctx.handleClick(_ctx.dateRange[(row - 1) * 7 + cell - 1]), ["prevent"]), ["enter"]),
                    withKeys(withModifiers(($event) => _ctx.handleClick(_ctx.dateRange[(row - 1) * 7 + cell - 1]), ["prevent"]), ["space"])
                  ]
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(_ctx.nh.be("index-inner"))
                  }, toDisplayString(_ctx.dateRange[(row - 1) * 7 + cell - 1].getDate()), 3)
                ], 42, _hoisted_23)
              ])
            ], 42, _hoisted_17);
          }), 64))
        ], 2);
      }), 64))
    ], 2),
    renderSlot(_ctx.$slots, "footer")
  ], 2);
}
var CalendarPanel = _export_sfc(_sfc_main18, [["render", _sfc_render18]]);

// node_modules/vexip-ui/es/components/row/column.mjs
var colProps = ["span", "offset", "pull", "push", "order"];
var Column = defineComponent({
  name: "Column",
  props: columnProps,
  setup(_props, { slots }) {
    const props = useProps("column", _props, {
      tag: "div",
      span: 24,
      offset: null,
      push: null,
      pull: null,
      order: null,
      xs: null,
      sm: null,
      md: null,
      lg: null,
      xl: null,
      xxl: null,
      flex: null,
      useFlex: null
    });
    const rowState = inject(ROW_STATE, null);
    const nh = useNameHelper("column");
    provide(ROW_STATE, null);
    const className = computed(() => {
      const columnFlex = (props.useFlex || (rowState == null ? void 0 : rowState.columnFlex)) && {
        ...(rowState == null ? void 0 : rowState.columnFlex) || {},
        ...props.useFlex ? props.useFlex === true ? { justify: "start", align: "top" } : props.useFlex : {}
      };
      const className2 = [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("flex")]: columnFlex,
          [nh.bm("inherit")]: rowState || props.inherit
        }
      ];
      if (columnFlex) {
        columnFlex.justify && className2.push(nh.bm(columnFlex.justify));
        columnFlex.align && className2.push(nh.bm(columnFlex.align));
      }
      colProps.forEach((prop) => {
        if (typeof props[prop] === "number") {
          className2.push(prop === "span" ? nh.bm(props[prop]) : nh.bm(`${prop}-${props[prop]}`));
        }
      });
      breakPoints.forEach((size) => {
        const sizeProp2 = props[size];
        if (!sizeProp2 && sizeProp2 !== 0)
          return;
        if (typeof sizeProp2 === "number") {
          className2.push(nh.bm(`${size}-${sizeProp2}`));
        } else if (typeof sizeProp2 === "object") {
          colProps.forEach((prop) => {
            const value = sizeProp2[prop];
            if (!value && value !== 0)
              return;
            className2.push(prop === "span" ? nh.bm(value) : nh.bm(`${prop}-${value}`));
          });
        }
      });
      return className2;
    });
    const style = computed(() => {
      const flex = props.flex;
      const style2 = {};
      if (rowState) {
        if (typeof rowState.gap === "number") {
          style2.paddingRight = style2.paddingLeft = `${rowState.gap / 2}px`;
        } else if (Array.isArray(rowState.gap)) {
          style2.paddingRight = style2.paddingLeft = `${rowState.gap[0] / 2}px`;
        }
      }
      if (flex) {
        if (typeof flex === "number") {
          style2.flex = `${flex} ${flex} auto`;
        } else if (typeof flex === "string") {
          if (/^\d+\s\d+\s\d+(\w+)?$/.test(flex)) {
            style2.flex = flex;
          } else {
            style2.flex = flex === "auto" ? "1 1 auto" : `0 0 ${flex}`;
          }
        }
      }
      return style2;
    });
    return () => h(
      props.tag || "div",
      {
        class: className.value,
        style: style.value
      },
      {
        default: () => slots.default && slots.default()
      }
    );
  }
});

// node_modules/vexip-ui/es/components/number-input/props.mjs
var numberInputProps = buildProps({
  size: sizeProp,
  state: stateProp,
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  formatter: Function,
  value: Number,
  min: Number,
  max: Number,
  placeholder: String,
  autofocus: booleanProp,
  spellcheck: booleanProp,
  autocomplete: booleanProp,
  precision: Number,
  readonly: booleanProp,
  step: Number,
  ctrlStep: Number,
  shiftStep: Number,
  altStep: Number,
  disabled: booleanProp,
  inputClass: classProp,
  debounce: booleanProp,
  clearable: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  sync: booleanProp,
  controlType: String,
  onFocus: eventProp(),
  onBlur: eventProp(),
  onInput: eventProp(),
  onChange: eventProp(),
  onEnter: eventProp(),
  onClear: eventProp(),
  onPrefixClick: eventProp(),
  onSuffixClick: eventProp(),
  onKeyDown: eventProp(),
  onKeyPress: eventProp(),
  onKeyUp: eventProp()
});

// node_modules/vexip-ui/es/components/number-input/number-input.mjs
var isNullOrNaN = (value) => qe(value) || Number.isNaN(value);
var _sfc_main19 = defineComponent({
  name: "NumberInput",
  components: {
    Icon,
    CaretUp: $14,
    CaretDown: $12,
    CircleXmark: u
  },
  props: numberInputProps,
  emits: ["update:value"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(focus);
    const props = useProps("numberInput", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      formatter: {
        default: null,
        isFunc: true
      },
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      min: -Infinity,
      max: Infinity,
      placeholder: null,
      autofocus: false,
      spellcheck: false,
      autocomplete: false,
      precision: 0,
      readonly: false,
      step: 1,
      ctrlStep: 100,
      shiftStep: 10,
      altStep: 0.1,
      disabled: () => disabled.value,
      inputClass: null,
      debounce: false,
      clearable: false,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      sync: false,
      controlType: "right"
    });
    const nh = useNameHelper("number-input");
    const focused = ref(false);
    const currentValue = ref(props.value);
    const inputting = ref(false);
    const inputControl = ref();
    const { wrapper, isHover } = Co();
    No({
      target: inputControl,
      passive: false,
      onKeyDown: (event, modifier) => {
        emitEvent(props.onKeyDown, event);
        if (modifier.up || modifier.down) {
          event.preventDefault();
          changeStep(
            modifier.up ? "plus" : "minus",
            event.ctrlKey ? "ctrl" : event.shiftKey ? "shift" : event.altKey ? "alt" : void 0
          );
          modifier.resetAll();
        } else if (modifier.enter) {
          event.preventDefault();
          emitChangeEvent("change");
          modifier.resetAll();
        }
      },
      onKeyUp: (event) => {
        emitEvent(props.onKeyUp, event);
        if (event.key === "Enter") {
          handleEnter();
        }
      }
    });
    let lastValue = props.value;
    const className = computed(() => {
      const [display, fade] = (props.controlType || "right").split("-");
      return [
        nh.b(),
        nh.ns("input-vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("focused")]: focused.value,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading && props.loadingLock,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm(`control-${display}`)]: display !== "right",
          [nh.bm("control-fade")]: fade
        }
      ];
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const hasSuffix = computed(() => {
      return !!(slots.suffix || props.suffix);
    });
    const inputStyle = computed(() => {
      return {
        paddingLeft: hasPrefix.value ? "2em" : "",
        paddingRight: hasSuffix.value ? "2em" : ""
      };
    });
    const preciseNumber = computed(() => {
      return !inputting.value && typeof currentValue.value === "number" && props.precision > 0 ? zt(currentValue.value, props.precision) : currentValue.value;
    });
    const formattedValue = computed(() => {
      var _a;
      if (typeof preciseNumber.value !== "number")
        return (_a = preciseNumber.value) != null ? _a : "";
      return typeof props.formatter === "function" ? props.formatter(preciseNumber.value) : preciseNumber.value.toString();
    });
    const plusDisabled = computed(() => {
      return !isNullOrNaN(currentValue.value) && currentValue.value >= props.max;
    });
    const minusDisabled = computed(() => {
      return !isNullOrNaN(currentValue.value) && currentValue.value <= props.min;
    });
    const hasValue = computed(() => {
      return currentValue.value || currentValue.value === 0;
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && hasValue.value;
    });
    const inputValue = computed(() => {
      if (Number.isNaN(currentValue.value)) {
        return "";
      }
      return focused.value ? preciseNumber.value : formattedValue.value;
    });
    const isReadonly = computed(() => props.loading && props.loadingLock || props.readonly);
    const controlFade = computed(() => {
      var _a;
      return (_a = props.controlType) == null ? void 0 : _a.endsWith("fade");
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = qe(value) ? NaN : value;
        lastValue = currentValue.value;
      }
    );
    function focus() {
      inputControl.value && inputControl.value.focus();
    }
    function handleFocus(event) {
      focused.value = true;
      inputting.value = true;
      emitEvent(props.onFocus, event);
    }
    function handleBlur(event) {
      focused.value = false;
      setTimeout(() => {
        if (!focused.value) {
          inputting.value = false;
          emitEvent(props.onBlur, event);
          emitChangeEvent("change");
        }
      }, 120);
    }
    function plusNumber(event) {
      if (plusDisabled.value) {
        return;
      }
      !focused.value && focus();
      changeStep(
        "plus",
        event.ctrlKey ? "ctrl" : event.shiftKey ? "shift" : event.altKey ? "alt" : void 0
      );
    }
    function minusNumber(event) {
      if (minusDisabled.value) {
        return;
      }
      !focused.value && focus();
      changeStep(
        "minus",
        event.ctrlKey ? "ctrl" : event.shiftKey ? "shift" : event.altKey ? "alt" : void 0
      );
    }
    function changeStep(type, modifier) {
      if (props.disabled || props.loading && props.loadingLock) {
        return;
      }
      let value = currentValue.value || 0;
      let step;
      switch (modifier) {
        case "ctrl":
          step = props.ctrlStep;
          break;
        case "shift":
          step = props.shiftStep;
          break;
        case "alt":
          step = props.altStep;
          break;
        default:
          step = props.step;
      }
      const stringValue = value.toString().trim();
      if (stringValue.endsWith(".")) {
        value = En(stringValue.slice(0, -1));
      }
      if (type === "plus") {
        value = kn(value, step);
      } else {
        value = $n(value, step);
      }
      setValue(value, "input");
    }
    function handleChange(event) {
      const type = event.type;
      const stringValue = event.target.value;
      let value = stringValue;
      if (!/^-?[0-9]*\.?[0-9]*$/.test(stringValue)) {
        const floatValue = parseFloat(stringValue);
        if (Number.isNaN(floatValue)) {
          value = "";
        } else {
          value = floatValue.toString();
        }
        event.target.value = value;
      }
      inputting.value = type === "input";
      setValue(En(value), type);
    }
    function setValue(value, type) {
      if (type !== "input") {
        currentValue.value = Fn(value, props.min, props.max);
      } else {
        currentValue.value = value;
      }
      emitChangeEvent(type);
    }
    function emitChangeEvent(type) {
      type = type === "input" ? "input" : "change";
      if (type === "change") {
        if (lastValue === currentValue.value)
          return;
        lastValue = currentValue.value;
        setFieldValue(currentValue.value);
        emitEvent(props.onChange, currentValue.value);
        if (!props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      } else {
        emitEvent(props.onInput, currentValue.value);
        if (props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      }
    }
    function handleClear() {
      setValue(NaN, "change");
      if (props.sync) {
        emit("update:value", currentValue.value);
        validateField();
      }
      emitEvent(props.onClear);
      clearField();
    }
    function handleEnter() {
      emitEvent(props.onEnter);
    }
    function handlePrefixClick(event) {
      emitEvent(props.onPrefixClick, event);
    }
    function handleSuffixClick(event) {
      emitEvent(props.onSuffixClick, event);
    }
    function handleKeyPress(event) {
      emitEvent(props.onKeyPress, event);
    }
    const handleInput = props.debounce ? yr(handleChange) : br(handleChange);
    return {
      props,
      nh,
      locale: useLocale("input"),
      idFor,
      focused,
      isHover,
      className,
      hasPrefix,
      hasSuffix,
      inputStyle,
      preciseNumber,
      formattedValue,
      plusDisabled,
      minusDisabled,
      hasValue,
      showClear,
      inputValue,
      isReadonly,
      controlFade,
      wrapper,
      input: inputControl,
      handleFocus,
      handleBlur,
      plusNumber,
      minusNumber,
      handleInput,
      handleChange,
      handleClear,
      handlePrefixClick,
      handleSuffixClick,
      handleKeyPress
    };
  }
});
var _hoisted_18 = ["id"];
var _hoisted_24 = ["value", "autofocus", "autocomplete", "spellcheck", "disabled", "readonly", "placeholder", "aria-valuenow", "aria-valuemin", "aria-valuemax"];
function _sfc_render19(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_Icon = resolveComponent("Icon");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_CaretUp = resolveComponent("CaretUp");
  const _component_CaretDown = resolveComponent("CaretDown");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[12] || (_cache[12] = ($event) => {
      var _a2;
      return (_a2 = _ctx.input) == null ? void 0 : _a2.focus();
    })
  }, [
    _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
      style: normalizeStyle({ color: _ctx.props.prefixColor }),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handlePrefixClick && _ctx.handlePrefixClick(...args))
    }, [
      renderSlot(_ctx.$slots, "prefix", {}, () => [
        createVNode(_component_Icon, {
          icon: _ctx.props.prefix
        }, null, 8, ["icon"])
      ])
    ], 6)) : createCommentVNode("", true),
    createBaseVNode("input", {
      ref: "input",
      type: "text",
      class: normalizeClass([_ctx.nh.be("control"), _ctx.inputClass]),
      value: _ctx.inputValue,
      autofocus: _ctx.props.autofocus,
      autocomplete: _ctx.props.autocomplete ? "on" : "off",
      spellcheck: _ctx.props.spellcheck,
      disabled: _ctx.props.disabled,
      readonly: _ctx.isReadonly,
      placeholder: (_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder,
      role: "spinbutton",
      "aria-valuenow": _ctx.preciseNumber,
      "aria-valuemin": _ctx.props.min !== -Infinity ? _ctx.props.min : void 0,
      "aria-valuemax": _ctx.props.max !== Infinity ? _ctx.props.max : void 0,
      onBlur: _cache[1] || (_cache[1] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
      onFocus: _cache[2] || (_cache[2] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onKeypress: _cache[3] || (_cache[3] = (...args) => _ctx.handleKeyPress && _ctx.handleKeyPress(...args)),
      onInput: _cache[4] || (_cache[4] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
      onChange: _cache[5] || (_cache[5] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 42, _hoisted_24),
    _ctx.hasSuffix ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
      style: normalizeStyle({
        color: _ctx.props.suffixColor,
        opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
      }),
      onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleSuffixClick && _ctx.handleSuffixClick(...args))
    }, [
      renderSlot(_ctx.$slots, "suffix", {}, () => [
        createVNode(_component_Icon, {
          icon: _ctx.props.suffix
        }, null, 8, ["icon"])
      ])
    ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
    }, null, 2)) : createCommentVNode("", true),
    createVNode(Transition, {
      name: _ctx.nh.ns("fade"),
      appear: ""
    }, {
      default: withCtx(() => [
        _ctx.showClear ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
          onClick: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
        }, [
          createVNode(_component_Icon, null, {
            default: withCtx(() => [
              createVNode(_component_CircleXmark)
            ]),
            _: 1
          })
        ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
        }, [
          createVNode(_component_Icon, {
            spin: _ctx.props.loadingSpin,
            pulse: !_ctx.props.loadingSpin,
            icon: _ctx.props.loadingIcon
          }, null, 8, ["spin", "pulse", "icon"])
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["name"]),
    _ctx.props.controlType !== "none" ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("plus")),
        onClick: _cache[8] || (_cache[8] = (...args) => _ctx.plusNumber && _ctx.plusNumber(...args)),
        onMousedown: _cache[9] || (_cache[9] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createVNode(_component_Icon, { scale: 0.8 }, {
          default: withCtx(() => [
            createVNode(_component_CaretUp)
          ]),
          _: 1
        }, 8, ["scale"])
      ], 34),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("minus")),
        onClick: _cache[10] || (_cache[10] = (...args) => _ctx.minusNumber && _ctx.minusNumber(...args)),
        onMousedown: _cache[11] || (_cache[11] = withModifiers(() => {
        }, ["prevent"]))
      }, [
        createVNode(_component_Icon, { scale: 0.8 }, {
          default: withCtx(() => [
            createVNode(_component_CaretDown)
          ]),
          _: 1
        }, 8, ["scale"])
      ], 34)
    ], 64)) : createCommentVNode("", true)
  ], 10, _hoisted_18);
}
var NumberInput = _export_sfc(_sfc_main19, [["render", _sfc_render19]]);

// node_modules/vexip-ui/es/components/calendar/calendar.mjs
var _sfc_main20 = defineComponent({
  name: "Calendar",
  components: {
    CalendarPanel,
    Column,
    NumberInput,
    Row
  },
  props: calendarProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const props = useProps("calendar", _props, {
      value: {
        default: null,
        static: true
      },
      year: () => new Date().getFullYear(),
      month: {
        default: () => new Date().getMonth() + 1,
        validator: (value) => value > 0 && value <= 12
      },
      weekDays: {
        default: null,
        validator: (value) => !value || value.length === 0 || value.length === 7
      },
      weekStart: {
        default: 0,
        validator: (value) => value >= 0 && value < 7
      },
      today: {
        default: () => new Date(),
        validator: (value) => !Number.isNaN(+new Date(value))
      },
      disabledDate: {
        default: () => false,
        isFunc: true
      }
    });
    const nh = useNameHelper("calendar");
    const locale = useLocale("calendar");
    const calendarValue = ref(props.value);
    const calendarYear = ref(props.year);
    const calendarMonth = ref(props.month);
    function formatYearInput(value) {
      return `${value}${locale.value.year}`;
    }
    function formatMonthInput(value) {
      return `${value}${locale.value.month}`;
    }
    function isDisabled(date) {
      if (typeof props.disabledDate !== "function") {
        return true;
      }
      return props.disabledDate(date);
    }
    function handleClick(date) {
      if (!isDisabled(date)) {
        calendarValue.value = date;
      }
      emitEvent(props.onSelect, date);
      emit("update:value", date);
    }
    return {
      props,
      nh,
      calendarValue,
      calendarYear,
      calendarMonth,
      formatYearInput,
      formatMonthInput,
      handleClick
    };
  }
});
var _hoisted_19 = ["onClick", "onKeydown"];
function _sfc_render20(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Column = resolveComponent("Column");
  const _component_NumberInput = resolveComponent("NumberInput");
  const _component_Row = resolveComponent("Row");
  const _component_CalendarPanel = resolveComponent("CalendarPanel");
  return openBlock(), createBlock(_component_CalendarPanel, {
    value: _ctx.calendarValue,
    "onUpdate:value": _cache[2] || (_cache[2] = ($event) => _ctx.calendarValue = $event),
    inherit: _ctx.props.inherit,
    class: normalizeClass([_ctx.nh.b()]),
    year: _ctx.calendarYear,
    month: _ctx.calendarMonth,
    "week-start": _ctx.props.weekStart,
    today: _ctx.props.today,
    "disabled-date": _ctx.props.disabledDate
  }, {
    header: withCtx(() => [
      renderSlot(_ctx.$slots, "header", {}, () => [
        createVNode(_component_Row, {
          inherit: "",
          class: normalizeClass(_ctx.nh.be("header")),
          align: "middle"
        }, {
          default: withCtx(() => [
            createVNode(_component_Column, { flex: "auto" }, {
              default: withCtx(() => [
                renderSlot(_ctx.$slots, "title")
              ]),
              _: 3
            }),
            createVNode(_component_Column, {
              class: normalizeClass(_ctx.nh.be("actions")),
              flex: "0"
            }, {
              default: withCtx(() => [
                createVNode(_component_NumberInput, {
                  value: _ctx.calendarYear,
                  "onUpdate:value": _cache[0] || (_cache[0] = ($event) => _ctx.calendarYear = $event),
                  inherit: "",
                  class: normalizeClass(_ctx.nh.be("year-input")),
                  range: [1970, 2300],
                  formatter: _ctx.formatYearInput
                }, null, 8, ["value", "class", "formatter"]),
                createVNode(_component_NumberInput, {
                  value: _ctx.calendarMonth,
                  "onUpdate:value": _cache[1] || (_cache[1] = ($event) => _ctx.calendarMonth = $event),
                  inherit: "",
                  class: normalizeClass(_ctx.nh.be("month-input")),
                  range: [1, 12],
                  formatter: _ctx.formatMonthInput
                }, null, 8, ["value", "class", "formatter"])
              ]),
              _: 1
            }, 8, ["class"])
          ]),
          _: 3
        }, 8, ["class"])
      ])
    ]),
    week: withCtx(({ label, index, week }) => [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("week"))
      }, [
        renderSlot(_ctx.$slots, "week", {
          label,
          index,
          week
        }, () => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("week-value"))
          }, toDisplayString(label), 3)
        ])
      ], 2)
    ]),
    item: withCtx(({ selected, date, isPrev, isNext, isToday, disabled }) => [
      createBaseVNode("div", {
        class: normalizeClass({
          [_ctx.nh.be("date")]: true,
          [_ctx.nh.bem("date", "selected")]: selected,
          [_ctx.nh.bem("date", "prev")]: isPrev,
          [_ctx.nh.bem("date", "next")]: isNext,
          [_ctx.nh.bem("date", "today")]: isToday,
          [_ctx.nh.bem("date", "disabled")]: disabled
        }),
        tabindex: "0",
        onClick: ($event) => _ctx.handleClick(date),
        onKeydown: [
          withKeys(withModifiers(($event) => _ctx.handleClick(date), ["prevent"]), ["enter"]),
          withKeys(withModifiers(($event) => _ctx.handleClick(date), ["prevent"]), ["space"])
        ]
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("date-header"))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("date-value"))
          }, toDisplayString(date.getDate()), 3)
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("date-content"))
        }, [
          renderSlot(_ctx.$slots, "content", {
            selected,
            date,
            isPrev,
            isNext,
            isToday,
            disabled
          })
        ], 2)
      ], 42, _hoisted_19)
    ]),
    _: 3
  }, 8, ["value", "inherit", "class", "year", "month", "week-start", "today", "disabled-date"]);
}
var Calendar = _export_sfc(_sfc_main20, [["render", _sfc_render20]]);

// node_modules/vexip-ui/es/components/card/props.mjs
var cardProps = buildProps({
  title: String,
  shadow: String,
  contentStyle: styleProp
});

// node_modules/vexip-ui/es/components/card/card.mjs
var _sfc_main21 = defineComponent({
  name: "Card",
  props: cardProps,
  setup(_props, { slots }) {
    const props = useProps("card", _props, {
      title: "",
      shadow: {
        default: "always",
        validator: (value) => ["always", "hover", "never"].includes(value)
      },
      contentStyle: () => ({})
    });
    const nh = useNameHelper("card");
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(`shadow-${props.shadow}`),
        {
          [nh.bm("inherit")]: props.inherit
        }
      ];
    });
    const hasTitle = computed(() => {
      return slots.title || props.title;
    });
    const hasExtra = computed(() => {
      return slots.extra;
    });
    const hasHeader = computed(() => {
      return slots.header || hasTitle.value || hasExtra.value;
    });
    return {
      props,
      nh,
      className,
      hasTitle,
      hasExtra,
      hasHeader
    };
  }
});
function _sfc_render21(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("article", {
    class: normalizeClass(_ctx.className)
  }, [
    _ctx.hasHeader ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("header"))
    }, [
      renderSlot(_ctx.$slots, "header", {}, () => [
        _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("title"))
        }, [
          renderSlot(_ctx.$slots, "title", {}, () => [
            createTextVNode(toDisplayString(_ctx.props.title), 1)
          ])
        ], 2)) : createCommentVNode("", true),
        _ctx.hasExtra ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("extra"))
        }, [
          renderSlot(_ctx.$slots, "extra")
        ], 2)) : createCommentVNode("", true)
      ])
    ], 2)) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("content")),
      style: normalizeStyle(_ctx.props.contentStyle)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 6)
  ], 2);
}
var Card = _export_sfc(_sfc_main21, [["render", _sfc_render21]]);

// node_modules/vexip-ui/es/components/carousel/props.mjs
var carouselProps = buildProps({
  active: Number,
  viewSize: Number,
  vertical: booleanProp,
  disabled: booleanProp,
  loop: booleanProp,
  arrow: String,
  arrowTrigger: String,
  autoplay: booleanNumberProp,
  pointer: String,
  speed: Number,
  activeOffset: Number,
  height: [Number, String],
  ignoreHover: booleanProp,
  onChange: eventProp(),
  onPrev: eventProp(),
  onNext: eventProp(),
  onSelect: eventProp()
});

// node_modules/vexip-ui/es/components/carousel/symbol.mjs
var CAROUSEL_STATE = Symbol("CAROUSEL_STATE");

// node_modules/vexip-ui/es/components/carousel/carousel.mjs
var _sfc_main22 = defineComponent({
  name: "Carousel",
  components: {
    Icon
  },
  props: carouselProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const props = useProps("carousel", _props, {
      active: {
        default: 0,
        static: true
      },
      viewSize: {
        default: 3,
        validator: (value) => value > 0
      },
      vertical: false,
      disabled: false,
      loop: false,
      arrow: {
        default: "outside",
        validator: (value) => ["outside", "inside", "none"].includes(value)
      },
      arrowTrigger: {
        default: "hover",
        validator: (value) => ["hover", "always"].includes(value)
      },
      autoplay: {
        default: false,
        validator: (value) => typeof value === "number" ? value > 500 : true
      },
      pointer: {
        default: "none",
        validator: (value) => ["outside", "inside", "none"].includes(value)
      },
      speed: 300,
      activeOffset: 0,
      height: null,
      ignoreHover: false
    });
    const nh = useNameHelper("carousel");
    const itemStates = ref(/* @__PURE__ */ new Set());
    const currentActive = ref(0);
    const isLocked = ref(false);
    const arrowActive = ref(props.arrowTrigger === "always");
    const listRect = reactive({
      width: 0,
      height: 0
    });
    const trackRect = reactive({
      width: 0,
      height: 0,
      offset: 0
    });
    const itemRect = reactive({
      width: 0,
      height: 0
    });
    const { wrapper, isHover } = Co();
    const prev = ref();
    const next = ref();
    const isDisabled = computed(() => {
      return props.disabled || itemStates.value.size <= props.viewSize;
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("vertical")]: props.vertical,
        [nh.bm("disabled")]: isDisabled.value
      };
    });
    const style = computed(() => {
      return {
        height: props.vertical && props.height ? `${props.height}${typeof props.height === "number" ? "px" : ""}` : void 0
      };
    });
    const listStyle = computed(() => {
      return {
        width: listRect.width ? `${listRect.width}px` : void 0,
        height: listRect.height ? `${listRect.height}px` : void 0
      };
    });
    const trackStyle = computed(() => {
      return {
        width: trackRect.width ? `${trackRect.width}px` : void 0,
        height: trackRect.height ? `${trackRect.height}px` : void 0,
        transform: trackRect.offset ? `translate${props.vertical ? "Y" : "X"}(${trackRect.offset}px) translateZ(0)` : void 0,
        transitionDuration: isLocked.value ? "0ms" : `${props.speed}ms`
      };
    });
    const disabledPrev = computed(() => {
      return isDisabled.value || !props.loop && currentActive.value <= 0;
    });
    const disabledNext = computed(() => {
      return isDisabled.value || !props.loop && currentActive.value >= itemStates.value.size - props.viewSize;
    });
    const arrowIcons = computed(() => {
      return props.vertical ? [$11, $6] : [$7, $10];
    });
    watch(
      () => props.active,
      (value) => {
        handleWheel(value - props.activeOffset);
      }
    );
    watch(currentActive, (value) => {
      const active = (value + props.activeOffset) % itemStates.value.size;
      emitEvent(props.onChange, active);
      emit("update:active", active);
    });
    watch(isHover, (value) => {
      if (props.ignoreHover)
        return;
      if (value) {
        handleMouseEnter();
      } else {
        handleMouseLeave();
      }
    });
    watch(() => props.viewSize, refresh);
    watch(() => props.autoplay, setAutoplay);
    const refreshLabels = Mr(() => {
      Array.from(itemStates.value).forEach((item, index) => {
        item.label = index;
      });
    });
    const updateItemRect = Mr(() => {
      itemStates.value.forEach((state) => {
        state.width = itemRect.width;
        state.height = itemRect.height;
      });
    });
    const updateListRect = Mr(() => {
      trackRect.width = itemRect.width * itemStates.value.size;
      trackRect.height = itemRect.height * itemStates.value.size;
    });
    provide(
      CAROUSEL_STATE,
      reactive({
        vertical: toRef(props, "vertical"),
        increaseItem,
        decreaseItem,
        isItemActive,
        handleSelect
      })
    );
    let inTransition = false;
    let shouldReset = false;
    isLocked.value = true;
    let observer;
    onMounted(() => {
      computeItemRect();
      handleWheel(props.active - props.activeOffset);
      handleAfterMove();
      setTimeout(() => {
        isLocked.value = false;
        inTransition = false;
        setAutoplay();
      }, 0);
      window.addEventListener("resize", refresh);
      if (wrapper.value) {
        observer = new MutationObserver(() => {
          refresh();
        });
        observer.observe(wrapper.value, {
          attributes: true,
          childList: true,
          characterData: true,
          attributeFilter: ["style"]
        });
      }
    });
    onBeforeUnmount(() => {
      observer == null ? void 0 : observer.disconnect();
      observer = null;
      window.removeEventListener("resize", refresh);
    });
    function increaseItem(item) {
      itemStates.value.add(item);
      refreshLabels();
      updateItemRect();
      updateListRect();
    }
    function decreaseItem(item) {
      itemStates.value.delete(item);
      refreshLabels();
      updateListRect();
    }
    function isItemActive(label) {
      return (currentActive.value + props.activeOffset) % itemStates.value.size === label;
    }
    function computeItemRect() {
      if (!wrapper.value)
        return;
      let prevFix = 0;
      let nextFix = 0;
      if (props.arrow === "outside") {
        if (props.vertical) {
          prevFix = prev.value ? prev.value.offsetHeight : 0;
          nextFix = next.value ? next.value.offsetHeight : 0;
        } else {
          prevFix = prev.value ? prev.value.offsetWidth : 0;
          nextFix = next.value ? next.value.offsetWidth : 0;
        }
      }
      if (props.vertical) {
        listRect.width = 0;
        listRect.height = wrapper.value.offsetHeight - prevFix - nextFix;
        itemRect.width = 0;
        itemRect.height = listRect.height / props.viewSize;
      } else {
        listRect.width = wrapper.value.offsetWidth - prevFix - nextFix;
        listRect.height = 0;
        itemRect.width = listRect.width / props.viewSize;
        itemRect.height = 0;
      }
    }
    function refresh() {
      computeItemRect();
      updateItemRect();
      updateListRect();
      if (trackRect.offset > 0) {
        handlePrev(0);
      } else {
        handleNext(0);
      }
      setTimeout(() => {
        isLocked.value = false;
        inTransition = false;
      }, 0);
    }
    function handlePrev(amount = 1) {
      if (isDisabled.value || inTransition)
        return;
      const itemLength = props.vertical ? itemRect.height : itemRect.width;
      const itemList = Array.from(itemStates.value);
      const itemCount = itemList.length;
      const targetIndex = (currentActive.value - amount + itemCount) % itemCount;
      if (targetIndex >= itemCount - props.viewSize) {
        if (!props.loop)
          return;
        if (trackRect.offset < 0) {
          if (amount < currentActive.value) {
            trackRect.offset = -targetIndex * itemLength;
          } else {
            trackRect.offset = itemLength * (itemCount - targetIndex);
            for (let i = targetIndex; i < itemCount; ++i) {
              itemList[i].offset = -itemCount * itemLength;
            }
          }
        } else {
          for (let i = 0; i < itemCount; ++i) {
            itemList[i].offset = i < targetIndex ? 0 : -itemCount * itemLength;
          }
          trackRect.offset = itemLength * (itemCount - targetIndex);
        }
        currentActive.value = targetIndex;
      } else {
        currentActive.value = targetIndex;
        trackRect.offset = -currentActive.value * itemLength;
      }
      shouldReset = currentActive.value <= itemCount - props.viewSize;
      inTransition = true;
    }
    function handleNext(amount = 1) {
      if (isDisabled.value || inTransition)
        return;
      const itemLength = props.vertical ? itemRect.height : itemRect.width;
      const itemList = Array.from(itemStates.value);
      const itemCount = itemList.length;
      const targetIndex = currentActive.value + amount;
      if (targetIndex > itemStates.value.size - props.viewSize) {
        if (!props.loop)
          return;
        if (trackRect.offset > 0) {
          trackRect.offset = itemLength * (itemCount - targetIndex);
        } else {
          const anchorIndex = targetIndex + props.viewSize - itemCount;
          for (let i = 0, len = itemList.length; i < len; ++i) {
            itemList[i].offset = i < anchorIndex ? itemCount * itemLength : 0;
          }
          trackRect.offset = -targetIndex * itemLength;
        }
        currentActive.value = targetIndex % itemCount;
      } else {
        currentActive.value = targetIndex;
        trackRect.offset = -currentActive.value * itemLength;
      }
      shouldReset = currentActive.value <= itemCount - props.viewSize;
      inTransition = true;
    }
    function handleWheel(active) {
      if (isDisabled.value || inTransition || active === currentActive.value)
        return;
      const itemCount = itemStates.value.size;
      active = active % itemCount + (active < 0 ? itemCount : 0);
      if (props.loop) {
        let forward;
        let back;
        if (active > currentActive.value) {
          forward = active - currentActive.value;
          back = itemCount - active + currentActive.value;
        } else {
          forward = itemCount - currentActive.value + active;
          back = currentActive.value - active;
        }
        if (forward < back) {
          handleNext(forward);
        } else if (forward > back) {
          handlePrev(back);
        } else {
          if (trackRect.offset > 0) {
            handlePrev(forward);
          } else {
            handleNext(forward);
          }
        }
      } else {
        if (active < currentActive.value) {
          handlePrev(currentActive.value - active);
        } else {
          handleNext(active - currentActive.value);
        }
      }
    }
    function handleAfterMove() {
      if (!shouldReset) {
        inTransition = false;
      } else {
        itemStates.value.forEach((state) => {
          state.offset = 0;
        });
        shouldReset = false;
        isLocked.value = true;
        requestAnimationFrame(() => {
          trackRect.offset = -currentActive.value * (props.vertical ? itemRect.height : itemRect.width);
          requestAnimationFrame(() => {
            isLocked.value = false;
            inTransition = false;
          });
        });
      }
    }
    function handlePrevClick() {
      handlePrev(1);
      emitEvent(props.onPrev, (currentActive.value + props.activeOffset) % itemStates.value.size);
    }
    function handleNextClick() {
      handleNext(1);
      emitEvent(props.onNext, (currentActive.value + props.activeOffset) % itemStates.value.size);
    }
    function handleSelect(label) {
      emitEvent(props.onSelect, label);
    }
    const { timer: timer2 } = $o();
    function setAutoplay() {
      clearInterval(timer2.play);
      if (!props.autoplay)
        return;
      let waiting = 4e3;
      if (typeof props.autoplay === "number") {
        waiting = props.autoplay;
      }
      timer2.play = window.setInterval(() => {
        if (!props.loop && disabledNext.value) {
          handleWheel(0);
        } else {
          handleNext();
        }
      }, waiting);
    }
    function handleMouseEnter() {
      if (props.autoplay) {
        clearTimeout(timer2.hover);
        timer2.hover = setTimeout(() => {
          clearInterval(timer2.play);
        }, 250);
      }
      if (props.arrowTrigger === "hover" && props.arrow === "inside") {
        arrowActive.value = true;
      }
    }
    function handleMouseLeave() {
      if (props.autoplay) {
        clearTimeout(timer2.hover);
        timer2.hover = setTimeout(() => {
          setAutoplay();
        }, 250);
      }
      if (props.arrowTrigger === "hover") {
        arrowActive.value = false;
      }
    }
    function isPointerDisabled(index) {
      if (props.loop)
        return false;
      return !(index >= props.activeOffset - 1 && index < itemStates.value.size - props.activeOffset - 1);
    }
    return {
      props,
      nh,
      itemStates,
      currentActive,
      arrowActive,
      className,
      style,
      listStyle,
      trackStyle,
      disabledPrev,
      disabledNext,
      arrowIcons,
      wrapper,
      prev,
      next,
      handlePrevClick,
      handleNextClick,
      handleWheel,
      handleAfterMove,
      isPointerDisabled,
      refresh
    };
  }
});
var _hoisted_110 = ["onClick"];
function _sfc_render22(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    role: "list",
    style: normalizeStyle(_ctx.style)
  }, [
    createBaseVNode("div", {
      style: normalizeStyle({
        position: "relative",
        display: "flex",
        flexDirection: _ctx.props.vertical ? "column" : "row",
        width: "100%"
      })
    }, [
      _ctx.props.arrow !== "none" ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "prev",
        class: normalizeClass([
          _ctx.nh.bem("arrow", _ctx.props.arrow),
          _ctx.nh.bem("arrow", "prev"),
          _ctx.arrowActive ? _ctx.nh.bem("arrow", "show") : ""
        ])
      }, [
        createBaseVNode("div", {
          class: normalizeClass({
            [_ctx.nh.be("handler")]: true,
            [_ctx.nh.bem("handler", "disabled")]: _ctx.disabledPrev
          }),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handlePrevClick && _ctx.handlePrevClick(...args))
        }, [
          renderSlot(_ctx.$slots, "prev-arrow", { disabled: _ctx.disabledPrev }, () => [
            createVNode(_component_Icon, {
              icon: _ctx.arrowIcons[0],
              scale: 1.5
            }, null, 8, ["icon", "scale"])
          ])
        ], 2)
      ], 2)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("list")),
        style: normalizeStyle(_ctx.listStyle)
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("track")),
          style: normalizeStyle(_ctx.trackStyle),
          onTransitionend: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleAfterMove && _ctx.handleAfterMove(...args), ["self"]))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 38)
      ], 6),
      _ctx.props.arrow !== "none" ? (openBlock(), createElementBlock("div", {
        key: 1,
        ref: "next",
        class: normalizeClass([
          _ctx.nh.bem("arrow", _ctx.props.arrow),
          _ctx.nh.bem("arrow", "next"),
          _ctx.arrowActive ? _ctx.nh.bem("arrow", "show") : ""
        ])
      }, [
        createBaseVNode("div", {
          class: normalizeClass({
            [_ctx.nh.be("handler")]: true,
            [_ctx.nh.bem("handler", "disabled")]: _ctx.disabledNext
          }),
          onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleNextClick && _ctx.handleNextClick(...args))
        }, [
          renderSlot(_ctx.$slots, "next-arrow", { disabled: _ctx.disabledNext }, () => [
            createVNode(_component_Icon, {
              icon: _ctx.arrowIcons[1],
              scale: 1.5
            }, null, 8, ["icon", "scale"])
          ])
        ], 2)
      ], 2)) : createCommentVNode("", true)
    ], 4),
    _ctx.props.pointer !== "none" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.bem("pointers", _ctx.props.pointer))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.itemStates.size, (index) => {
        return openBlock(), createElementBlock("div", {
          key: index,
          class: normalizeClass({
            [_ctx.nh.be("pointer")]: true,
            [_ctx.nh.bem("pointer", "active")]: index - 1 === (_ctx.currentActive + _ctx.props.activeOffset) % _ctx.itemStates.size,
            [_ctx.nh.bem("pointer", "disabled")]: _ctx.isPointerDisabled(index - _ctx.props.activeOffset - 1)
          }),
          onClick: ($event) => _ctx.handleWheel(index - _ctx.props.activeOffset - 1)
        }, [
          renderSlot(_ctx.$slots, "pointer", {
            active: index - 1 === (_ctx.currentActive + _ctx.props.activeOffset) % _ctx.itemStates.size
          }, () => [
            createBaseVNode("span", {
              class: normalizeClass(_ctx.nh.be("pointer-inner"))
            }, null, 2)
          ])
        ], 10, _hoisted_110);
      }), 128))
    ], 2)) : createCommentVNode("", true)
  ], 6);
}
var Carousel = _export_sfc(_sfc_main22, [["render", _sfc_render22]]);

// node_modules/vexip-ui/es/components/carousel/carousel-item.mjs
var _sfc_main23 = defineComponent({
  name: "CarouselItem",
  setup() {
    const carouselState = inject(CAROUSEL_STATE, null);
    const nh = useNameHelper("carousel");
    const state = reactive({
      label: -1,
      width: 0,
      height: 0,
      offset: 0
    });
    const active = computed(() => {
      var _a;
      return (_a = carouselState == null ? void 0 : carouselState.isItemActive(state.label)) != null ? _a : false;
    });
    const className = computed(() => {
      return {
        [nh.be("item")]: true,
        [nh.bem("item", "active")]: active.value
      };
    });
    const style = computed(() => {
      const { width, height, offset } = state;
      return {
        width: width ? `${width}px` : void 0,
        height: height ? `${height}px` : void 0,
        transform: offset ? `translate${(carouselState == null ? void 0 : carouselState.vertical) ? "Y" : "X"}(${offset}px)` : void 0
      };
    });
    if (carouselState) {
      carouselState.increaseItem(state);
      onBeforeUnmount(() => {
        carouselState.decreaseItem(state);
      });
    }
    function handleClick() {
      carouselState == null ? void 0 : carouselState.handleSelect(state.label);
    }
    return {
      active,
      className,
      style,
      handleClick
    };
  }
});
function _sfc_render23(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "listitem",
    style: normalizeStyle(_ctx.style),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", { active: _ctx.active })
  ], 6);
}
var CarouselItem = _export_sfc(_sfc_main23, [["render", _sfc_render23]]);

// node_modules/vexip-ui/es/components/checkbox/props.mjs
var checkboxProps = buildProps({
  size: sizeProp,
  state: stateProp,
  checked: booleanProp,
  label: String,
  value: [String, Number],
  labelClass: classProp,
  disabled: booleanProp,
  border: booleanProp,
  control: booleanProp,
  partial: booleanProp,
  tabIndex: [String, Number],
  loading: booleanProp,
  loadingLock: booleanProp,
  onChange: eventProp(),
  onClick: eventProp()
});
var checkboxGroupProps = buildProps({
  size: sizeProp,
  state: stateProp,
  value: Array,
  vertical: booleanProp,
  disabled: booleanProp,
  border: booleanProp,
  options: Array,
  loading: booleanProp,
  loadingLock: booleanProp,
  control: booleanStringProp,
  onChange: eventProp()
});

// node_modules/vexip-ui/es/components/checkbox/symbol.mjs
var GROUP_STATE3 = Symbol("CHECKBOX_GROUP_STATE");

// node_modules/vexip-ui/es/components/checkbox/checkbox.mjs
var _sfc_main24 = defineComponent({
  name: "Checkbox",
  props: checkboxProps,
  emits: ["update:checked"],
  setup(_props, { slots, emit }) {
    const { idFor, state, disabled, loading, size, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = input.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("checkbox", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      checked: {
        default: () => getFieldValue(false),
        static: true
      },
      label: null,
      value: {
        default: null,
        static: true
      },
      labelClass: null,
      disabled: () => disabled.value,
      border: false,
      control: false,
      partial: false,
      tabIndex: 0,
      loading: () => loading.value,
      loadingLock: false
    });
    const groupState = inject(GROUP_STATE3, null);
    const nh = useNameHelper("checkbox");
    const currentChecked = ref(props.checked);
    const currentPartial = ref(props.partial);
    const input = ref();
    const controlState = reactive({
      checked: currentChecked,
      partial: currentPartial
    });
    const computedSize = computed(() => (groupState == null ? void 0 : groupState.size) || props.size);
    const computedState = computed(() => (groupState == null ? void 0 : groupState.state) || props.state);
    const isDisabled = computed(() => (groupState == null ? void 0 : groupState.disabled) || props.disabled);
    const isLoading = computed(() => (groupState == null ? void 0 : groupState.loading) || props.loading);
    const isLoadingLock = computed(() => (groupState == null ? void 0 : groupState.loadingLock) || props.loadingLock);
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("checked")]: currentChecked.value,
          [nh.bm("disabled")]: isDisabled.value,
          [nh.bm("loading")]: isLoading.value && isLoadingLock.value,
          [nh.bm(computedSize.value)]: computedSize.value !== "default",
          [nh.bm("border")]: props.border,
          [nh.bm("partial")]: props.control && currentPartial.value,
          [nh.bm(computedState.value)]: computedState.value !== "default"
        }
      ];
    });
    const hasLabel = computed(() => {
      return y(props.label) && props.label !== "";
    });
    const hasSlot = computed(() => {
      return !!slots.default;
    });
    const currentValue = computed(() => {
      var _a;
      return (_a = props.value) != null ? _a : props.label;
    });
    watch(
      () => props.checked,
      (value) => {
        setCurrentChecked(value);
      }
    );
    watch(
      () => props.partial,
      (value) => {
        currentPartial.value = value;
      }
    );
    watch(currentChecked, (checked) => {
      setFieldValue(checked);
      emitEvent(props.onChange, checked);
      emit("update:checked", checked);
    });
    if (groupState) {
      let increased = false;
      watch(currentValue, (value, prevValue) => {
        if (gt(groupState.replaceValue)) {
          groupState.replaceValue(prevValue, value);
        }
      });
      watch(
        () => props.control,
        (value) => {
          if (value) {
            if (increased) {
              groupState.decreaseItem(currentValue.value, input);
              increased = false;
            }
            groupState.increaseControl(controlState);
          } else {
            groupState.decreaseControl(controlState);
          }
        },
        { immediate: true }
      );
      watch(
        () => groupState.currentValues,
        (value) => {
          if (!props.control) {
            setCurrentChecked(value.includes(currentValue.value));
          }
        },
        { immediate: true }
      );
      onMounted(() => {
        if (!props.control) {
          groupState.increaseItem(currentValue.value, currentChecked.value, input);
          increased = true;
        }
      });
      onBeforeUnmount(() => {
        if (!props.control) {
          groupState.decreaseItem(currentValue.value, input);
        } else {
          groupState.decreaseControl(controlState);
        }
      });
    }
    function setCurrentChecked(checked) {
      if (props.control && gt(groupState == null ? void 0 : groupState.handleControlChange)) {
        groupState.handleControlChange();
      } else {
        currentChecked.value = checked;
      }
    }
    function handleChange(checked) {
      if (isDisabled.value || isLoading.value && isLoadingLock.value) {
        return;
      }
      setCurrentChecked(checked);
      if (!props.control && groupState) {
        gt(groupState.setItemChecked) && groupState.setItemChecked(currentValue.value, checked);
      }
      if (!groupState) {
        validateField();
      }
    }
    function handleClick(event) {
      emitEvent(props.onClick, event);
    }
    return {
      props,
      nh,
      idFor,
      currentChecked,
      isDisabled,
      className,
      hasLabel,
      hasSlot,
      isLoading,
      input,
      handleChange,
      handleClick
    };
  }
});
var _hoisted_111 = ["aria-disabled"];
var _hoisted_25 = ["checked", "disabled", "tabindex"];
function _sfc_render24(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(_ctx.className),
    "aria-disabled": _ctx.isDisabled,
    onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    createBaseVNode("span", {
      class: normalizeClass([_ctx.nh.be("signal"), _ctx.isLoading && _ctx.nh.bem("signal", "active")])
    }, null, 2),
    _ctx.hasLabel || _ctx.hasSlot ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("label"), _ctx.props.labelClass])
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.props.label), 1)
      ])
    ], 2)) : createCommentVNode("", true),
    createBaseVNode("input", {
      ref: "input",
      type: "checkbox",
      class: normalizeClass(_ctx.nh.be("input")),
      checked: _ctx.currentChecked,
      disabled: _ctx.isDisabled,
      tabindex: _ctx.props.tabIndex,
      onChange: _cache[0] || (_cache[0] = ($event) => _ctx.handleChange(!_ctx.currentChecked))
    }, null, 42, _hoisted_25)
  ], 10, _hoisted_111);
}
var Checkbox = _export_sfc(_sfc_main24, [["render", _sfc_render24]]);

// node_modules/vexip-ui/es/components/cascader/cascader-panel.mjs
var _sfc_main25 = defineComponent({
  name: "CascaderPanel",
  components: {
    Checkbox,
    Icon,
    Option,
    VirtualList,
    ChevronRight: $17,
    Spinner: h4,
    ArrowsRotate: v
  },
  props: {
    options: {
      type: Array,
      default: () => []
    },
    openedId: {
      type: Number,
      default: null
    },
    values: {
      type: Array,
      default: () => []
    },
    ready: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    checkIcon: {
      type: Object,
      default: x
    },
    isAsync: {
      type: Boolean,
      default: false
    },
    merged: {
      type: Boolean,
      default: false
    },
    noCascaded: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: false
    }
  },
  emits: ["select", "check", "hover", "open", "back", "close"],
  setup(props, { emit }) {
    const nh = useNameHelper("cascader");
    const currentHitting = ref(-1);
    const list = ref();
    const { target: wrapper } = No({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down) {
          event.preventDefault();
          if (currentHitting.value < 0) {
            currentHitting.value = props.options.findIndex(isSelected);
            if (currentHitting.value < 0) {
              currentHitting.value = 0;
            }
            return;
          }
          currentHitting.value = Fn(
            findEnabledIndex(currentHitting.value + (modifier.up ? -1 : 1), modifier.up ? -1 : 1),
            0,
            props.options.length - 1
          );
          ensureOptionInView(currentHitting.value, modifier.up ? "top" : "bottom");
        } else if (modifier.left || modifier.right) {
          event.preventDefault();
          if (modifier.right) {
            const option = props.options[currentHitting.value];
            if (option && hasChildren(option)) {
              emit("open", option);
            }
          } else {
            emit("back");
          }
        } else if (modifier.enter || modifier.space) {
          event.preventDefault();
          event.stopPropagation();
          const option = props.options[currentHitting.value];
          if (option) {
            if (props.multiple) {
              handleToggleCheck(option);
            } else {
              handleSelect(option, currentHitting.value);
            }
          }
        } else if (modifier.escape) {
          emit("close");
        }
      }
    });
    let listHeight = 0;
    let hoverTimer;
    watch(
      () => props.ready,
      (value) => {
        var _a;
        requestAnimationFrame(computeListHeight);
        if (value) {
          (_a = list.value) == null ? void 0 : _a.refresh();
          currentHitting.value = props.options.findIndex(isSelected);
        } else {
          currentHitting.value = -1;
        }
      }
    );
    onMounted(() => {
      requestAnimationFrame(computeListHeight);
    });
    onBeforeUnmount(handleMouseLeave);
    function hasChildren(option) {
      var _a;
      return !!(option.hasChild || ((_a = option.children) == null ? void 0 : _a.length));
    }
    function isSelected(option) {
      return hasChildren(option) && option.id === props.openedId || props.values.includes(option.fullValue);
    }
    function isCheckboxDisabled(option) {
      return option.disabled || !props.merged && props.multiple && props.isAsync && hasChildren(option) && !option.childrenLoaded;
    }
    function handleSelect(option, index) {
      if (option.disabled)
        return;
      currentHitting.value = index;
      if (props.multiple || props.noCascaded) {
        hasChildren(option) ? emit("select", option) : handleToggleCheck(option);
      } else {
        emit("select", option);
      }
    }
    function handleToggleCheck(option) {
      !isCheckboxDisabled(option) && emit("check", option);
    }
    function handleMouseEnter(option) {
      clearTimeout(hoverTimer);
      hoverTimer = setTimeout(() => {
        !option.disabled && emit("hover", option);
      }, 250);
    }
    function handleMouseLeave() {
      clearTimeout(hoverTimer);
    }
    function computeListHeight() {
      var _a;
      const el = (_a = list.value) == null ? void 0 : _a.wrapper;
      if (el) {
        const style = getComputedStyle(el);
        const paddingTop = parseInt(style.paddingTop);
        const paddingBottom = parseInt(style.paddingBottom);
        listHeight = el.offsetHeight - paddingTop - paddingBottom;
      }
    }
    function queryEnabledIndex(index, step) {
      var _a;
      const options = props.options;
      step = step / Math.abs(step);
      while ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index += step;
        if (index < 0 || index >= options.length)
          break;
      }
      return index;
    }
    function findEnabledIndex(index, sign = 1) {
      var _a;
      const options = props.options;
      if ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index = queryEnabledIndex(index, sign);
        if (sign > 0 ? index >= options.length : index < 0) {
          index = queryEnabledIndex(index, -sign);
          if (sign > 0 ? index < 0 : index >= options.length)
            index = -1;
        }
      }
      return index;
    }
    function ensureOptionInView(index, direction) {
      const option = props.options[index];
      const optionHeight = 32;
      if (!option || !list.value)
        return;
      if (direction === "bottom") {
        const target = (index + 1) * optionHeight;
        if (list.value.scrollOffset + listHeight < target) {
          list.value.scrollTo(target - listHeight);
        }
      } else {
        const target = index * optionHeight;
        if (list.value.scrollOffset > target) {
          list.value.scrollTo(target);
        }
      }
    }
    return {
      nh,
      currentHitting,
      wrapper,
      list,
      hasChildren,
      isSelected,
      isCheckboxDisabled,
      handleSelect,
      handleToggleCheck,
      handleMouseEnter,
      handleMouseLeave,
      computeListHeight
    };
  }
});
function _sfc_render25(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Spinner = resolveComponent("Spinner");
  const _component_Icon = resolveComponent("Icon");
  const _component_ArrowsRotate = resolveComponent("ArrowsRotate");
  const _component_ChevronRight = resolveComponent("ChevronRight");
  const _component_Option = resolveComponent("Option");
  const _component_VirtualList = resolveComponent("VirtualList");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("panel")),
    tabindex: "-1",
    onMouseleave: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args))
  }, [
    createVNode(_component_VirtualList, {
      ref: "list",
      inherit: "",
      items: _ctx.options,
      "item-size": 32,
      height: "100%",
      "id-key": "id",
      "items-attrs": {
        class: [
          _ctx.nh.be("options"),
          _ctx.multiple ? _ctx.nh.bem("options", "multiple") : null,
          _ctx.noCascaded ? _ctx.nh.bem("options", "no-cascaded") : null
        ],
        role: "listbox"
      },
      onResize: _ctx.computeListHeight
    }, {
      default: withCtx(({ item, index }) => [
        createVNode(_component_Option, {
          class: normalizeClass({
            [_ctx.nh.ns("option--error")]: item.error
          }),
          value: item.value,
          label: item.label,
          disabled: item.disabled,
          selected: _ctx.isSelected(item),
          hitting: index === _ctx.currentHitting,
          onSelect: ($event) => _ctx.handleSelect(item, index),
          onMouseenter: ($event) => _ctx.handleMouseEnter(item)
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {
              option: item,
              index,
              selected: _ctx.isSelected(item),
              canCheck: _ctx.isCheckboxDisabled(item),
              hasChild: _ctx.hasChildren(item)
            }, () => [
              _ctx.multiple || _ctx.noCascaded ? (openBlock(), createBlock(_component_Checkbox, {
                key: 0,
                inherit: "",
                class: normalizeClass(_ctx.nh.be("checkbox")),
                checked: item.checked,
                control: _ctx.hasChildren(item),
                partial: item.partial,
                disabled: _ctx.isCheckboxDisabled(item),
                size: "small",
                onClick: withModifiers(($event) => _ctx.handleToggleCheck(item), ["prevent", "stop"])
              }, null, 8, ["class", "checked", "control", "partial", "disabled", "onClick"])) : createCommentVNode("", true),
              createBaseVNode("span", {
                class: normalizeClass(_ctx.nh.be("label"))
              }, [
                renderSlot(_ctx.$slots, "label", {
                  option: item,
                  index,
                  selected: _ctx.isSelected(item),
                  canCheck: _ctx.isCheckboxDisabled(item),
                  hasChild: _ctx.hasChildren(item),
                  handleSelect: () => _ctx.handleSelect(item, index)
                }, () => [
                  createTextVNode(toDisplayString(item.label), 1)
                ])
              ], 2),
              createBaseVNode("div", {
                class: normalizeClass(_ctx.nh.be("icon"))
              }, [
                item.loading ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  pulse: ""
                }, {
                  default: withCtx(() => [
                    createVNode(_component_Spinner)
                  ]),
                  _: 1
                })) : item.error ? (openBlock(), createBlock(_component_Icon, { key: 1 }, {
                  default: withCtx(() => [
                    createVNode(_component_ArrowsRotate)
                  ]),
                  _: 1
                })) : _ctx.hasChildren(item) ? (openBlock(), createBlock(_component_Icon, { key: 2 }, {
                  default: withCtx(() => [
                    createVNode(_component_ChevronRight)
                  ]),
                  _: 1
                })) : !_ctx.multiple && !_ctx.noCascaded && _ctx.checkIcon && _ctx.values.includes(item.fullValue) ? (openBlock(), createBlock(_component_Icon, {
                  key: 3,
                  icon: _ctx.checkIcon
                }, null, 8, ["icon"])) : createCommentVNode("", true)
              ], 2)
            ])
          ]),
          _: 2
        }, 1032, ["class", "value", "label", "disabled", "selected", "hitting", "onSelect", "onMouseenter"])
      ]),
      _: 3
    }, 8, ["items", "items-attrs", "onResize"])
  ], 34);
}
var CascaderPanel = _export_sfc(_sfc_main25, [["render", _sfc_render25]]);

// node_modules/vexip-ui/es/components/overflow/props.mjs
var overflowProps = buildProps({
  items: Array,
  tag: String,
  attrFlag: booleanStringProp,
  static: booleanProp,
  maxCount: Number,
  onRestChange: eventProp(),
  onToggle: eventProp()
});

// node_modules/vexip-ui/es/components/overflow/overflow.mjs
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var TEXT_VNODE = createTextVNode("").type;
var Overflow = defineComponent({
  name: "Overflow",
  inheritAttrs: false,
  props: overflowProps,
  emits: [],
  setup(_props, {
    attrs,
    slots,
    expose
  }) {
    const props = useProps("overflow", _props, {
      items: {
        default: null,
        static: true
      },
      tag: "div",
      attrFlag: false,
      static: false,
      maxCount: 0
    });
    const nh = useNameHelper("overflow");
    const restCount = ref(0);
    const wrapper = ref();
    const counter = ref();
    const suffix = ref();
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("manual")]: props.maxCount > 0
      }];
    });
    const hiddenFlag = computed(() => {
      return props.attrFlag ? props.attrFlag === true ? "hidden" : props.attrFlag : false;
    });
    watch([() => {
      var _a;
      return (_a = props.items) == null ? void 0 : _a.length;
    }, () => props.maxCount], () => {
      nextTick(refresh);
    });
    expose({
      refresh
    });
    onMounted(refresh);
    function toggleDisplay(el, show) {
      if (hiddenFlag.value) {
        show ? el.removeAttribute(hiddenFlag.value) : el.setAttribute(hiddenFlag.value, "");
      } else {
        if (show) {
          el.style.display = "";
        } else {
          el.style.display = "none";
        }
      }
    }
    function computeHorizontalMargin(el) {
      const style = getComputedStyle(el);
      const marginLeft = parseFloat(style.marginLeft) || 0;
      const marginRight = parseFloat(style.marginRight) || 0;
      return marginLeft + marginRight;
    }
    function computeHorizontalPadding(el) {
      const style = getComputedStyle(el);
      const paddingLeft = parseFloat(style.paddingLeft) || 0;
      const paddingRight = parseFloat(style.paddingRight) || 0;
      return paddingLeft + paddingRight;
    }
    function computeOuterWidth(el) {
      return el.offsetWidth + computeHorizontalMargin(el);
    }
    let lastOverflow = false;
    let lastRestCount = restCount.value;
    function refresh() {
      const counterEl = counter.value;
      if (!wrapper.value || !counterEl)
        return;
      toggleDisplay(counterEl, true);
      const children = wrapper.value.children;
      const childCount = children.length;
      let overflow = false;
      if (props.maxCount > 0) {
        for (let i = 0, len = childCount - 1; i < len; ++i) {
          const child = children[i];
          child.style.display = i < props.maxCount ? "" : "none";
        }
        if (props.maxCount > childCount - 1) {
          toggleDisplay(counterEl, false);
          restCount.value = 0;
        } else {
          restCount.value = childCount - 1 - props.maxCount;
          overflow = restCount.value > 0;
        }
        postRefresh(overflow);
        return;
      }
      const suffixEl = suffix.value;
      const wrapperWidth = wrapper.value.offsetWidth - computeHorizontalPadding(wrapper.value);
      const childWidths = [];
      let totalWidth = suffixEl ? suffixEl.offsetWidth : 0;
      const counterMargin = computeHorizontalMargin(counterEl);
      const length = childCount - (suffixEl ? 2 : 1);
      for (let i = 0; i < length; ++i) {
        if (i < 0)
          continue;
        const child = children[i];
        if (overflow) {
          toggleDisplay(child, false);
          continue;
        } else {
          toggleDisplay(child, true);
        }
        const childWidth = computeOuterWidth(child);
        totalWidth += childWidth;
        childWidths[i] = childWidth;
        if (totalWidth > wrapperWidth) {
          for (let j = i; j >= 0; --j) {
            restCount.value = length - j;
            totalWidth -= childWidths[j];
            if (totalWidth + counterEl.offsetWidth + counterMargin <= wrapperWidth || !j) {
              overflow = true;
              i = j - 1;
              if (suffixEl) {
                suffixEl.style.maxWidth = i === -1 ? `${wrapperWidth - counterEl.offsetWidth}px` : "";
              }
              break;
            }
          }
        }
      }
      postRefresh(overflow);
    }
    function postRefresh(overflow) {
      if (lastRestCount !== restCount.value) {
        lastRestCount = restCount.value;
        emitEvent(props.onRestChange, restCount.value);
      }
      counter.value && toggleDisplay(counter.value, overflow);
      if (overflow !== lastOverflow) {
        lastOverflow = overflow;
        emitEvent(props.onToggle, overflow);
      }
    }
    function syncCounterRef(el) {
      if (el) {
        counter.value = el.nextElementSibling;
      } else {
        counter.value = void 0;
      }
    }
    return () => {
      var _a;
      let _slot;
      const CustomTag = props.tag || "div";
      const itemSlot = slots.default;
      const staticItem = props.static;
      const counterVNode = ((_a = slots.counter) == null ? void 0 : _a.call(slots, {
        count: restCount.value
      })[0]) || null;
      const renderCounter = () => (counterVNode == null ? void 0 : counterVNode.type) === TEXT_VNODE ? createVNode("span", null, [counterVNode]) : counterVNode;
      const render2 = () => createVNode(CustomTag, mergeProps({
        "ref": wrapper
      }, attrs, {
        "class": className.value
      }), {
        default: () => [itemSlot && y(props.items) ? props.items.map((item, index) => {
          const vnode = itemSlot({
            item,
            index
          })[0];
          if (staticItem) {
            vnode.key = index;
            return vnode;
          }
          return createVNode(ResizeObserver, {
            "key": index,
            "onResize": refresh
          }, {
            default: () => vnode
          });
        }) : itemSlot == null ? void 0 : itemSlot(), counterVNode ? createVNode(Fragment, {
          "ref": syncCounterRef
        }, [renderCounter()]) : createVNode("span", {
          "ref": counter,
          "style": {
            display: "inline-block"
          }
        }, null), slots.suffix ? createVNode(ResizeObserver, {
          "onResize": refresh
        }, {
          default: () => [createVNode("div", {
            "ref": suffix,
            "class": nh.be("suffix")
          }, [slots.suffix()])]
        }) : null]
      });
      if (false) {
        return render2();
      }
      return createVNode(ResizeObserver, {
        "onResize": refresh
      }, _isSlot(_slot = render2()) ? _slot : {
        default: () => [_slot]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/cascader/props.mjs
var cascaderProps = buildProps({
  size: sizeProp,
  state: stateProp,
  value: Array,
  visible: booleanProp,
  options: Array,
  placeholder: String,
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  noCascaded: booleanProp,
  multiple: booleanProp,
  disabled: booleanProp,
  clearable: booleanProp,
  placement: String,
  transfer: booleanStringProp,
  staticSuffix: booleanProp,
  noSuffix: booleanProp,
  transitionName: String,
  outsideClose: booleanProp,
  keyConfig: Object,
  separator: String,
  hoverTrigger: booleanProp,
  maxTagCount: Number,
  briefLabel: booleanProp,
  noRestTip: booleanProp,
  onAsyncLoad: Function,
  mergeTags: booleanProp,
  tagType: String,
  emptyText: String,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  transparent: booleanProp,
  onToggle: eventProp(),
  onSelect: eventProp(),
  onCancel: eventProp(),
  onChange: eventProp(),
  onClickOutside: eventProp(),
  onOutsideClose: eventProp(),
  onClear: eventProp()
});

// node_modules/vexip-ui/es/components/cascader/cascader.mjs
var ID_KEY = Symbol("ID_KEY");
var PARENT_KEY = Symbol("PARENT_KEY");
var defaultKeyConfig2 = {
  value: "value",
  label: "label",
  children: "children",
  disabled: "disabled",
  hasChild: "hasChild"
};
var _sfc_main26 = defineComponent({
  name: "Cascader",
  components: {
    CascaderPanel,
    Icon,
    NativeScroll,
    Overflow,
    Portal,
    Tag,
    Tooltip,
    ChevronDown: $15,
    CircleXmark: u
  },
  props: cascaderProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { emit, slots }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("cascader");
    const props = useProps("cascader", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue([]),
        static: true
      },
      visible: {
        default: false,
        static: true
      },
      options: {
        default: () => [],
        static: true
      },
      placeholder: null,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noCascaded: false,
      multiple: false,
      disabled: () => disabled.value,
      clearable: false,
      placement: {
        default: "bottom-start",
        validator: (value) => Wo.includes(value)
      },
      transfer: false,
      staticSuffix: false,
      noSuffix: false,
      transitionName: () => nh.ns("drop"),
      outsideClose: true,
      keyConfig: () => ({}),
      separator: {
        default: "/",
        validator: (value) => value.length === 1
      },
      hoverTrigger: false,
      maxTagCount: 0,
      briefLabel: false,
      noRestTip: false,
      onAsyncLoad: {
        default: null,
        isFunc: true
      },
      mergeTags: false,
      tagType: null,
      emptyText: null,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      transparent: false
    });
    const currentVisible = ref(props.visible);
    const currentValues = ref([]);
    const currentLabels = ref([]);
    const mergedValues = ref([]);
    const mergedLabels = ref([]);
    const isPopperShow = ref(false);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const emittedValue = ref(null);
    const optionTree = ref(null);
    const isAsyncLoad = computed(() => typeof props.onAsyncLoad === "function");
    let optionList = null;
    let optionIdMap = null;
    let optionValueMap = null;
    let outsideClosed = false;
    let prevClosedId = -1;
    const updateTrigger = ref(0);
    watchEffect(() => {
      props.keyConfig.value;
      props.keyConfig.label;
      props.keyConfig.children;
      props.keyConfig.disabled;
      props.keyConfig.hasChild;
      props.separator;
      props.options;
      isAsyncLoad.value;
      updateTrigger.value++;
    });
    watch(updateTrigger, initOptionStates, { immediate: true });
    function initOptionStates() {
      var _a;
      const childrenKey = (_a = props.keyConfig.children) != null ? _a : defaultKeyConfig2.children;
      const rawOptions = Rr(props.options, {
        keyField: ID_KEY,
        parentField: PARENT_KEY,
        childField: childrenKey
      });
      const separator = props.separator;
      const isAsync = isAsyncLoad.value;
      optionList = createOptionStates(rawOptions);
      optionIdMap = /* @__PURE__ */ new Map();
      optionValueMap = /* @__PURE__ */ new Map();
      for (let i = 0, len = optionList.length; i < len; ++i) {
        const option = optionList[i];
        initOptionFull(option, separator);
        optionIdMap.set(option.id, option);
        optionValueMap.set(option.fullValue, option);
        if (isAsync) {
          option.childrenLoaded = queryChildrenLoaded(option);
        }
      }
      optionTree.value = _r(optionList);
      initValueAndLabel(emittedValue.value);
    }
    const openedIds = ref([]);
    const optionsList = computed(() => {
      return [
        optionTree.value,
        ...openedIds.value.map((id2) => {
          var _a;
          return (_a = optionIdMap.get(id2)) == null ? void 0 : _a.children;
        }).filter(Boolean)
      ];
    });
    const wrapper = Do(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = qo({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = Co(reference);
    const locale = useLocale("select");
    const panelElList = ref([]);
    const restTagCount = ref(0);
    const restTipShow = ref(false);
    const selectorWidth = ref(0);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("multiple")]: props.multiple,
        [nh.bm("responsive")]: props.multiple && props.maxTagCount <= 0
      };
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--focused`]: !props.disabled && currentVisible.value,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--${props.state}`]: props.state !== "default",
        [`${baseCls}--has-prefix`]: hasPrefix.value,
        [`${baseCls}--has-suffix`]: !props.noSuffix,
        [`${baseCls}--transparent`]: props.transparent
      };
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const usingMerged = computed(() => props.mergeTags && !props.noCascaded);
    const templateValues = computed(
      () => usingMerged.value ? mergedValues.value : currentValues.value
    );
    const templateLabels = computed(
      () => usingMerged.value ? mergedLabels.value : currentLabels.value
    );
    const hasValue = computed(() => !!templateValues.value[0]);
    const usingHover = computed(() => props.hoverTrigger && !isAsyncLoad.value);
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && hasValue.value;
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      var _a;
      if (value) {
        restTipShow.value = false;
        selectorWidth.value = ((_a = wrapper.value) == null ? void 0 : _a.offsetWidth) || 0;
        updatePopper();
        nextTick(() => {
          var _a2, _b;
          (_b = (_a2 = panelElList.value.at(-1)) == null ? void 0 : _a2.$el) == null ? void 0 : _b.focus();
        });
      } else {
        isPopperShow.value = false;
        if (reference.value && !outsideClosed) {
          reference.value.focus();
        }
      }
      outsideClosed = false;
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    let outsideChanged = false;
    watch(emittedValue, () => {
      outsideChanged = true;
    });
    watch(
      () => props.value,
      (value) => {
        if (value !== emittedValue.value || outsideChanged) {
          emittedValue.value = value;
          initValueAndLabel(value);
          nextTick(() => {
            outsideChanged = false;
          });
        }
      },
      { immediate: true }
    );
    watch(
      () => props.briefLabel,
      (brief) => {
        currentLabels.value = currentValues.value.map((value) => {
          var _a;
          return (_a = optionValueMap.get(value)) == null ? void 0 : _a[brief ? "label" : "fullLabel"];
        }).filter(Boolean);
      }
    );
    watch(isAsyncLoad, (value) => {
      if (value) {
        for (const option of optionIdMap.values()) {
          option.childrenLoaded = queryChildrenLoaded(option);
        }
      }
    });
    watch(usingMerged, (value) => {
      if (value) {
        mergedValues.value.length = 0;
        mergedLabels.value.length = 0;
        updateMergedProps();
      }
      if (isAsyncLoad.value) {
        const originalOptions = [];
        for (const option of optionIdMap.values()) {
          if (option.checked) {
            originalOptions.push(option);
          }
          if (option.hasChild && !option.children.length && !option.loaded) {
            option.checked = false;
          }
        }
        for (let i = 0, len = originalOptions.length; i < len; ++i) {
          const option = originalOptions[i];
          updateCheckedUpward(option);
          updateCheckedDown(option);
        }
      }
      emitMultipleChange();
    });
    watch(
      () => optionsList.value.length,
      () => {
        nextTick(() => {
          const panel = panelElList.value.at(-1);
          if (panel == null ? void 0 : panel.$el) {
            panel.$el.focus();
          }
          prevClosedId = -1;
        });
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    onBeforeUpdate(() => {
      panelElList.value.length = 0;
    });
    function createOptionStates(rawOptions) {
      const {
        value: valueKey,
        label: labelKey,
        disabled: disabledKey,
        hasChild: hasChildKey
      } = { ...defaultKeyConfig2, ...props.keyConfig };
      return rawOptions.map((rawOption) => {
        const {
          [ID_KEY]: id2,
          [PARENT_KEY]: parent,
          [valueKey]: value,
          [labelKey]: label,
          [disabledKey]: disabled2,
          [hasChildKey]: hasChild
        } = rawOption;
        return reactive({
          id: id2,
          parent,
          value,
          disabled: disabled2,
          hasChild,
          label: label || String(value),
          fullValue: "",
          fullLabel: "",
          children: [],
          checked: false,
          partial: false,
          loading: false,
          loaded: false,
          error: false,
          childrenLoaded: false,
          data: rawOption
        });
      });
    }
    function initOptionFull(option, separator) {
      let value = option.value;
      let label = option.label;
      let parent = optionIdMap.get(option.parent);
      while (parent) {
        value = `${parent.value}${separator}${value}`;
        label = `${parent.label}${separator}${label}`;
        parent = optionIdMap.get(parent.parent);
      }
      option.fullValue = value;
      option.fullLabel = label;
    }
    function queryChildrenLoaded(option) {
      var _a, _b;
      if (option.hasChild && !((_a = option.children) == null ? void 0 : _a.length)) {
        return option.loaded;
      }
      const loop = [...option.children];
      while (loop.length) {
        const child = loop.shift();
        if (child.childrenLoaded)
          continue;
        if (child.hasChild && !((_b = child.children) == null ? void 0 : _b.length)) {
          child.childrenLoaded = child.loaded;
          if (!child.loaded)
            return false;
        }
        loop.push(...child.children);
      }
      return true;
    }
    function updateMergedProps() {
      const baseValues = isAsyncLoad.value ? currentValues.value.concat(mergedValues.value) : currentValues.value;
      const values = new Set(baseValues);
      const loop = [...baseValues];
      while (loop.length) {
        const value = loop.shift();
        const option = optionValueMap.get(value);
        if (option) {
          const parent = optionIdMap.get(option.parent);
          if (parent == null ? void 0 : parent.checked) {
            values.delete(value);
            values.add(parent.fullValue);
            loop.push(parent.fullValue);
          }
        }
      }
      const briefLabel = props.briefLabel;
      mergedValues.value = Array.from(values).filter((value) => optionValueMap.has(value));
      mergedLabels.value = mergedValues.value.map((value) => {
        const option = optionValueMap.get(value);
        return briefLabel ? option.label : option.fullLabel;
      }).filter(Boolean);
    }
    function isFlatArray(value) {
      return !!value.length && !Array.isArray(value[0]);
    }
    function isComplexArray(value) {
      return !!value.length && Array.isArray(value[0]);
    }
    function initValueAndLabel(value) {
      for (const option of optionList) {
        option.checked = false;
        option.partial = false;
      }
      if (!(value == null ? void 0 : value.length)) {
        currentValues.value = [];
        currentLabels.value = [];
        return;
      }
      const briefLabel = props.briefLabel;
      if (props.multiple) {
        const normalizedValue = isFlatArray(value) ? [value] : value;
        const valueSet = new Set(normalizedValue.map((v5) => v5.join(props.separator)));
        const selectedValues = [];
        const selectedLabels = [];
        const selectedOptions = [];
        valueSet.forEach((value2) => {
          const option = optionValueMap.get(value2);
          if (option) {
            option.checked = true;
            option.partial = false;
            selectedValues.push(value2);
            selectedLabels.push(briefLabel ? option.label : option.fullLabel);
            selectedOptions.push(option);
          }
        });
        if (!props.noCascaded) {
          const originalOptions = selectedOptions.concat(
            Array.from(optionIdMap.values()).filter((option) => option.disabled && option.checked)
          );
          for (let i = 0, len = originalOptions.length; i < len; ++i) {
            const option = originalOptions[i];
            updateCheckedUpward(option);
            updateCheckedDown(option);
          }
        }
        currentValues.value = selectedValues;
        currentLabels.value = selectedLabels;
      } else {
        const normalizedValue = isComplexArray(value) ? value[0] : value;
        const stringValue = normalizedValue.join(props.separator);
        const option = optionValueMap.get(stringValue);
        if (option) {
          currentValues.value = [stringValue];
          currentLabels.value = [briefLabel ? option.label : option.fullLabel];
          if (props.noCascaded) {
            option.checked = true;
            option.partial = false;
          }
        } else {
          currentValues.value = [];
          currentLabels.value = [];
        }
      }
      if (openedIds.value.length)
        return;
      const firstValue = currentValues.value[0];
      if (firstValue) {
        const option = optionValueMap.get(firstValue);
        const ids = [option.id];
        let parent = optionIdMap.get(option.parent);
        while (parent) {
          ids.push(parent.id);
          parent = optionIdMap.get(parent.parent);
        }
        openedIds.value = ids.reverse().slice(0, -1);
      }
    }
    async function handlePanelOpen(option, depth) {
      var _a, _b;
      if (!option.hasChild && !((_a = option.children) == null ? void 0 : _a.length))
        return;
      if (isAsyncLoad.value && !((_b = option.children) == null ? void 0 : _b.length) && !option.loaded) {
        option.loading = true;
        let result;
        try {
          result = props.onAsyncLoad(option.data);
          result = Je(result) ? await result : result;
        } catch (e) {
          option.error = true;
          option.loading = false;
          return;
        }
        const rawOptions = result;
        if (!Array.isArray(rawOptions) || !rawOptions.length) {
          option.hasChild = false;
        } else {
          const options = createOptionStates(rawOptions);
          const parentId = option.id;
          const separator = props.separator;
          option.children.push(...options);
          let idCount3 = Math.max(...Array.from(optionIdMap.keys()).map(Number)) + 1;
          options.forEach((option2) => {
            option2.id = idCount3++;
            option2.parent = parentId;
            initOptionFull(option2, separator);
            optionIdMap.set(option2.id, option2);
            optionValueMap.set(option2.fullValue, option2);
          });
          optionList.push(...options);
        }
        option.loaded = true;
        option.loading = false;
        const upstream = queryUpstreamOptions(option);
        upstream.forEach((option2) => {
          option2.childrenLoaded = queryChildrenLoaded(option2);
        });
      }
      if (depth < openedIds.value.length) {
        openedIds.value = openedIds.value.slice(0, depth);
      }
      openedIds.value.push(option.id);
      requestAnimationFrame(() => {
        var _a2, _b2;
        (_b2 = (_a2 = panelElList.value.at(-1)) == null ? void 0 : _a2.$el) == null ? void 0 : _b2.focus();
      });
    }
    function handleOptionSelect(option, depth) {
      var _a;
      if (!option)
        return;
      if (option.hasChild || ((_a = option.children) == null ? void 0 : _a.length)) {
        handlePanelOpen(option, depth);
      } else {
        handleSingleSelect(option.fullValue);
      }
    }
    function queryUpstreamOptions(option) {
      const options = [option];
      let parent = optionIdMap.get(option.parent);
      while (parent) {
        options.push(parent);
        parent = optionIdMap.get(parent.parent);
      }
      return options;
    }
    function updateCheckedUpward(originalOption) {
      let option = originalOption;
      while (!qe(option.parent)) {
        const parent = optionIdMap.get(option.parent);
        if (!parent)
          break;
        if (option.checked === parent.checked && option.partial === parent.partial) {
          break;
        }
        if (option.checked) {
          parent.checked = parent.children.every((item) => item.disabled || item.checked);
          parent.partial = !parent.checked;
        } else {
          parent.checked = false;
          parent.partial = parent.children.some((item) => item.checked || item.partial);
        }
        option = parent;
      }
    }
    function updateCheckedDown(originalOption) {
      var _a;
      const checked = originalOption.checked;
      const partial = originalOption.partial;
      const loop = [...originalOption.children];
      let option;
      while (loop.length) {
        option = loop.shift();
        if (option.disabled)
          continue;
        option.checked = checked;
        option.partial = partial;
        if ((_a = option.children) == null ? void 0 : _a.length) {
          loop.push(...option.children);
        }
      }
    }
    function handleOptionCheck(option) {
      if (!option)
        return;
      const options = Array.from(optionIdMap.values());
      const checked = !option.checked;
      if (!props.multiple) {
        for (let i = 0, len = options.length; i < len; ++i) {
          options[i].checked = false;
        }
        option.checked = checked;
        option.partial = false;
        return handleSingleSelect(option.fullValue);
      }
      option.checked = checked;
      option.partial = false;
      if (!props.noCascaded) {
        const originalOptions = [option].concat(
          options.filter((option2) => option2.disabled && option2.checked)
        );
        for (let i = 0, len = originalOptions.length; i < len; ++i) {
          const option2 = originalOptions[i];
          updateCheckedUpward(option2);
          updateCheckedDown(option2);
        }
      }
      emitEvent(props[checked ? "onSelect" : "onCancel"], option.fullValue, option.data);
      emitMultipleChange();
    }
    function emitMultipleChange() {
      const options = Array.from(optionIdMap.values());
      const selectedOptions = props.noCascaded ? options.filter((option) => option.checked) : options.filter((option) => {
        var _a;
        return option.checked && !(option.hasChild || ((_a = option.children) == null ? void 0 : _a.length));
      });
      const selectedValues = [];
      const selectedLabels = [];
      const values = [];
      const dataList = [];
      const briefLabel = props.briefLabel;
      selectedOptions.forEach((option) => {
        selectedValues.push(option.fullValue);
        selectedLabels.push(briefLabel ? option.label : option.fullLabel);
        const { value, data } = queryArrayMeta(option.fullValue);
        values.push(value);
        dataList.push(data);
      });
      currentValues.value = selectedValues;
      currentLabels.value = selectedLabels;
      if (usingMerged.value) {
        if (isAsyncLoad.value) {
          mergedValues.value = options.filter((option) => option.checked).map((option) => option.fullValue);
        }
        updateMergedProps();
      }
      if (usingMerged.value && isAsyncLoad.value) {
        values.length = 0;
        dataList.length = 0;
        mergedValues.value.forEach((fullValue) => {
          const option = optionValueMap.get(fullValue);
          if (option) {
            const { value, data } = queryArrayMeta(option.fullValue);
            values.push(value);
            dataList.push(data);
          }
        });
      }
      emitChangeEvent(values, dataList);
      nextTick(updatePopper);
    }
    function handleSingleSelect(fullValue) {
      const option = optionValueMap.get(fullValue);
      if (!option)
        return;
      emitEvent(props.onSelect, fullValue, option.data);
      if (fullValue) {
        currentValues.value[0] = fullValue;
        currentLabels.value[0] = props.briefLabel ? option.label : option.fullLabel;
      } else {
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
      }
      const { value, data } = queryArrayMeta(fullValue);
      emitChangeEvent(value, data);
      currentVisible.value = false;
    }
    function emitChangeEvent(value, data) {
      emittedValue.value = value;
      nextTick(() => {
        outsideChanged = false;
        setFieldValue(value);
        emitEvent(props.onChange, value, data);
        emit("update:value", value);
        validateField();
      });
    }
    function queryArrayMeta(fullValue) {
      let option = optionValueMap.get(fullValue);
      if (!option)
        return { value: [], data: [] };
      const value = [option.value];
      const data = [option.data];
      while (option.parent) {
        const parent = optionIdMap.get(option.parent);
        if (!parent)
          break;
        value.push(parent.value);
        data.push(parent.data);
        option = parent;
      }
      return {
        value: value.reverse(),
        data: data.reverse()
      };
    }
    function toggleVisible(visible = !currentVisible.value) {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      currentVisible.value = visible;
    }
    function handleClickOutside() {
      restTipShow.value = false;
      emitEvent(props.onClickOutside);
      if (props.outsideClose && currentVisible.value) {
        currentVisible.value = false;
        outsideClosed = true;
        emitEvent(props.onOutsideClose);
      }
    }
    function handleClear() {
      if (props.clearable) {
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
        mergedValues.value.length = 0;
        mergedLabels.value.length = 0;
        openedIds.value.length = 0;
        emittedValue.value = [];
        restTipShow.value = false;
        for (const option of optionIdMap.values()) {
          option.checked = false;
          option.partial = false;
        }
        emitEvent(props.onChange, emittedValue.value, []);
        emit("update:value", emittedValue.value);
        emitEvent(props.onClear);
        clearField(emittedValue.value);
      }
    }
    function toggleShowRestTip() {
      if (!currentVisible.value) {
        restTipShow.value = !restTipShow.value;
      } else {
        restTipShow.value = false;
      }
    }
    function handleTipClose(fullValue) {
      if (props.multiple) {
        handleOptionCheck(optionValueMap.get(fullValue));
      } else {
        handleSingleSelect(fullValue);
      }
    }
    function handlePanelKeyOpen(option, depth) {
      handlePanelOpen(option, depth);
      requestAnimationFrame(() => {
        const panel = panelElList.value.at(-1);
        if (panel && panel.currentHitting < 0) {
          panel.currentHitting = panel.options.findIndex((option2) => option2.id === prevClosedId);
          if (panel.currentHitting < 0) {
            panel.currentHitting = 0;
          }
        }
      });
    }
    function handlePanelBack() {
      prevClosedId = openedIds.value.pop();
    }
    function handlePanelsEnter() {
      requestAnimationFrame(() => {
        isPopperShow.value = true;
      });
    }
    return {
      props,
      nh,
      locale,
      idFor,
      currentVisible,
      isPopperShow,
      currentValues,
      currentLabels,
      transferTo,
      isHover,
      openedIds,
      restTagCount,
      restTipShow,
      selectorWidth,
      optionsList,
      className,
      selectorClass,
      hasValue,
      hasPrefix,
      isAsyncLoad,
      usingMerged,
      templateValues,
      templateLabels,
      usingHover,
      showClear,
      wrapper,
      reference,
      popper,
      panelElList,
      handlePanelOpen,
      handleOptionSelect,
      handleOptionCheck,
      toggleVisible,
      handleClear,
      toggleShowRestTip,
      handleTipClose,
      handlePanelKeyOpen,
      handlePanelBack,
      handlePanelsEnter
    };
  }
});
var _hoisted_112 = ["id"];
var _hoisted_26 = { key: 1 };
function _sfc_render26(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Tag = resolveComponent("Tag");
  const _component_NativeScroll = resolveComponent("NativeScroll");
  const _component_Tooltip = resolveComponent("Tooltip");
  const _component_Overflow = resolveComponent("Overflow");
  const _component_ChevronDown = resolveComponent("ChevronDown");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_CascaderPanel = resolveComponent("CascaderPanel");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[8] || (_cache[8] = ($event) => _ctx.toggleVisible())
  }, [
    createBaseVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onKeydown: [
        _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.toggleVisible(), ["prevent"]), ["space"])),
        _cache[4] || (_cache[4] = withKeys(($event) => _ctx.toggleVisible(false), ["tab"]))
      ]
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        renderSlot(_ctx.$slots, "control", {}, () => {
          var _a, _b;
          return [
            _ctx.props.multiple ? (openBlock(), createBlock(_component_Overflow, {
              key: 0,
              inherit: "",
              class: normalizeClass([_ctx.nh.be("tags")]),
              items: _ctx.templateValues,
              "max-count": _ctx.props.maxTagCount,
              onRestChange: _cache[1] || (_cache[1] = ($event) => _ctx.restTagCount = $event)
            }, {
              default: withCtx(({ item, index }) => [
                createVNode(_component_Tag, {
                  inherit: "",
                  class: normalizeClass(_ctx.nh.be("tag")),
                  type: _ctx.props.tagType,
                  closable: "",
                  onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.toggleVisible(), ["stop"])),
                  onClose: ($event) => _ctx.handleTipClose(item)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.templateLabels[index]), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "type", "onClose"])
              ]),
              counter: withCtx(({ count: count3 }) => [
                _ctx.props.noRestTip ? (openBlock(), createBlock(_component_Tag, {
                  key: 0,
                  inherit: "",
                  class: normalizeClass([_ctx.nh.be("tag"), _ctx.nh.be("counter")]),
                  type: _ctx.props.tagType
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(`+${count3}`), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "type"])) : (openBlock(), createElementBlock("span", _hoisted_26, [
                  createVNode(_component_Tooltip, {
                    inherit: "",
                    transfer: false,
                    visible: _ctx.restTipShow,
                    trigger: "custom",
                    placement: "top-end",
                    "tip-class": _ctx.nh.be("rest-tip"),
                    onClick: withModifiers(_ctx.toggleShowRestTip, ["stop"])
                  }, {
                    trigger: withCtx(() => [
                      createVNode(_component_Tag, {
                        inherit: "",
                        class: normalizeClass([_ctx.nh.be("tag"), _ctx.nh.be("counter")]),
                        type: _ctx.props.tagType
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(`+${count3}`), 1)
                        ]),
                        _: 2
                      }, 1032, ["class", "type"])
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_NativeScroll, {
                        inherit: "",
                        "use-y-bar": ""
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.templateValues, (item, index) => {
                            return openBlock(), createElementBlock(Fragment, { key: index }, [
                              index >= _ctx.templateValues.length - _ctx.restTagCount ? (openBlock(), createBlock(_component_Tag, {
                                key: 0,
                                inherit: "",
                                class: normalizeClass(_ctx.nh.be("tag")),
                                closable: "",
                                type: _ctx.props.tagType,
                                onClose: ($event) => _ctx.handleTipClose(item)
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(_ctx.templateLabels[index]), 1)
                                ]),
                                _: 2
                              }, 1032, ["class", "type", "onClose"])) : createCommentVNode("", true)
                            ], 64);
                          }), 128))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 2
                  }, 1032, ["visible", "tip-class", "onClick"])
                ]))
              ]),
              _: 1
            }, 8, ["class", "items", "max-count"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.currentLabels[0]), 1)
            ], 64)),
            ((_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder) && !_ctx.hasValue ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass(_ctx.nh.be("placeholder"))
            }, toDisplayString((_b = _ctx.props.placeholder) != null ? _b : _ctx.locale.placeholder), 3)) : createCommentVNode("", true)
          ];
        })
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          _ctx.props.suffix ? (openBlock(), createBlock(_component_Icon, {
            key: 0,
            icon: _ctx.props.suffix,
            class: normalizeClass({
              [_ctx.nh.be("arrow")]: !_ctx.props.staticSuffix
            })
          }, null, 8, ["icon", "class"])) : (openBlock(), createBlock(_component_Icon, {
            key: 1,
            class: normalizeClass(_ctx.nh.be("arrow"))
          }, {
            default: withCtx(() => [
              createVNode(_component_ChevronDown)
            ]),
            _: 1
          }, 8, ["class"]))
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.showClear ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onEnter: _ctx.handlePanelsEnter
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[7] || (_cache[7] = withModifiers(() => {
              }, ["stop"]))
            }, [
              createBaseVNode("div", {
                class: normalizeClass({
                  [_ctx.nh.be("panels")]: true,
                  [_ctx.nh.bem("panels", "empty")]: !_ctx.optionsList[0] || !_ctx.optionsList[0].length
                })
              }, [
                _ctx.optionsList[0] && _ctx.optionsList[0].length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.optionsList, (items, index) => {
                  return openBlock(), createBlock(_component_CascaderPanel, {
                    key: index,
                    ref_for: true,
                    ref: (panel) => panel && _ctx.panelElList.push(panel),
                    options: items,
                    "opened-id": _ctx.openedIds[index],
                    values: _ctx.currentValues,
                    ready: _ctx.isPopperShow,
                    multiple: _ctx.props.multiple,
                    "is-async": _ctx.isAsyncLoad,
                    merged: _ctx.usingMerged,
                    "no-cascaded": _ctx.props.noCascaded,
                    onSelect: ($event) => _ctx.handleOptionSelect($event, index),
                    onHover: ($event) => _ctx.usingHover && _ctx.handlePanelOpen($event, index),
                    onCheck: _cache[5] || (_cache[5] = ($event) => _ctx.handleOptionCheck($event)),
                    onOpen: ($event) => _ctx.handlePanelKeyOpen($event, index),
                    onBack: _ctx.handlePanelBack,
                    onClose: _cache[6] || (_cache[6] = ($event) => _ctx.currentVisible = false)
                  }, {
                    default: withCtx((payload) => [
                      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(payload)))
                    ]),
                    label: withCtx((payload) => [
                      renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(payload)))
                    ]),
                    _: 2
                  }, 1032, ["options", "opened-id", "values", "ready", "multiple", "is-async", "merged", "no-cascaded", "onSelect", "onHover", "onOpen", "onBack"]);
                }), 128)) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nh.be("empty")),
                  style: normalizeStyle({ width: `${_ctx.selectorWidth}px` })
                }, [
                  renderSlot(_ctx.$slots, "empty", {}, () => {
                    var _a;
                    return [
                      createTextVNode(toDisplayString((_a = _ctx.props.emptyText) != null ? _a : _ctx.locale.empty), 1)
                    ];
                  })
                ], 6))
              ], 2)
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "onEnter"])
      ]),
      _: 3
    }, 8, ["to"])
  ], 10, _hoisted_112);
}
var Cascader = _export_sfc(_sfc_main26, [["render", _sfc_render26]]);

// node_modules/vexip-ui/es/components/grid/props.mjs
var layoutProp = [Number, String, Array];
var gridProps = buildProps({
  tag: String,
  gap: [Number, Array],
  rows: layoutProp,
  columns: layoutProp,
  autoRows: layoutProp,
  autoColumns: layoutProp,
  dense: booleanProp,
  justify: String,
  align: String,
  cellFlex: {
    type: [Boolean, Object],
    default: null
  }
});
var mediaProp3 = [Number, Object];
var cellProps = buildProps({
  tag: String,
  top: [Number, String],
  left: [Number, String],
  width: Number,
  height: Number,
  right: [Number, String],
  bottom: [Number, String],
  xs: mediaProp3,
  sm: mediaProp3,
  md: mediaProp3,
  lg: mediaProp3,
  xl: mediaProp3,
  xxl: mediaProp3,
  useFlex: {
    type: [Boolean, Object],
    default: null
  }
});

// node_modules/vexip-ui/es/components/grid/helpler.mjs
var breakPoints2 = Object.freeze(["xs", "sm", "md", "lg", "xl", "xxl"]);
var currentBreakPoint = ref("xs");
if (V) {
  let handleBreakPointChange = function() {
    for (const [point, query] of queryEntries) {
      if (query.matches) {
        currentBreakPoint.value = point;
        break;
      }
    }
  };
  const computedStyle = getComputedStyle(document.documentElement);
  const queryMap = {};
  breakPoints2.forEach((point) => {
    const media = computedStyle.getPropertyValue(`--vxp-break-point-${point}`).trim();
    const query = matchMedia(`only screen and ${media}`);
    query.addEventListener("change", handleBreakPointChange);
    queryMap[point] = query;
  });
  const queryEntries = Object.entries(queryMap).reverse();
  handleBreakPointChange();
}

// node_modules/vexip-ui/es/components/grid/symbol.mjs
var GRID_STATE = Symbol("GRID_STATE");

// node_modules/vexip-ui/es/components/grid/cell.mjs
var Cell = defineComponent({
  name: "Cell",
  props: cellProps,
  setup(_props, { slots }) {
    const props = useProps("cell", _props, {
      tag: "div",
      top: "auto",
      left: "auto",
      width: null,
      height: 1,
      right: "",
      bottom: "",
      xs: null,
      sm: null,
      md: null,
      lg: null,
      xl: null,
      xxl: null,
      useFlex: null
    });
    const gridState = inject(GRID_STATE, null);
    const nh = useNameHelper("cell");
    provide(GRID_STATE, null);
    const layoutState = reactive({
      top: props.top,
      right: props.right,
      bottom: props.bottom,
      left: props.left,
      width: props.width,
      height: props.height
    });
    const leyoutKeys = Object.keys(layoutState);
    const defaultWidth = computed(() => {
      if (y(props.width)) {
        return props.width;
      }
      return (gridState == null ? void 0 : gridState.columns) && typeof gridState.columns === "number" ? gridState.columns : 1;
    });
    watch(
      currentBreakPoint,
      (value) => {
        var _a;
        const matchSize = queryBreakPointOptions(value);
        if (matchSize) {
          if (typeof matchSize === "number") {
            leyoutKeys.forEach((key) => {
              layoutState[key] = props[key];
            });
            layoutState.width = matchSize;
          } else {
            leyoutKeys.forEach((key) => {
              layoutState[key] = Ge(matchSize, key) ? matchSize[key] : props[key];
            });
            layoutState.width = (_a = layoutState.width) != null ? _a : defaultWidth.value;
          }
        } else {
          leyoutKeys.forEach((key) => {
            layoutState[key] = props[key];
          });
          layoutState.width = defaultWidth.value;
        }
      },
      { immediate: true }
    );
    const className = computed(() => {
      const cellFelx = props.useFlex !== false && (props.useFlex || (gridState == null ? void 0 : gridState.cellFlex)) && {
        ...(gridState == null ? void 0 : gridState.cellFlex) || {},
        ...props.useFlex ? props.useFlex === true ? { justify: "start", align: "top" } : props.useFlex : {}
      };
      const className2 = {
        [nh.b()]: true,
        [nh.bm("inherit")]: gridState || props.inherit,
        [nh.bm("flex")]: cellFelx
      };
      if (cellFelx) {
        if (cellFelx.justify)
          className2[nh.bm(cellFelx.justify)] = true;
        if (cellFelx.align)
          className2[nh.bm(cellFelx.align)] = true;
      }
      return className2;
    });
    const style = computed(() => {
      const style2 = {};
      const topSet = isPositionSet(layoutState.top);
      const rightSet = isPositionSet(layoutState.right);
      const bottomSet = isPositionSet(layoutState.bottom);
      const leftSet = isPositionSet(layoutState.left);
      if (topSet && bottomSet) {
        style2.gridRowStart = parsePosition(layoutState.top);
        style2.gridRowEnd = parsePosition(layoutState.bottom);
      } else if (topSet) {
        style2.gridRowStart = parsePosition(layoutState.top);
        style2.gridRowEnd = `span ${layoutState.height}`;
      } else if (bottomSet) {
        style2.gridRowStart = `span ${layoutState.height}`;
        style2.gridRowEnd = parsePosition(layoutState.bottom);
      } else {
        style2.gridRowEnd = `span ${layoutState.height}`;
      }
      if (leftSet && rightSet) {
        style2.gridColumnStart = parsePosition(layoutState.left);
        style2.gridColumnEnd = parsePosition(layoutState.right);
      } else if (leftSet) {
        style2.gridColumnStart = parsePosition(layoutState.left);
        style2.gridColumnEnd = `span ${layoutState.width}`;
      } else if (rightSet) {
        style2.gridColumnStart = `span ${layoutState.width}`;
        style2.gridColumnEnd = parsePosition(layoutState.right);
      } else {
        style2.gridColumnStart = `span ${layoutState.width}`;
      }
      return style2;
    });
    function isPositionSet(value) {
      return value === 0 || value && value !== "auto";
    }
    function parsePosition(value) {
      return typeof value === "number" ? value + 1 : value;
    }
    function queryBreakPointOptions(breakPoint) {
      const index = breakPoints2.findIndex((v5) => v5 === breakPoint);
      if (~index) {
        for (let i = index; i >= 0; --i) {
          if (y(props[breakPoints2[i]])) {
            return props[breakPoints2[i]];
          }
        }
      }
      return null;
    }
    return () => h(
      props.tag || "div",
      {
        class: className.value,
        style: style.value
      },
      {
        default: () => {
          var _a;
          return (_a = slots.default) == null ? void 0 : _a.call(slots);
        }
      }
    );
  }
});

// node_modules/vexip-ui/es/components/checkbox/checkbox-group.mjs
var _sfc_main27 = defineComponent({
  name: "CheckboxGroup",
  components: {
    Checkbox
  },
  props: checkboxGroupProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, size, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a, _b;
      return (_b = (_a = Array.from(inputSet)[0]) == null ? void 0 : _a.value) == null ? void 0 : _b.focus();
    });
    const props = useProps("checkboxGroup", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue([]),
        static: true
      },
      vertical: false,
      disabled: () => disabled.value,
      border: false,
      options: {
        default: () => [],
        static: true
      },
      loading: () => loading.value,
      control: null,
      loadingLock: false
    });
    const nh = useNameHelper("checkbox-group");
    const locale = useLocale("checkbox");
    const valueMap = /* @__PURE__ */ new Map();
    const inputSet = /* @__PURE__ */ new Set();
    const controlSet = /* @__PURE__ */ new Set();
    const currentValues = ref(props.value || []);
    const className = computed(() => {
      return [
        nh.b(),
        nh.ns("checkbox-vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("vertical")]: props.vertical,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading && props.loadingLock,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("border")]: props.border,
          [nh.bm(props.state)]: props.state !== "default"
        }
      ];
    });
    const controlLabel = computed(() => {
      return typeof props.control === "string" ? props.control : locale.value.all;
    });
    const updateValue = Mr(() => {
      currentValues.value = [];
      valueMap.forEach((checked, value) => {
        if (checked) {
          currentValues.value.push(value);
        }
      });
      handleChange(currentValues.value);
    });
    const updateControl = Mr(() => {
      const valueLength = currentValues.value.length;
      const checked = valueLength === valueMap.size;
      const partial = valueLength > 0 && !checked;
      controlSet.forEach((state2) => {
        state2.checked = checked;
        state2.partial = partial;
      });
    });
    provide(
      GROUP_STATE3,
      reactive({
        currentValues,
        size: toRef(props, "size"),
        state: toRef(props, "state"),
        disabled: toRef(props, "disabled"),
        loading: toRef(props, "loading"),
        loadingLock: toRef(props, "loadingLock"),
        increaseItem,
        decreaseItem,
        increaseControl,
        decreaseControl,
        handleControlChange,
        setItemChecked,
        replaceValue
      })
    );
    watch(
      () => props.value,
      (value) => {
        const checkedValues = new Set(value);
        const allValues = Array.from(valueMap.keys());
        currentValues.value = [];
        allValues.forEach((value2) => {
          const checked = checkedValues.has(value2);
          valueMap.set(value2, checkedValues.has(value2));
          checked && currentValues.value.push(value2);
        });
      }
    );
    watch(currentValues, () => {
      updateControl();
    });
    function increaseItem(value, checked, input) {
      valueMap.set(value, checked);
      inputSet.add(input);
    }
    function decreaseItem(value, input) {
      valueMap.delete(value);
      inputSet.delete(input);
    }
    function increaseControl(state2) {
      controlSet.add(state2);
      updateControl();
    }
    function decreaseControl(state2) {
      controlSet.delete(state2);
    }
    function setItemChecked(value, checked) {
      if (!y(value) || !valueMap.has(value))
        return;
      valueMap.set(value, checked);
      updateValue();
      updateControl();
    }
    function handleControlChange() {
      const allValues = Array.from(valueMap.keys());
      const checked = currentValues.value.length !== allValues.length;
      allValues.forEach((value) => {
        valueMap.set(value, checked);
      });
      updateValue();
      updateControl();
    }
    function handleChange(value) {
      setFieldValue(value);
      emitEvent(props.onChange, value);
      emit("update:value", value);
      validateField();
    }
    function replaceValue(prevValue, newValue) {
      if (y(prevValue) && y(newValue) && prevValue !== newValue && valueMap.has(prevValue)) {
        valueMap.set(newValue, valueMap.get(prevValue));
        valueMap.delete(prevValue);
      }
    }
    return {
      props,
      idFor,
      className,
      controlLabel,
      isObject: L,
      increaseControl,
      decreaseControl
    };
  }
});
var _hoisted_113 = ["id"];
function _sfc_render27(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    role: "group"
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      _ctx.props.control ? (openBlock(), createBlock(_component_Checkbox, {
        key: 0,
        inherit: "",
        control: ""
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.controlLabel), 1)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.options, (item, index) => {
        return openBlock(), createElementBlock(Fragment, { key: index }, [
          _ctx.isObject(item) ? (openBlock(), createBlock(_component_Checkbox, {
            key: 0,
            inherit: "",
            value: item.value,
            control: item.control
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item.label || item.value), 1)
            ]),
            _: 2
          }, 1032, ["value", "control"])) : (openBlock(), createBlock(_component_Checkbox, {
            key: 1,
            inherit: "",
            value: item
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item), 1)
            ]),
            _: 2
          }, 1032, ["value"]))
        ], 64);
      }), 128))
    ])
  ], 10, _hoisted_113);
}
var CheckboxGroup = _export_sfc(_sfc_main27, [["render", _sfc_render27]]);

// node_modules/vexip-ui/es/components/collapse/symbol.mjs
var COLLAPSE_STATE = Symbol("COLLAPSE_STATE");

// node_modules/vexip-ui/es/components/collapse/collapse.mjs
var _sfc_main28 = defineComponent({
  name: "Collapse",
  props: collapseProps,
  emits: ["update:expanded"],
  setup(_props, { emit }) {
    const props = useProps("collapse", _props, {
      expanded: {
        default: null,
        static: true
      },
      card: false,
      accordion: false,
      arrowType: {
        default: "right",
        validator: (value) => ["right", "left", "none"].includes(value)
      },
      ghost: false
    });
    const nh = useNameHelper("collapse");
    const paneExpandedMap = /* @__PURE__ */ new Map();
    const currentExpanded = ref([]);
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(`arrow-${props.arrowType}`),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("card")]: props.card,
          [nh.bm("ghost")]: !props.card && props.ghost
        }
      ];
    });
    provide(
      COLLAPSE_STATE,
      reactive({
        arrowType: toRef(props, "arrowType"),
        registerPane,
        unregisterPane,
        expandPane
      })
    );
    watchEffect(() => {
      const rawExpanded = props.expanded;
      const expanded = props.accordion && Array.isArray(rawExpanded) ? rawExpanded[0] : rawExpanded || rawExpanded === 0 ? rawExpanded : [];
      currentExpanded.value = Array.isArray(expanded) ? Array.from(expanded) : [expanded];
    });
    onMounted(() => {
      nextTick(updateItemExpanded);
    });
    function registerPane(label, paneExpanded) {
      paneExpandedMap.set(label, paneExpanded);
      if (currentExpanded.value.includes(label)) {
        paneExpanded.value = true;
      } else if (paneExpanded.value) {
        expandPane(label, true);
      }
    }
    function unregisterPane(label) {
      paneExpandedMap.delete(label);
      expandPane(label, false);
    }
    function expandPane(label, expanded) {
      if (!label && label !== 0)
        return;
      if (props.accordion) {
        currentExpanded.value = expanded ? [label] : [];
      } else {
        if (expanded) {
          currentExpanded.value.push(label);
        } else {
          kr(currentExpanded.value, label);
        }
      }
      emitChangeEvent();
      updateItemExpanded();
    }
    function emitChangeEvent() {
      emitEvent(props.onChange, currentExpanded.value);
      emit("update:expanded", currentExpanded.value);
    }
    function updateItemExpanded() {
      paneExpandedMap.forEach((expanded, label) => {
        expanded.value = currentExpanded.value.includes(label);
      });
    }
    return {
      className
    };
  }
});
function _sfc_render28(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "tablist"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var Collapse = _export_sfc(_sfc_main28, [["render", _sfc_render28]]);

// node_modules/vexip-ui/es/components/collapse/collapse-panel.mjs
var _sfc_main29 = defineComponent({
  name: "CollapsePanel",
  components: {
    CollapseTransition,
    Icon,
    ChevronRight: $17
  },
  props: collapsePanelProps,
  emits: ["update:expanded"],
  setup(_props, { emit }) {
    const props = useProps("collapsePanel", _props, {
      label: {
        default: null,
        static: true
      },
      title: "",
      disabled: false,
      contentStyle: null,
      expanded: false,
      card: false,
      arrowType: {
        default: "right",
        validator: (value) => ["right", "left", "none"].includes(value)
      },
      icon: null,
      ghost: false
    });
    const collapseState = inject(COLLAPSE_STATE, null);
    const nh = useNameHelper("collapse");
    const currentExpanded = ref(props.expanded);
    const currentLabel = ref("");
    const useCard = computed(() => {
      if (!collapseState) {
        return props.card;
      }
      return false;
    });
    const useGhost = computed(() => {
      if (!collapseState) {
        return props.ghost;
      }
      return false;
    });
    const useArrowType = computed(() => {
      if (collapseState) {
        return collapseState.arrowType;
      }
      return props.arrowType;
    });
    const className = computed(() => {
      return [
        nh.be("panel"),
        nh.bs("vars"),
        nh.bem("panel", `arrow-${useArrowType.value}`),
        {
          [nh.bem("panel", "inherit")]: collapseState || props.inherit,
          [nh.bem("panel", "card")]: useCard.value,
          [nh.bem("panel", "ghost")]: !useCard.value && useGhost.value,
          [nh.bem("panel", "expanded")]: currentExpanded.value,
          [nh.bem("panel", "disabled")]: props.disabled
        }
      ];
    });
    watch(
      () => props.label,
      (value) => {
        const prevValue = currentLabel.value;
        currentLabel.value = value || value === 0 ? value : prevValue;
        if (collapseState && prevValue !== currentLabel.value) {
          collapseState.unregisterPane(prevValue);
          collapseState.registerPane(currentLabel.value, currentExpanded);
        }
      }
    );
    watch(currentExpanded, (value) => {
      emitEvent(props.onToggle, value);
      emit("update:expanded", value);
    });
    if (!collapseState) {
      watch(
        () => props.expanded,
        (value) => {
          currentExpanded.value = value;
        }
      );
    }
    if (collapseState) {
      onMounted(() => {
        if (props.label || props.label === 0) {
          currentLabel.value = props.label;
        } else {
          currentLabel.value = dn();
        }
        collapseState.registerPane(currentLabel.value, currentExpanded);
      });
      onBeforeUnmount(() => {
        collapseState.unregisterPane(currentLabel.value);
      });
    }
    function handleToggle() {
      if (props.disabled)
        return;
      if (collapseState) {
        collapseState.expandPane(currentLabel.value, !currentExpanded.value);
      } else {
        currentExpanded.value = !currentExpanded.value;
      }
    }
    return {
      props,
      nh,
      inGroup: !!collapseState,
      currentExpanded,
      className,
      handleToggle
    };
  }
});
var _hoisted_114 = ["role", "aria-expanded"];
function _sfc_render29(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChevronRight = resolveComponent("ChevronRight");
  const _component_Icon = resolveComponent("Icon");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return openBlock(), createElementBlock("section", {
    class: normalizeClass(_ctx.className),
    role: _ctx.inGroup ? "tab" : void 0,
    "aria-expanded": _ctx.currentExpanded
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("header")),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleToggle && _ctx.handleToggle(...args))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("arrow"))
      }, [
        createVNode(_component_Icon, null, {
          default: withCtx(() => [
            createVNode(_component_ChevronRight)
          ]),
          _: 1
        })
      ], 2),
      renderSlot(_ctx.$slots, "title", {}, () => [
        _ctx.props.icon ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("icon"))
        }, [
          createVNode(_component_Icon, {
            icon: _ctx.props.icon
          }, null, 8, ["icon"])
        ], 2)) : createCommentVNode("", true),
        createTextVNode(" " + toDisplayString(_ctx.props.title), 1)
      ])
    ], 2),
    createVNode(_component_CollapseTransition, null, {
      default: withCtx(() => [
        _ctx.currentExpanded ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("body"))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("content")),
            style: normalizeStyle(_ctx.props.contentStyle)
          }, [
            renderSlot(_ctx.$slots, "default")
          ], 6)
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 3
    })
  ], 10, _hoisted_114);
}
var CollapsePanel = _export_sfc(_sfc_main29, [["render", _sfc_render29]]);

// node_modules/vexip-ui/es/components/color-picker/color-alpha.mjs
var _sfc_main30 = defineComponent({
  name: "ColorAlpha",
  props: {
    rgb: {
      type: Object,
      default: () => {
        return { r: 0, g: 0, b: 0 };
      },
      validator: (value) => {
        return "r" in value && "g" in value && "b" in value;
      }
    },
    alpha: {
      type: Number,
      default: 1,
      validator: (value) => {
        return value >= 0 && value <= 1;
      }
    }
  },
  emits: ["edit-start", "edit-end", "change"],
  setup(props, { emit }) {
    const currentLeft = ref(props.alpha * 100);
    let prevLeft = currentLeft.value;
    let widthLimit;
    let leftStartAt;
    const { target: wrapper } = No({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.left || modifier.right) {
          event.preventDefault();
          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2;
          const delta = step * (modifier.left ? -1 : 1);
          currentLeft.value += delta;
          verifyPosition();
          prevLeft = currentLeft.value;
          handleChange();
        }
      }
    });
    const { moving: editing } = jo({
      target: wrapper,
      onStart: (state, event) => {
        if (!wrapper.value || event.button > 0) {
          return false;
        }
        const rect = wrapper.value.getBoundingClientRect();
        const { left, width } = rect;
        widthLimit = width;
        currentLeft.value = (leftStartAt = state.clientX - left) / width * 100;
        verifyPosition();
        emit("edit-start");
        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {
          prevLeft = currentLeft.value;
          handleChange();
        }
      },
      onMove: (state) => {
        currentLeft.value = (leftStartAt + state.deltaX) / widthLimit * 100;
        verifyPosition();
        handleChange();
      },
      onEnd: () => {
        emit("edit-end");
      }
    });
    const rgbString = computed(() => {
      const { r, g, b } = props.rgb;
      return `${r}, ${g}, ${b}`;
    });
    verifyPosition();
    watch(
      () => props.alpha,
      (value) => {
        currentLeft.value = value * 100;
        verifyPosition();
      },
      { immediate: true }
    );
    function verifyPosition() {
      currentLeft.value = zt(Fn(currentLeft.value, 0, 100), 3);
    }
    function handleChange() {
      emit("change", currentLeft.value / 100);
    }
    return {
      nh: useNameHelper("color-picker"),
      currentLeft,
      editing,
      rgbString,
      wrapper
    };
  }
});
function _sfc_render30(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("alpha")),
    tabindex: "-1"
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("opacity")),
      style: normalizeStyle({
        backgroundImage: `linear-gradient(to right, rgba(${_ctx.rgbString}, 0) 0%, rgb(${_ctx.rgbString}) 100%)`
      })
    }, null, 6),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("alpha-handler")),
      style: normalizeStyle({ left: `${_ctx.currentLeft}%` })
    }, null, 6)
  ], 2);
}
var ColorAlpha = _export_sfc(_sfc_main30, [["render", _sfc_render30]]);

// node_modules/vexip-ui/es/components/color-picker/color-hue.mjs
var _sfc_main31 = defineComponent({
  name: "ColorHue",
  props: {
    hue: {
      type: Number,
      default: 0,
      validator: (value) => {
        return value >= 0 && value <= 360;
      }
    }
  },
  emits: ["edit-start", "edit-end", "change"],
  setup(props, { emit }) {
    const currentLeft = ref(props.hue * 100);
    let prevLeft = currentLeft.value;
    let widthLimit;
    let leftStartAt;
    const { target: wrapper } = No({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.left || modifier.right) {
          event.preventDefault();
          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2;
          const delta = step * (modifier.left ? -1 : 1);
          currentLeft.value += delta;
          verifyPosition();
          prevLeft = currentLeft.value;
          handleChange();
        }
      }
    });
    const { moving: editing } = jo({
      target: wrapper,
      onStart: (state, event) => {
        if (!wrapper.value || event.button > 0) {
          return false;
        }
        const rect = wrapper.value.getBoundingClientRect();
        const { left, width } = rect;
        widthLimit = width;
        currentLeft.value = (leftStartAt = state.clientX - left) / width * 100;
        verifyPosition();
        emit("edit-start");
        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {
          prevLeft = currentLeft.value;
          handleChange();
        }
      },
      onMove: (state) => {
        currentLeft.value = (leftStartAt + state.deltaX) / widthLimit * 100;
        verifyPosition();
        handleChange();
      },
      onEnd: () => {
        emit("edit-end");
      }
    });
    watch(
      () => props.hue,
      (value) => {
        currentLeft.value = value / 360 * 100;
        verifyPosition();
      },
      { immediate: true }
    );
    function verifyPosition() {
      currentLeft.value = zt(Fn(currentLeft.value, 0, 100), 3);
    }
    function handleChange() {
      emit("change", currentLeft.value / 100 * 360);
    }
    return {
      nh: useNameHelper("color-picker"),
      currentLeft,
      editing,
      wrapper
    };
  }
});
function _sfc_render31(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("hue")),
    tabindex: "-1"
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("hue-handler")),
      style: normalizeStyle({ left: `${_ctx.currentLeft}%` })
    }, null, 6)
  ], 2);
}
var ColorHue = _export_sfc(_sfc_main31, [["render", _sfc_render31]]);

// node_modules/vexip-ui/es/components/color-picker/color-palette.mjs
var _sfc_main32 = defineComponent({
  name: "ColorPalette",
  props: {
    hue: {
      type: Number,
      default: 0,
      validator: (value) => {
        return value >= 0 && value <= 360;
      }
    },
    value: {
      type: Number,
      default: 1,
      validator: (value) => {
        return value >= 0 && value <= 1;
      }
    },
    saturation: {
      type: Number,
      default: 0,
      validator: (value) => {
        return value >= 0 && value <= 1;
      }
    }
  },
  emits: ["edit-start", "edit-end", "change"],
  setup(props, { emit }) {
    const currentTop = ref((1 - props.value) * 100);
    const currentLeft = ref(props.saturation * 100);
    let prevTop = currentTop.value;
    let prevLeft = currentLeft.value;
    let widthLimit;
    let heightLimit;
    let topStartAt;
    let leftStartAt;
    const { target: wrapper } = No({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down || modifier.left || modifier.right) {
          event.preventDefault();
          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2;
          const sign = modifier.up || modifier.left ? -1 : 1;
          const delta = step * sign;
          if (modifier.up || modifier.down) {
            currentTop.value += delta;
          } else {
            currentLeft.value += delta;
          }
          verifyPosition();
          prevTop = currentTop.value;
          prevLeft = currentLeft.value;
          handleChange();
        }
      }
    });
    const { moving: editing } = jo({
      target: wrapper,
      onStart: (state, event) => {
        if (!wrapper.value || event.button > 0) {
          return false;
        }
        const rect = wrapper.value.getBoundingClientRect();
        const { top, left, width, height } = rect;
        widthLimit = width;
        heightLimit = height;
        currentTop.value = (topStartAt = state.clientY - top) / height * 100;
        currentLeft.value = (leftStartAt = state.clientX - left) / width * 100;
        verifyPosition();
        emit("edit-start");
        let changed = false;
        if (Math.abs(currentTop.value - prevTop) >= 0.01) {
          prevTop = currentTop.value;
          changed = true;
        }
        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {
          prevLeft = currentLeft.value;
          changed = true;
        }
        changed && handleChange();
      },
      onMove: (state) => {
        currentTop.value = (topStartAt + state.deltaY) / heightLimit * 100;
        currentLeft.value = (leftStartAt + state.deltaX) / widthLimit * 100;
        verifyPosition();
        handleChange();
      },
      onEnd: () => {
        emit("edit-end");
      }
    });
    watch(
      () => props.value,
      (value) => {
        currentTop.value = (1 - value) * 100;
        verifyPosition();
      },
      { immediate: true }
    );
    watch(
      () => props.saturation,
      (value) => {
        currentLeft.value = value * 100;
        verifyPosition();
      },
      { immediate: true }
    );
    function verifyPosition() {
      currentTop.value = zt(Fn(currentTop.value, 0, 100), 3);
      currentLeft.value = zt(Fn(currentLeft.value, 0, 100), 3);
    }
    function handleChange() {
      emit("change", {
        h: props.hue,
        s: currentLeft.value / 100,
        v: zt(1 - currentTop.value / 100, 3)
      });
    }
    return {
      nh: useNameHelper("color-picker"),
      currentTop,
      currentLeft,
      editing,
      wrapper
    };
  }
});
function _sfc_render32(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("palette")),
    tabindex: "-1",
    style: normalizeStyle({
      backgroundColor: `hsl(${_ctx.hue}, 100%, 50%)`
    })
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("saturation"))
    }, null, 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("value"))
    }, null, 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("palette-handler")),
      style: normalizeStyle({
        top: `${_ctx.currentTop}%`,
        left: `${_ctx.currentLeft}%`
      })
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("palette-pointer"))
      }, null, 2)
    ], 6)
  ], 6);
}
var ColorPalette = _export_sfc(_sfc_main32, [["render", _sfc_render32]]);

// node_modules/vexip-ui/es/components/input/props.mjs
var inputProps = buildProps({
  size: sizeProp,
  state: stateProp,
  type: String,
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  formatter: Function,
  value: [String, Number],
  placeholder: String,
  autofocus: booleanProp,
  spellcheck: booleanProp,
  autocomplete: booleanProp,
  readonly: booleanProp,
  disabled: booleanProp,
  inputClass: classProp,
  debounce: booleanProp,
  maxLength: Number,
  before: String,
  after: String,
  plainPassword: booleanProp,
  clearable: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  transparent: booleanProp,
  sync: booleanProp,
  onFocus: eventProp(),
  onBlur: eventProp(),
  onInput: eventProp(),
  onChange: eventProp(),
  onEnter: eventProp(),
  onClear: eventProp(),
  onPrefixClick: eventProp(),
  onSuffixClick: eventProp(),
  onKeyDown: eventProp(),
  onKeyPress: eventProp(),
  onKeyUp: eventProp()
});

// node_modules/vexip-ui/es/components/input/input.mjs
function _isSlot2(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var inputTypes = Object.freeze(["text", "password", "date", "datetime", "time"]);
function toNotNullString(value) {
  return qe(value) ? "" : String(value);
}
var Input = defineComponent({
  name: "Input",
  components: {
    Icon
  },
  props: inputProps,
  emits: ["update:value"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = inputControl.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("input", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      type: {
        default: "text",
        validator: (value) => inputTypes.includes(value)
      },
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      formatter: {
        default: null,
        isFunc: true
      },
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      placeholder: null,
      autofocus: false,
      spellcheck: false,
      autocomplete: false,
      readonly: false,
      disabled: () => disabled.value,
      inputClass: "",
      debounce: false,
      maxLength: 0,
      before: "",
      after: "",
      plainPassword: false,
      clearable: false,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      transparent: false,
      sync: false
    });
    const initValue = toNotNullString(props.value);
    const nh = useNameHelper("input");
    const focused = ref(false);
    const currentValue = ref(initValue);
    const showPassword = ref(false);
    const currentLength = ref(initValue.length);
    const beforeHover = ref(false);
    const afterHover = ref(false);
    const inputControl = ref();
    const {
      wrapper: control,
      isHover
    } = Co();
    const locale = useLocale("input");
    let lastValue = props.value;
    const hasBefore = computed(() => {
      return !!(slots.before || slots.beforeAction || slots["before-action"] || props.before);
    });
    const hasAfter = computed(() => {
      return !!(slots.after || slots.afterAction || slots["after-action"] || props.after);
    });
    const basisClass = computed(() => {
      return {
        [nh.bs("wrapper")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.size)]: props.size !== "default"
      };
    });
    const className = computed(() => {
      return [nh.b(), nh.bm(props.type), !hasBefore.value && !hasAfter.value && basisClass.value, {
        [nh.bm("focused")]: focused.value,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("loading")]: props.loading && props.loadingLock,
        [nh.bm(props.state)]: props.state !== "default",
        [nh.bm("before")]: slots.beforeAction || slots["before-action"],
        [nh.bm("after")]: slots.afterAction || slots["after-action"],
        [nh.bm("loading")]: props.loading,
        [nh.bm("transparent")]: props.transparent
      }];
    });
    const wrapperClass = computed(() => {
      return {
        ...basisClass.value,
        [nh.bm(`wrapper--${props.size}`)]: props.size !== "default",
        [nh.bs("wrapper--before-only")]: hasBefore.value && !hasAfter.value,
        [nh.bs("wrapper--after-only")]: !hasBefore.value && hasAfter.value,
        [nh.bm("transparent")]: props.transparent
      };
    });
    const hasPrefix = computed(() => !!(slots.prefix || props.prefix));
    const hasSuffix = computed(() => !!(slots.suffix || props.suffix));
    const inputType = computed(() => {
      const type = props.type;
      if (type === "password") {
        return showPassword.value ? "text" : "password";
      }
      if (type === "datetime") {
        return "datetime-local";
      }
      return type;
    });
    const formattedValue = computed(() => {
      return typeof props.formatter === "function" ? toNotNullString(props.formatter(currentValue.value)) : currentValue.value;
    });
    const passwordIcon = computed(() => showPassword.value ? x20 : u4);
    const hasValue = computed(() => {
      return !(qe(currentValue.value) || currentValue.value === "");
    });
    const readonly = computed(() => props.loading && props.loadingLock || props.readonly);
    const showClear = computed(() => {
      return !props.disabled && props.clearable && hasValue.value && isHover.value;
    });
    watch(() => props.value, (value) => {
      currentValue.value = toNotNullString(value);
      limitValueLength();
      lastValue = currentValue.value;
    });
    expose({
      input: inputControl,
      focus: () => {
        var _a;
        (_a = inputControl.value) == null ? void 0 : _a.focus();
      },
      blur: () => {
        var _a;
        (_a = inputControl.value) == null ? void 0 : _a.blur();
      }
    });
    function handleFocus(event) {
      if (!focused.value) {
        focused.value = true;
        emitEvent(props.onFocus, event);
      }
    }
    function handleBlur(event) {
      if (focused.value) {
        focused.value = false;
        setTimeout(() => {
          if (!focused.value) {
            emitEvent(props.onBlur, event);
            emitChangeEvent("change");
          }
        }, 120);
      }
    }
    function handleChange(event) {
      const type = event.type;
      currentValue.value = event.target.value;
      limitValueLength();
      const value = currentValue.value;
      setValue(value, type);
    }
    function setValue(value, type) {
      currentValue.value = value;
      emitChangeEvent(type);
    }
    function emitChangeEvent(type) {
      type = type === "input" ? "input" : "change";
      const value = typeof props.value === "number" ? parseFloat(currentValue.value) : currentValue.value;
      if (type === "change") {
        if (lastValue === value)
          return;
        lastValue = value;
        setFieldValue(value);
        emitEvent(props.onChange, value);
        if (!props.sync) {
          emit("update:value", value);
          validateField();
        }
      } else {
        emitEvent(props.onInput, value);
        if (props.sync) {
          emit("update:value", value);
          validateField();
        }
      }
    }
    function limitValueLength() {
      let value = currentValue.value;
      if (qe(value)) {
        currentLength.value = 0;
        return;
      }
      const maxLength = props.maxLength;
      if (maxLength && value.length > maxLength) {
        value = value.slice(0, maxLength);
      }
      currentLength.value = value.length;
      currentValue.value = value;
    }
    function toggleShowPassword() {
      var _a;
      if (props.disabled) {
        return;
      }
      showPassword.value = !showPassword.value;
      (_a = inputControl.value) == null ? void 0 : _a.focus();
    }
    function handleClear(event) {
      event.stopPropagation();
      setValue("", "change");
      if (props.sync) {
        emit("update:value", currentValue.value);
        validateField();
      }
      emitEvent(props.onClear);
      nextTick(clearField);
    }
    function handleEnter() {
      emitEvent(props.onEnter);
    }
    function handlePrefixClick(event) {
      emitEvent(props.onPrefixClick, event);
    }
    function handleSuffixClick(event) {
      emitEvent(props.onSuffixClick, event);
    }
    function handleKeyDown(event) {
      emitEvent(props.onKeyDown, event);
    }
    function handleKeyPress(event) {
      emitEvent(props.onKeyPress, event);
    }
    function handleKeyUp(event) {
      if (event.key === "Enter") {
        handleEnter();
      }
      emitEvent(props.onKeyUp, event);
    }
    const handleInput = props.debounce ? yr(handleChange) : br(handleChange);
    function renderPrefix() {
      return createVNode("div", {
        "class": [nh.be("icon"), nh.be("prefix")],
        "style": {
          color: props.prefixColor
        },
        "onClick": handlePrefixClick
      }, [slots.prefix ? slots.prefix() : createVNode(Icon, {
        "icon": props.prefix
      }, null)]);
    }
    function renderCustomSuffix() {
      if (hasSuffix.value) {
        return createVNode("div", {
          "key": "suffix",
          "class": [nh.be("icon"), nh.be("suffix")],
          "style": {
            color: props.suffixColor,
            opacity: showClear.value || props.loading ? "0%" : ""
          },
          "onClick": handleSuffixClick
        }, [slots.suffix ? slots.suffix() : createVNode(Icon, {
          "icon": props.suffix
        }, null)]);
      }
      if (props.type === "password" && props.plainPassword) {
        return createVNode("div", {
          "key": "password",
          "class": [nh.be("icon"), nh.be("password")],
          "style": {
            color: props.suffixColor,
            opacity: showClear.value || props.loading ? "0%" : ""
          },
          "onClick": toggleShowPassword
        }, [createVNode(Icon, {
          "icon": passwordIcon.value
        }, null)]);
      }
      if (props.clearable || props.loading) {
        return createVNode("div", {
          "key": "placeholder",
          "class": [nh.be("icon"), nh.bem("icon", "placeholder")]
        }, null);
      }
      return null;
    }
    function renderSuffixAction() {
      if (showClear.value) {
        return createVNode("div", {
          "key": "clear",
          "class": [nh.be("icon"), nh.be("clear")],
          "onClick": handleClear
        }, [createVNode(Icon, {
          "icon": u
        }, null)]);
      }
      if (props.loading) {
        return createVNode("div", {
          "key": "loading",
          "class": [nh.be("icon"), nh.be("loading")]
        }, [createVNode(Icon, {
          "spin": props.loadingSpin,
          "pulse": !props.loadingSpin,
          "icon": props.loadingIcon
        }, null)]);
      }
      return null;
    }
    function renderSuffix() {
      let _slot;
      return createVNode("div", {
        "class": nh.be("suffix-wrapper")
      }, [renderCustomSuffix(), createVNode(Transition, {
        "name": nh.ns("fade"),
        "appear": true
      }, _isSlot2(_slot = renderSuffixAction()) ? _slot : {
        default: () => [_slot]
      })]);
    }
    function renderCount() {
      return createVNode("div", {
        "class": nh.be("count")
      }, [slots.count ? slots.count({
        value: currentValue.value
      }) : `${currentLength.value}/${props.maxLength}`]);
    }
    function renderControl() {
      var _a;
      return createVNode("div", {
        "id": idFor.value,
        "ref": control,
        "class": className.value,
        "onClick": () => {
          var _a2;
          return (_a2 = inputControl.value) == null ? void 0 : _a2.focus();
        }
      }, [hasPrefix.value && renderPrefix(), createVNode("input", {
        "ref": inputControl,
        "class": [nh.be("control"), props.inputClass],
        "type": inputType.value,
        "value": formattedValue.value,
        "autofocus": props.autofocus,
        "autocomplete": props.autocomplete ? "on" : "off",
        "spellcheck": props.spellcheck,
        "disabled": props.disabled,
        "readonly": readonly.value,
        "placeholder": (_a = props.placeholder) != null ? _a : locale.value.placeholder,
        "maxlength": props.maxLength > 0 ? props.maxLength : void 0,
        "onBlur": handleBlur,
        "onFocus": handleFocus,
        "onInput": handleInput,
        "onChange": handleChange,
        "onKeypress": handleKeyPress,
        "onKeydown": handleKeyDown,
        "onKeyup": handleKeyUp
      }, null), renderSuffix(), props.maxLength > 0 ? renderCount() : null]);
    }
    function renderAside(type) {
      const buttonSlot = slots[`${type}Action`] || slots[`${type}-action`];
      if (buttonSlot) {
        return createVNode("div", {
          "class": [nh.be(type), nh.bem(type, "action")],
          "onMouseenter": () => (type === "before" ? beforeHover : afterHover).value = true,
          "onMouseleave": () => (type === "before" ? beforeHover : afterHover).value = false
        }, [buttonSlot()]);
      }
      return createVNode("div", {
        "class": nh.be(type)
      }, [slots[type] ? slots[type]() : props[type]]);
    }
    return () => {
      if (hasBefore.value || hasAfter.value) {
        return createVNode("div", {
          "class": wrapperClass.value
        }, [hasBefore.value && renderAside("before"), renderControl(), hasAfter.value && renderAside("after")]);
      }
      return renderControl();
    };
  },
  methods: {
    focus: cn,
    blur: cn
  }
});

// node_modules/vexip-ui/es/components/color-picker/props.mjs
var colorPickerProps = buildProps({
  size: sizeProp,
  state: stateProp,
  value: [String, Object],
  visible: booleanProp,
  format: String,
  alpha: booleanProp,
  disabled: booleanProp,
  transitionName: String,
  noInput: booleanProp,
  shortcut: {
    type: [Boolean, Array],
    default: null
  },
  placement: String,
  transfer: booleanStringProp,
  outsideClose: booleanProp,
  clearable: booleanProp,
  cancelText: String,
  confirmText: String,
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  noSuffix: booleanProp,
  staticSuffix: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  onToggle: eventProp(),
  onClickOutside: eventProp(),
  onOutsideClose: eventProp(),
  onClear: eventProp(),
  onChange: eventProp(),
  onShortcut: eventProp()
});

// node_modules/vexip-ui/es/components/color-picker/color-picker.mjs
var getDefaultHsv = () => Ft(0, 0, 0);
var defaultShotcuts = Object.freeze([
  "#2d8cf0",
  "#19be6b",
  "#ff9900",
  "#ed4014",
  "#00b5ff",
  "#19c919",
  "#f9e31c",
  "#ea1a1a",
  "#9b1dea",
  "#00c2b1",
  "#ac7a33",
  "#1d35ea",
  "#8bc34a",
  "#f16b62",
  "#ea4ca3",
  "#0d94aa",
  "#febd79",
  "#5d4037",
  "#00bcd4",
  "#f06292",
  "#cddc39",
  "#607d8b",
  "#000000",
  "#ffffff"
]);
var _sfc_main33 = defineComponent({
  name: "ColorPicker",
  components: {
    Button,
    ColorAlpha,
    ColorHue,
    ColorPalette,
    Icon,
    Input,
    Portal,
    Xmark: L2,
    ChevronDown: $15,
    CircleXmark: u
  },
  props: colorPickerProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("color-picker");
    const props = useProps("colorPicker", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      visible: false,
      format: {
        default: "rgb",
        validator: (value) => ["rgb", "hsl", "hsv", "hex"].includes(value)
      },
      alpha: false,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      noInput: false,
      shortcut: false,
      placement: {
        default: "bottom",
        validator: (value) => Wo.includes(value)
      },
      transfer: false,
      outsideClose: true,
      clearable: false,
      cancelText: null,
      confirmText: null,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      staticSuffix: false,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false
    });
    const isEmpty = ref(true);
    const currentVisible = ref(props.visible);
    const currentValue = ref(null);
    const currentAlpha = ref(1);
    const editing = ref(false);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const shortcutHitting = ref(0);
    const shortcutsFocused = ref(false);
    parseValue(props.value);
    const palette = ref(null);
    const hue = ref(null);
    const alpha = ref(null);
    const shortcut = ref(null);
    const input = ref(null);
    const cancel = ref(null);
    const confirm = ref(null);
    const wrapper = Do(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = qo({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = Co(reference);
    const unitList = computed(() => {
      return [
        palette.value,
        hue.value,
        alpha.value,
        shortcut.value,
        input.value,
        cancel.value,
        confirm.value
      ].filter(Boolean);
    });
    const lastValue = ref({
      ...currentValue.value,
      a: currentAlpha.value,
      format: "hsva"
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("empty")]: isEmpty.value && !currentVisible.value,
        [nh.bm("focused")]: currentVisible.value,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("alpha")]: props.alpha,
        [nh.bm(props.size)]: props.size !== "default",
        [nh.bm(props.state)]: props.state !== "default"
      };
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--focused`]: currentVisible.value,
        [`${baseCls}--${props.state}`]: props.state !== "default"
      };
    });
    const rgb = computed(() => {
      var _a;
      const { h: h7, s, v: v5 } = currentValue.value && currentVisible.value ? currentValue.value : (_a = lastValue.value) != null ? _a : { h: 0, s: 0, v: 0 };
      return qt(h7, s, v5);
    });
    const hex = computed(() => {
      const { r, g, b } = rgb.value;
      if (props.alpha) {
        return kt(r, g, b, currentAlpha.value);
      }
      return Tt(r, g, b);
    });
    const shortcutList = computed(() => {
      if (!props.shortcut)
        return [];
      if (Array.isArray(props.shortcut)) {
        return props.shortcut;
      }
      return defaultShotcuts;
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && !isEmpty.value;
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      value && updatePopper();
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
        lastValue.value = { ...currentValue.value, a: currentAlpha.value, format: "hsva" };
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
        }
      }
    );
    function parseValue(value) {
      if (value) {
        const { r, g, b, a } = N(value);
        isEmpty.value = false;
        currentValue.value = Ft(r, g, b);
        currentAlpha.value = a;
      } else {
        isEmpty.value = true;
        currentValue.value = getDefaultHsv();
        currentAlpha.value = 1;
      }
    }
    function handleClickOutside() {
      if (!editing.value) {
        emitEvent(props.onClickOutside);
        if (props.outsideClose && currentVisible.value) {
          currentVisible.value = false;
          emitEvent(props.onOutsideClose);
        }
      }
    }
    function toggleVisible() {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      currentVisible.value = !currentVisible.value;
    }
    function handleClear() {
      if (props.clearable) {
        currentVisible.value = false;
        nextTick(() => {
          parseValue(null);
          clearField();
          emitEvent(props.onClear);
        });
      }
    }
    function handleOk() {
      lastValue.value = { ...currentValue.value, a: currentAlpha.value, format: "hsva" };
      isEmpty.value = false;
      currentVisible.value = false;
      handleChange();
    }
    function getForamttedColor() {
      let color;
      if (props.format === "hex") {
        const { r, g, b } = rgb.value;
        if (props.alpha) {
          color = kt(r, g, b, currentAlpha.value);
        } else {
          color = Tt(r, g, b);
        }
      } else {
        switch (props.format) {
          case "rgb": {
            color = { ...rgb.value };
            color.r = Math.round(color.r);
            color.g = Math.round(color.g);
            color.b = Math.round(color.b);
            break;
          }
          case "hsl": {
            const { h: h7, s, v: v5 } = currentValue.value;
            color = mn(h7, s, v5);
            color.h = Math.round(color.h);
            color.s = zt(color.s, 3);
            color.l = zt(color.l, 3);
            break;
          }
          default: {
            color = { ...currentValue.value };
            color.h = Math.round(color.h);
            color.s = zt(color.s, 3);
            color.v = zt(color.v, 3);
          }
        }
        color.a = zt(currentAlpha.value, 3);
      }
      return color;
    }
    function handleChange() {
      const formattedColor = getForamttedColor();
      setFieldValue(formattedColor);
      emitEvent(props.onChange, formattedColor);
      emit("update:value", formattedColor);
      validateField();
    }
    function handlePaletteChange({ s, v: v5 }) {
      currentValue.value.s = s;
      currentValue.value.v = v5;
    }
    function handleHueChange(hue2) {
      currentValue.value.h = hue2;
    }
    function handleAlphaChange(alpha2) {
      currentAlpha.value = alpha2;
    }
    function handleInputColor(value) {
      const { r, g, b, a } = N(value);
      currentValue.value = Ft(r, g, b);
      currentAlpha.value = a;
    }
    function handleShortcutClick(color) {
      const { r, g, b, a } = N(color);
      currentValue.value = Ft(r, g, b);
      currentAlpha.value = a;
      emitEvent(props.onShortcut, getForamttedColor());
    }
    function toggleEditing(able) {
      if (!able) {
        setTimeout(() => {
          editing.value = false;
        }, 0);
      } else {
        editing.value = true;
      }
    }
    function handleTabDown(event) {
      var _a;
      if (V && currentVisible.value) {
        const activeEl = document && document.activeElement;
        if (!activeEl)
          return;
        event.preventDefault();
        const shift = event.shiftKey;
        const elList = Array.from(unitList.value);
        const index = elList.findIndex((unit) => {
          const el = sn(unit) ? unit : unit.$el;
          return el === activeEl || el.contains(activeEl);
        });
        let maybeEl;
        if (!~index) {
          maybeEl = elList.at(shift ? -1 : 0);
        } else if (shift ? !index : index === elList.length - 1) {
          maybeEl = reference.value;
        } else {
          maybeEl = elList.at(index + (shift ? -1 : 1));
        }
        if (maybeEl) {
          if (typeof maybeEl.focus === "function") {
            maybeEl.focus();
          } else {
            (_a = maybeEl.$el) == null ? void 0 : _a.focus();
          }
        }
      }
    }
    function handleShrtcutsFocus() {
      shortcutHitting.value = 0;
      shortcutsFocused.value = true;
    }
    function handleShortcutsKeydown(event) {
      const key = event.code || event.key;
      const shortcutCount = shortcutList.value.length;
      switch (key) {
        case "ArrowUp":
        case "ArrowLeft": {
          shortcutHitting.value--;
          break;
        }
        case "ArrowDown":
        case "ArrowRight": {
          shortcutHitting.value++;
          break;
        }
        case "Enter":
        case "Space":
        case " ": {
          const color = shortcutList.value.at(shortcutHitting.value);
          color && handleShortcutClick(color);
          break;
        }
      }
      shortcutHitting.value = (shortcutHitting.value + shortcutCount) % shortcutCount;
    }
    function handleSpaceDown(event) {
      var _a;
      if (props.disabled) {
        currentVisible.value = false;
      } else {
        event.preventDefault();
        if (currentVisible.value) {
          handleOk();
          (_a = reference.value) == null ? void 0 : _a.focus();
        } else {
          currentVisible.value = true;
        }
      }
    }
    function handleEscDown() {
      var _a;
      currentVisible.value = false;
      (_a = reference.value) == null ? void 0 : _a.focus();
    }
    return {
      props,
      nh,
      locale: useLocale("colorPicker"),
      idFor,
      isEmpty,
      currentVisible,
      currentValue,
      currentAlpha,
      transferTo,
      lastValue,
      shortcutHitting,
      shortcutsFocused,
      className,
      selectorClass,
      rgb,
      hex,
      shortcutList,
      hasPrefix,
      showClear,
      wrapper,
      reference,
      popper,
      palette,
      hue,
      alphaUnit: alpha,
      shortcutUnit: shortcut,
      input,
      cancel,
      confirm,
      toggleVisible,
      handleClear,
      handleOk,
      handlePaletteChange,
      handleHueChange,
      handleAlphaChange,
      handleInputColor,
      handleShortcutClick,
      toggleEditing,
      handleTabDown,
      handleShrtcutsFocus,
      handleShortcutsKeydown,
      handleSpaceDown,
      handleEscDown
    };
  }
});
var _hoisted_115 = ["id"];
var _hoisted_27 = ["onClick"];
function _sfc_render33(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Xmark = resolveComponent("Xmark");
  const _component_ChevronDown = resolveComponent("ChevronDown");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_ColorPalette = resolveComponent("ColorPalette");
  const _component_ColorHue = resolveComponent("ColorHue");
  const _component_ColorAlpha = resolveComponent("ColorAlpha");
  const _component_Input = resolveComponent("Input");
  const _component_Button = resolveComponent("Button");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onKeydown: [
      _cache[14] || (_cache[14] = withKeys(withModifiers((...args) => _ctx.handleTabDown && _ctx.handleTabDown(...args), ["stop"]), ["tab"])),
      _cache[15] || (_cache[15] = withKeys((...args) => _ctx.handleSpaceDown && _ctx.handleSpaceDown(...args), ["space"])),
      _cache[16] || (_cache[16] = withKeys((...args) => _ctx.handleEscDown && _ctx.handleEscDown(...args), ["escape"]))
    ]
  }, [
    createBaseVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.toggleVisible && _ctx.toggleVisible(...args))
    }, [
      renderSlot(_ctx.$slots, "control", {
        color: _ctx.rgb,
        alpha: _ctx.currentAlpha,
        empty: _ctx.isEmpty
      }, () => [
        _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
          style: normalizeStyle({ color: _ctx.props.prefixColor })
        }, [
          renderSlot(_ctx.$slots, "prefix", {}, () => [
            createVNode(_component_Icon, {
              icon: _ctx.props.prefix
            }, null, 8, ["icon"])
          ])
        ], 6)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("control"))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("marker"))
          }, [
            !_ctx.currentVisible && _ctx.isEmpty ? (openBlock(), createBlock(_component_Icon, { key: 0 }, {
              default: withCtx(() => [
                createVNode(_component_Xmark)
              ]),
              _: 1
            })) : (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle({
                width: "100%",
                height: "100%",
                backgroundColor: `rgba(${_ctx.rgb.r}, ${_ctx.rgb.g}, ${_ctx.rgb.b}, ${_ctx.currentVisible ? _ctx.currentAlpha : _ctx.lastValue.a})`
              })
            }, null, 4))
          ], 2)
        ], 2),
        !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
          style: normalizeStyle({
            color: _ctx.props.suffixColor,
            opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
          })
        }, [
          renderSlot(_ctx.$slots, "suffix", {}, () => [
            _ctx.props.suffix ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              icon: _ctx.props.suffix,
              class: normalizeClass({
                [_ctx.nh.be("arrow")]: !_ctx.props.staticSuffix
              })
            }, null, 8, ["icon", "class"])) : (openBlock(), createBlock(_component_Icon, {
              key: 1,
              class: normalizeClass(_ctx.nh.be("arrow"))
            }, {
              default: withCtx(() => [
                createVNode(_component_ChevronDown)
              ]),
              _: 1
            }, 8, ["class"]))
          ])
        ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
        }, null, 2)) : createCommentVNode("", true),
        createVNode(Transition, {
          name: _ctx.nh.ns("fade"),
          appear: ""
        }, {
          default: withCtx(() => [
            _ctx.showClear ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_CircleXmark)
                ]),
                _: 1
              })
            ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
            }, [
              createVNode(_component_Icon, {
                spin: _ctx.props.loadingSpin,
                pulse: !_ctx.props.loadingSpin,
                icon: _ctx.props.loadingIcon
              }, null, 8, ["spin", "pulse", "icon"])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name"])
      ])
    ], 2),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onKeydown: [
                _cache[11] || (_cache[11] = withKeys(withModifiers((...args) => _ctx.handleTabDown && _ctx.handleTabDown(...args), ["stop"]), ["tab"])),
                _cache[12] || (_cache[12] = withKeys((...args) => _ctx.handleSpaceDown && _ctx.handleSpaceDown(...args), ["space"])),
                _cache[13] || (_cache[13] = withKeys((...args) => _ctx.handleEscDown && _ctx.handleEscDown(...args), ["escape"]))
              ]
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.nh.be("panel"))
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.nh.be("section"))
                }, [
                  createVNode(_component_ColorPalette, {
                    ref: "palette",
                    hue: _ctx.currentValue.h,
                    saturation: _ctx.currentValue.s,
                    value: _ctx.currentValue.v,
                    onEditStart: _cache[2] || (_cache[2] = ($event) => _ctx.toggleEditing(true)),
                    onEditEnd: _cache[3] || (_cache[3] = ($event) => _ctx.toggleEditing(false)),
                    onChange: _ctx.handlePaletteChange
                  }, null, 8, ["hue", "saturation", "value", "onChange"]),
                  createVNode(_component_ColorHue, {
                    ref: "hue",
                    hue: _ctx.currentValue.h,
                    onEditStart: _cache[4] || (_cache[4] = ($event) => _ctx.toggleEditing(true)),
                    onEditEnd: _cache[5] || (_cache[5] = ($event) => _ctx.toggleEditing(false)),
                    onChange: _ctx.handleHueChange
                  }, null, 8, ["hue", "onChange"]),
                  _ctx.props.alpha ? (openBlock(), createBlock(_component_ColorAlpha, {
                    key: 0,
                    ref: "alphaUnit",
                    rgb: _ctx.rgb,
                    alpha: _ctx.currentAlpha,
                    onEditStart: _cache[6] || (_cache[6] = ($event) => _ctx.toggleEditing(true)),
                    onEditEnd: _cache[7] || (_cache[7] = ($event) => _ctx.toggleEditing(false)),
                    onChange: _ctx.handleAlphaChange
                  }, null, 8, ["rgb", "alpha", "onChange"])) : createCommentVNode("", true),
                  _ctx.props.shortcut ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "shortcutUnit",
                    class: normalizeClass(_ctx.nh.be("shortcuts")),
                    tabindex: "-1",
                    onFocus: _cache[8] || (_cache[8] = (...args) => _ctx.handleShrtcutsFocus && _ctx.handleShrtcutsFocus(...args)),
                    onBlur: _cache[9] || (_cache[9] = ($event) => _ctx.shortcutsFocused = false),
                    onKeydown: _cache[10] || (_cache[10] = (...args) => _ctx.handleShortcutsKeydown && _ctx.handleShortcutsKeydown(...args))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcutList, (item, index) => {
                      return openBlock(), createElementBlock("div", {
                        key: index,
                        class: normalizeClass({
                          [_ctx.nh.be("shortcut-item")]: true,
                          [_ctx.nh.bem("shortcut-item", "hitting")]: _ctx.shortcutsFocused && _ctx.shortcutHitting === index
                        }),
                        style: normalizeStyle({ backgroundColor: item }),
                        onClick: ($event) => _ctx.handleShortcutClick(item)
                      }, null, 14, _hoisted_27);
                    }), 128))
                  ], 34)) : createCommentVNode("", true)
                ], 2),
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.nh.be("action"))
                }, [
                  !_ctx.props.noInput ? (openBlock(), createBlock(_component_Input, {
                    key: 0,
                    ref: "input",
                    inherit: "",
                    class: normalizeClass(_ctx.nh.be("input")),
                    size: "small",
                    value: _ctx.hex.toUpperCase(),
                    respond: false,
                    onChange: _ctx.handleInputColor
                  }, null, 8, ["class", "value", "onChange"])) : createCommentVNode("", true),
                  _ctx.props.clearable ? (openBlock(), createBlock(_component_Button, {
                    key: 1,
                    ref: "cancel",
                    inherit: "",
                    text: "",
                    size: "small",
                    onClick: _ctx.handleClear
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : createCommentVNode("", true),
                  createVNode(_component_Button, {
                    ref: "confirm",
                    inherit: "",
                    type: "primary",
                    size: "small",
                    onClick: _ctx.handleOk
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ], 2)
              ], 2)
            ], 34)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name"])
      ]),
      _: 1
    }, 8, ["to"])
  ], 42, _hoisted_115);
}
var ColorPicker = _export_sfc(_sfc_main33, [["render", _sfc_render33]]);

// node_modules/vexip-ui/es/components/config-provider/config-provider.mjs
var ConfigProvider = defineComponent({
  name: "ConfigProvider",
  props: {
    props: {
      type: Object,
      default: () => ({})
    },
    locale: {
      type: Object,
      default: () => ({})
    }
  },
  setup(props, { slots }) {
    configProps(toRef(props, "props"));
    configLocale(toRef(props, "locale"));
    return () => renderSlot(slots, "default");
  }
});

// node_modules/vexip-ui/es/components/masker/props.mjs
var maskerProps = buildProps({
  active: booleanProp,
  closable: booleanProp,
  inner: booleanProp,
  maskTransition: String,
  transitionName: String,
  disabled: booleanProp,
  onBeforeClose: Function,
  transfer: booleanStringProp,
  autoRemove: booleanProp,
  onToggle: eventProp(),
  onClose: eventProp(),
  onHide: eventProp(),
  onShow: eventProp()
});

// node_modules/vexip-ui/es/components/masker/masker.mjs
var _sfc_main34 = defineComponent({
  name: "Masker",
  components: {
    Portal
  },
  props: maskerProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const nh = useNameHelper("masker");
    const props = useProps("masker", _props, {
      active: {
        default: false,
        static: true
      },
      closable: false,
      inner: false,
      maskTransition: () => nh.ns("fade"),
      transitionName: () => nh.ns("fade"),
      disabled: false,
      onBeforeClose: {
        default: null,
        isFunc: true
      },
      transfer: false,
      autoRemove: false
    });
    const currentActive = ref(props.active);
    const wrapShow = ref(props.active);
    const wrapper = ref();
    const topTrap = ref();
    const bottomTrap = ref();
    let showing = false;
    let prevFocusdEl = null;
    const transferTo = computed(() => {
      return props.inner ? "" : typeof props.transfer === "boolean" ? props.transfer ? "body" : "" : props.transfer;
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: transferTo.value !== "body" && props.inherit,
          [nh.bm("inner")]: props.inner,
          [nh.bm("disabled")]: props.disabled
        }
      ];
    });
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
        if (value) {
          wrapShow.value = value;
        }
      }
    );
    watch(currentActive, (value) => {
      if (!value) {
        showing = false;
        if (prevFocusdEl) {
          prevFocusdEl.focus();
          prevFocusdEl = null;
        }
      } else {
        prevFocusdEl = document.activeElement;
      }
      emitEvent(props.onToggle, value);
      emit("update:active", value);
    });
    function toggleActive(value) {
      currentActive.value = value;
    }
    async function handleClose() {
      if (!props.closable)
        return;
      let result = true;
      if (typeof props.onBeforeClose === "function") {
        result = props.onBeforeClose();
        if (Je(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        nextTick(() => {
          toggleActive(false);
          emitEvent(props.onClose);
        });
      }
    }
    function afterClose() {
      nextTick(() => {
        wrapShow.value = false;
        emitEvent(props.onHide);
      });
    }
    function afterOpen() {
      var _a;
      const activeEl = document && document.activeElement;
      if (!activeEl || !wrapper.value || !wrapper.value.contains(activeEl)) {
        (_a = topTrap.value) == null ? void 0 : _a.focus();
      }
      nextTick(() => {
        showing = true;
        emitEvent(props.onShow);
      });
    }
    function handleFocusIn(event) {
      const target = event.target;
      if (!showing || !wrapper.value || !target || !topTrap.value || !bottomTrap.value) {
        return;
      }
      const tabables = cr(wrapper.value);
      if (!tabables.length) {
        return;
      }
      if (topTrap.value === target) {
        tabables.at(-1).focus();
      } else if (bottomTrap.value === target) {
        tabables[0].focus();
      }
    }
    return {
      props,
      nh,
      currentActive,
      wrapShow,
      className,
      transferTo,
      wrapper,
      topTrap,
      bottomTrap,
      handleClose,
      afterClose,
      afterOpen,
      handleFocusIn
    };
  }
});
var _hoisted_116 = {
  ref: "topTrap",
  tabindex: "0",
  "aria-hidden": "true",
  style: { "width": "0", "height": "0", "overflow": "hidden", "outline": "none" }
};
var _hoisted_28 = {
  ref: "bottomTrap",
  tabindex: "0",
  "aria-hidden": "true",
  style: { "width": "0", "height": "0", "overflow": "hidden", "outline": "none" }
};
function _sfc_render34(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");
  return !_ctx.props.autoRemove || _ctx.wrapShow ? (openBlock(), createBlock(_component_Portal, {
    key: 0,
    to: _ctx.transferTo
  }, {
    default: withCtx(() => [
      createBaseVNode("div", mergeProps({
        ref: "wrapper",
        class: _ctx.className,
        tabindex: "-1",
        style: {
          pointerEvents: _ctx.wrapShow ? void 0 : "none",
          visibility: _ctx.wrapShow ? void 0 : "hidden"
        }
      }, _ctx.$attrs, {
        onFocusin: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocusIn && _ctx.handleFocusIn(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.handleClose && _ctx.handleClose(...args), ["prevent"]), ["escape"]))
      }), [
        !_ctx.props.disabled ? (openBlock(), createBlock(Transition, {
          key: 0,
          appear: _ctx.props.autoRemove,
          name: _ctx.props.maskTransition,
          onAfterEnter: _ctx.afterOpen,
          onAfterLeave: _ctx.afterClose
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("div", {
              class: normalizeClass(_ctx.nh.be("mask")),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.nh.be("mask-inner"))
              }, null, 2)
            ], 2), [
              [vShow, _ctx.currentActive]
            ])
          ]),
          _: 1
        }, 8, ["appear", "name", "onAfterEnter", "onAfterLeave"])) : createCommentVNode("", true),
        createBaseVNode("span", _hoisted_116, null, 512),
        createVNode(Transition, {
          appear: _ctx.props.autoRemove,
          name: _ctx.props.transitionName
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", { show: _ctx.currentActive })
          ]),
          _: 3
        }, 8, ["appear", "name"]),
        createBaseVNode("span", _hoisted_28, null, 512)
      ], 16)
    ]),
    _: 3
  }, 8, ["to"])) : createCommentVNode("", true);
}
var Masker = _export_sfc(_sfc_main34, [["render", _sfc_render34]]);

// node_modules/vexip-ui/es/components/modal/props.mjs
var positionType = [Number, String];
var modalProps = buildProps({
  transfer: booleanStringProp,
  active: booleanProp,
  width: positionType,
  height: positionType,
  top: positionType,
  left: positionType,
  right: positionType,
  bottom: positionType,
  title: String,
  closable: booleanProp,
  inner: booleanProp,
  maskClose: booleanProp,
  modalClass: classProp,
  modalStyle: styleProp,
  noFooter: booleanProp,
  hideMask: booleanProp,
  draggable: booleanProp,
  resizable: booleanProp,
  onBeforeClose: Function,
  loading: booleanProp,
  minWidth: Number,
  minHeight: Number,
  transitionName: String,
  confirmText: String,
  cancelText: String,
  autoRemove: booleanProp,
  onToggle: eventProp(),
  onConfirm: eventProp(),
  onCancel: eventProp(),
  onClose: eventProp(),
  onShow: eventProp(),
  onHide: eventProp(),
  onDragStart: eventProp(),
  onDragMove: eventProp(),
  onDragEnd: eventProp(),
  onResizeStart: eventProp(),
  onResizeMove: eventProp(),
  onResizeEnd: eventProp()
});

// node_modules/vexip-ui/es/components/modal/modal.mjs
var positionValidator = (value) => {
  return value === "auto" || !Number.isNaN(parseFloat(value));
};
var positionProp = {
  default: "auto",
  validator: positionValidator
};
var idCount = 0;
var _sfc_main35 = defineComponent({
  name: "Modal",
  components: {
    Button,
    Icon,
    Masker,
    Xmark: L2
  },
  props: modalProps,
  emits: ["update:active"],
  setup(_props, { slots, emit }) {
    const nh = useNameHelper("modal");
    const props = useProps("modal", _props, {
      transfer: false,
      active: {
        default: false,
        static: true
      },
      width: positionProp,
      height: positionProp,
      top: {
        default: 100,
        validator: positionValidator
      },
      left: positionProp,
      right: positionProp,
      bottom: positionProp,
      title: "",
      closable: true,
      inner: false,
      maskClose: true,
      modalClass: null,
      modalStyle: null,
      noFooter: false,
      hideMask: false,
      draggable: false,
      resizable: false,
      onBeforeClose: {
        default: null,
        isFunc: true
      },
      loading: false,
      minWidth: 150,
      minHeight: 120,
      transitionName: () => nh.ns("ease"),
      confirmText: null,
      cancelText: null,
      autoRemove: false
    });
    const currentActive = ref(props.active);
    const currentTop = ref(En(props.top));
    const currentLeft = ref(En(props.left));
    const currentWidth = ref(normalizeSizeValue(props.width));
    const currentHeight = ref(normalizeSizeValue(props.height));
    const idIndex = `${idCount++}`;
    let hasComputedTop = false;
    let hasComputedLeft = false;
    const wrapper = ref();
    const footer = ref();
    const { target: header, moving: dragging } = jo({
      onStart: (state, event) => {
        if (!props.draggable || event.button > 0) {
          return false;
        }
        state.xStart = currentLeft.value;
        state.yStart = currentTop.value;
        emitEvent(props.onDragStart, {
          top: currentTop.value,
          left: currentLeft.value
        });
      },
      onMove: (state) => {
        currentLeft.value = state.xEnd;
        currentTop.value = state.yEnd;
        emitEvent(props.onDragMove, {
          top: currentTop.value,
          left: currentLeft.value
        });
      },
      onEnd: () => {
        emitEvent(props.onDragEnd, {
          top: currentTop.value,
          left: currentLeft.value
        });
      }
    });
    const { target: resizer, moving: resizing } = jo({
      onStart: (state, event) => {
        var _a, _b, _c, _d;
        if (!props.resizable || event.button > 0) {
          return false;
        }
        let widthStart;
        let heightStart;
        let minHeight = 32;
        if (currentWidth.value === "auto") {
          widthStart = (_b = (_a = wrapper.value) == null ? void 0 : _a.offsetWidth) != null ? _b : 0;
        } else {
          widthStart = currentWidth.value;
        }
        if (currentHeight.value === "auto") {
          heightStart = (_d = (_c = wrapper.value) == null ? void 0 : _c.offsetHeight) != null ? _d : 0;
        } else {
          heightStart = currentHeight.value;
        }
        if (header.value) {
          minHeight += header.value.offsetHeight;
        }
        if (footer.value) {
          minHeight += footer.value.offsetHeight;
        }
        state.xStart = widthStart;
        state.yStart = heightStart;
        state.minHeight = Math.max(minHeight, props.minHeight);
        emitEvent(props.onResizeStart, {
          width: widthStart,
          height: heightStart
        });
      },
      onMove: (state) => {
        currentWidth.value = state.xEnd;
        currentHeight.value = state.yEnd;
        currentWidth.value = Math.max(props.minWidth, state.xEnd);
        currentHeight.value = Math.max(state.minHeight, state.yEnd);
        emitEvent(props.onResizeMove, {
          width: currentWidth.value,
          height: currentHeight.value
        });
      },
      onEnd: () => {
        emitEvent(props.onResizeEnd, {
          width: currentWidth.value,
          height: currentHeight.value
        });
      }
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inner")]: props.inner,
          [nh.bm("draggable")]: props.draggable,
          [nh.bm("resizable")]: props.resizable
        }
      ];
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        {
          [nh.bem("wrapper", "closable")]: props.closable,
          [nh.bem("wrapper", "dragging")]: dragging.value,
          [nh.bem("wrapper", "resizing")]: resizing.value
        },
        props.modalClass
      ];
    });
    const wrapperStyle = computed(() => {
      const fixedHeight = currentHeight.value !== "auto";
      return [
        props.modalStyle,
        {
          top: `${currentTop.value}px`,
          right: fixedHeight || !props.right || props.right === "auto" ? void 0 : `${props.right}px`,
          bottom: fixedHeight || !props.bottom || props.bottom === "auto" ? void 0 : `${props.bottom}px`,
          left: `${currentLeft.value}px`,
          width: `${currentWidth.value}px`,
          height: fixedHeight ? `${currentHeight.value}px` : void 0
        }
      ];
    });
    const hasTitle = computed(() => {
      return !!(slots.header || props.title);
    });
    const titleId = computed(() => `${nh.bs(idIndex)}__title`);
    const bodyId = computed(() => `${nh.bs(idIndex)}__body`);
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    watch(currentActive, (value) => {
      emitEvent(props.onToggle, value);
      emit("update:active", value);
      if (value) {
        nextTick(() => {
          computeTop();
          computeLeft();
        });
      }
    });
    watch(
      () => props.top,
      () => {
        hasComputedTop = false;
        currentActive.value && computeTop();
      }
    );
    watch(
      () => props.left,
      () => {
        hasComputedLeft = false;
        currentActive.value && computeLeft();
      }
    );
    watch(
      () => props.width,
      (value) => {
        currentWidth.value = normalizeSizeValue(value);
        computeLeft();
      }
    );
    watch(
      () => props.height,
      (value) => {
        currentHeight.value = normalizeSizeValue(value);
        computeTop();
      }
    );
    onMounted(() => {
      nextTick(() => {
        if (currentActive.value) {
          computeTop();
          computeLeft();
        }
      });
    });
    function normalizeSizeValue(value) {
      return value === "auto" ? "auto" : En(value);
    }
    function findPositionalParent() {
      if (!wrapper.value)
        return document.body;
      let parentElement = wrapper.value.parentElement;
      while (parentElement && parentElement !== document.body) {
        if (getComputedStyle(parentElement).position !== "static") {
          return parentElement;
        }
        parentElement = parentElement.parentElement;
      }
      return parentElement;
    }
    function computeTop() {
      if (!wrapper.value || hasComputedTop)
        return;
      const currentHeight2 = wrapper.value.offsetHeight;
      if (props.top === "auto" && props.inner) {
        currentTop.value = (findPositionalParent().offsetHeight - currentHeight2) / 2;
      } else {
        currentTop.value = props.top === "auto" ? (window.innerHeight - currentHeight2) / 2 - 20 : En(props.top);
      }
      hasComputedTop = true;
    }
    function computeLeft() {
      if (!wrapper.value || hasComputedLeft)
        return;
      const currentWidth2 = wrapper.value.offsetWidth;
      if (props.left === "auto" && props.inner) {
        currentLeft.value = (findPositionalParent().offsetWidth - currentWidth2) / 2;
      } else {
        currentLeft.value = props.left === "auto" ? (window.innerWidth - currentWidth2) / 2 : En(props.left);
      }
      hasComputedLeft = true;
    }
    function handleConfirm() {
      handleClose(true);
      emitEvent(props.onConfirm);
    }
    function handleCancle() {
      handleClose(false);
      emitEvent(props.onCancel);
    }
    async function handleClose(isConfirm) {
      let result = true;
      if (typeof props.onBeforeClose === "function") {
        result = props.onBeforeClose(isConfirm);
        if (Je(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        nextTick(() => {
          currentActive.value = false;
          emitEvent(props.onClose);
        });
      }
      return result;
    }
    function handleShow() {
      emitEvent(props.onShow);
    }
    function handleHide() {
      emitEvent(props.onHide);
    }
    function handleMaskClose() {
      if (props.maskClose) {
        return handleClose(false);
      }
    }
    return {
      props,
      nh,
      locale: useLocale("modal"),
      currentActive,
      dragging,
      resizing,
      titleId,
      bodyId,
      className,
      wrapperClass,
      wrapperStyle,
      hasTitle,
      wrapper,
      header,
      footer,
      resizer,
      handleConfirm,
      handleCancle,
      handleClose,
      handleShow,
      handleHide,
      handleMaskClose
    };
  }
});
var _hoisted_117 = ["aria-modal", "aria-labelledby", "aria-describedby"];
var _hoisted_29 = ["id"];
var _hoisted_32 = ["id"];
function _sfc_render35(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button");
  const _component_Masker = resolveComponent("Masker");
  return openBlock(), createBlock(_component_Masker, {
    active: _ctx.currentActive,
    "onUpdate:active": _cache[2] || (_cache[2] = ($event) => _ctx.currentActive = $event),
    inherit: _ctx.props.inherit,
    class: normalizeClass(_ctx.className),
    inner: _ctx.props.inner,
    "transition-name": _ctx.props.transitionName,
    closable: _ctx.props.maskClose,
    disabled: _ctx.props.hideMask,
    "on-before-close": _ctx.handleMaskClose,
    transfer: _ctx.props.transfer,
    "auto-remove": _ctx.props.autoRemove,
    onShow: _ctx.handleShow,
    onHide: _ctx.handleHide
  }, {
    default: withCtx(({ show }) => [
      withDirectives(createBaseVNode("section", {
        ref: "wrapper",
        class: normalizeClass(_ctx.wrapperClass),
        role: "dialog",
        style: normalizeStyle(_ctx.wrapperStyle),
        "aria-modal": show ? "true" : void 0,
        "aria-labelledby": _ctx.titleId,
        "aria-describedby": _ctx.bodyId
      }, [
        _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "header",
          class: normalizeClass(_ctx.nh.be("header"))
        }, [
          renderSlot(_ctx.$slots, "header", {}, () => [
            createBaseVNode("div", {
              id: _ctx.titleId,
              class: normalizeClass(_ctx.nh.be("title"))
            }, [
              renderSlot(_ctx.$slots, "title", {}, () => [
                createTextVNode(toDisplayString(_ctx.props.title), 1)
              ])
            ], 10, _hoisted_29),
            _ctx.props.closable ? (openBlock(), createElementBlock("button", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("close")),
              onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
              }, ["stop"])),
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleClose(false))
            }, [
              renderSlot(_ctx.$slots, "close", {}, () => [
                createVNode(_component_Icon, {
                  scale: 1.2,
                  label: "close"
                }, {
                  default: withCtx(() => [
                    createVNode(_component_Xmark)
                  ]),
                  _: 1
                }, 8, ["scale"])
              ])
            ], 34)) : createCommentVNode("", true)
          ])
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          id: _ctx.bodyId,
          class: normalizeClass(_ctx.nh.be("content")),
          style: normalizeStyle({
            overflow: _ctx.resizing ? "hidden" : void 0
          })
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 14, _hoisted_32),
        !_ctx.props.noFooter ? (openBlock(), createElementBlock("div", {
          key: 1,
          ref: "footer",
          class: normalizeClass(_ctx.nh.be("footer"))
        }, [
          renderSlot(_ctx.$slots, "footer", {}, () => [
            createVNode(_component_Button, {
              inherit: "",
              text: "",
              size: "small",
              onClick: _ctx.handleCancle
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
              ]),
              _: 1
            }, 8, ["onClick"]),
            createVNode(_component_Button, {
              inherit: "",
              type: "primary",
              size: "small",
              loading: _ctx.props.loading,
              onClick: _ctx.handleConfirm
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
              ]),
              _: 1
            }, 8, ["loading", "onClick"])
          ])
        ], 2)) : createCommentVNode("", true),
        _ctx.props.resizable ? (openBlock(), createElementBlock("div", {
          key: 2,
          ref: "resizer",
          class: normalizeClass(_ctx.nh.be("resizer"))
        }, null, 2)) : createCommentVNode("", true)
      ], 14, _hoisted_117), [
        [vShow, show]
      ])
    ]),
    _: 3
  }, 8, ["active", "inherit", "class", "inner", "transition-name", "closable", "disabled", "on-before-close", "transfer", "auto-remove", "onShow", "onHide"]);
}
var Modal = _export_sfc(_sfc_main35, [["render", _sfc_render35]]);

// node_modules/vexip-ui/es/components/confirm/props.mjs
var positionType2 = [Number, String];
var confirmProps = buildProps({
  top: positionType2,
  left: positionType2,
  width: positionType2,
  maskClose: booleanProp,
  confirmType: String,
  confirmText: String,
  cancelText: String,
  icon: [Object, Function],
  className: classProp,
  style: styleProp,
  renderer: Function,
  iconColor: String,
  closable: booleanProp,
  contentAlign: String,
  actionsAlign: String,
  parseHtml: booleanProp
});

// node_modules/vexip-ui/es/components/confirm/confirm.mjs
var positionValidator2 = (value) => {
  return value === "auto" || !Number.isNaN(parseFloat(value));
};
var confirmTypes = Object.freeze([
  "default",
  "primary",
  "info",
  "success",
  "warning",
  "error"
]);
var _sfc_main36 = defineComponent({
  name: "Confirm",
  components: {
    Button,
    Icon,
    Modal,
    Renderer,
    Xmark: L2
  },
  props: confirmProps,
  setup(_props) {
    const props = useProps("confirm", _props, {
      top: {
        default: "auto",
        validator: positionValidator2
      },
      left: {
        default: "auto",
        validator: positionValidator2
      },
      width: {
        default: 420,
        validator: positionValidator2
      },
      maskClose: false,
      confirmType: {
        default: "default",
        validator: (value) => confirmTypes.includes(value)
      },
      confirmText: null,
      cancelText: null,
      icon: null,
      className: null,
      style: null,
      renderer: {
        default: null,
        isFunc: true,
        static: true
      },
      iconColor: "",
      closable: false,
      parseHtml: false,
      contentAlign: "center",
      actionsAlign: "center"
    });
    const visible = ref(false);
    const loading = ref(false);
    const title = ref("");
    const content = ref("");
    const iconColorR = ref(props.iconColor);
    const classR = ref(props.className);
    const styleR = ref(props.style || {});
    const confirmTypeR = ref(props.confirmType);
    const confirmTextR = ref(props.confirmText);
    const cancelTextR = ref(props.cancelText);
    const maskCloseR = ref(props.maskClose);
    const parseHtmlR = ref(props.parseHtml);
    const closableR = ref(props.closable);
    const contentAlignR = ref(props.contentAlign);
    const actionsAlignR = ref(props.actionsAlign);
    const iconR = ref(props.icon);
    const rendererR = ref(props.renderer);
    const onBeforeConfirm = ref(null);
    const onConfirm = ref(null);
    const onCancel = ref(null);
    const mounted = new Promise((resolve) => {
      onMounted(() => {
        nextTick(resolve);
      });
    });
    async function openConfirm(options) {
      await mounted;
      return await new Promise((resolve) => {
        var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        title.value = (_a = options.title) != null ? _a : "";
        content.value = (_b = options.content) != null ? _b : "";
        classR.value = (_c = options.className) != null ? _c : props.className;
        styleR.value = (_d = options.style) != null ? _d : props.style;
        iconColorR.value = (_e2 = options.iconColor) != null ? _e2 : props.iconColor;
        maskCloseR.value = (_f = options.maskClose) != null ? _f : props.maskClose;
        confirmTypeR.value = (_g = options.confirmType) != null ? _g : props.confirmType;
        confirmTextR.value = (_h = options.confirmText) != null ? _h : props.confirmText;
        cancelTextR.value = (_i = options.cancelText) != null ? _i : props.cancelText;
        parseHtmlR.value = (_j = options.parseHtml) != null ? _j : props.parseHtml;
        closableR.value = (_k = options.closable) != null ? _k : props.closable;
        contentAlignR.value = (_l = options.contentAlign) != null ? _l : props.contentAlign;
        actionsAlignR.value = (_m = options.actionsAlign) != null ? _m : props.actionsAlign;
        iconR.value = (_n = options.icon) != null ? _n : props.icon;
        rendererR.value = gt(options.renderer) ? options.renderer : props.renderer;
        onBeforeConfirm.value = gt(options.onBeforeConfirm) ? options.onBeforeConfirm : null;
        if (gt(rendererR.value)) {
          rendererR.value = () => rendererR.value(options, handleConfirm, handleCancel);
        }
        visible.value = true;
        onConfirm.value = () => {
          resolve(true);
          onBeforeConfirm.value = null;
        };
        onCancel.value = () => {
          resolve(false);
          onBeforeConfirm.value = null;
        };
      });
    }
    async function handleConfirm() {
      loading.value = true;
      if (gt(onBeforeConfirm.value)) {
        let result = onBeforeConfirm.value();
        if (Je(result)) {
          result = await result;
        }
        if (result === false) {
          loading.value = false;
          return;
        }
      }
      visible.value = false;
      loading.value = false;
      if (gt(onConfirm.value)) {
        onConfirm.value();
        onConfirm.value = null;
      }
    }
    function handleCancel() {
      visible.value = false;
      if (gt(onCancel.value)) {
        onCancel.value();
        onCancel.value = null;
      }
    }
    function handleReset() {
      visible.value = false;
      title.value = "";
      content.value = "";
      iconColorR.value = props.iconColor;
      classR.value = props.className;
      styleR.value = props.style;
      maskCloseR.value = props.maskClose;
      confirmTypeR.value = props.confirmType;
      confirmTextR.value = props.confirmText;
      cancelTextR.value = props.cancelText;
      parseHtmlR.value = props.parseHtml;
      closableR.value = props.closable;
      contentAlignR.value = props.contentAlign;
      actionsAlignR.value = props.actionsAlign;
      iconR.value = props.icon;
      rendererR.value = props.renderer;
    }
    return {
      CircleQuestion: x4,
      props,
      nh: useNameHelper("confirm"),
      locale: useLocale("confirm"),
      visible,
      loading,
      title,
      content,
      classR,
      styleR,
      iconColorR,
      maskCloseR,
      confirmTypeR,
      confirmTextR,
      cancelTextR,
      parseHtmlR,
      closableR,
      contentAlignR,
      actionsAlignR,
      iconR,
      rendererR,
      isFunction: gt,
      openConfirm,
      handleConfirm,
      handleCancel,
      handleReset
    };
  }
});
var _hoisted_118 = ["innerHTML"];
function _sfc_render36(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button");
  const _component_Modal = resolveComponent("Modal");
  return openBlock(), createBlock(_component_Modal, {
    "no-footer": "",
    closable: false,
    active: _ctx.visible,
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars")]),
    "modal-class": _ctx.classR,
    "modal-style": _ctx.styleR,
    top: _ctx.props.top,
    left: _ctx.props.left,
    width: _ctx.props.width,
    "mask-close": _ctx.maskCloseR,
    onHide: _ctx.handleReset
  }, {
    default: withCtx(() => [
      _ctx.isFunction(_ctx.rendererR) ? (openBlock(), createBlock(_component_Renderer, {
        key: 0,
        renderer: _ctx.rendererR
      }, null, 8, ["renderer"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        _ctx.title ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("header"))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("title"))
          }, toDisplayString(_ctx.title), 3),
          _ctx.closableR ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("close")),
            onMousedown: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"])),
            onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              createVNode(_component_Icon, {
                scale: 1.2,
                label: "close"
              }, {
                default: withCtx(() => [
                  createVNode(_component_Xmark)
                ]),
                _: 1
              }, 8, ["scale"])
            ])
          ], 34)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass([
            _ctx.nh.be("body"),
            _ctx.nh.bem("body", _ctx.contentAlignR),
            _ctx.title && _ctx.nh.bem("body", "with-title")
          ])
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("icon"))
          }, [
            _ctx.isFunction(_ctx.icon) ? (openBlock(), createBlock(_component_Renderer, {
              key: 0,
              renderer: _ctx.icon
            }, null, 8, ["renderer"])) : (openBlock(), createBlock(_component_Icon, {
              key: 1,
              icon: _ctx.iconR || _ctx.CircleQuestion,
              scale: 2.2,
              style: normalizeStyle({ color: _ctx.iconColorR })
            }, null, 8, ["icon", "scale", "style"]))
          ], 2),
          _ctx.parseHtmlR ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("content")),
            innerHTML: _ctx.content
          }, null, 10, _hoisted_118)) : (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.nh.be("content"))
          }, toDisplayString(_ctx.content), 3))
        ], 2),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.nh.be("footer"), _ctx.nh.bem("footer", _ctx.actionsAlignR)])
        }, [
          createVNode(_component_Button, {
            class: normalizeClass(_ctx.nh.be("button")),
            inherit: "",
            "no-pulse": "",
            onClick: _ctx.handleCancel
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.cancelTextR || _ctx.locale.cancel), 1)
            ]),
            _: 1
          }, 8, ["class", "onClick"]),
          createVNode(_component_Button, {
            class: normalizeClass(_ctx.nh.be("button")),
            inherit: "",
            "no-pulse": "",
            type: _ctx.confirmTypeR,
            loading: _ctx.loading,
            onClick: _ctx.handleConfirm
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(_ctx.confirmTextR || _ctx.locale.confirm), 1)
            ]),
            _: 1
          }, 8, ["class", "type", "loading", "onClick"])
        ], 2),
        _ctx.closableR && !_ctx.title ? (openBlock(), createElementBlock("button", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("close")),
          onMousedown: _cache[2] || (_cache[2] = withModifiers(() => {
          }, ["stop"])),
          onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleCancel && _ctx.handleCancel(...args))
        }, [
          renderSlot(_ctx.$slots, "close", {}, () => [
            createVNode(_component_Icon, {
              scale: 1.2,
              label: "close"
            }, {
              default: withCtx(() => [
                createVNode(_component_Xmark)
              ]),
              _: 1
            }, 8, ["scale"])
          ])
        ], 34)) : createCommentVNode("", true)
      ], 64))
    ]),
    _: 3
  }, 8, ["active", "class", "modal-class", "modal-style", "top", "left", "width", "mask-close", "onHide"]);
}
var Component = _export_sfc(_sfc_main36, [["render", _sfc_render36]]);

// node_modules/vexip-ui/es/components/confirm/index.mjs
var ConfirmManager = class {
  constructor(options = {}) {
    this._mountedApp = null;
    this._instance = null;
    this._container = null;
    this.name = "Confirm";
    this.defaults = {};
    this.config(options);
  }
  open(options, title, type) {
    var _a;
    if (!V) {
      return;
    }
    if (typeof options === "string") {
      if (type) {
        options = { title, content: options, confirmType: type };
      } else {
        options = { content: options, confirmType: title };
      }
    }
    const item = { ...this.defaults, ...options };
    if (item.icon && typeof item.icon !== "function") {
      item.icon = markRaw(item.icon);
    }
    return (_a = this._getInstance()) == null ? void 0 : _a.openConfirm(item);
  }
  config(options) {
    this.defaults = { ...this.defaults, ...options };
  }
  clone() {
    return new ConfirmManager(this.defaults);
  }
  destroy() {
    this._container && render(null, this._container);
    Jn(this);
  }
  isDestroyed() {
    return false;
  }
  install(app, options = {}) {
    this.config(options);
    app.config.globalProperties.$confirm = this;
    this._mountedApp = app;
  }
  _getInstance() {
    if (!this._mountedApp) {
      console.warn("[vexip-ui:Confirm]: App missing, the plugin maybe not installed.");
      return null;
    }
    if (!this._instance) {
      const vnode = createVNode(Component, null, null);
      this._container = document.createElement("div");
      vnode.appContext = this._mountedApp._context;
      render(vnode, this._container, false);
      document.body.appendChild(this._container.firstElementChild);
      this._instance = vnode.component.proxy;
    }
    return this._instance;
  }
};
var Confirm = new ConfirmManager();

// node_modules/vexip-ui/es/components/dropdown/symbol.mjs
var SELECT_HANDLER = Symbol("SELECT_HANDLER");
var DROPDOWN_STATE = Symbol("DROPDOWN_STATE");

// node_modules/vexip-ui/es/components/dropdown/dropdown-drop.mjs
var DropdownDrop = defineComponent({
  setup(_, { slots }) {
    const dropdownState = inject(DROPDOWN_STATE, null);
    provide(SELECT_HANDLER, dropdownState == null ? void 0 : dropdownState.handleSelect);
    return () => {
      var _a, _b;
      return (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : null;
    };
  }
});

// node_modules/vexip-ui/es/components/dropdown/props.mjs
var dropdownProps = buildProps({
  visible: booleanProp,
  placement: String,
  outsideClose: booleanProp,
  trigger: String,
  label: [String, Number],
  transitionName: String,
  transfer: booleanStringProp,
  dropClass: classProp,
  appear: booleanProp,
  meta: Object,
  onToggle: eventProp(),
  onSelect: eventProp(),
  onClickOutside: eventProp(),
  onOutsideClose: eventProp()
});

// node_modules/vexip-ui/es/components/dropdown/hooks.mjs
function useLabel(rawLabel, element) {
  const label = ref(rawLabel.value);
  function setLabel(value) {
    var _a, _b;
    if (element.value) {
      label.value = (_b = value != null ? value : (_a = element.value.textContent) == null ? void 0 : _a.trim()) != null ? _b : null;
    } else {
      label.value = value;
    }
  }
  watch(rawLabel, (value) => {
    setLabel(value);
  });
  onMounted(() => {
    nextTick(() => {
      setLabel(rawLabel.value);
    });
  });
  return label;
}

// node_modules/vexip-ui/es/components/dropdown/dropdown.mjs
var _sfc_main37 = defineComponent({
  name: "Dropdown",
  components: {
    DropdownDrop,
    Portal
  },
  props: dropdownProps,
  emits: ["update:visible"],
  setup(_props, { emit }) {
    const nh = useNameHelper("dropdown");
    const props = useProps("dropdown", _props, {
      visible: {
        default: false,
        static: true
      },
      placement: {
        default: "bottom",
        validator: (value) => Wo.includes(value)
      },
      outsideClose: true,
      trigger: {
        default: "hover",
        validator: (value) => ["hover", "click", "custom"].includes(value)
      },
      label: {
        default: null,
        static: true
      },
      transitionName: () => nh.ns("drop"),
      transfer: false,
      dropClass: null,
      appear: false,
      meta: null
    });
    const parentState = inject(DROPDOWN_STATE, null);
    const isNested = !!parentState;
    const label = toRef(props, "label");
    const placement = ref(props.placement);
    const currentVisible = ref(props.visible);
    const transfer = toRef(props, "transfer");
    const wrapper = Do(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = qo({
      placement,
      transfer,
      wrapper,
      isDrop: true,
      offset: isNested ? [-5, 0] : void 0
    });
    const currentLabel = useLabel(label, reference);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("visible")]: currentVisible.value
      };
    });
    provide(SELECT_HANDLER, null);
    provide(DROPDOWN_STATE, {
      handleSelect,
      handleTriggerEnter,
      handleTriggerLeave
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(
      () => props.placement,
      (value) => {
        setPlacement(value);
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        updatePopper();
      }
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    onMounted(() => {
      nextTick(() => {
        setPlacement(props.placement);
      });
    });
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      if (props.outsideClose && props.trigger !== "custom" && currentVisible.value) {
        currentVisible.value = false;
        emitEvent(props.onOutsideClose);
      }
    }
    function handleSelect(labels, metas) {
      if (props.trigger !== "custom") {
        currentVisible.value = false;
        emitEvent(props.onSelect, labels, metas);
      }
      if (typeof (parentState == null ? void 0 : parentState.handleSelect) === "function") {
        parentState.handleSelect([currentLabel.value, ...labels], [props.meta || {}, ...metas]);
      }
    }
    function setPlacement(value) {
      const [xPlacement] = value.split("-");
      if (isNested && xPlacement !== "right" && xPlacement !== "left") {
        placement.value = "right-start";
      } else {
        placement.value = value;
      }
    }
    const { timer: timer2 } = $o();
    function handleTriggerEnter() {
      if (props.trigger === "hover") {
        clearTimeout(timer2.hover);
        if (typeof (parentState == null ? void 0 : parentState.handleTriggerEnter) === "function") {
          parentState.handleTriggerEnter();
        }
        timer2.hover = setTimeout(() => {
          currentVisible.value = true;
        }, 250);
      }
    }
    function handleTriggerLeave() {
      if (props.trigger === "hover") {
        clearTimeout(timer2.hover);
        if (typeof (parentState == null ? void 0 : parentState.handleTriggerLeave) === "function") {
          parentState.handleTriggerLeave();
        }
        timer2.hover = setTimeout(() => {
          currentVisible.value = false;
        }, 250);
      }
    }
    function handleTriggerClick() {
      if (props.trigger === "click") {
        currentVisible.value = !currentVisible.value;
      }
    }
    return {
      props,
      nh,
      isNested,
      currentVisible,
      transferTo,
      wrapper,
      reference,
      popper,
      className,
      handleTriggerEnter,
      handleTriggerLeave,
      handleTriggerClick
    };
  }
});
function _sfc_render37(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");
  const _component_DropdownDrop = resolveComponent("DropdownDrop");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onMouseenter: _cache[5] || (_cache[5] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
    onMouseleave: _cache[6] || (_cache[6] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
  }, [
    createBaseVNode("div", {
      ref: "reference",
      class: normalizeClass([_ctx.nh.be("trigger"), _ctx.currentVisible ? _ctx.nh.bem("trigger", "active") : ""]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleTriggerClick && _ctx.handleTriggerClick(...args)),
      onKeydown: [
        _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.handleTriggerClick && _ctx.handleTriggerClick(...args), ["prevent"]), ["enter"])),
        _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.handleTriggerClick && _ctx.handleTriggerClick(...args), ["prevent"]), ["space"]))
      ]
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 34),
    createVNode(_component_DropdownDrop, null, {
      default: withCtx(() => [
        createVNode(_component_Portal, { to: _ctx.transferTo }, {
          default: withCtx(() => [
            createVNode(Transition, {
              name: _ctx.props.transitionName,
              appear: _ctx.props.appear
            }, {
              default: withCtx(() => [
                withDirectives(createBaseVNode("div", {
                  ref: "popper",
                  class: normalizeClass([
                    _ctx.nh.be("popper"),
                    _ctx.nh.bs("vars"),
                    _ctx.isNested ? _ctx.nh.bem("popper", "nested") : null,
                    _ctx.props.dropClass
                  ]),
                  onMouseenter: _cache[3] || (_cache[3] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
                  onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
                }, [
                  renderSlot(_ctx.$slots, "drop")
                ], 34), [
                  [vShow, _ctx.currentVisible]
                ])
              ]),
              _: 3
            }, 8, ["name", "appear"])
          ]),
          _: 3
        }, 8, ["to"])
      ]),
      _: 3
    })
  ], 34);
}
var Dropdown = _export_sfc(_sfc_main37, [["render", _sfc_render37]]);

// node_modules/vexip-ui/es/components/dropdown/dropdown-list.mjs
var _sfc_main38 = defineComponent({
  name: "DropdownList",
  setup() {
    return {
      nh: useNameHelper("dropdown")
    };
  }
});
function _sfc_render38(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("ul", {
    class: normalizeClass(_ctx.nh.be("list")),
    role: "menu"
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var DropdownList = _export_sfc(_sfc_main38, [["render", _sfc_render38]]);

// node_modules/vexip-ui/es/components/dropdown/dropdown-item.mjs
var _sfc_main39 = defineComponent({
  name: "DropdownItem",
  props: {
    label: {
      type: [String, Number],
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    selected: {
      type: Boolean,
      default: false
    },
    divided: {
      type: Boolean,
      default: false
    },
    reference: {
      type: Boolean,
      default: false
    },
    meta: {
      type: Object,
      default: () => ({})
    },
    onSelect: eventProp()
  },
  emits: [],
  setup(props) {
    const parentSelectHandler = inject(SELECT_HANDLER, null);
    const nh = useNameHelper("dropdown");
    const wrapper = ref(null);
    const label = toRef(props, "label");
    const isReference = ref(props.reference);
    const currentLabel = useLabel(label, wrapper);
    const className = computed(() => {
      const baseClass = nh.be("item");
      return {
        [baseClass]: true,
        [`${baseClass}--disabled`]: props.disabled,
        [`${baseClass}--selected`]: !props.disabled && props.selected,
        [`${baseClass}--divided`]: props.divided
      };
    });
    function handleSelect() {
      if (props.disabled || isReference.value) {
        return;
      }
      if (typeof parentSelectHandler === "function") {
        parentSelectHandler([currentLabel.value], [props.meta || {}]);
      }
      emitEvent(props.onSelect, currentLabel.value);
    }
    return {
      wrapper,
      className,
      handleSelect
    };
  }
});
function _sfc_render39(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    role: "menuitem",
    tabindex: "0",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleSelect && _ctx.handleSelect(...args))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var DropdownItem = _export_sfc(_sfc_main39, [["render", _sfc_render39]]);

// node_modules/vexip-ui/es/components/contextmenu/render.mjs
function _isSlot3(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
function renderItemIcon(item, nh) {
  if (!item.icon)
    return null;
  let icon;
  if (typeof item.icon === "function") {
    icon = item.icon();
  } else {
    icon = createVNode(Icon, {
      "icon": item.icon,
      "style": [{
        color: item.iconColor || item.color
      }, item.icon.style]
    }, null);
  }
  return createVNode("div", {
    "class": nh.be("icon")
  }, [icon]);
}
function renderItemShortcut(item, nh) {
  if (!item.shortcut)
    return null;
  return createVNode("div", {
    "class": nh.be("shortcut")
  }, [item.shortcut]);
}
function renderGroupItem(item, nh) {
  return createVNode(Dropdown, mergeProps({
    "inherit": true,
    "transfer": false
  }, {
    onContextmenu: (event) => {
      event.preventDefault();
      event.stopPropagation();
    }
  }), {
    default: () => createVNode(DropdownItem, {
      "class": nh.be("item"),
      "label": item.key,
      "divided": item.divided,
      "disabled": item.disabled
    }, {
      default: () => [renderItemIcon(item, nh), createVNode("span", {
        "class": nh.be("label"),
        "style": {
          color: item.color
        }
      }, [item.label || item.key]), renderItemShortcut(item, nh), createVNode("div", {
        "class": [nh.be("icon"), nh.be("arrow")]
      }, [createVNode(Icon, {
        "icon": $17,
        "style": {
          color: item.iconColor || item.color
        }
      }, null)])]
    }),
    drop: () => {
      let _slot;
      return createVNode(DropdownList, {
        "class": [nh.be("list"), item.children.some((c) => c.icon) ? nh.bem("list", "icons") : nh.bem("list", "no-icon"), item.children.some((c) => {
          var _a;
          return (_a = c.children) == null ? void 0 : _a.length;
        }) ? nh.bem("list", "arrows") : nh.bem("list", "no-arrow")]
      }, _isSlot3(_slot = item.children.map((i) => renderItem({
        nh,
        config: i
      }))) ? _slot : {
        default: () => [_slot]
      });
    }
  });
}
function renderItem({
  config,
  nh
}) {
  var _a;
  if ((_a = config.children) == null ? void 0 : _a.length) {
    return renderGroupItem(config, nh);
  } else {
    return createVNode(DropdownItem, {
      "class": nh.be("item"),
      "label": config.key,
      "divided": config.divided,
      "disabled": config.disabled
    }, {
      default: () => [renderItemIcon(config, nh), createVNode("span", {
        "class": nh.be("label"),
        "style": {
          color: config.color
        }
      }, [config.label || config.key]), renderItemShortcut(config, nh)]
    });
  }
}

// node_modules/vexip-ui/es/components/contextmenu/contextmenu.mjs
var _sfc_main40 = defineComponent({
  name: "Contextmenu",
  components: {
    Dropdown,
    DropdownList,
    Renderer
  },
  setup() {
    const nh = useNameHelper("contextmenu");
    const visible = ref(false);
    const configs = ref([]);
    const appear = ref(false);
    const position = reactive({
      x: 0,
      y: 0
    });
    const onSelect = ref(null);
    const onCancel = ref(null);
    function openContextmenu(options) {
      var _a;
      position.x = options.clientX || 0;
      position.y = options.clientY || 0;
      configs.value = options.configs;
      appear.value = (_a = options.appear) != null ? _a : false;
      visible.value = true;
      return new Promise((resolve) => {
        onSelect.value = (keys) => {
          resolve(keys);
        };
        onCancel.value = () => {
          resolve(null);
        };
      });
    }
    function afterContextmenu() {
      onSelect.value = null;
      onCancel.value = null;
    }
    function handleSelect(keys) {
      visible.value = false;
      if (gt(onSelect.value)) {
        onSelect.value(keys);
        afterContextmenu();
      }
    }
    function handleCancel() {
      visible.value = false;
      if (gt(onCancel.value)) {
        onCancel.value();
        afterContextmenu();
      }
    }
    return {
      nh,
      visible,
      configs,
      appear,
      position,
      renderItem,
      openContextmenu,
      handleSelect,
      handleCancel
    };
  }
});
function _sfc_render40(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_DropdownList = resolveComponent("DropdownList");
  const _component_Dropdown = resolveComponent("Dropdown");
  return openBlock(), createBlock(_component_Dropdown, {
    visible: _ctx.visible,
    "onUpdate:visible": _cache[0] || (_cache[0] = ($event) => _ctx.visible = $event),
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars")]),
    trigger: "click",
    placement: "right-start",
    appear: _ctx.appear,
    transfer: false,
    style: normalizeStyle({
      top: `${_ctx.position.y}px`,
      left: `${_ctx.position.x}px`
    }),
    onContextmenu: _cache[1] || (_cache[1] = withModifiers(() => {
    }, ["prevent", "stop"])),
    onSelect: _ctx.handleSelect,
    onOutsideClose: _ctx.handleCancel
  }, {
    drop: withCtx(() => [
      createVNode(_component_DropdownList, {
        class: normalizeClass([
          _ctx.nh.be("list"),
          _ctx.configs.some((c) => c.icon) ? _ctx.nh.bem("list", "icons") : _ctx.nh.bem("list", "no-icon"),
          _ctx.configs.some((c) => c.children && c.children.length) ? _ctx.nh.bem("list", "arrows") : _ctx.nh.bem("list", "no-arrow")
        ])
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.configs, (item) => {
            return openBlock(), createBlock(_component_Renderer, {
              key: item.key,
              data: { config: item, nh: _ctx.nh },
              renderer: _ctx.renderItem
            }, null, 8, ["data", "renderer"]);
          }), 128))
        ]),
        _: 1
      }, 8, ["class"])
    ]),
    _: 1
  }, 8, ["visible", "class", "appear", "style", "onSelect", "onOutsideClose"]);
}
var Component2 = _export_sfc(_sfc_main40, [["render", _sfc_render40]]);

// node_modules/vexip-ui/es/components/contextmenu/index.mjs
var ContextmenuManager = class {
  constructor() {
    this._instance = null;
    this._innerApp = null;
    this._container = null;
    this._pending = null;
    this.name = "Contextmenu";
  }
  open(options) {
    if (!V) {
      return;
    }
    this._pending = this._getInstance().openContextmenu(options);
    return this._pending;
  }
  destroy() {
    var _a;
    (_a = this._innerApp) == null ? void 0 : _a.unmount();
    Jn(this);
  }
  isDestroyed() {
    return false;
  }
  install(app) {
    app.config.globalProperties.$contextmenu = this;
  }
  _getInstance() {
    var _a;
    if (this._pending) {
      let innerApp = this._innerApp;
      const unmount = () => {
        innerApp == null ? void 0 : innerApp.unmount();
        innerApp = null;
      };
      this._pending.finally(unmount);
      this._instance.handleCancel();
    } else {
      (_a = this._innerApp) == null ? void 0 : _a.unmount();
    }
    this._container = document.createElement("div");
    this._innerApp = createApp(Component2);
    this._instance = this._innerApp.mount(this._container);
    this._pending = null;
    document.body.appendChild(this._container.firstElementChild);
    return this._instance;
  }
};
var Contextmenu = new ContextmenuManager();

// node_modules/vexip-ui/es/components/date-picker/symbol.mjs
var DisabledType = ((DisabledType2) => {
  DisabledType2[DisabledType2["UPSTREAM"] = 0] = "UPSTREAM";
  DisabledType2[DisabledType2["TRUE"] = 1] = "TRUE";
  DisabledType2[DisabledType2["AT_MIN_TRUE"] = 2] = "AT_MIN_TRUE";
  DisabledType2[DisabledType2["AT_MAX_TRUE"] = 3] = "AT_MAX_TRUE";
  DisabledType2[DisabledType2["FALSE"] = 4] = "FALSE";
  return DisabledType2;
})(DisabledType || {});
var datePickerTypes = Object.freeze(["date", "datetime", "year", "month"]);

// node_modules/vexip-ui/es/components/date-picker/helper.mjs
var numberKeys = Array.from({ length: 10 }, (_, i) => i);
function isNumberKey(key, num) {
  return key === `Digit${num}` || key === `Numpad${num}` || key === `${num}`;
}
function handleKeyEnter(event) {
  const key = event.code || event.key;
  let type = null;
  let isMatch = false;
  switch (key) {
    case "Tab": {
      isMatch = true;
      type = event.shiftKey ? "prev" : "next";
      break;
    }
    case "ArrowRight": {
      isMatch = true;
      type = "next";
      break;
    }
    case "Backspace":
    case "Delete":
    case "ArrowLeft": {
      isMatch = true;
      type = "prev";
      break;
    }
    case "ArrowUp": {
      isMatch = true;
      type = "up";
      break;
    }
    case "ArrowDown": {
      isMatch = true;
      type = "down";
      break;
    }
    case "Space":
    case " ":
    case "Enter":
    case "NumpadEnter": {
      isMatch = true;
      type = "ok";
      break;
    }
    case "Escape": {
      isMatch = true;
      type = "esc";
      break;
    }
  }
  if (isMatch) {
    event.preventDefault();
    event.stopPropagation();
  } else {
    const inputtedNumber = numberKeys.findIndex((num) => isNumberKey(key, num));
    if (~inputtedNumber) {
      type = inputtedNumber;
      event.preventDefault();
      event.stopPropagation();
    }
  }
  return type;
}
function useColumn(colTypes, currentColumn = ref(colTypes[0])) {
  const columnTypes4 = Array.from(colTypes);
  const columnCount = columnTypes4.length;
  const enabled = reactive(
    columnTypes4.reduce((prev, current) => {
      prev[current] = false;
      return prev;
    }, {})
  );
  function findEnabledColumn(types) {
    var _a;
    currentColumn.value = (_a = types.find((type) => enabled[type])) != null ? _a : currentColumn.value;
  }
  function resetColumn(type, reverse = false) {
    const types = reverse ? Array.from(columnTypes4).reverse() : columnTypes4;
    const index = types.findIndex((column) => column === type);
    if (~index) {
      findEnabledColumn(types.slice(index, columnCount).concat(types.slice(0, index)));
    } else {
      findEnabledColumn(types);
    }
  }
  function enterColumn(type, canLoop = true) {
    for (let i = 0; i < columnCount; ++i) {
      if (currentColumn.value === columnTypes4[i]) {
        const rawTypes = type === "prev" ? Array.from(columnTypes4).reverse() : columnTypes4;
        const nextIndex = (type === "prev" ? columnCount - i : i + 1) % columnCount;
        const types = canLoop ? rawTypes.slice(nextIndex, columnCount).concat(rawTypes.slice(0, nextIndex)) : nextIndex ? rawTypes.slice(nextIndex, columnCount) : [];
        findEnabledColumn(types);
        break;
      }
    }
  }
  return {
    currentColumn,
    enabled,
    resetColumn,
    enterColumn
  };
}
var defaultMin = [0, 0, 0];
var defaultMax = [23, 59, 59];
function useTimeBound(originMin, originMax) {
  const minUnits = computed(() => {
    return originMin.value ? originMin.value.split(":").map(En) : defaultMin;
  });
  const maxUnits = computed(() => {
    return originMax.value ? originMax.value.split(":").map(En) : defaultMax;
  });
  const reversed = computed(() => {
    const min = minUnits.value;
    const max = maxUnits.value;
    for (let i = 0; i < 3; ++i) {
      if (min[i] < max[i])
        return false;
      if (min[i] > max[i])
        return true;
    }
    return false;
  });
  const isTimeDisabled = {
    hour: isHourDisabled,
    minute: (hour, minute) => isMinuteDisabled(hour, minute) !== DisabledType.FALSE,
    second: (hour, minute, second) => isSecondDisabled(hour, minute, second) !== DisabledType.FALSE
  };
  function isHourDisabled(hour) {
    const min = minUnits.value[0] || defaultMin[0];
    const max = maxUnits.value[0] || defaultMax[0];
    return reversed.value ? hour > max && hour < min : hour < min || hour > max;
  }
  function isMinuteDisabled(hour, minute) {
    if (isHourDisabled(hour))
      return DisabledType.UPSTREAM;
    if (minUnits.value[0] === maxUnits.value[0] && hour === minUnits.value[0]) {
      const min = minUnits.value[1] || defaultMin[1];
      const max = maxUnits.value[1] || defaultMax[1];
      if (reversed.value ? minute > max && minute < min : minute < min || minute > max) {
        return DisabledType.TRUE;
      }
    }
    if (hour === minUnits.value[0]) {
      const min = minUnits.value[1] || defaultMin[1];
      if (minute < min)
        return DisabledType.AT_MIN_TRUE;
    }
    if (hour === maxUnits.value[0]) {
      const max = maxUnits.value[1] || defaultMax[1];
      if (minute > max)
        return DisabledType.AT_MAX_TRUE;
    }
    return DisabledType.FALSE;
  }
  function isSecondDisabled(hour, minute, second) {
    if (isMinuteDisabled(hour, minute) !== DisabledType.FALSE)
      return DisabledType.UPSTREAM;
    if (minUnits.value[0] === maxUnits.value[0] && hour === minUnits.value[0] && minUnits.value[1] === maxUnits.value[1] && minute === minUnits.value[1]) {
      const min = minUnits.value[2] || defaultMin[2];
      const max = maxUnits.value[2] || defaultMax[2];
      if (reversed.value ? second > max && second < min : second < min || second > max) {
        return DisabledType.TRUE;
      }
    }
    if (hour === minUnits.value[0] && minute === minUnits.value[1]) {
      const min = minUnits.value[2] || defaultMin[2];
      if (second < min)
        return DisabledType.AT_MIN_TRUE;
    }
    if (hour === maxUnits.value[0] && minute === maxUnits.value[1]) {
      const max = maxUnits.value[2] || defaultMax[2];
      if (second > max)
        return DisabledType.AT_MAX_TRUE;
    }
    return DisabledType.FALSE;
  }
  return {
    minUnits,
    maxUnits,
    reversed,
    isTimeDisabled
  };
}

// node_modules/vexip-ui/es/components/date-picker/date-control.mjs
var _sfc_main41 = defineComponent({
  name: "DateControl",
  props: {
    unitType: {
      type: String,
      default: "date"
    },
    enabled: {
      type: Object,
      default: () => ({})
    },
    activated: {
      type: Object,
      default: () => ({})
    },
    dateValue: {
      type: Object,
      default: () => ({})
    },
    dateSeparator: {
      type: String,
      default: "/"
    },
    timeSeparator: {
      type: String,
      default: ":"
    },
    visible: {
      type: Boolean,
      default: false
    },
    focused: {
      type: Boolean,
      default: false
    },
    filler: {
      type: String,
      default: "-",
      validator: (value) => {
        return value.length === 1;
      }
    },
    noFiller: {
      type: Boolean,
      default: false
    },
    steps: {
      type: Array,
      default: () => [1, 1, 1]
    },
    ctrlSteps: {
      type: Array,
      default: () => [5, 5, 5]
    },
    labels: {
      type: Object,
      default: () => ({})
    },
    hasError: {
      type: Boolean,
      default: false
    }
  },
  emits: ["input", "plus", "minus", "enter", "cancel", "unit-focus", "prev-unit", "next-unit"],
  setup(props, { emit }) {
    const nh = useNameHelper("date-picker");
    const wrapper = ref();
    const isActivated = computed(() => {
      return Object.keys(props.enabled).every((type) => {
        return !props.enabled[type] || props.activated[type];
      });
    });
    const className = computed(() => {
      return {
        [nh.be("input")]: true,
        [nh.bem("input", "activated")]: isActivated.value,
        [nh.bem("input", "error")]: props.hasError
      };
    });
    const showTimeUnits = computed(() => {
      return props.enabled.hour || props.enabled.minute || props.enabled.second;
    });
    const formattedYear = computed(() => {
      return formatValue("year");
    });
    const formattedMonth = computed(() => {
      return formatValue("month");
    });
    const formattedDate = computed(() => {
      return formatValue("date");
    });
    const formattedHour = computed(() => {
      return formatValue("hour");
    });
    const formattedMinute = computed(() => {
      return formatValue("minute");
    });
    const formattedSecond = computed(() => {
      return formatValue("second");
    });
    function formatValue(type) {
      const isYear = type === "year";
      const filler = props.filler;
      return props.noFiller || props.activated[type] ? isYear ? props.dateValue.year.toString().padStart(4, "0") : m(props.dateValue[type]) : `${isYear ? `${filler}${filler}` : ""}${filler}${filler}`;
    }
    function handleInputFocus(type) {
      emit("unit-focus", type);
    }
    function handleInput(event) {
      if (!props.visible)
        return;
      const type = handleKeyEnter(event);
      switch (type) {
        case "next": {
          emit("next-unit");
          break;
        }
        case "prev": {
          emit("prev-unit");
          break;
        }
        case "up": {
          emit("minus", event.ctrlKey);
          break;
        }
        case "down": {
          emit("plus", event.ctrlKey);
          break;
        }
        case "ok": {
          emit("enter");
          break;
        }
        case "esc": {
          emit("cancel");
          break;
        }
        default: {
          if (typeof type === "number") {
            emit("input", type);
          }
        }
      }
    }
    return {
      nh,
      className,
      showTimeUnits,
      formattedYear,
      formattedMonth,
      formattedDate,
      formattedHour,
      formattedMinute,
      formattedSecond,
      wrapper,
      handleInputFocus,
      handleInput,
      focus: () => {
        var _a;
        (_a = wrapper.value) == null ? void 0 : _a.focus();
      },
      blur: () => {
        var _a;
        (_a = wrapper.value) == null ? void 0 : _a.blur();
      }
    };
  }
});
function _sfc_render41(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    tabindex: "-1",
    onKeydown: _cache[6] || (_cache[6] = (...args) => _ctx.handleInput && _ctx.handleInput(...args))
  }, [
    _ctx.enabled.year ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "year" && _ctx.nh.bem("unit", "focused")]),
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleInputFocus("year"))
    }, toDisplayString(_ctx.formattedYear), 3)) : createCommentVNode("", true),
    _ctx.labels.year ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(_ctx.nh.be("label"))
    }, toDisplayString(_ctx.labels.year), 3)) : createCommentVNode("", true),
    _ctx.enabled.month ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
      _ctx.enabled.year ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("separator"))
      }, toDisplayString(_ctx.dateSeparator), 3)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "month" && _ctx.nh.bem("unit", "focused")]),
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleInputFocus("month"))
      }, toDisplayString(_ctx.formattedMonth), 3),
      _ctx.labels.month ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("label"))
      }, toDisplayString(_ctx.labels.month), 3)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _ctx.enabled.date ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      _ctx.enabled.month || _ctx.enabled.year ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("separator"))
      }, toDisplayString(_ctx.dateSeparator), 3)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "date" && _ctx.nh.bem("unit", "focused")]),
        onClick: _cache[2] || (_cache[2] = ($event) => _ctx.handleInputFocus("date"))
      }, toDisplayString(_ctx.formattedDate), 3),
      _ctx.labels.date ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("label"))
      }, toDisplayString(_ctx.labels.date), 3)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _ctx.showTimeUnits ? (openBlock(), createElementBlock(Fragment, { key: 4 }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("pad"))
      }, null, 2),
      _ctx.enabled.hour ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "hour" && _ctx.nh.bem("unit", "focused")]),
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.handleInputFocus("hour"))
      }, toDisplayString(_ctx.formattedHour), 3)) : createCommentVNode("", true),
      _ctx.labels.hour ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("label"))
      }, toDisplayString(_ctx.labels.hour), 3)) : createCommentVNode("", true),
      _ctx.enabled.minute ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        _ctx.enabled.hour ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("separator"))
        }, toDisplayString(_ctx.timeSeparator), 3)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "minute" && _ctx.nh.bem("unit", "focused")]),
          onClick: _cache[4] || (_cache[4] = ($event) => _ctx.handleInputFocus("minute"))
        }, toDisplayString(_ctx.formattedMinute), 3),
        _ctx.labels.minute ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("label"))
        }, toDisplayString(_ctx.labels.minute), 3)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true),
      _ctx.enabled.second ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
        _ctx.enabled.minute || _ctx.enabled.hour ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("separator"))
        }, toDisplayString(_ctx.timeSeparator), 3)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "second" && _ctx.nh.bem("unit", "focused")]),
          onClick: _cache[5] || (_cache[5] = ($event) => _ctx.handleInputFocus("second"))
        }, toDisplayString(_ctx.formattedSecond), 3),
        _ctx.labels.second ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("label"))
        }, toDisplayString(_ctx.labels.second), 3)) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true)
  ], 34);
}
var DateControl = _export_sfc(_sfc_main41, [["render", _sfc_render41]]);

// node_modules/vexip-ui/es/components/wheel/symbol.mjs
var WHEEL_STATE = Symbol("WHEEL_STATE");

// node_modules/vexip-ui/es/components/wheel/wheel-item.mjs
var _sfc_main42 = defineComponent({
  name: "WheelItem",
  props: {
    value: {
      type: [Number, String],
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: false
    },
    meta: {
      type: [String, Number, Object],
      default: null
    }
  },
  setup(props) {
    const wheelState = inject(WHEEL_STATE, null);
    const width = ref(0);
    const height = ref(0);
    const wrapper = ref();
    const state = reactive({
      width,
      height,
      el: wrapper,
      value: toRef(props, "value"),
      disabled: toRef(props, "disabled"),
      meta: toRef(props, "meta")
    });
    const style = computed(() => {
      return {
        width: width.value ? `${width.value}px` : void 0,
        height: height.value ? `${height.value}px` : void 0
      };
    });
    if (wheelState) {
      onMounted(() => {
        wheelState.increaseItem(state);
      });
      onBeforeUnmount(() => {
        wheelState.decreaseItem(state);
      });
    }
    return {
      nh: useNameHelper("wheel"),
      style,
      wrapper
    };
  }
});
var _hoisted_119 = ["aria-disabled", "aria-selected"];
function _sfc_render42(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    ref: "wrapper",
    class: normalizeClass([
      _ctx.nh.be("item"),
      _ctx.disabled && _ctx.nh.bem("item", "disabled"),
      _ctx.active && _ctx.nh.bem("item", "active")
    ]),
    role: "option",
    "aria-disabled": _ctx.disabled ? "true" : void 0,
    "aria-selected": _ctx.active,
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createTextVNode(toDisplayString(_ctx.value), 1)
    ])
  ], 14, _hoisted_119);
}
var WheelItem = _export_sfc(_sfc_main42, [["render", _sfc_render42]]);

// node_modules/vexip-ui/es/components/scroll/props.mjs
var scrollProps = buildProps({
  scrollClass: classProp,
  mode: String,
  width: [Number, String],
  height: [Number, String],
  deltaX: Number,
  deltaY: Number,
  disabled: booleanProp,
  pointer: booleanProp,
  wheel: booleanProp,
  scrollX: Number,
  scrollY: Number,
  useXBar: booleanProp,
  useYBar: booleanProp,
  barFade: Number,
  barClass: classProp,
  autoplay: booleanNumberProp,
  playWaiting: Number,
  noBuffer: booleanProp,
  noTransition: booleanProp,
  onBeforeScroll: Function,
  useBarTrack: booleanProp,
  wrapperTag: String,
  onResize: eventProp(),
  onXEnabledChange: eventProp(),
  onYEnabledChange: eventProp(),
  onWheel: eventProp(),
  onScrollStart: eventProp(),
  onScroll: eventProp(),
  onScrollEnd: eventProp(),
  onBarScrollStart: eventProp(),
  onBarScroll: eventProp(),
  onBarScrollEnd: eventProp(),
  onReady: eventProp()
});

// node_modules/vexip-ui/es/components/scroll/hooks.mjs
function useScrollWrapper2({
  mode,
  disabled,
  width,
  height,
  scrollX,
  scrollY,
  onResize,
  onBeforeRefresh,
  onAfterRefresh
}) {
  const wrapperElement = ref();
  const contentElement = ref();
  const wrapper = reactive({
    el: wrapperElement,
    width: En(width.value),
    height: En(height.value)
  });
  const content = reactive({
    el: contentElement,
    width: 0,
    height: 0
  });
  const xScrollLimit = computed(() => {
    return wrapper.width ? wrapper.width - content.width : 0;
  });
  const yScrollLimit = computed(() => {
    return wrapper.height ? wrapper.height - content.height : 0;
  });
  const enableXScroll = computed(() => {
    return !disabled.value && mode.value !== "vertical" && !!wrapper.width && content.width - wrapper.width > 1;
  });
  const enableYScroll = computed(() => {
    return !disabled.value && mode.value !== "horizontal" && !!wrapper.height && content.height - wrapper.height > 1;
  });
  const xBarLength = computed(() => {
    if (wrapper.width) {
      return Math.max(Math.min(wrapper.width / (content.width || 1) * 100, 99), 5);
    }
    return 35;
  });
  const yBarLength = computed(() => {
    if (wrapper.height) {
      return Math.max(Math.min(wrapper.height / (content.height || 1) * 100, 99), 5);
    }
    return 35;
  });
  watch(wrapperElement, () => {
    refreshWrapper();
  });
  watch(contentElement, () => {
    computeContentSize();
  });
  watch(scrollX, (value) => {
    currentScroll.x = -value;
    verifyScroll();
  });
  watch(scrollY, (value) => {
    currentScroll.y = -value;
    verifyScroll();
  });
  watch(width, () => {
    refreshWrapper();
    verifyScroll();
  });
  watch(height, () => {
    refreshWrapper();
    verifyScroll();
  });
  function computeWrapperSize(sizeType) {
    nextTick(() => {
      if (!wrapper.el)
        return;
      const size = sizeType === "width" ? width.value : height.value;
      const titleCaseSizeType = sizeType.slice(0, 1).toUpperCase() + sizeType.slice(1);
      if (typeof size === "string") {
        if (!size.endsWith("px") && Number.isNaN(Number(size))) {
          wrapper[sizeType] = wrapper.el[`offset${titleCaseSizeType}`];
        } else {
          wrapper[sizeType] = parseInt(size);
        }
      } else {
        wrapper[sizeType] = size;
      }
    });
  }
  function refreshWrapper() {
    if (mode.value !== "vertical") {
      computeWrapperSize("width");
    }
    if (mode.value !== "horizontal") {
      computeWrapperSize("height");
    }
  }
  const isReady = ref(false);
  const currentScroll = reactive({
    x: -scrollX.value,
    y: -scrollY.value
  });
  const percentX = ref(0);
  const percentY = ref(0);
  let timer2;
  function computeContentSize() {
    clearTimeout(timer2);
    timer2 = setTimeout(() => {
      if (!content.el)
        return;
      if (mode.value !== "vertical") {
        content.width = content.el.offsetWidth;
        if (wrapper.width >= content.width) {
          currentScroll.x = 0;
        } else {
          if (currentScroll.x === 0) {
            currentScroll.x = -scrollX.value;
          }
        }
      }
      if (mode.value !== "horizontal") {
        content.height = content.el.offsetHeight;
        if (wrapper.height >= content.height) {
          currentScroll.y = 0;
        } else {
          if (currentScroll.y === 0) {
            currentScroll.y = -scrollY.value;
          }
        }
      }
      isReady.value = false;
      setTimeout(() => {
        isReady.value = true;
        verifyScroll();
      }, 1);
    }, 0);
  }
  function verifyScroll() {
    if (!isReady.value) {
      return;
    }
    if (mode.value !== "vertical") {
      currentScroll.x = Math.min(0, Math.max(currentScroll.x, xScrollLimit.value));
    }
    if (mode.value !== "horizontal") {
      currentScroll.y = Math.min(0, Math.max(currentScroll.y, yScrollLimit.value));
    }
    computePercent();
  }
  function computePercent() {
    percentX.value = An(currentScroll.x / (xScrollLimit.value || -1), 100, 2);
    percentY.value = An(currentScroll.y / (yScrollLimit.value || -1), 100, 2);
    percentX.value = Math.max(0, Math.min(percentX.value, 100));
    percentY.value = Math.max(0, Math.min(percentY.value, 100));
  }
  function handleResize(entity) {
    refresh();
    onResize == null ? void 0 : onResize(entity);
  }
  let isMounted = false;
  onMounted(() => {
    refresh();
    isMounted = true;
  });
  function refresh() {
    if (typeof onBeforeRefresh === "function") {
      onBeforeRefresh();
    }
    refreshWrapper();
    computeContentSize();
    setTimeout(
      () => {
        verifyScroll();
        if (typeof onAfterRefresh === "function") {
          onAfterRefresh();
        }
      },
      isMounted ? 20 : 100
    );
  }
  return {
    wrapperElement,
    contentElement,
    wrapper,
    isReady,
    currentScroll,
    percentX,
    percentY,
    xScrollLimit,
    yScrollLimit,
    enableXScroll,
    enableYScroll,
    xBarLength,
    yBarLength,
    handleResize,
    verifyScroll,
    computePercent,
    refresh
  };
}

// node_modules/vexip-ui/es/components/scroll/scroll.mjs
var scrollModes2 = Object.freeze(["horizontal", "horizontal-exact", "vertical", "both"]);
var MOVE_EVENT2 = Fe ? "touchmove" : "mousemove";
var UP_EVENT2 = Fe ? "touchend" : "mouseup";
var _sfc_main43 = defineComponent({
  name: "Scroll",
  components: {
    Scrollbar,
    ResizeObserver
  },
  props: scrollProps,
  emits: [],
  setup(_props) {
    const props = useProps("scroll", _props, {
      scrollClass: null,
      mode: {
        default: "vertical",
        validator: (value) => scrollModes2.includes(value)
      },
      width: "",
      height: "",
      deltaX: 20,
      deltaY: 20,
      disabled: false,
      pointer: Fe,
      wheel: true,
      scrollX: {
        default: 0,
        static: true
      },
      scrollY: {
        default: 0,
        static: true
      },
      useXBar: false,
      useYBar: false,
      barFade: 1500,
      barClass: null,
      autoplay: false,
      playWaiting: 500,
      noBuffer: false,
      noTransition: false,
      onBeforeScroll: {
        default: null,
        isFunc: true
      },
      useBarTrack: false,
      wrapperTag: "div"
    });
    const emitter = gr();
    const nh = useNameHelper("scroll");
    const usingBar = ref(false);
    const scrolling = ref(false);
    const transitionDuration = ref(-1);
    const mode = computed(() => props.mode === "horizontal-exact" ? "horizontal" : props.mode);
    const {
      wrapperElement,
      contentElement,
      wrapper,
      isReady,
      currentScroll,
      percentX,
      percentY,
      xScrollLimit,
      yScrollLimit,
      enableXScroll,
      enableYScroll,
      xBarLength,
      yBarLength,
      handleResize,
      verifyScroll,
      computePercent,
      refresh
    } = useScrollWrapper2({
      mode,
      disabled: toRef(props, "disabled"),
      width: toRef(props, "width"),
      height: toRef(props, "height"),
      scrollX: toRef(props, "scrollX"),
      scrollY: toRef(props, "scrollY"),
      onResize: (entry) => {
        emitEvent(props.onResize, entry);
      },
      onBeforeRefresh: stopAutoplay,
      onAfterRefresh: startAutoplay
    });
    const canPlay = ref(false);
    const canAutoplay = computed(() => {
      return mode.value !== "both" && (Ke(props.autoplay) || props.autoplay > 1e3) && (mode.value === "horizontal" && enableXScroll.value || mode.value === "vertical" && enableYScroll.value);
    });
    watch(
      () => props.autoplay,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    watch(
      () => props.playWaiting,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    let playTimer;
    let startTimer;
    let endTimer;
    onBeforeUnmount(stopAutoplay);
    function startAutoplay() {
      if (!canAutoplay.value)
        return;
      stopAutoplay();
      const distance = mode.value === "horizontal" ? "width" : "height";
      const limit = mode.value === "horizontal" ? xScrollLimit : yScrollLimit;
      const prop = mode.value === "horizontal" ? "x" : "y";
      const waiting = props.playWaiting < 20 ? 20 : props.playWaiting;
      let playSpeed = 0.5;
      if (typeof props.autoplay === "number") {
        playSpeed = wrapper[distance] / props.autoplay * 16;
      }
      const scroll = () => {
        currentScroll[prop] -= playSpeed;
        if (currentScroll[prop] <= limit.value) {
          currentScroll[prop] = limit.value;
          canPlay.value = false;
          computePercent();
          syncBarScroll();
          endTimer = setTimeout(() => {
            scrollTo(0, 0, 500);
            startTimer = setTimeout(() => {
              canPlay.value = true;
              scroll();
            }, 500 + waiting);
          }, waiting);
        } else {
          computePercent();
          syncBarScroll();
          if (canPlay.value) {
            requestAnimationFrame(scroll);
          }
        }
      };
      playTimer = setTimeout(() => {
        canPlay.value = true;
        scroll();
      }, waiting);
    }
    function stopAutoplay() {
      canPlay.value = false;
      clearTimeout(playTimer);
      clearTimeout(startTimer);
      clearTimeout(endTimer);
    }
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(mode.value),
        {
          [nh.bm("inherit")]: props.inherit
        }
      ];
    });
    const style = computed(() => {
      const { width, height } = props;
      return {
        width: width ? typeof width === "string" ? Number.isNaN(Number(width)) ? width : `${Number(width)}px` : `${width}px` : void 0,
        height: height ? typeof height === "string" ? Number.isNaN(Number(height)) ? height : `${Number(height)}px` : `${height}px` : void 0
      };
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        props.scrollClass,
        {
          [nh.bem("wrapper", "scrolling")]: scrolling.value,
          [nh.bem("wrapper", "no-ready")]: !isReady.value,
          [nh.bem("wrapper", "using-bar")]: usingBar.value,
          [nh.bem("wrapper", "no-transition")]: props.noTransition
        }
      ];
    });
    const wrapperStyle = computed(() => {
      return {
        transform: `translate3d(${currentScroll.x}px, ${currentScroll.y}px, 0)`,
        transitionDuration: transitionDuration.value < 0 ? void 0 : `${transitionDuration.value}ms`
      };
    });
    watch(enableXScroll, (value) => {
      emitEvent(props.onXEnabledChange, value);
    });
    watch(enableYScroll, (value) => {
      emitEvent(props.onYEnabledChange, value);
    });
    watch(isReady, (value) => {
      if (value)
        emitEvent(props.onReady);
    });
    const xBar = ref();
    const yBar = ref();
    function syncBarScroll() {
      var _a, _b;
      (_a = xBar.value) == null ? void 0 : _a.handleScroll(percentX.value);
      (_b = yBar.value) == null ? void 0 : _b.handleScroll(percentY.value);
    }
    function handleMouseDown(event) {
      if (!props.pointer || event.button > 0 || Fe) {
        return false;
      }
      handlePointerDown(event);
    }
    function handleTouchStart(event) {
      if (!props.pointer || event.touches.length !== 1) {
        return false;
      }
      handlePointerDown(event);
    }
    let xScrollStartAt = 0;
    let yScrollStartAt = 0;
    let cursorXPosition = 0;
    let cursorYPosition = 0;
    let moved = false;
    let target = null;
    let lastDate = 0;
    function handlePointerDown(event) {
      if (!enableXScroll.value && !enableYScroll.value) {
        return false;
      }
      if (event.cancelable) {
        event.preventDefault();
      }
      prepareScroll();
      transitionDuration.value = 0;
      const pointer = "touches" in event ? event.touches[0] : event;
      xScrollStartAt = currentScroll.x;
      yScrollStartAt = currentScroll.y;
      cursorXPosition = pointer.clientX;
      cursorYPosition = pointer.clientY;
      moved = false;
      target = event.target;
      lastDate = Date.now();
      document.addEventListener(MOVE_EVENT2, handlePointerMove);
      document.addEventListener(UP_EVENT2, handlePointerUp);
      emitEvent(props.onScrollStart, {
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handlePointerMove(event) {
      var _a;
      event.stopPropagation();
      if (!Fe) {
        event.preventDefault();
      }
      const pointer = "touches" in event ? event.touches[0] : event;
      const signX = pointer.clientX - cursorXPosition > 0 ? 1 : -1;
      const signY = pointer.clientY - cursorYPosition > 0 ? 1 : -1;
      if (((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX, signY })) === false) {
        return false;
      }
      scrolling.value = true;
      if (enableXScroll.value) {
        currentScroll.x = xScrollStartAt + pointer.clientX - cursorXPosition;
        moved = true;
      }
      if (enableYScroll.value) {
        currentScroll.y = yScrollStartAt + pointer.clientY - cursorYPosition;
        moved = true;
      }
      if (props.noBuffer) {
        verifyScroll();
      } else {
        computePercent();
      }
      syncBarScroll();
      emitScrollEvent(mode.value);
    }
    function handlePointerUp(event) {
      if (!moved && target && event.target === target && Date.now() - lastDate <= 500) {
        target.dispatchEvent(new MouseEvent("click", event));
      }
      document.removeEventListener(MOVE_EVENT2, handlePointerMove);
      document.removeEventListener(UP_EVENT2, handlePointerUp);
      transitionDuration.value = -1;
      moved = false;
      handleBuffer();
      verifyScroll();
      syncBarScroll();
      emitEvent(props.onScrollEnd, {
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      startAutoplay();
    }
    function handleWheel(event, type) {
      var _a;
      const isVerticalScroll = enableYScroll.value && type === "vertical";
      const isHorizontalScroll = enableXScroll.value && type === "horizontal";
      const sign = event.deltaY > 0 ? -1 : 1;
      if (props.wheel && (isVerticalScroll || isHorizontalScroll) && ((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX: -sign, signY: -sign })) !== false) {
        event.preventDefault();
        event.stopPropagation();
      } else {
        return true;
      }
      if (mode.value !== "both" && mode.value !== type)
        return false;
      prepareScroll();
      const computedDelta = sign * (type === "horizontal" ? props.deltaX : props.deltaY);
      if (isVerticalScroll) {
        currentScroll.y += computedDelta;
      } else if (isHorizontalScroll) {
        currentScroll.x += computedDelta;
      }
      verifyScroll();
      syncBarScroll();
      emitScrollEvent(type);
      emitEvent(props.onWheel, {
        type,
        sign: -sign,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      startAutoplay();
    }
    let bufferTimer;
    function prepareScroll() {
      stopAutoplay();
      clearTimeout(bufferTimer);
    }
    function handleBuffer() {
      if (props.noBuffer) {
        bufferTimer = setTimeout(() => {
          scrolling.value = false;
        }, 300);
      } else {
        scrolling.value = false;
      }
    }
    function handleBarScrollStart(type) {
      usingBar.value = true;
      emitEvent(props.onBarScrollStart, {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleBarScrollEnd(type) {
      usingBar.value = false;
      emitEvent(props.onBarScrollEnd, {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleXBarScroll(percent) {
      percentX.value = percent;
      currentScroll.x = percent * xScrollLimit.value / 100;
      emitEvent(props.onBarScroll, {
        type: "horizontal",
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("horizontal");
    }
    function handleYBarScroll(percent) {
      percentY.value = percent;
      currentScroll.y = percent * yScrollLimit.value / 100;
      emitEvent(props.onBarScroll, {
        type: "vertical",
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("vertical");
    }
    function emitScrollEvent(type) {
      emitEvent(props.onScroll, {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitter.emit("scroll", {
        type,
        clientX: -currentScroll.x,
        clientY: -currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function ensureScrollOffset() {
      if (wrapperElement.value) {
        wrapperElement.value.scrollTop = 0;
        wrapperElement.value.scrollLeft = 0;
      }
    }
    function scrollTo(clientX, clientY, duration) {
      setDuration(duration);
      nextTick(() => {
        let changed = false;
        if (enableXScroll.value && Math.abs(currentScroll.x + clientX) > 0.01) {
          currentScroll.x = -clientX;
          changed = true;
        }
        if (enableYScroll.value && Math.abs(currentScroll.y + clientY) > 0.01) {
          currentScroll.y = -clientY;
          changed = true;
        }
        verifyScroll();
        syncBarScroll();
        if (!changed)
          transitionDuration.value = -1;
      });
    }
    function scrollBy(deltaX, deltaY, duration) {
      setDuration(duration);
      nextTick(() => {
        let changed = false;
        if (deltaX && enableXScroll) {
          currentScroll.x -= deltaX;
          changed = true;
        }
        if (deltaY && enableYScroll) {
          currentScroll.y -= deltaY;
          changed = true;
        }
        verifyScroll();
        syncBarScroll();
        if (!changed)
          transitionDuration.value = -1;
      });
    }
    function setDuration(duration) {
      if (typeof duration === "number") {
        transitionDuration.value = duration;
        if (transitionDuration.value === 0) {
          nextTick(() => {
            transitionDuration.value = -1;
          });
        }
      }
    }
    function getXScrollLimit() {
      return [0, -xScrollLimit.value];
    }
    function getYScrollLimit() {
      return [0, -yScrollLimit.value];
    }
    function scrollToElement(el, duration, offset = 0) {
      if (!contentElement.value)
        return;
      if (typeof el === "string") {
        el = contentElement.value.querySelector(el);
      }
      if (!sn(el))
        return;
      const wrapperRect = contentElement.value.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      let clientX = 0;
      let clientY = 0;
      if (mode.value !== "vertical") {
        clientX = elRect.left - wrapperRect.left + offset;
      }
      if (mode.value !== "horizontal") {
        clientY = elRect.top - wrapperRect.top + offset;
      }
      scrollTo(clientX, clientY, duration);
    }
    function ensureInView(el, duration, offset = 0) {
      if (!wrapperElement.value)
        return;
      if (typeof el === "string") {
        el = wrapperElement.value.querySelector(el);
      }
      if (!sn(el))
        return;
      const wrapperRect = wrapperElement.value.getBoundingClientRect();
      const elRect = el.getBoundingClientRect();
      let clientX = 0;
      let clientY = 0;
      if (mode.value !== "vertical") {
        if (elRect.left < wrapperRect.left + offset) {
          clientX = elRect.left - wrapperRect.left - offset;
        } else if (elRect.right > wrapperRect.right - offset) {
          clientX = elRect.right - wrapperRect.right + offset;
        }
      }
      if (mode.value !== "horizontal") {
        if (elRect.top < wrapperRect.top + offset) {
          clientY = elRect.top - wrapperRect.top - offset;
        } else if (elRect.bottom > wrapperRect.bottom - offset) {
          clientY = elRect.bottom - wrapperRect.bottom + offset;
        }
      }
      scrollBy(clientX, clientY, duration);
    }
    function addScrollListener(listener) {
      emitter.on("scroll", listener);
    }
    function removeScrollListener(listener) {
      emitter.off("scroll", listener);
    }
    return {
      props,
      nh,
      percentX,
      percentY,
      transitionDuration,
      currentScroll,
      className,
      style,
      wrapperClass,
      wrapperStyle,
      xBarLength,
      yBarLength,
      enableXScroll,
      enableYScroll,
      wrapper: wrapperElement,
      content: contentElement,
      xBar,
      yBar,
      handleResize,
      handleMouseDown,
      handleTouchStart,
      handleWheel,
      handleBarScrollStart,
      handleBarScrollEnd,
      handleXBarScroll,
      handleYBarScroll,
      ensureScrollOffset,
      refresh,
      scrollTo,
      scrollBy,
      getXScrollLimit,
      getYScrollLimit,
      scrollToElement,
      ensureInView,
      addScrollListener,
      removeScrollListener
    };
  }
});
function _sfc_render43(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.style),
    onMousedown: _cache[5] || (_cache[5] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args)),
    onTouchstart: _cache[6] || (_cache[6] = (...args) => _ctx.handleTouchStart && _ctx.handleTouchStart(...args)),
    onScroll: _cache[7] || (_cache[7] = (...args) => _ctx.ensureScrollOffset && _ctx.ensureScrollOffset(...args)),
    onWheel: [
      _cache[8] || (_cache[8] = withModifiers(($event) => _ctx.handleWheel($event, _ctx.mode === "horizontal-exact" ? "horizontal" : "vertical"), ["exact"])),
      _cache[9] || (_cache[9] = withModifiers(($event) => _ctx.handleWheel($event, "horizontal"), ["shift"]))
    ]
  }, [
    createVNode(_component_ResizeObserver, {
      throttle: "",
      "on-resize": _ctx.handleResize
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.props.wrapperTag || "div"), {
          ref: "content",
          class: normalizeClass(_ctx.wrapperClass),
          style: normalizeStyle(_ctx.wrapperStyle),
          onTransitionend: _cache[0] || (_cache[0] = ($event) => _ctx.transitionDuration = -1)
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 40, ["class", "style"]))
      ]),
      _: 3
    }, 8, ["on-resize"]),
    _ctx.props.useXBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 0,
      ref: "xBar",
      inherit: "",
      placement: "bottom",
      class: normalizeClass([_ctx.nh.bem("bar", "horizontal"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.xBarLength,
      disabled: !_ctx.enableXScroll,
      duration: _ctx.transitionDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[1] || (_cache[1] = ($event) => _ctx.handleBarScrollStart("horizontal")),
      onScroll: _ctx.handleXBarScroll,
      onScrollEnd: _cache[2] || (_cache[2] = ($event) => _ctx.handleBarScrollEnd("horizontal"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "duration", "use-track", "onScroll"])) : createCommentVNode("", true),
    _ctx.props.useYBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 1,
      ref: "yBar",
      inherit: "",
      placement: "right",
      class: normalizeClass([_ctx.nh.bem("bar", "vertical"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.yBarLength,
      disabled: !_ctx.enableYScroll,
      duration: _ctx.transitionDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[3] || (_cache[3] = ($event) => _ctx.handleBarScrollStart("vertical")),
      onScroll: _ctx.handleYBarScroll,
      onScrollEnd: _cache[4] || (_cache[4] = ($event) => _ctx.handleBarScrollEnd("vertical"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "duration", "use-track", "onScroll"])) : createCommentVNode("", true)
  ], 38);
}
var Scroll = _export_sfc(_sfc_main43, [["render", _sfc_render43]]);

// node_modules/vexip-ui/es/components/wheel/props.mjs
var wheelProps = buildProps({
  state: stateProp,
  horizontal: booleanProp,
  value: [String, Number],
  candidate: Number,
  arrow: booleanProp,
  pointer: booleanProp,
  options: Array,
  insertEmpty: booleanStringProp,
  disabled: booleanProp,
  loading: booleanProp,
  loadingLock: booleanProp,
  disabledItem: Function,
  onChange: eventProp(),
  onPrev: eventProp(),
  onNext: eventProp()
});

// node_modules/vexip-ui/es/components/wheel/wheel.mjs
var _sfc_main44 = defineComponent({
  name: "Wheel",
  components: {
    WheelItem,
    Icon,
    Scroll
  },
  props: wheelProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = wrapper.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("wheel", _props, {
      state: createStateProp(state),
      horizontal: false,
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      candidate: {
        default: 2,
        validator: (value) => [0, 1, 2, 3].includes(value)
      },
      arrow: false,
      pointer: Fe,
      options: {
        default: () => [],
        static: true
      },
      insertEmpty: false,
      disabled: () => disabled.value,
      loading: () => loading.value,
      loadingLock: false,
      disabledItem: {
        default: fn,
        isFunc: true
      }
    });
    const nh = useNameHelper("wheel");
    const items = ref(/* @__PURE__ */ new Set());
    const currentActive = ref(0);
    const wrapperWidth = ref(0);
    const wrapperHeight = ref(0);
    const targetWidth = ref(0);
    const targetHeight = ref(0);
    const horizontalPadding = ref(0);
    const verticalPadding = ref(0);
    const isInit = ref(false);
    const wrapper = Ao(displayInit);
    const scroll = ref();
    No({
      target: wrapper,
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down) {
          event.preventDefault();
          modifier.up ? handlePrev() : handleNext();
        }
      }
    });
    const normalizedOptions = computed(() => {
      const options = props.options.map((option) => {
        if (typeof option === "object") {
          const { value, label, disabled: disabled2 = false } = option;
          return {
            value,
            label: label || String(value),
            disabled: disabled2,
            meta: option
          };
        }
        return { value: option, label: String(option), disabled: false, meta: option };
      });
      if (props.insertEmpty) {
        options.unshift({
          value: "",
          label: typeof props.insertEmpty === "string" ? props.insertEmpty : "-",
          disabled: false,
          meta: ""
        });
      }
      return options;
    });
    const itemList = computed(() => {
      return Array.from(items.value);
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(props.horizontal ? "horizontal" : "vertical"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading && props.loadingLock
        }
      ];
    });
    const listStyle = computed(() => {
      if (props.horizontal) {
        return {
          paddingRight: `${horizontalPadding.value}px`,
          paddingLeft: `${horizontalPadding.value}px`
        };
      }
      return {
        paddingTop: `${verticalPadding.value}px`,
        paddingBottom: `${verticalPadding.value}px`
      };
    });
    const maskStyle = computed(() => {
      if (props.horizontal) {
        return {
          width: horizontalPadding.value ? `${horizontalPadding.value}px` : void 0
        };
      }
      return {
        height: verticalPadding.value ? `${verticalPadding.value}px` : void 0
      };
    });
    const borderStyle = computed(() => {
      const style = {
        inset: props.horizontal ? `0 ${horizontalPadding.value - 1}px` : `${verticalPadding.value - 1}px 0`
      };
      if (props.horizontal) {
        style.borderTop = "0";
        style.borderBottom = "0";
      } else {
        style.borderRight = "0";
        style.borderLeft = "0";
      }
      return style;
    });
    const prevDisabled = computed(() => {
      return props.disabled || !itemList.value.slice(0, currentActive.value).some((item) => !isItemDisbaled(item));
    });
    const nextDisabled = computed(() => {
      return props.disabled || currentActive.value >= itemList.value.length - 1 || !itemList.value.slice(currentActive.value + 1, itemList.value.length).some((item) => !isItemDisbaled(item));
    });
    const prevIcon = computed(() => props.horizontal ? $2 : $4);
    const nextIcon = computed(() => props.horizontal ? $3 : $);
    provide(WHEEL_STATE, { increaseItem, decreaseItem });
    const updateActive = Mr(() => {
      const active = Math.max(
        itemList.value.findIndex((item) => item.value === props.value),
        0
      );
      currentActive.value = findEnabledActive(active);
    });
    const computeSize = Mr(() => {
      nextTick(() => {
        const horizontal = props.horizontal;
        itemList.value.forEach((item) => {
          if (item && item.el) {
            targetWidth.value = Math.max(targetWidth.value, item.el.offsetWidth);
            targetHeight.value = Math.max(targetHeight.value, item.el.offsetHeight);
          }
        });
        const candidate = props.candidate;
        const showCount = 2 * candidate + 1;
        wrapperWidth.value = showCount * targetWidth.value;
        wrapperHeight.value = showCount * targetHeight.value;
        horizontalPadding.value = candidate * targetWidth.value;
        verticalPadding.value = candidate * targetHeight.value;
        items.value.forEach((item) => {
          if (horizontal) {
            item.width = targetWidth.value;
          } else {
            item.height = targetHeight.value;
          }
        });
        setTimeout(() => {
          var _a;
          (_a = scroll.value) == null ? void 0 : _a.refresh();
        }, 0);
      });
    });
    const refreshScroll = yr(() => {
      if (scroll.value) {
        let targetXScroll = 0;
        let targetYScroll = 0;
        if (props.horizontal) {
          targetXScroll = currentActive.value * targetWidth.value;
        } else {
          targetYScroll = currentActive.value * targetHeight.value;
        }
        nextTick(() => {
          var _a;
          (_a = scroll.value) == null ? void 0 : _a.scrollTo(targetXScroll, targetYScroll);
        });
      }
    }, 20);
    watch(
      () => props.value,
      () => {
        updateActive();
        refreshScroll();
      },
      { immediate: true }
    );
    watch(() => props.horizontal, computeSize);
    watch(currentActive, () => {
      refreshScroll();
      const item = itemList.value[currentActive.value];
      const value = item == null ? void 0 : item.value;
      setFieldValue(value);
      emitEvent(props.onChange, value, item == null ? void 0 : item.meta);
      emit("update:value", value);
      validateField();
    });
    watch(() => props.candidate, computeSize);
    function isItemDisbaled(item) {
      return item.disabled || props.disabledItem(item.value, item.meta);
    }
    function queryEnabledActive(active, step) {
      step = step / Math.abs(step);
      while (itemList.value[active].disabled) {
        active += step;
        if (active < 0 || active >= itemList.value.length)
          break;
      }
      return active;
    }
    function findEnabledActive(active, sign = 1) {
      if (itemList.value[active] && isItemDisbaled(itemList.value[active])) {
        active = queryEnabledActive(active, 1 * sign);
        if (sign > 0 ? active >= itemList.value.length : active < 0) {
          active = queryEnabledActive(Fn(active, 0, itemList.value.length - 1), -1 * sign);
          if (sign > 0 ? active < 0 : active >= itemList.value.length)
            active = 0;
        }
      }
      return active;
    }
    function increaseItem(item) {
      items.value.add(item);
      computeSize();
      updateActive();
    }
    function decreaseItem(item) {
      items.value.delete(item);
      computeSize();
      updateActive();
    }
    function displayInit() {
      var _a;
      computeSize();
      (_a = scroll.value) == null ? void 0 : _a.refresh();
      nextTick(() => {
        isInit.value = true;
        updateActive();
        refreshScroll();
      });
    }
    function beforeScroll({ signX, signY }) {
      if (props.disabled || props.loading && props.loadingLock)
        return false;
      const sign = props.horizontal ? signX : signY;
      return !(sign < 0 && prevDisabled.value || sign > 0 && nextDisabled.value);
    }
    function handleScrollEnd({ clientX, clientY }) {
      const aboutActive = props.horizontal ? clientX / targetWidth.value : clientY / targetHeight.value;
      const active = Math.round(aboutActive);
      if (active !== currentActive.value) {
        currentActive.value = findEnabledActive(active, active > aboutActive ? 1 : -1);
      } else {
        refreshScroll();
      }
    }
    function handleWheel({
      sign,
      clientX,
      clientY
    }) {
      const active = props.horizontal ? Math.round(clientX / targetWidth.value) : Math.round(clientY / targetHeight.value);
      currentActive.value = findEnabledActive(active, sign);
    }
    function handlePrev() {
      if (!prevDisabled.value) {
        currentActive.value = findEnabledActive(currentActive.value - 1, -1);
        const item = itemList.value[currentActive.value];
        emitEvent(props.onPrev, item == null ? void 0 : item.value, item == null ? void 0 : item.meta);
      }
    }
    function handleNext() {
      if (!nextDisabled.value) {
        currentActive.value = findEnabledActive(currentActive.value + 1, 1);
        const item = itemList.value[currentActive.value];
        emitEvent(props.onNext, item == null ? void 0 : item.value, item == null ? void 0 : item.meta);
      }
    }
    return {
      props,
      nh,
      idFor,
      currentActive,
      isInit,
      targetWidth,
      targetHeight,
      wrapperWidth,
      wrapperHeight,
      normalizedOptions,
      itemList,
      className,
      listStyle,
      maskStyle,
      borderStyle,
      prevDisabled,
      nextDisabled,
      prevIcon,
      nextIcon,
      wrapper,
      scroll,
      isItemDisbaled,
      beforeScroll,
      handleWheel,
      handleScrollEnd,
      handlePrev,
      handleNext,
      refreshScroll
    };
  }
});
var _hoisted_120 = ["id"];
function _sfc_render44(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_WheelItem = resolveComponent("WheelItem");
  const _component_Scroll = resolveComponent("Scroll");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    tabindex: "0"
  }, [
    _ctx.props.arrow ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "prevArrow",
      class: normalizeClass([
        _ctx.nh.be("arrow"),
        _ctx.nh.bem("arrow", "prev"),
        _ctx.prevDisabled ? _ctx.nh.bem("arrow", "disabled") : ""
      ]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handlePrev && _ctx.handlePrev(...args))
    }, [
      createVNode(_component_Icon, { icon: _ctx.prevIcon }, null, 8, ["icon"])
    ], 2)) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("scroll"))
    }, [
      createVNode(_component_Scroll, {
        ref: "scroll",
        inherit: "",
        "scroll-x": _ctx.props.horizontal ? _ctx.targetWidth * _ctx.currentActive : 0,
        "scroll-y": _ctx.props.horizontal ? 0 : _ctx.targetHeight * _ctx.currentActive,
        width: _ctx.props.horizontal ? _ctx.wrapperWidth : "100%",
        height: _ctx.props.horizontal ? "100%" : _ctx.wrapperHeight,
        pointer: _ctx.props.pointer,
        mode: _ctx.props.horizontal ? "horizontal" : "vertical",
        "delta-x": _ctx.targetWidth,
        "delta-y": _ctx.targetHeight,
        "on-before-scroll": _ctx.beforeScroll,
        onWheel: _ctx.handleWheel,
        onScrollEnd: _ctx.handleScrollEnd
      }, {
        default: withCtx(() => [
          createBaseVNode("ul", {
            ref: "list",
            class: normalizeClass(_ctx.nh.be("list")),
            style: normalizeStyle(_ctx.listStyle)
          }, [
            _ctx.isInit ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.normalizedOptions, (option, index) => {
              return openBlock(), createBlock(_component_WheelItem, {
                key: index,
                value: option.value,
                disabled: option.disabled || _ctx.props.disabledItem(option.value, option),
                active: _ctx.currentActive === index,
                meta: option.meta
              }, {
                default: withCtx(() => [
                  renderSlot(_ctx.$slots, "default", {
                    option,
                    index
                  }, () => [
                    createTextVNode(toDisplayString(option.label), 1)
                  ])
                ]),
                _: 2
              }, 1032, ["value", "disabled", "active", "meta"]);
            }), 128)) : createCommentVNode("", true)
          ], 6)
        ]),
        _: 3
      }, 8, ["scroll-x", "scroll-y", "width", "height", "pointer", "mode", "delta-x", "delta-y", "on-before-scroll", "onWheel", "onScrollEnd"]),
      _ctx.props.candidate ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createBaseVNode("div", {
          class: normalizeClass([_ctx.nh.be("mask"), _ctx.nh.bem("mask", "top")]),
          style: normalizeStyle(_ctx.maskStyle)
        }, null, 6),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.nh.be("mask"), _ctx.nh.bem("mask", "bottom")]),
          style: normalizeStyle(_ctx.maskStyle)
        }, null, 6)
      ], 64)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass({
          [_ctx.nh.be("border")]: true,
          [_ctx.nh.bem("border", "active")]: _ctx.props.loading,
          [_ctx.nh.bem("border", "vertical")]: _ctx.props.horizontal
        }),
        style: normalizeStyle(_ctx.borderStyle)
      }, null, 6)
    ], 2),
    _ctx.props.arrow ? (openBlock(), createElementBlock("div", {
      key: 1,
      ref: "nextArrow",
      class: normalizeClass([
        _ctx.nh.be("arrow"),
        _ctx.nh.bem("arrow", "next"),
        _ctx.nextDisabled ? _ctx.nh.bem("arrow", "disabled") : ""
      ]),
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleNext && _ctx.handleNext(...args))
    }, [
      createVNode(_component_Icon, { icon: _ctx.nextIcon }, null, 8, ["icon"])
    ], 2)) : createCommentVNode("", true)
  ], 10, _hoisted_120);
}
var Wheel = _export_sfc(_sfc_main44, [["render", _sfc_render44]]);

// node_modules/vexip-ui/es/components/date-picker/time-wheel.mjs
var _sfc_main45 = defineComponent({
  name: "TimeWheel",
  components: {
    Wheel
  },
  props: {
    noArrow: {
      type: Boolean,
      default: false
    },
    hour: {
      type: Number,
      default: 0,
      validator: (value) => value >= 0 && value <= 23
    },
    minute: {
      type: Number,
      default: 0,
      validator: (value) => value >= 0 && value <= 59
    },
    second: {
      type: Number,
      default: 0,
      validator: (value) => value >= 0 && value <= 59
    },
    candidate: {
      default: 2,
      validator: (value) => [0, 1, 2, 3].includes(value)
    },
    steps: {
      type: Array,
      default: () => [1, 1, 1],
      validator: (value) => {
        if (value[0] && 24 % value[0] !== 0) {
          return false;
        }
        for (let i = 1; i < 3; ++i) {
          if (value[i] && 60 % value[i] !== 0) {
            return false;
          }
        }
        return true;
      }
    },
    pointer: {
      type: Boolean,
      default: Fe
    },
    disabledTime: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["change", "toggle-col", "update:hour", "update:minute", "update:second"],
  setup(props, { emit }) {
    const currentHour = ref(props.hour);
    const currentMinute = ref(props.minute);
    const currentSecond = ref(props.second);
    const hourRange = ref([]);
    const minuteRange = ref([]);
    const secondRange = ref([]);
    const hourWheel = ref();
    const minuteWheel = ref();
    const secondWheel = ref();
    watch(() => props.steps, updateTimeRange, { immediate: true });
    watch(
      () => props.hour,
      (value) => {
        currentHour.value = value;
      }
    );
    watch(
      () => props.minute,
      (value) => {
        currentMinute.value = value;
      }
    );
    watch(
      () => props.second,
      (value) => {
        currentSecond.value = value;
      }
    );
    watch(currentHour, (value) => {
      emit("update:hour", value);
      emit("change", "hour", value);
    });
    watch(currentMinute, (value) => {
      emit("update:minute", value);
      emit("change", "minute", value);
    });
    watch(currentSecond, (value) => {
      emit("update:second", value);
      emit("change", "second", value);
    });
    function isHourDisabled(hour) {
      return typeof props.disabledTime.hour === "function" && props.disabledTime.hour(hour);
    }
    function isMinuteDisabled(minute) {
      return typeof props.disabledTime.minute === "function" && props.disabledTime.minute(currentHour.value, minute);
    }
    function isSecondDisabled(second) {
      return typeof props.disabledTime.second === "function" && props.disabledTime.second(currentHour.value, currentMinute.value, second);
    }
    function updateTimeRange() {
      const [hourStep = 1, minuteStep = 1, secondStep = 1] = props.steps;
      hourRange.value = un(24 / hourStep, 0, hourStep);
      minuteRange.value = un(60 / minuteStep, 0, minuteStep);
      secondRange.value = un(60 / secondStep, 0, secondStep);
    }
    function handleToggleColumn(type) {
      emit("toggle-col", type);
    }
    function refreshWheel() {
      [hourWheel.value, minuteWheel.value, secondWheel.value].forEach((wheel) => {
        wheel == null ? void 0 : wheel.refreshScroll();
      });
    }
    return {
      nh: useNameHelper("time-picker"),
      currentHour,
      currentMinute,
      currentSecond,
      hourRange,
      minuteRange,
      secondRange,
      hourWheel,
      minuteWheel,
      secondWheel,
      doubleDigits: m,
      isHourDisabled,
      isMinuteDisabled,
      isSecondDisabled,
      handleToggleColumn,
      refreshWheel
    };
  }
});
function _sfc_render45(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Wheel = resolveComponent("Wheel");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.nh.be("wheel"))
  }, [
    createVNode(_component_Wheel, {
      ref: "hourWheel",
      value: _ctx.currentHour,
      "onUpdate:value": _cache[0] || (_cache[0] = ($event) => _ctx.currentHour = $event),
      inherit: "",
      pointer: _ctx.pointer,
      arrow: !_ctx.noArrow,
      candidate: _ctx.candidate,
      options: _ctx.hourRange,
      tabindex: "-1",
      onMouseenter: _cache[1] || (_cache[1] = ($event) => _ctx.handleToggleColumn("hour")),
      onTouchstart: _cache[2] || (_cache[2] = ($event) => _ctx.handleToggleColumn("hour")),
      onKeydown: _cache[3] || (_cache[3] = withModifiers(() => {
      }, ["stop"]))
    }, {
      default: withCtx(({ option }) => [
        createBaseVNode("span", {
          class: normalizeClass([_ctx.nh.be("option"), _ctx.isHourDisabled(option.value) && _ctx.nh.bem("option", "disabled")])
        }, toDisplayString(_ctx.doubleDigits(option.value)), 3)
      ]),
      _: 1
    }, 8, ["value", "pointer", "arrow", "candidate", "options"]),
    createVNode(_component_Wheel, {
      ref: "minuteWheel",
      value: _ctx.currentMinute,
      "onUpdate:value": _cache[4] || (_cache[4] = ($event) => _ctx.currentMinute = $event),
      inherit: "",
      pointer: _ctx.pointer,
      arrow: !_ctx.noArrow,
      candidate: _ctx.candidate,
      options: _ctx.minuteRange,
      tabindex: "-1",
      onMouseenter: _cache[5] || (_cache[5] = ($event) => _ctx.handleToggleColumn("minute")),
      onTouchstart: _cache[6] || (_cache[6] = ($event) => _ctx.handleToggleColumn("minute")),
      onKeydown: _cache[7] || (_cache[7] = withModifiers(() => {
      }, ["stop"]))
    }, {
      default: withCtx(({ option }) => [
        createBaseVNode("span", {
          class: normalizeClass([_ctx.nh.be("option"), _ctx.isMinuteDisabled(option.value) && _ctx.nh.bem("option", "disabled")])
        }, toDisplayString(_ctx.doubleDigits(option.value)), 3)
      ]),
      _: 1
    }, 8, ["value", "pointer", "arrow", "candidate", "options"]),
    createVNode(_component_Wheel, {
      ref: "secondWheel",
      value: _ctx.currentSecond,
      "onUpdate:value": _cache[8] || (_cache[8] = ($event) => _ctx.currentSecond = $event),
      inherit: "",
      pointer: _ctx.pointer,
      arrow: !_ctx.noArrow,
      candidate: _ctx.candidate,
      options: _ctx.secondRange,
      tabindex: "-1",
      onMouseenter: _cache[9] || (_cache[9] = ($event) => _ctx.handleToggleColumn("second")),
      onTouchstart: _cache[10] || (_cache[10] = ($event) => _ctx.handleToggleColumn("second")),
      onKeydown: _cache[11] || (_cache[11] = withModifiers(() => {
      }, ["stop"]))
    }, {
      default: withCtx(({ option }) => [
        createBaseVNode("span", {
          class: normalizeClass([_ctx.nh.be("option"), _ctx.isSecondDisabled(option.value) && _ctx.nh.bem("option", "disabled")])
        }, toDisplayString(_ctx.doubleDigits(option.value)), 3)
      ]),
      _: 1
    }, 8, ["value", "pointer", "arrow", "candidate", "options"])
  ], 2);
}
var TimeWheel = _export_sfc(_sfc_main45, [["render", _sfc_render45]]);

// node_modules/vexip-ui/es/components/date-picker/date-panel.mjs
var _sfc_main46 = defineComponent({
  name: "DatePanel",
  components: {
    Button,
    CalendarPanel,
    Icon,
    TimeWheel,
    AngleRight: $3,
    AngleLeft: $2,
    AnglesRight: C,
    AnglesLeft: $5
  },
  props: {
    type: {
      default: "date",
      validator: (value) => {
        return datePickerTypes.includes(value);
      }
    },
    enabled: {
      type: Object,
      default: () => ({})
    },
    startValue: {
      type: Object,
      default: () => ({})
    },
    endValue: {
      type: Object,
      default: () => ({})
    },
    valueType: {
      type: String,
      default: "start"
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    column: {
      type: String,
      default: "date"
    },
    confirmText: {
      type: String,
      default: null
    },
    cancelText: {
      type: String,
      default: null
    },
    today: {
      type: [Number, String, Date],
      default: () => new Date()
    },
    disabledDate: {
      type: Function,
      default: () => false
    },
    noAction: {
      type: Boolean,
      default: false
    },
    steps: {
      type: Array,
      default: () => [1, 1, 1]
    },
    isRange: {
      type: Boolean,
      default: false
    },
    startActivated: {
      type: Object,
      default: () => ({})
    },
    endActivated: {
      type: Object,
      default: () => ({})
    },
    min: {
      type: [Number, String, Date],
      default: null
    },
    max: {
      type: [Number, String, Date],
      default: null
    },
    disabledTime: {
      type: Object,
      default: () => ({})
    },
    hasError: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click", "shortcut", "toggle-col", "change", "cancel", "confirm", "hover", "type-change"],
  setup(props, { emit }) {
    const today = l(props.today);
    const currentPane = ref("date");
    const calendarYear = ref(today.getFullYear());
    const calendarMonth = ref(today.getMonth() + 1);
    const hoveredYear = ref(0);
    const hoveredMonth = ref(0);
    const yearRange = ref([]);
    const calendar = ref();
    const { isHover } = Co(calendar);
    const locale = computed(() => {
      return { ...useLocale("calendar").value, ...useLocale("datePicker").value };
    });
    const startActivated = computed(() => {
      const activated2 = props.startActivated;
      return activated2.year && activated2.month && activated2.date;
    });
    const endActivated = computed(() => {
      const activated2 = props.endActivated;
      return activated2.year && activated2.month && activated2.date;
    });
    const isDatetime = computed(() => {
      return props.type === "datetime";
    });
    const dateValue = computed(() => {
      return props.valueType === "start" ? props.startValue : props.endValue;
    });
    const activated = computed(() => {
      return props.valueType === "start" ? props.startActivated : props.endActivated;
    });
    const calendarRange = computed(() => {
      return props.isRange && (props.valueType === "start" && endActivated.value || props.valueType === "end" && startActivated.value);
    });
    const calendarValue = computed(() => {
      return calendarRange.value ? [
        startActivated.value ? getStringValue("start") : "",
        endActivated.value ? getStringValue("end") : ""
      ] : props.valueType === "start" ? startActivated.value ? getStringValue(props.valueType) : "" : endActivated.value ? getStringValue(props.valueType) : "";
    });
    watch(
      () => props.column,
      (value) => {
        if (value === "year" || value === "month" || value === "date") {
          currentPane.value = value;
          refreshCalendar();
        }
      },
      { immediate: true }
    );
    watch(
      calendarYear,
      (value) => {
        yearRange.value = un(12, Math.floor(value / 10) * 10, 1);
      },
      { immediate: true }
    );
    watch(isHover, (value) => {
      if (value) {
        toggleColumn(currentPane.value);
      }
    });
    function getStringValue(type) {
      const value = type === "start" ? props.startValue : props.endValue;
      return `${value.year}-${value.month}-${value.date}`;
    }
    function getMonthLabel(index) {
      return locale.value[`month${index}`];
    }
    function togglePane(type) {
      currentPane.value = type;
      toggleColumn(type);
    }
    function adjustCalendar(type, amount) {
      if (type === "year") {
        calendarYear.value += amount;
      } else {
        calendarMonth.value += amount;
        const date = new Date(calendarYear.value, calendarMonth.value - 1, 1);
        calendarYear.value = date.getFullYear();
        calendarMonth.value = date.getMonth() + 1;
      }
    }
    function handleClick(event) {
      emit("click", event);
    }
    function handleShortcut(index) {
      let { value, name } = props.shortcuts[index];
      if (typeof value === "function") {
        value = value();
      }
      emit("shortcut", name, value);
    }
    function handleSelectDate(date) {
      emitChange("year", date.getFullYear());
      emitChange("month", date.getMonth() + 1);
      emitChange("date", date.getDate());
    }
    function handleSelectYear(year) {
      if (isDisabledYear(year))
        return;
      calendarYear.value = year;
      emitChange("year", year);
      if (props.type !== "year") {
        togglePane("month");
      }
    }
    function handleSelectMonth(month) {
      if (isDisabledMonth(month))
        return;
      calendarMonth.value = month;
      emitChange("year", calendarYear.value);
      emitChange("month", month);
      if (props.type !== "month") {
        togglePane("date");
      }
    }
    function toggleColumn(type) {
      emit("toggle-col", type);
    }
    function emitChange(type, value) {
      emit("change", type, value);
    }
    function handleDoublePrevClick() {
      if (currentPane.value === "year") {
        yearRange.value = un(12, yearRange.value[0] - 10, 1);
      } else {
        adjustCalendar("year", -1);
      }
    }
    function handleDoubleNextClick() {
      if (currentPane.value === "year") {
        yearRange.value = un(12, yearRange.value[10], 1);
      } else {
        adjustCalendar("year", 1);
      }
    }
    function handleCancel() {
      emit("cancel");
    }
    function handleConfirm() {
      emit("confirm");
    }
    function handleHoverDate(date) {
      emit("hover", date);
    }
    function isSelectedYear(year) {
      if (!year)
        return false;
      return props.startActivated.year && props.startValue.year === year || props.endActivated.year && props.endValue.year === year;
    }
    function isSelectedMonth(month) {
      if (!month)
        return false;
      const monthYear = 100 * calendarYear.value + month;
      return props.startActivated.month && 100 * props.startValue.year + props.startValue.month === monthYear || props.endActivated.month && 100 * props.endValue.year + props.endValue.month === monthYear;
    }
    function isDisabledYear(year) {
      if (props.isRange) {
        if (props.valueType === "end" && props.startActivated.year && year < props.startValue.year) {
          return true;
        }
        if (props.valueType === "start" && props.endActivated.year && props.endValue.year < year) {
          return true;
        }
      }
      if (props.type === "year") {
        return props.disabledDate(new Date(year, 0));
      }
      for (let i = 1; i <= 12; ++i) {
        if (!isDisabledMonth(i, year)) {
          return false;
        }
      }
      return true;
    }
    function isDisabledMonth(month, year = calendarYear.value) {
      if (props.type === "year")
        return false;
      if (props.isRange) {
        const monthYear = year * 100 + month;
        if (props.valueType === "end" && props.startActivated.month && monthYear < 100 * props.startValue.year + props.startValue.month) {
          return true;
        }
        if (props.valueType === "start" && props.endActivated.month && monthYear > 100 * props.endValue.year + props.endValue.month) {
          return true;
        }
      }
      if (props.type === "month") {
        return props.disabledDate(new Date(year, month - 1));
      }
      const current = new Date(year, month - 1);
      const end = new Date(year, month, 0);
      const dayCount = end.getDate();
      for (let i = 1; i <= dayCount; ++i) {
        current.setDate(i);
        if (!props.disabledDate(current)) {
          return false;
        }
      }
      return true;
    }
    function handleYearHover(year) {
      hoveredYear.value = isDisabledYear(year) ? 0 : year;
    }
    function handleMonthHover(month) {
      hoveredMonth.value = isDisabledMonth(month) ? 0 : month;
    }
    function isYearInRange(year) {
      if (!calendarRange.value || !hoveredYear.value && !props.startActivated.year && !props.endActivated.year) {
        return false;
      }
      if (props.valueType === "start" && !props.endActivated.year || props.valueType === "end" && !props.startActivated.year) {
        return false;
      }
      const startYear = props.startValue.year;
      const endYear = props.endValue.year;
      let min;
      let max;
      if (!hoveredYear.value && props.startActivated.year && props.endActivated.year) {
        min = Math.min(startYear, endYear);
        max = Math.max(startYear, endYear);
      } else if (hoveredYear.value) {
        if (!props.startActivated.year && !props.endActivated.year)
          return false;
        if (!props.startActivated.year || !props.endActivated.year) {
          const selectedYear = props.startActivated.year ? startYear : endYear;
          min = Math.min(hoveredYear.value, selectedYear);
          max = Math.max(hoveredYear.value, selectedYear);
        } else {
          const minYear = Math.min(startYear, endYear);
          const maxYear = Math.max(startYear, endYear);
          min = Math.min(hoveredYear.value, minYear);
          max = Math.max(hoveredYear.value, maxYear);
        }
      } else {
        return false;
      }
      return year >= min && year <= max;
    }
    function isMonthInRange(month) {
      if (!calendarRange.value || !hoveredMonth.value && !props.startActivated.month && !props.endActivated.month) {
        return false;
      }
      if (props.valueType === "start" && !props.endActivated.month || props.valueType === "end" && !props.startActivated.month) {
        return false;
      }
      const startMonthYear = 100 * props.startValue.year + props.startValue.month;
      const endMonthYear = 100 * props.endValue.year + props.endValue.month;
      let min;
      let max;
      if (!hoveredMonth.value && props.startActivated.month && props.endActivated.month) {
        min = Math.min(startMonthYear, endMonthYear);
        max = Math.max(startMonthYear, endMonthYear);
      } else if (hoveredMonth.value) {
        if (!props.startActivated.month && !props.endActivated.month)
          return false;
        const hoveredMonthYear = 100 * calendarYear.value + hoveredMonth.value;
        if (!props.startActivated.month || !props.endActivated.month) {
          const selectedMonthYear = props.startActivated.month ? startMonthYear : endMonthYear;
          min = Math.min(hoveredMonthYear, selectedMonthYear);
          max = Math.max(hoveredMonthYear, selectedMonthYear);
        } else {
          const minMonthYear = Math.min(startMonthYear, endMonthYear);
          const maxMonthYear = Math.max(startMonthYear, endMonthYear);
          min = Math.min(hoveredMonthYear, minMonthYear);
          max = Math.max(hoveredMonthYear, maxMonthYear);
        }
      } else {
        return false;
      }
      const monthYear = 100 * calendarYear.value + month;
      return monthYear >= min && monthYear <= max;
    }
    function refreshCalendar() {
      const today2 = l(props.today);
      if (props.valueType === "start") {
        calendarYear.value = props.startActivated.year ? props.startValue.year : today2.getFullYear();
        calendarMonth.value = props.startActivated.month ? props.startValue.month : today2.getMonth() + 1;
      } else {
        calendarYear.value = props.endActivated.year ? props.endValue.year : today2.getFullYear();
        calendarMonth.value = props.endActivated.month ? props.endValue.month : today2.getMonth() + 1;
      }
    }
    return {
      nh: useNameHelper("date-picker"),
      locale,
      currentPane,
      calendarYear,
      calendarMonth,
      yearRange,
      monthRange: un(12, 1, 1),
      hoveredYear,
      hoveredMonth,
      isDatetime,
      dateValue,
      activated,
      calendarValue,
      calendarRange,
      calendar,
      getMonthLabel,
      togglePane,
      adjustCalendar,
      handleClick,
      handleShortcut,
      handleSelectDate,
      handleSelectYear,
      handleSelectMonth,
      toggleColumn,
      emitChange,
      handleDoublePrevClick,
      handleDoubleNextClick,
      handleCancel,
      handleConfirm,
      handleHoverDate,
      isSelectedYear,
      isSelectedMonth,
      isDisabledYear,
      isDisabledMonth,
      handleYearHover,
      handleMonthHover,
      isYearInRange,
      isMonthInRange,
      refreshCalendar
    };
  }
});
var _hoisted_121 = ["title", "onClick"];
var _hoisted_210 = { style: { "display": "flex" } };
var _hoisted_33 = ["onClick", "onMouseenter"];
var _hoisted_42 = ["onClick", "onMouseenter"];
function _sfc_render46(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_AnglesLeft = resolveComponent("AnglesLeft");
  const _component_Icon = resolveComponent("Icon");
  const _component_AngleLeft = resolveComponent("AngleLeft");
  const _component_AngleRight = resolveComponent("AngleRight");
  const _component_AnglesRight = resolveComponent("AnglesRight");
  const _component_CalendarPanel = resolveComponent("CalendarPanel");
  const _component_TimeWheel = resolveComponent("TimeWheel");
  const _component_Button = resolveComponent("Button");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.nh.be("panel")),
    onClick: _cache[8] || (_cache[8] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    _ctx.shortcuts.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("list"), _ctx.nh.bem("list", "sub")])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcuts, (item, index) => {
        return openBlock(), createElementBlock("div", {
          key: index,
          class: normalizeClass(_ctx.nh.be("shortcut")),
          title: item.name,
          onClick: ($event) => _ctx.handleShortcut(index)
        }, toDisplayString(item.name), 11, _hoisted_121);
      }), 128))
    ], 2)) : createCommentVNode("", true),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      createBaseVNode("div", _hoisted_210, [
        createBaseVNode("div", null, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("header"))
          }, [
            createBaseVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("prev-year")]),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleDoublePrevClick && _ctx.handleDoublePrevClick(...args))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AnglesLeft)
                ]),
                _: 1
              })
            ], 2),
            withDirectives(createBaseVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("prev-month")]),
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.adjustCalendar("month", -1))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AngleLeft)
                ]),
                _: 1
              })
            ], 2), [
              [vShow, _ctx.currentPane === "date"]
            ]),
            createBaseVNode("div", {
              key: "year",
              class: normalizeClass(_ctx.nh.be("year")),
              onClick: _cache[2] || (_cache[2] = withModifiers(($event) => _ctx.togglePane("year"), ["stop"]))
            }, [
              _ctx.currentPane === "year" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString(`${_ctx.yearRange[0]}${_ctx.locale.year} - ${_ctx.yearRange[9]}${_ctx.locale.year}`), 1)
              ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(`${_ctx.calendarYear}${_ctx.locale.year}`), 1)
              ], 64))
            ], 2),
            withDirectives(createBaseVNode("div", {
              class: normalizeClass(_ctx.nh.be("month")),
              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.togglePane("month"), ["stop"]))
            }, toDisplayString(_ctx.getMonthLabel(_ctx.calendarMonth)), 3), [
              [vShow, _ctx.currentPane === "date"]
            ]),
            withDirectives(createBaseVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("next-month")]),
              onClick: _cache[4] || (_cache[4] = ($event) => _ctx.adjustCalendar("month", 1))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AngleRight)
                ]),
                _: 1
              })
            ], 2), [
              [vShow, _ctx.currentPane === "date"]
            ]),
            createBaseVNode("div", {
              class: normalizeClass([_ctx.nh.be("arrow"), _ctx.nh.be("next-year")]),
              onClick: _cache[5] || (_cache[5] = (...args) => _ctx.handleDoubleNextClick && _ctx.handleDoubleNextClick(...args))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_AnglesRight)
                ]),
                _: 1
              })
            ], 2)
          ], 2),
          createBaseVNode("div", {
            ref: "calendar",
            class: normalizeClass(_ctx.nh.be("calendar"))
          }, [
            _ctx.currentPane === "year" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("year-pane")),
              onMouseleave: _cache[6] || (_cache[6] = ($event) => _ctx.hoveredYear = 0)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.yearRange, (item, index) => {
                return openBlock(), createElementBlock("div", {
                  key: index,
                  class: normalizeClass({
                    [_ctx.nh.be("year-item")]: true,
                    [_ctx.nh.bem("year-item", "selected")]: _ctx.isSelectedYear(item),
                    [_ctx.nh.bem("year-item", "next")]: index > 9,
                    [_ctx.nh.bem("year-item", "disabled")]: _ctx.isDisabledYear(item),
                    [_ctx.nh.bem("year-item", "in-range")]: _ctx.isYearInRange(item)
                  }),
                  onClick: withModifiers(($event) => _ctx.handleSelectYear(item), ["stop"]),
                  onMouseenter: ($event) => _ctx.handleYearHover(item)
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(_ctx.nh.be("year-label"))
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.nh.be("year-label-inner"))
                    }, toDisplayString(item), 3)
                  ], 2)
                ], 42, _hoisted_33);
              }), 128))
            ], 34)) : _ctx.currentPane === "month" ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(_ctx.nh.be("month-pane")),
              onMouseleave: _cache[7] || (_cache[7] = ($event) => _ctx.hoveredMonth = 0)
            }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.monthRange, (index) => {
                return openBlock(), createElementBlock("div", {
                  key: index,
                  class: normalizeClass({
                    [_ctx.nh.be("month-item")]: true,
                    [_ctx.nh.bem("month-item", "selected")]: _ctx.isSelectedMonth(index),
                    [_ctx.nh.bem("month-item", "disabled")]: _ctx.isDisabledMonth(index),
                    [_ctx.nh.bem("month-item", "in-range")]: _ctx.isMonthInRange(index)
                  }),
                  onClick: withModifiers(($event) => _ctx.handleSelectMonth(index), ["stop"]),
                  onMouseenter: ($event) => _ctx.handleMonthHover(index)
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(_ctx.nh.be("month-label"))
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(_ctx.nh.be("month-label-inner"))
                    }, toDisplayString(_ctx.getMonthLabel(index)), 3)
                  ], 2)
                ], 42, _hoisted_42);
              }), 128))
            ], 34)) : (openBlock(), createBlock(_component_CalendarPanel, {
              key: 2,
              inherit: "",
              value: _ctx.calendarValue,
              year: _ctx.calendarYear,
              month: _ctx.calendarMonth,
              "disabled-date": _ctx.disabledDate,
              "is-range": _ctx.calendarRange,
              "value-type": _ctx.valueType,
              min: _ctx.min,
              max: _ctx.max,
              onSelect: _ctx.handleSelectDate,
              onHover: _ctx.handleHoverDate
            }, null, 8, ["value", "year", "month", "disabled-date", "is-range", "value-type", "min", "max", "onSelect", "onHover"]))
          ], 2)
        ]),
        _ctx.isDatetime ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("time-wheel"))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("header"))
          }, null, 2),
          createVNode(_component_TimeWheel, {
            hour: _ctx.dateValue.hour,
            minute: _ctx.dateValue.minute,
            second: _ctx.dateValue.second,
            candidate: 3,
            steps: _ctx.steps,
            "disabled-time": _ctx.disabledTime,
            onToggleCol: _ctx.toggleColumn,
            onChange: _ctx.emitChange
          }, null, 8, ["hour", "minute", "second", "steps", "disabled-time", "onToggleCol", "onChange"])
        ], 2)) : createCommentVNode("", true)
      ]),
      !_ctx.noAction ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("action"))
      }, [
        createVNode(_component_Button, {
          inherit: "",
          text: "",
          size: "small",
          onClick: _ctx.handleCancel
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.cancelText || _ctx.locale.cancel), 1)
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_Button, {
          inherit: "",
          type: "primary",
          size: "small",
          disabled: _ctx.hasError,
          onClick: _ctx.handleConfirm
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(_ctx.confirmText || _ctx.locale.confirm), 1)
          ]),
          _: 1
        }, 8, ["disabled", "onClick"])
      ], 2)) : createCommentVNode("", true)
    ], 2)
  ], 2);
}
var DatePanel = _export_sfc(_sfc_main46, [["render", _sfc_render46]]);

// node_modules/vexip-ui/es/components/date-picker/props.mjs
var datePickerProps = buildProps({
  size: sizeProp,
  state: stateProp,
  type: String,
  visible: booleanProp,
  placement: String,
  transfer: booleanStringProp,
  value: [Number, String, Date, Array],
  format: String,
  filler: String,
  noFiller: booleanProp,
  clearable: booleanProp,
  noAction: booleanProp,
  labels: Object,
  dateSeparator: String,
  timeSeparator: String,
  shortcuts: Array,
  disabledDate: Function,
  steps: Array,
  ctrlSteps: Array,
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  noSuffix: booleanProp,
  disabled: booleanProp,
  transitionName: String,
  confirmText: String,
  cancelText: String,
  today: [Number, String, Date],
  isRange: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  min: [Number, String, Date],
  max: [Number, String, Date],
  onInput: eventProp(),
  onPlus: eventProp(),
  onMinus: eventProp(),
  onEnter: eventProp(),
  onCancel: eventProp(),
  onChange: eventProp(),
  onClear: eventProp(),
  onShortcut: eventProp(),
  onToggle: eventProp(),
  onFocus: eventProp(),
  onBlur: eventProp(),
  onChangeCol: eventProp(),
  onClickOutside: eventProp()
});
var timePickerProps = buildProps({
  size: sizeProp,
  state: stateProp,
  visible: booleanProp,
  placement: String,
  transfer: booleanStringProp,
  format: String,
  separator: String,
  value: [String, Array],
  filler: String,
  noFiller: booleanProp,
  clearable: booleanProp,
  noAction: booleanProp,
  noArrow: booleanProp,
  pointer: booleanProp,
  candidate: Number,
  steps: Array,
  labels: Object,
  shortcuts: Array,
  isRange: booleanProp,
  disabled: booleanProp,
  transitionName: String,
  confirmText: String,
  cancelText: String,
  ctrlSteps: Array,
  prefix: Object,
  prefixColor: String,
  suffix: Object,
  suffixColor: String,
  noSuffix: booleanProp,
  exchange: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  min: String,
  max: String,
  onInput: eventProp(),
  onPlus: eventProp(),
  onMinus: eventProp(),
  onEnter: eventProp(),
  onCancel: eventProp(),
  onChange: eventProp(),
  onClear: eventProp(),
  onShortcut: eventProp(),
  onToggle: eventProp(),
  onFocus: eventProp(),
  onBlur: eventProp(),
  onChangeCol: eventProp(),
  onClickOutside: eventProp()
});

// node_modules/vexip-ui/es/components/date-picker/date-picker.mjs
var invalidDate = new Date("");
var _sfc_main47 = defineComponent({
  name: "DatePicker",
  components: {
    DateControl,
    DatePanel,
    Icon,
    Portal,
    CircleXmark: u,
    ArrowRightArrowLeft: $8
  },
  props: datePickerProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("date-picker");
    const props = useProps("datePicker", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      type: {
        default: "date",
        validator: (value) => datePickerTypes.includes(value)
      },
      visible: false,
      placement: {
        default: "bottom-start",
        validator: (value) => Wo.includes(value)
      },
      transfer: false,
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      format: "yyyy-MM-dd HH:mm:ss",
      filler: {
        default: "-",
        validator: (value) => value.length === 1
      },
      noFiller: false,
      clearable: false,
      noAction: false,
      labels: () => ({}),
      dateSeparator: "/",
      timeSeparator: ":",
      shortcuts: () => [],
      disabledDate: {
        default: fn,
        isFunc: true
      },
      steps: () => [1, 1, 1],
      ctrlSteps: () => [5, 5, 5],
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      confirmText: null,
      cancelText: null,
      today: {
        default: () => new Date(),
        validator: (value) => !Number.isNaN(new Date(value))
      },
      isRange: false,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      min: null,
      max: null
    });
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const currentVisible = ref(props.visible);
    const focused = ref(false);
    const startState = createDateState();
    const endState = createDateState();
    const currentState = ref("start");
    const lastValue = ref("");
    const { timer: timer2 } = $o();
    const wrapper = Do(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = qo({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = Co(reference);
    const startInput = ref();
    const endInput = ref();
    const datePanel = ref();
    const className = computed(() => {
      return [
        nh.b(),
        nh.ns("input-vars"),
        nh.bs("vars"),
        nh.bm(props.type),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("no-hour")]: !startState.enabled.hour,
          [nh.bm("no-minute")]: !startState.enabled.minute,
          [nh.bm("no-second")]: !startState.enabled.second,
          [nh.bm("visible")]: currentVisible.value,
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm("is-range")]: props.isRange
        }
      ];
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--focused`]: focused.value,
        [`${baseCls}--${props.state}`]: props.state !== "default"
      };
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const currentValue = computed(() => {
      const values = [startState, endState].map((state2) => {
        const values2 = Object.values(state2.dateValue).map(m);
        return `${values2.slice(0, 3).join("-")} ${values2.slice(3).join(":")}`;
      });
      return props.isRange ? values : values[0];
    });
    const startActivated = computed(() => {
      const activated = startState.activated;
      return activated.year && activated.month && activated.date;
    });
    const endActivated = computed(() => {
      const activated = endState.activated;
      return activated.year && activated.month && activated.date;
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && !!lastValue.value;
    });
    const min = computed(() => {
      if (props.min) {
        const date = rawValueToDate(props.min, invalidDate);
        if (Number.isNaN(+date))
          return -Infinity;
        date.setHours(0, 0, 0, 0);
        return date;
      }
      return -Infinity;
    });
    const max = computed(() => {
      if (props.max) {
        let date = rawValueToDate(props.max, invalidDate);
        if (Number.isNaN(+date))
          return Infinity;
        if (props.type !== "datetime") {
          date.setHours(23, 59, 59, 999);
          if (props.type === "year") {
            date.setMonth(11);
            date.setDate(31);
          } else if (props.type === "month") {
            date.setMonth(date.getMonth() + 1);
            date = Gn(date);
            date.setDate(date.getDate() - 1);
          }
        }
        return +date;
      }
      return Infinity;
    });
    const reversed = computed(() => {
      if (Number.isNaN(min.value) || Number.isNaN(max.value)) {
        return false;
      }
      return min.value > max.value;
    });
    const startMinTime = computed(() => {
      if (props.type === "datetime" && props.min && !me(props.min, startState.getDate())) {
        return On(props.min);
      }
      return "";
    });
    const startMaxTime = computed(() => {
      if (props.type === "datetime" && props.max && !me(props.max, startState.getDate())) {
        return On(props.max);
      }
      return "";
    });
    const endMinTime = computed(() => {
      if (props.type === "datetime" && props.isRange && props.min && !me(props.min, startState.getDate())) {
        return On(props.min);
      }
      return "";
    });
    const endMaxTime = computed(() => {
      if (props.type === "datetime" && props.isRange && props.max && !me(props.max, startState.getDate())) {
        return On(props.max);
      }
      return "";
    });
    const startReversed = computed(() => {
      if (!props.isRange)
        return false;
      const startValue = startState.dateValue;
      const endValue = endState.dateValue;
      let types;
      if (props.type === "year") {
        types = ["year"];
      } else if (props.type === "month") {
        types = ["year", "month"];
      } else if (props.type === "date") {
        types = ["year", "month", "date"];
      } else {
        types = ["year", "month", "date", "hour", "minute", "second"];
      }
      for (const type of types) {
        if (startValue[type] < endValue[type])
          return false;
        if (startValue[type] > endValue[type])
          return true;
      }
      return false;
    });
    const startTimeBound = useTimeBound(startMinTime, startMaxTime);
    const endTimeBound = useTimeBound(endMinTime, endMaxTime);
    const isTimeDisabled = computed(() => {
      return currentState.value === "start" ? startTimeBound.isTimeDisabled : endTimeBound.isTimeDisabled;
    });
    const startError = computed(() => {
      const { hour, minute, second } = startState.dateValue;
      const { isTimeDisabled: isTimeDisabled2 } = startTimeBound;
      return startReversed.value || isDateDisabled(startState.getDate()) || isTimeDisabled2.hour(hour) || isTimeDisabled2.minute(hour, minute) || isTimeDisabled2.second(hour, minute, second);
    });
    const endError = computed(() => {
      if (!props.isRange)
        return false;
      const { hour, minute, second } = endState.dateValue;
      const { isTimeDisabled: isTimeDisabled2 } = endTimeBound;
      return startReversed.value || isDateDisabled(endState.getDate()) || isTimeDisabled2.hour(hour) || isTimeDisabled2.minute(hour, minute) || isTimeDisabled2.second(hour, minute, second);
    });
    startState.enabled.year = true;
    endState.enabled.year = true;
    nextTick(() => {
      startState.resetColumn("date");
      endState.resetColumn("date");
    });
    watch(() => props.type, parseFormat);
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
      },
      { immediate: true }
    );
    watch(
      () => props.type,
      (value) => {
        const hasMonth = value !== "year";
        const hasDate = hasMonth && value !== "month";
        startState.enabled.month = hasMonth;
        endState.enabled.month = hasMonth;
        startState.enabled.date = hasDate;
        endState.enabled.date = hasDate;
      },
      { immediate: true }
    );
    watch(() => props.format, parseFormat, { immediate: true });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        updatePopper();
      } else {
        emitChange();
      }
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(focused, (value) => {
      if (value) {
        emitEvent(props.onFocus);
      } else {
        emitEvent(props.onBlur);
      }
    });
    watch(currentState, (value) => {
      if (currentVisible.value) {
        emitEvent(props.onChangeCol, getCurrentState().column, value);
      }
    });
    watch(
      () => startState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "start") {
          emitEvent(props.onChangeCol, value, "start");
        }
      }
    );
    watch(
      () => endState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "end") {
          emitEvent(props.onChangeCol, value, "end");
        }
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
          handleBlur();
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    function createDateState() {
      const noFiller = props.noFiller;
      const { currentColumn, enabled, resetColumn, enterColumn: enterColumn2 } = useColumn([
        "year",
        "month",
        "date",
        "hour",
        "minute",
        "second"
      ]);
      const dateValue = reactive({
        year: 1970,
        month: 1,
        date: 1,
        hour: 0,
        minute: 0,
        second: 0
      });
      const activated = reactive({
        year: noFiller,
        month: noFiller,
        date: noFiller,
        hour: noFiller,
        minute: noFiller,
        second: noFiller
      });
      return reactive({
        column: currentColumn,
        enabled,
        activated,
        dateValue,
        resetColumn,
        enterColumn: enterColumn2,
        setDate: (date) => {
          dateValue.year = date.getFullYear();
          dateValue.month = date.getMonth() + 1;
          dateValue.date = date.getDate();
          dateValue.hour = date.getHours();
          dateValue.minute = date.getMinutes();
          dateValue.second = date.getSeconds();
        },
        getDate: () => {
          return new Date(
            dateValue.year,
            dateValue.month - 1,
            dateValue.date,
            dateValue.hour,
            dateValue.minute,
            dateValue.second
          );
        }
      });
    }
    function getCurrentState() {
      return currentState.value === "start" ? startState : endState;
    }
    function rawValueToDate(value, defaultValue = new Date(props.today)) {
      let date;
      if (typeof value === "number") {
        if (props.type === "year") {
          if (value < 3e3) {
            date = new Date(value, 1);
          } else {
            date = l(value);
          }
        } else if (props.type === "month") {
          if (value < 3e5) {
            const year = Math.floor(value / 100);
            const month = value - year * 100;
            date = new Date(year, month - 1);
          } else {
            date = l(value);
          }
        } else {
          date = l(value);
        }
      } else {
        date = l(value);
      }
      if (Number.isNaN(date.getTime())) {
        date = defaultValue;
      }
      return date;
    }
    function parseValue(value) {
      var _a;
      if (!Array.isArray(value)) {
        value = [value, value];
      }
      for (let i = 0; i < 2; ++i) {
        const date = rawValueToDate((_a = value[i]) != null ? _a : "");
        const state2 = i === 0 ? startState : endState;
        state2.setDate(date);
        if (!props.isRange)
          break;
      }
    }
    function parseFormat() {
      const isDatetime = props.type === "datetime";
      [startState, endState].forEach((state2) => {
        state2.enabled.hour = false;
        state2.enabled.minute = false;
        state2.enabled.second = false;
        if (isDatetime && props.format.length) {
          const length = props.format.length;
          let inQuotation = false;
          for (let i = 0; i < length; ++i) {
            const char = props.format.charAt(i);
            if (char === "'") {
              inQuotation = !inQuotation;
            } else if (!inQuotation) {
              switch (char) {
                case "H":
                  state2.enabled.hour = true;
                  break;
                case "m":
                  state2.enabled.minute = true;
                  break;
                case "s":
                  state2.enabled.second = true;
                  break;
              }
            }
          }
        }
      });
    }
    function toggleActivated(value, type) {
      const states = type ? type === "start" ? [startState] : [endState] : [startState, endState];
      states.forEach((state2) => {
        Object.keys(state2.activated).forEach((type2) => {
          state2.activated[type2] = value;
        });
      });
    }
    function getStringValue() {
      return Array.isArray(currentValue.value) ? currentValue.value.join("|") : currentValue.value;
    }
    function isDateDisabled(date) {
      if (typeof props.disabledDate === "function") {
        if (props.disabledDate(date)) {
          return true;
        }
      }
      const time = date.getTime();
      if (reversed.value) {
        if (time > max.value && time < min.value) {
          return true;
        }
      } else {
        if (time < min.value || time > max.value) {
          return true;
        }
      }
      return false;
    }
    function verifyDate() {
      if (startError.value || props.isRange && endError.value) {
        if (lastValue.value) {
          parseValue(lastValue.value.split("|"));
        } else {
          parseValue(props.value);
        }
      }
    }
    function emitChange() {
      verifyDate();
      if (lastValue.value !== getStringValue()) {
        lastValue.value = getStringValue();
        const values = Array.isArray(currentValue.value) ? currentValue.value : [currentValue.value];
        const emitValues = [];
        for (let i = 0; i < 2; ++i) {
          if (props.type === "year") {
            emitValues[i] = i === 0 ? startState.dateValue.year : endState.dateValue.year;
          } else if (props.type !== "datetime") {
            emitValues[i] = values[i].split(" ")[0];
          } else {
            emitValues[i] = values[i];
          }
          if (!props.isRange)
            break;
        }
        const emitValue = props.isRange ? emitValues : emitValues[0];
        toggleActivated(true);
        setFieldValue(emitValue);
        emitEvent(props.onChange, emitValue);
        emit("update:value", emitValue);
        validateField();
      }
    }
    function finishInput() {
      currentVisible.value = false;
      startState.resetColumn("date");
      endState.resetColumn("date");
    }
    function verifyValue(type) {
      const dateValue = getCurrentState().dateValue;
      switch (type) {
        case "year": {
          dateValue.year = Fn(dateValue.year, 1970, 9999);
          break;
        }
        case "month": {
          dateValue.month = Fn(dateValue.month, 1, 12);
          break;
        }
        case "date": {
          const month = dateValue.month;
          let lastDay;
          if (month < 7) {
            if (month !== 2) {
              lastDay = 30 + month % 2;
            } else {
              if (Pn(dateValue.year)) {
                lastDay = 29;
              } else {
                lastDay = 28;
              }
            }
          } else {
            lastDay = 31 - month % 2;
          }
          dateValue.date = Fn(dateValue.date, 1, lastDay);
          break;
        }
        case "hour":
        case "minute":
        case "second": {
          dateValue[type] = Fn(dateValue[type], 0, type === "hour" ? 23 : 59);
          dateValue[type] = Math.round(dateValue[type] / getStep(type)) * getStep(type);
        }
      }
    }
    function handleFocused() {
      if (props.disabled)
        return;
      focused.value = true;
      timer2.focus = setTimeout(() => {
        var _a, _b;
        if (focused.value) {
          if (currentState.value === "start") {
            (_a = startInput.value) == null ? void 0 : _a.focus();
          } else {
            (_b = endInput.value) == null ? void 0 : _b.focus();
          }
        }
      }, 120);
    }
    function handleBlur() {
      var _a, _b;
      clearTimeout(timer2.focus);
      focused.value = false;
      (_a = startInput.value) == null ? void 0 : _a.blur();
      (_b = endInput.value) == null ? void 0 : _b.blur();
    }
    function showPanel(event) {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      const target = event.target;
      const lastVisible = currentVisible.value;
      currentVisible.value = true;
      handleFocused();
      if (!lastVisible && wrapper.value && target) {
        const units = Array.from(wrapper.value.querySelectorAll(`.${nh.be("unit")}`));
        if (!units.some((unit) => unit === target || unit.contains(target))) {
          emitEvent(props.onChangeCol, getCurrentState().column, currentState.value);
        }
      }
    }
    function handleInput(value) {
      const state2 = getCurrentState();
      handleInputNumber(state2.column, value);
      if (state2.column === "year" ? state2.dateValue.year >= 1e3 : state2.dateValue[state2.column] >= 10) {
        state2.enterColumn("next", false);
      }
    }
    function handleInputNumber(type, number) {
      const state2 = getCurrentState();
      const prev = state2.dateValue[type];
      if ((props.noFiller || state2.activated[type]) && prev > 0 && prev < (type === "year" ? 1e3 : 10)) {
        state2.dateValue[type] = prev * 10 + number;
      } else {
        state2.dateValue[type] = number;
        setActivated(type);
      }
      type !== "year" && verifyValue(type);
      emitEvent(props.onInput, type, state2.dateValue[type]);
    }
    function setActivated(type) {
      const activated = getCurrentState().activated;
      if (type === "date") {
        activated.year = true;
        activated.month = true;
      } else if (type === "month") {
        activated.year = true;
      } else if (type === "minute") {
        activated.hour = true;
      } else if (type === "second") {
        activated.hour = true;
        activated.minute = true;
      }
      activated[type] = true;
    }
    function handleInputFocus(type) {
      getCurrentState().column = type;
    }
    function isTimeType(type) {
      return ["hour", "minute", "second"].includes(type);
    }
    function handleAdjust(adjustType, ctrlKey) {
      var _a;
      const isPlus = adjustType === "plus";
      const sign = isPlus ? 1 : -1;
      const state2 = getCurrentState();
      const type = state2.column;
      if (state2.enabled[type]) {
        if (isTimeType(type)) {
          state2.dateValue[type] += sign * (ctrlKey ? getCtrlStep(type) : getStep(type));
        } else {
          if (ctrlKey) {
            if (type === "year") {
              state2.dateValue.year += sign * 10;
            } else {
              state2.dateValue[type === "date" ? "month" : "year"] += sign;
            }
          } else {
            state2.dateValue[type] += sign;
          }
          computeDate();
          updateDateActivated(type);
        }
        verifyValue(type);
        emitEvent(props[isPlus ? "onPlus" : "onMinus"], type, state2.dateValue[type]);
        (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
      }
    }
    function handlePlus(ctrlKey) {
      handleAdjust("plus", ctrlKey);
    }
    function handleMinus(ctrlKey) {
      handleAdjust("minus", ctrlKey);
    }
    function computeDate() {
      const dateValue = getCurrentState().dateValue;
      const date = new Date(dateValue.year, dateValue.month - 1, dateValue.date);
      dateValue.year = date.getFullYear();
      dateValue.month = date.getMonth() + 1;
      dateValue.date = date.getDate();
    }
    function handleEnter() {
      finishInput();
      emitEvent(props.onEnter);
    }
    function handleCancel() {
      parseValue(props.value);
      finishInput();
      emitEvent(props.onCancel);
    }
    function resetValue() {
      [startState, endState].forEach((state2) => {
        state2.dateValue.year = 1970;
        state2.dateValue.month = 1;
        state2.dateValue.date = 1;
        state2.dateValue.hour = 0;
        state2.dateValue.minute = 0;
        state2.dateValue.second = 0;
      });
      lastValue.value = "";
    }
    function handleClear() {
      if (props.clearable) {
        finishInput();
        nextTick(() => {
          const emitValue = props.isRange ? [] : null;
          resetValue();
          emitEvent(props.onChange, emitValue);
          emit("update:value", emitValue);
          emitEvent(props.onClear);
          clearField(emitValue);
          nextTick(() => {
            toggleActivated(false);
          });
        });
      }
    }
    function handleShortcut(name, value) {
      parseValue(value);
      emitEvent(props.onShortcut, name, value);
      finishInput();
    }
    function getStep(type) {
      return props.steps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function getCtrlStep(type) {
      return props.ctrlSteps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function handlePanelChange(type, value) {
      getCurrentState().dateValue[type] = value;
      updateDateActivated(type);
      verifyRangeValue();
    }
    function updateDateActivated(type) {
      const state2 = getCurrentState();
      if (type === "month") {
        state2.activated.year = true;
      } else if (type === "date") {
        state2.activated.year = true;
        state2.activated.month = true;
      }
      state2.activated[type] = true;
    }
    function verifyRangeValue() {
      if (!props.isRange)
        return;
      const startDate = startState.getDate();
      const endDate = endState.getDate();
      if (startDate.getTime() > endDate.getTime()) {
        if (currentState.value === "start") {
          startState.setDate(endDate);
        } else {
          endState.setDate(startDate);
        }
      }
    }
    function toggleCurrentState(type) {
      currentState.value = type;
    }
    function enterColumn(type) {
      if (props.isRange) {
        const state2 = getCurrentState();
        const currentColumn = state2.column;
        state2.enterColumn(type, false);
        if (currentColumn === state2.column) {
          const isStart = currentState.value === "start";
          const otherState = isStart ? endState : startState;
          otherState.resetColumn(type === "prev" ? "second" : "year", type === "prev");
          toggleCurrentState(isStart ? "end" : "start");
        }
      } else {
        startState.enterColumn(type);
      }
    }
    function handleStartInput(type) {
      toggleCurrentState("start");
      handleInputFocus(type);
      nextTick(() => {
        var _a;
        (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
      });
    }
    function handleEndInput(type) {
      toggleCurrentState("end");
      handleInputFocus(type);
      nextTick(() => {
        var _a;
        (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
      });
    }
    function handlePaneConfirm() {
      if (!props.isRange) {
        handleEnter();
      } else {
        if (currentState.value === "start" && !endActivated.value) {
          toggleActivated(true, "start");
          currentState.value = "end";
        } else if (currentState.value === "end" && !startActivated.value) {
          toggleActivated(true, "end");
          currentState.value = "start";
        } else {
          handleEnter();
        }
      }
    }
    function handlePaneHide() {
      var _a;
      (_a = datePanel.value) == null ? void 0 : _a.refreshCalendar();
    }
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      finishInput();
      handleBlur();
    }
    return {
      CalendarR: h5,
      startMinTime,
      startMaxTime,
      props,
      nh,
      idFor,
      currentVisible,
      focused,
      transferTo,
      isHover,
      startState,
      endState,
      lastValue,
      currentState,
      className,
      selectorClass,
      hasPrefix,
      startActivated,
      endActivated,
      showClear,
      startError,
      endError,
      wrapper,
      reference,
      popper,
      start: startInput,
      end: endInput,
      panel: datePanel,
      isTimeDisabled,
      isDateDisabled,
      handleFocused,
      showPanel,
      handleInput,
      handleInputFocus,
      handlePlus,
      handleMinus,
      handleEnter,
      handleCancel,
      handleClear,
      handleShortcut,
      handlePanelChange,
      finishInput,
      toggleCurrentState,
      enterColumn,
      handleStartInput,
      handleEndInput,
      handlePaneConfirm,
      handlePaneHide,
      focus: handleFocused,
      blur: handleBlur,
      updatePopper
    };
  }
});
var _hoisted_122 = ["id"];
function _sfc_render47(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_DateControl = resolveComponent("DateControl");
  const _component_ArrowRightArrowLeft = resolveComponent("ArrowRightArrowLeft");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_DatePanel = resolveComponent("DatePanel");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[7] || (_cache[7] = (...args) => _ctx.showPanel && _ctx.showPanel(...args))
  }, [
    createBaseVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onKeydown: _cache[5] || (_cache[5] = withKeys(withModifiers((...args) => _ctx.showPanel && _ctx.showPanel(...args), ["prevent"]), ["space"]))
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        createVNode(_component_DateControl, {
          ref: "start",
          "unit-type": _ctx.currentState === "start" ? _ctx.startState.column : "",
          enabled: _ctx.startState.enabled,
          activated: _ctx.startState.activated,
          "date-value": _ctx.startState.dateValue,
          steps: _ctx.props.steps,
          "ctrl-steps": _ctx.props.ctrlSteps,
          focused: _ctx.focused,
          visible: _ctx.currentVisible,
          "date-separator": _ctx.props.dateSeparator,
          "time-separator": _ctx.props.timeSeparator,
          filler: _ctx.props.filler,
          "no-filler": _ctx.props.noFiller,
          labels: _ctx.props.labels,
          "has-error": _ctx.startError,
          onInput: _ctx.handleInput,
          onPlus: _ctx.handlePlus,
          onMinus: _ctx.handleMinus,
          onEnter: _ctx.handlePaneConfirm,
          onCancel: _ctx.handleCancel,
          onUnitFocus: _ctx.handleStartInput,
          onPrevUnit: _cache[0] || (_cache[0] = ($event) => _ctx.enterColumn("prev")),
          onNextUnit: _cache[1] || (_cache[1] = ($event) => _ctx.enterColumn("next"))
        }, null, 8, ["unit-type", "enabled", "activated", "date-value", "steps", "ctrl-steps", "focused", "visible", "date-separator", "time-separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"]),
        _ctx.props.isRange ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("exchange"))
          }, [
            renderSlot(_ctx.$slots, "exchange", {}, () => [
              createVNode(_component_Icon, { style: { "padding-top": "1px" } }, {
                default: withCtx(() => [
                  createVNode(_component_ArrowRightArrowLeft)
                ]),
                _: 1
              })
            ])
          ], 2),
          createVNode(_component_DateControl, {
            ref: "end",
            "unit-type": _ctx.currentState === "end" ? _ctx.endState.column : "",
            enabled: _ctx.endState.enabled,
            activated: _ctx.endState.activated,
            "date-value": _ctx.endState.dateValue,
            steps: _ctx.props.steps,
            "ctrl-steps": _ctx.props.ctrlSteps,
            focused: _ctx.focused,
            visible: _ctx.currentVisible,
            "date-separator": _ctx.props.dateSeparator,
            "time-separator": _ctx.props.timeSeparator,
            filler: _ctx.props.filler,
            "no-filler": _ctx.props.noFiller,
            labels: _ctx.props.labels,
            "has-error": _ctx.endError,
            onInput: _ctx.handleInput,
            onPlus: _ctx.handlePlus,
            onMinus: _ctx.handleMinus,
            onEnter: _ctx.handlePaneConfirm,
            onCancel: _ctx.handleCancel,
            onUnitFocus: _ctx.handleEndInput,
            onPrevUnit: _cache[2] || (_cache[2] = ($event) => _ctx.enterColumn("prev")),
            onNextUnit: _cache[3] || (_cache[3] = ($event) => _ctx.enterColumn("next"))
          }, null, 8, ["unit-type", "enabled", "activated", "date-value", "steps", "ctrl-steps", "focused", "visible", "date-separator", "time-separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"])
        ], 64)) : createCommentVNode("", true)
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.suffix || _ctx.CalendarR
          }, null, 8, ["icon"])
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.showClear ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onAfterLeave: _ctx.handlePaneHide
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.ns("calendar-vars"),
                _ctx.nh.ns("time-picker-vars"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[6] || (_cache[6] = withModifiers((...args) => _ctx.handleFocused && _ctx.handleFocused(...args), ["stop"]))
            }, [
              createVNode(_component_DatePanel, {
                ref: "panel",
                type: _ctx.props.type,
                column: (_ctx.currentState === "start" ? _ctx.startState : _ctx.endState).column,
                "start-value": _ctx.startState.dateValue,
                "end-value": _ctx.endState.dateValue,
                "start-activated": _ctx.startState.activated,
                "end-activated": _ctx.endState.activated,
                "value-type": _ctx.currentState,
                shortcuts: _ctx.props.shortcuts,
                "confirm-text": _ctx.props.confirmText,
                "cancel-text": _ctx.props.cancelText,
                today: _ctx.props.today,
                "no-action": _ctx.props.noAction,
                steps: _ctx.props.steps,
                "is-range": _ctx.props.isRange,
                min: _ctx.props.min,
                max: _ctx.props.max,
                "disabled-date": _ctx.isDateDisabled,
                "disabled-time": _ctx.isTimeDisabled,
                "has-error": _ctx.startError || _ctx.endError,
                onShortcut: _ctx.handleShortcut,
                onChange: _ctx.handlePanelChange,
                onToggleCol: _ctx.handleInputFocus,
                onCancel: _ctx.handleCancel,
                onConfirm: _ctx.handlePaneConfirm
              }, null, 8, ["type", "column", "start-value", "end-value", "start-activated", "end-activated", "value-type", "shortcuts", "confirm-text", "cancel-text", "today", "no-action", "steps", "is-range", "min", "max", "disabled-date", "disabled-time", "has-error", "onShortcut", "onChange", "onToggleCol", "onCancel", "onConfirm"])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name", "onAfterLeave"])
      ]),
      _: 1
    }, 8, ["to"])
  ], 10, _hoisted_122);
}
var DatePicker = _export_sfc(_sfc_main47, [["render", _sfc_render47]]);

// node_modules/vexip-ui/es/components/divider/props.mjs
var dividerProps = buildProps({
  vertical: booleanProp,
  textPosition: String,
  primary: booleanProp,
  dashed: booleanProp
});

// node_modules/vexip-ui/es/components/divider/divider.mjs
var _sfc_main48 = defineComponent({
  name: "Divider",
  props: dividerProps,
  setup(_props, { slots }) {
    const props = useProps("divider", _props, {
      vertical: false,
      textPosition: {
        default: "center",
        validator: (value) => ["center", "left", "right"].includes(value)
      },
      primary: false,
      dashed: false
    });
    const nh = useNameHelper("divider");
    const hasText = computed(() => {
      return !!slots.default;
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(props.vertical ? "vertical" : "horizontal"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("primary")]: !props.vertical && props.primary,
          [nh.bm("dashed")]: props.dashed,
          [nh.bm("with-text")]: !props.vertical && hasText.value,
          [nh.bm(`with-text-${props.textPosition}`)]: !props.vertical && hasText.value && props.textPosition !== "center"
        }
      ];
    });
    return {
      props,
      nh,
      hasText,
      className
    };
  }
});
function _sfc_render48(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "separator"
  }, [
    !_ctx.props.vertical && _ctx.hasText ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("text"))
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)) : createCommentVNode("", true)
  ], 2);
}
var Divider = _export_sfc(_sfc_main48, [["render", _sfc_render48]]);

// node_modules/vexip-ui/es/components/drawer/props.mjs
var drawerProps = buildProps({
  transfer: booleanStringProp,
  active: booleanProp,
  width: [Number, String],
  height: [Number, String],
  placement: String,
  title: String,
  closable: booleanProp,
  inner: booleanProp,
  maskClose: booleanProp,
  drawerClass: classProp,
  hideMask: booleanProp,
  onBeforeClose: Function,
  resizable: booleanProp,
  autoRemove: booleanProp,
  footer: booleanProp,
  confirmText: String,
  cancelText: String,
  loading: booleanProp,
  onToggle: eventProp(),
  onClose: eventProp(),
  onShow: eventProp(),
  onHide: eventProp(),
  onResizeStart: eventProp(),
  onResizeMove: eventProp(),
  onResizeEnd: eventProp(),
  onConfirm: eventProp(),
  onCancel: eventProp()
});

// node_modules/vexip-ui/es/components/drawer/drawer.mjs
var drawerPlacements = Object.freeze(["top", "right", "bottom", "left"]);
var idCount2 = 0;
var _sfc_main49 = defineComponent({
  name: "Drawer",
  components: {
    Button,
    Icon,
    Masker,
    Xmark: L2
  },
  props: drawerProps,
  emits: ["update:active"],
  setup(_props, { slots, emit }) {
    const props = useProps("drawer", _props, {
      transfer: false,
      active: {
        default: false,
        static: true
      },
      width: {
        default: 280,
        validator: (value) => value > 0
      },
      height: {
        default: 280,
        validator: (value) => value > 0
      },
      placement: {
        default: "right",
        validator: (value) => drawerPlacements.includes(value)
      },
      title: "",
      closable: true,
      inner: false,
      maskClose: true,
      drawerClass: null,
      hideMask: false,
      onBeforeClose: {
        default: null,
        isFunc: true
      },
      resizable: false,
      autoRemove: false,
      footer: false,
      confirmText: null,
      cancelText: null,
      loading: false
    });
    const nh = useNameHelper("drawer");
    const currentActive = ref(props.active);
    const currentWidth = ref(props.width);
    const currentHeight = ref(props.height);
    const wrapper = ref();
    const idIndex = `${idCount2++}`;
    const { target: resizer, moving: resizing } = jo({
      onStart: (state, event) => {
        if (!props.resizable || event.button > 0 || !wrapper.value) {
          return false;
        }
        const width = `${currentWidth.value}`.endsWith("%") ? wrapper.value.offsetWidth : En(currentWidth.value);
        const height = `${currentHeight.value}`.endsWith("%") ? wrapper.value.offsetHeight : En(currentHeight.value);
        state.xStart = width;
        state.yStart = height;
        emitEvent(props.onResizeStart, { width, height });
      },
      onMove: (state, event) => {
        const deltaX = event.clientX - state.clientX;
        const deltaY = event.clientY - state.clientY;
        let width = En(currentWidth.value);
        let height = En(currentHeight.value);
        switch (props.placement) {
          case "top": {
            height = state.yStart + deltaY;
            break;
          }
          case "right": {
            width = state.xStart - deltaX;
            break;
          }
          case "bottom": {
            height = state.yStart - deltaY;
            break;
          }
          default: {
            width = state.xStart + deltaX;
          }
        }
        currentWidth.value = Math.max(width, 100);
        currentHeight.value = Math.max(height, 100);
        emitEvent(props.onResizeMove, {
          width: En(currentWidth.value),
          height: En(currentHeight.value)
        });
      },
      onEnd: () => {
        emitEvent(props.onResizeEnd, {
          width: En(currentWidth.value),
          height: En(currentHeight.value)
        });
      }
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inner")]: props.inner,
          [nh.bm("closable")]: props.closable,
          [nh.bm("resizable")]: props.resizable
        }
      ];
    });
    const moveTransition = computed(() => {
      return nh.ns(`move-${props.placement}`);
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        nh.bem("wrapper", props.placement),
        {
          [nh.bem("wrapper", "resizing")]: resizing.value
        },
        props.drawerClass
      ];
    });
    const wrapperStyle = computed(() => {
      const placement = props.placement;
      if (placement === "top" || placement === "bottom") {
        const height = currentHeight.value;
        return {
          height: `${height}`.endsWith("%") ? height : `${height}px`
        };
      }
      const width = currentWidth.value;
      return {
        width: `${width}`.endsWith("%") ? width : `${width}px`
      };
    });
    const hasTitle = computed(() => {
      var _a;
      return !!((_a = slots.title) != null ? _a : props.title);
    });
    const titleId = computed(() => `${nh.bs(idIndex)}__title`);
    const bodyId = computed(() => `${nh.bs(idIndex)}__body`);
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    watch(currentActive, (value) => {
      emitEvent(props.onToggle, value);
      emit("update:active", value);
    });
    watch(
      () => props.width,
      (value) => {
        currentWidth.value = value;
      }
    );
    watch(
      () => props.height,
      (value) => {
        currentHeight.value = value;
      }
    );
    async function handleClose(isConfirm = false) {
      let result = true;
      if (typeof props.onBeforeClose === "function") {
        result = props.onBeforeClose(isConfirm);
        if (Je(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        nextTick(() => {
          currentActive.value = false;
          emitEvent(props.onClose);
        });
      }
      return result;
    }
    function handleMaskClose() {
      if (props.maskClose) {
        return handleClose();
      }
    }
    function handleShow() {
      emitEvent(props.onShow);
    }
    function handleHide() {
      emitEvent(props.onHide);
    }
    function handleConfirm() {
      handleClose(true);
      emitEvent(props.onConfirm);
    }
    function handleCancle() {
      handleClose(false);
      emitEvent(props.onCancel);
    }
    return {
      props,
      nh,
      locale: useLocale("modal"),
      currentActive,
      resizing,
      className,
      moveTransition,
      wrapperClass,
      wrapperStyle,
      hasTitle,
      titleId,
      bodyId,
      wrapper,
      resizer,
      handleClose,
      handleMaskClose,
      handleShow,
      handleHide,
      handleConfirm,
      handleCancle
    };
  }
});
var _hoisted_123 = ["aria-modal", "aria-labelledby", "aria-describedby"];
var _hoisted_211 = ["id"];
var _hoisted_34 = ["id"];
function _sfc_render49(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button");
  const _component_Masker = resolveComponent("Masker");
  return openBlock(), createBlock(_component_Masker, {
    active: _ctx.currentActive,
    "onUpdate:active": _cache[1] || (_cache[1] = ($event) => _ctx.currentActive = $event),
    inherit: _ctx.props.inherit,
    class: normalizeClass(_ctx.className),
    inner: _ctx.props.inner,
    "transition-name": _ctx.moveTransition,
    closable: _ctx.props.maskClose,
    disabled: _ctx.props.hideMask,
    "on-before-close": _ctx.handleMaskClose,
    transfer: _ctx.props.transfer,
    "auto-remove": _ctx.props.autoRemove,
    onShow: _ctx.handleShow,
    onHide: _ctx.handleHide
  }, {
    default: withCtx(({ show }) => [
      withDirectives(createBaseVNode("section", {
        ref: "wrapper",
        class: normalizeClass(_ctx.wrapperClass),
        style: normalizeStyle(_ctx.wrapperStyle),
        role: "dialog",
        "aria-modal": show ? "true" : void 0,
        "aria-labelledby": _ctx.titleId,
        "aria-describedby": _ctx.bodyId
      }, [
        _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("header"))
        }, [
          createBaseVNode("div", {
            id: _ctx.titleId,
            class: normalizeClass(_ctx.nh.be("title"))
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.props.title), 1)
            ])
          ], 10, _hoisted_211),
          _ctx.props.closable ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("close")),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleClose())
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              createVNode(_component_Icon, {
                scale: 1.2,
                label: "close"
              }, {
                default: withCtx(() => [
                  createVNode(_component_Xmark)
                ]),
                _: 1
              }, 8, ["scale"])
            ])
          ], 2)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createBaseVNode("div", {
          id: _ctx.bodyId,
          class: normalizeClass(_ctx.nh.be("content"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 10, _hoisted_34),
        _ctx.props.footer || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("footer"))
        }, [
          renderSlot(_ctx.$slots, "footer", {}, () => [
            createVNode(_component_Button, {
              inherit: "",
              text: "",
              size: "small",
              onClick: _ctx.handleCancle
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
              ]),
              _: 1
            }, 8, ["onClick"]),
            createVNode(_component_Button, {
              inherit: "",
              type: "primary",
              size: "small",
              loading: _ctx.props.loading,
              onClick: _ctx.handleConfirm
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
              ]),
              _: 1
            }, 8, ["loading", "onClick"])
          ])
        ], 2)) : createCommentVNode("", true),
        _ctx.props.resizable ? (openBlock(), createElementBlock("div", {
          key: 2,
          ref: "resizer",
          class: normalizeClass([
            _ctx.nh.be("handler"),
            _ctx.nh.bem("handler", _ctx.props.placement),
            {
              [_ctx.nh.bem("handler", "resizing")]: _ctx.resizing
            }
          ])
        }, [
          renderSlot(_ctx.$slots, "handler", { resizing: _ctx.resizing })
        ], 2)) : createCommentVNode("", true)
      ], 14, _hoisted_123), [
        [vShow, show]
      ])
    ]),
    _: 3
  }, 8, ["active", "inherit", "class", "inner", "transition-name", "closable", "disabled", "on-before-close", "transfer", "auto-remove", "onShow", "onHide"]);
}
var Drawer = _export_sfc(_sfc_main49, [["render", _sfc_render49]]);

// node_modules/vexip-ui/es/components/ellipsis/props.mjs
var ellipsisProps = buildProps({
  placement: String,
  transfer: {
    type: [String, Boolean],
    default: null
  },
  noHover: booleanProp,
  transitionName: String,
  tooltipTheme: String,
  tipClass: classProp,
  maxLines: Number,
  tipMaxWidth: [Number, String]
});

// node_modules/vexip-ui/es/components/ellipsis/ellipsis.mjs
var _sfc_main50 = defineComponent({
  name: "Ellipsis",
  components: {
    Portal
  },
  props: ellipsisProps,
  setup(_props) {
    const nh = useNameHelper("ellipsis");
    const props = useProps("ellipsis", _props, {
      placement: {
        default: "top",
        validator: (value) => Wo.includes(value)
      },
      transfer: "body",
      noHover: false,
      transitionName: () => nh.ns("fade"),
      tooltipTheme: {
        default: "dark",
        validator: (value) => ["light", "dark"].includes(value)
      },
      tipClass: null,
      maxLines: null,
      tipMaxWidth: 500
    });
    const tooltipNh = useNameHelper("tooltip");
    const visible = ref(false);
    const active = ref(false);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const content = ref("");
    const wrapper = ref();
    const { popper, transferTo, updatePopper } = qo({
      placement,
      transfer,
      wrapper,
      reference: wrapper
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("multiple")]: props.maxLines
      };
    });
    const ellipsisStyle = computed(() => {
      return props.maxLines > 0 ? { "-webkit-line-clamp": props.maxLines } : "";
    });
    const tipStyle = computed(() => {
      return {
        maxWidth: typeof props.tipMaxWidth === "string" ? parseFloat(props.tipMaxWidth) || props.tipMaxWidth : `${props.tipMaxWidth}px`
      };
    });
    watch(visible, (value) => {
      if (value) {
        updatePopper();
      }
    });
    const { timer: timer2 } = $o();
    function handleTriggerEnter() {
      clearTimeout(timer2.hover);
      timer2.hover = setTimeout(() => {
        var _a;
        if (!wrapper.value || !wrapper.value.childNodes.length) {
          visible.value = false;
          return;
        }
        if (props.maxLines > 0) {
          const scrollHeight = wrapper.value.scrollHeight;
          const clientHeight = wrapper.value.clientHeight;
          visible.value = scrollHeight > clientHeight;
        } else {
          visible.value = lr(wrapper.value) > wrapper.value.getBoundingClientRect().width;
        }
        content.value = visible.value ? (_a = wrapper.value.textContent) != null ? _a : "" : "";
        nextTick(() => {
          active.value = true;
        });
      }, 250);
    }
    function handleTriggerLeave() {
      clearTimeout(timer2.hover);
      timer2.hover = setTimeout(() => {
        active.value = false;
      });
    }
    return {
      props,
      nh,
      tooltipNh,
      visible,
      active,
      content,
      transferTo,
      className,
      ellipsisStyle,
      tipStyle,
      wrapper,
      popper,
      handleTriggerEnter,
      handleTriggerLeave
    };
  }
});
function _sfc_render50(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", mergeProps({
      ref: "wrapper",
      class: _ctx.className,
      style: _ctx.ellipsisStyle
    }, _ctx.$attrs, {
      onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
      onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
    }), [
      renderSlot(_ctx.$slots, "default")
    ], 16),
    _ctx.visible ? (openBlock(), createBlock(_component_Portal, {
      key: 0,
      to: _ctx.transferTo
    }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          appear: "",
          onAfterLeave: _cache[5] || (_cache[5] = ($event) => _ctx.visible = false)
        }, {
          default: withCtx(() => [
            withDirectives(createBaseVNode("div", {
              ref: "popper",
              class: normalizeClass({
                [_ctx.tooltipNh.be("popper")]: true,
                [_ctx.tooltipNh.bs("vars")]: true,
                [_ctx.tooltipNh.bem("popper", "inherit")]: _ctx.transferTo !== "body",
                [_ctx.tooltipNh.bem("popper", _ctx.props.tooltipTheme)]: true,
                [_ctx.tooltipNh.bem("popper", "no-hover")]: _ctx.props.noHover
              }),
              onClick: _cache[2] || (_cache[2] = withModifiers(() => {
              }, ["stop"])),
              onMouseenter: _cache[3] || (_cache[3] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
              onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
            }, [
              createBaseVNode("div", {
                class: normalizeClass([_ctx.nh.be("tip"), _ctx.tooltipNh.be("tip"), _ctx.props.tipClass]),
                style: normalizeStyle(_ctx.tipStyle)
              }, [
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.tooltipNh.be("arrow"))
                }, null, 2),
                createTextVNode(" " + toDisplayString(_ctx.content), 1)
              ], 6)
            ], 34), [
              [vShow, _ctx.active]
            ])
          ]),
          _: 1
        }, 8, ["name"])
      ]),
      _: 1
    }, 8, ["to"])) : createCommentVNode("", true)
  ], 64);
}
var Ellipsis = _export_sfc(_sfc_main50, [["render", _sfc_render50]]);

// node_modules/vexip-ui/es/components/form/form-item.mjs
var _sfc_main51 = defineComponent({
  name: "FormItem",
  components: {
    Column,
    Icon,
    Tooltip,
    CircleQuestionR: S
  },
  inheritAttrs: true,
  props: formItemProps,
  setup(_props, { slots }) {
    const nh = useNameHelper("form");
    const props = useProps("formItem", _props, {
      label: {
        default: "",
        static: true
      },
      prop: {
        default: "",
        static: true
      },
      rules: () => [],
      labelWidth: null,
      required: false,
      htmlFor: {
        default: null,
        static: true
      },
      errorTransition: () => nh.ns("fade"),
      defaultValue: {
        default: null,
        static: true
      },
      hideErrorTip: false,
      validateAll: null,
      hideAsterisk: null,
      hideLabel: null,
      action: false,
      help: "",
      pure: false,
      span: 24,
      offset: null,
      push: null,
      pull: null,
      order: null,
      xs: null,
      sm: null,
      md: null,
      lg: null,
      xl: null,
      xxl: null,
      flex: null
    });
    const formProps2 = inject(FORM_PROPS, {});
    const formActions = inject(FORM_ACTIONS, null);
    const formFields = inject(FORM_FIELDS, null);
    const emitter = gr();
    const locale = useLocale("form");
    const initValue = ref(props.defaultValue);
    const isError = ref(false);
    const errorTip = ref("");
    const validating = ref(false);
    const disabledValidate = ref(false);
    const labelWidth = ref(0);
    const labelEl = ref();
    const isRequired = computed(() => formProps2.allRequired || props.required);
    const requiredTip = computed(() => {
      return makeSentence(`${props.label || props.prop} ${locale.value.notNullable}`);
    });
    const allRules = computed(() => {
      var _a;
      if (!props.prop)
        return [];
      const requiredRule = isRequired.value ? [{ required: isRequired.value, message: requiredTip.value }] : [];
      const selfRules = Array.isArray(props.rules) ? props.rules : [props.rules];
      let formRules = [];
      if (formProps2.rules) {
        formRules = (_a = getValueByPath(formProps2.rules, props.prop)) != null ? _a : [];
      }
      formRules = Array.isArray(formRules) ? formRules : [formRules];
      return requiredRule.concat(formRules, selfRules);
    });
    const currentValue = computed(getValue);
    const isValidateAll = computed(() => {
      var _a;
      return qe(props.validateAll) ? (_a = formProps2.validateAll) != null ? _a : false : props.validateAll;
    });
    const useAsterisk = computed(() => {
      if (props.hideAsterisk === true || formProps2.hideAsterisk) {
        return false;
      }
      for (const rule of allRules.value) {
        if (rule.required)
          return true;
      }
      return isRequired.value;
    });
    const hideLabel = computed(
      () => props.action || props.hideLabel === true || formProps2.hideLabel
    );
    const hasLabel = computed(() => !(hideLabel.value || !(props.label || slots.label)));
    const computedlabelWidth = computed(() => {
      if (formProps2.labelAlign) {
        return getLabelWidth(
          formProps2.labelAlign === "top" ? 0 : hideLabel.value ? 0 : props.labelWidth || formProps2.labelWidth || 80
        );
      }
      return getLabelWidth(hideLabel.value ? 0 : props.labelWidth || 80);
    });
    const className = computed(() => {
      return {
        [nh.be("item")]: true,
        [nh.bs("vars")]: true,
        [nh.bem("item", "inherit")]: formFields || props.inherit,
        [nh.bem("item", "required")]: !formProps2.hideAsterisk && useAsterisk.value,
        [nh.bem("item", "error")]: isError.value,
        [nh.bem("item", "action")]: props.action,
        [nh.bem("item", "padding")]: formProps2.inline && formProps2.labelAlign === "top" && !hasLabel.value
      };
    });
    const controlStyle = computed(() => {
      return {
        width: formProps2.labelAlign === "top" ? void 0 : `calc(100% - ${computedlabelWidth.value}px)`,
        marginLeft: hasLabel.value || formProps2.labelAlign === "top" ? void 0 : `${computedlabelWidth.value}px`
      };
    });
    const inputValue = computed(() => {
      const value = currentValue.value;
      if (Array.isArray(value) || typeof value === "object") {
        return JSON.stringify(value);
      }
      return value;
    });
    const instances = /* @__PURE__ */ new Set();
    const fieldObject = Object.freeze({
      prop: computed(() => props.prop),
      idFor: computed(() => props.prop),
      state: computed(() => isError.value ? "error" : "default"),
      disabled: computed(() => !!formProps2.disabled),
      loading: computed(() => !!formProps2.loading),
      size: computed(() => formProps2.size || "default"),
      emitter,
      labelWidth,
      validate: validate$1,
      clearError,
      reset,
      getValue,
      setValue,
      sync: (instance) => {
        if (instances.size) {
          console.warn("[vexip-ui:Form]: must only be one control component under FormItem.");
        }
        instances.add(instance);
      },
      unsync: (instance) => {
        instances.delete(instance);
      }
    });
    provide(FIELD_OPTIONS, fieldObject);
    watch(
      () => props.defaultValue,
      (value) => {
        initValue.value = value;
      }
    );
    onMounted(() => {
      const value = currentValue.value;
      if (qe(initValue.value)) {
        initValue.value = Array.isArray(value) ? Array.from(value) : value;
      }
      if (labelEl.value) {
        labelWidth.value = lr(labelEl.value);
      }
      if (formFields) {
        formFields.add(fieldObject);
      }
    });
    onBeforeUnmount(() => {
      if (formFields) {
        formFields.delete(fieldObject);
      }
    });
    function getLabelWidth(width) {
      return width === "auto" ? (formActions == null ? void 0 : formActions.getLabelWidth()) || 80 : width;
    }
    let inited = false;
    function getValue(defaultValue) {
      if (!formProps2.model || !props.prop)
        return defaultValue;
      try {
        const value = getValueByPath(formProps2.model, props.prop, true);
        inited = true;
        return value;
      } catch (e) {
        if (!inited) {
          setValueByPath(formProps2.model, props.prop, defaultValue, false);
          inited = true;
        }
        return defaultValue;
      }
    }
    function setValue(value, strict = false) {
      if (!formProps2.model || !props.prop)
        return;
      try {
        return setValueByPath(formProps2.model, props.prop, value, strict);
      } catch (e) {
      }
    }
    function validate$1() {
      return handleValidate();
    }
    function clearError() {
      isError.value = false;
      errorTip.value = "";
    }
    function reset() {
      clearError();
      if (!formProps2.model || !props.prop)
        return false;
      const value = currentValue.value;
      let resetValue;
      if (Array.isArray(value)) {
        resetValue = Array.isArray(initValue.value) ? Array.from(initValue.value) : [];
      } else {
        resetValue = gt(initValue.value) ? initValue.value() : initValue.value;
      }
      if (resetValue !== value) {
        disabledValidate.value = true;
      }
      return setValueByPath(formProps2.model, props.prop, resetValue, true);
    }
    async function handleValidate() {
      if (disabledValidate.value) {
        disabledValidate.value = false;
        return handleValidateEnd(null);
      }
      if (!props.prop || !formProps2.model || validating.value) {
        return handleValidateEnd(null);
      }
      validating.value = true;
      const value = currentValue.value;
      const useRules = allRules.value;
      const model = formProps2.model;
      let errors = await validate(
        useRules,
        value,
        model,
        isValidateAll.value,
        locale.value.validateFail
      );
      errors = errors.length ? errors : null;
      return handleValidateEnd(errors);
    }
    function handleValidateEnd(errors) {
      validating.value = false;
      if (!errors) {
        clearError();
      } else {
        isError.value = true;
        errorTip.value = Array.isArray(errors) ? errors[0] : errors;
      }
      return errors;
    }
    function handleLabelClick() {
      emitter.emit("focus");
    }
    return {
      props,
      nh,
      isError,
      errorTip,
      labelSuffix: toRef(formProps2, "labelSuffix"),
      isNative: computed(() => !!(formProps2.action && formProps2.method)),
      className,
      inputValue,
      useAsterisk,
      hasLabel,
      computedlabelWidth,
      controlStyle,
      labelEl,
      handleLabelClick
    };
  }
});
var _hoisted_124 = ["name", "value"];
var _hoisted_212 = ["for"];
function _sfc_render51(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CircleQuestionR = resolveComponent("CircleQuestionR");
  const _component_Icon = resolveComponent("Icon");
  const _component_Tooltip = resolveComponent("Tooltip");
  const _component_Column = resolveComponent("Column");
  return _ctx.props.pure ? renderSlot(_ctx.$slots, "default", { key: 0 }) : (openBlock(), createBlock(_component_Column, mergeProps({ key: 1 }, _ctx.$attrs, {
    class: _ctx.className,
    role: "group",
    tag: "div",
    span: _ctx.props.span,
    offset: _ctx.props.offset,
    push: _ctx.props.push,
    pull: _ctx.props.pull,
    order: _ctx.props.order,
    xs: _ctx.props.xs,
    sm: _ctx.props.sm,
    md: _ctx.props.md,
    lg: _ctx.props.lg,
    xl: _ctx.props.xl,
    xxl: _ctx.props.xxl,
    flex: _ctx.props.flex
  }), {
    default: withCtx(() => [
      _ctx.isNative ? (openBlock(), createElementBlock("input", {
        key: 0,
        type: "hidden",
        name: _ctx.props.prop,
        value: _ctx.inputValue,
        style: { "display": "none" }
      }, null, 8, _hoisted_124)) : createCommentVNode("", true),
      _ctx.hasLabel ? (openBlock(), createElementBlock("label", {
        key: 1,
        ref: "labelEl",
        class: normalizeClass(_ctx.nh.be("label")),
        style: normalizeStyle({ width: `${_ctx.computedlabelWidth}px` }),
        for: _ctx.props.htmlFor || _ctx.props.prop,
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleLabelClick && _ctx.handleLabelClick(...args))
      }, [
        renderSlot(_ctx.$slots, "label", {}, () => [
          _ctx.props.help || _ctx.$slots.help ? (openBlock(), createBlock(_component_Tooltip, {
            key: 0,
            transfer: ""
          }, {
            trigger: withCtx(() => [
              createVNode(_component_Icon, {
                class: normalizeClass(_ctx.nh.be("help"))
              }, {
                default: withCtx(() => [
                  createVNode(_component_CircleQuestionR)
                ]),
                _: 1
              }, 8, ["class"])
            ]),
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "help", {}, () => [
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.nh.be("help-tip"))
                }, toDisplayString(_ctx.props.help), 3)
              ])
            ]),
            _: 3
          })) : createCommentVNode("", true),
          createTextVNode(" " + toDisplayString(_ctx.props.label + (_ctx.labelSuffix || "")), 1)
        ])
      ], 14, _hoisted_212)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass({
          [_ctx.nh.be("control")]: true,
          [_ctx.nh.bem("control", "no-label")]: !_ctx.hasLabel,
          [_ctx.nh.bem("control", "action")]: _ctx.props.action
        }),
        role: "alert",
        "aria-relevant": "all",
        style: normalizeStyle(_ctx.controlStyle)
      }, [
        renderSlot(_ctx.$slots, "default"),
        createVNode(Transition, {
          name: _ctx.props.errorTransition
        }, {
          default: withCtx(() => [
            !_ctx.props.hideErrorTip && _ctx.isError ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("error-tip"))
            }, [
              renderSlot(_ctx.$slots, "error", { tip: _ctx.errorTip }, () => [
                createTextVNode(toDisplayString(_ctx.errorTip), 1)
              ])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name"])
      ], 6)
    ]),
    _: 3
  }, 16, ["class", "span", "offset", "push", "pull", "order", "xs", "sm", "md", "lg", "xl", "xxl", "flex"]));
}
var FormItem = _export_sfc(_sfc_main51, [["render", _sfc_render51]]);

// node_modules/vexip-ui/es/components/form/form-reset.mjs
var _sfc_main52 = defineComponent({
  name: "FormReset",
  components: {
    Button
  },
  props: formResetProps,
  emits: [],
  setup(_props) {
    const props = useProps("formReset", _props, {
      size: null,
      type: "default",
      label: null,
      dashed: null,
      text: null,
      simple: null,
      ghost: null,
      disabled: null,
      loading: null,
      circle: null,
      loadingIcon: null,
      loadingSpin: null,
      icon: null,
      color: null,
      buttonType: null,
      block: null,
      onBeforeReset: {
        default: null,
        isFunc: true
      }
    });
    const actions = inject(FORM_ACTIONS, null);
    const isInherit = computed(() => !!actions || props.inherit);
    async function handleReset() {
      if (props.disabled)
        return;
      let result = true;
      if (typeof props.onBeforeReset === "function") {
        result = props.onBeforeReset();
        if (Je(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        actions == null ? void 0 : actions.reset();
        emitEvent(props.onReset);
      }
    }
    return {
      props,
      nh: useNameHelper("form"),
      locale: useLocale("form"),
      isInherit,
      handleReset
    };
  }
});
function _sfc_render52(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Button = resolveComponent("Button");
  return openBlock(), createBlock(_component_Button, {
    inherit: _ctx.isInherit,
    class: normalizeClass(_ctx.nh.be("reset")),
    size: _ctx.props.size,
    type: _ctx.props.type,
    simple: _ctx.props.simple,
    ghost: _ctx.props.ghost,
    dashed: _ctx.props.dashed,
    text: _ctx.props.text,
    disabled: _ctx.props.disabled,
    loading: _ctx.props.loading,
    circle: _ctx.props.circle,
    "loading-icon": _ctx.props.loadingIcon,
    "loading-spin": _ctx.props.loadingSpin,
    icon: _ctx.props.icon,
    color: _ctx.props.color,
    "button-type": _ctx.props.buttonType,
    block: _ctx.props.block,
    tag: _ctx.props.tag,
    onClick: _ctx.handleReset
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.props.label || _ctx.locale.reset), 1)
      ])
    ]),
    _: 3
  }, 8, ["inherit", "class", "size", "type", "simple", "ghost", "dashed", "text", "disabled", "loading", "circle", "loading-icon", "loading-spin", "icon", "color", "button-type", "block", "tag", "onClick"]);
}
var FormReset = _export_sfc(_sfc_main52, [["render", _sfc_render52]]);

// node_modules/vexip-ui/es/components/form/form-submit.mjs
var _sfc_main53 = defineComponent({
  name: "FormSubmit",
  components: {
    Button
  },
  props: formSubmitProps,
  emits: [],
  setup(_props) {
    const props = useProps("form-submit", _props, {
      size: null,
      type: "primary",
      label: null,
      dashed: null,
      text: null,
      simple: null,
      ghost: null,
      disabled: null,
      circle: null,
      loadingIcon: null,
      loadingSpin: null,
      icon: null,
      color: null,
      buttonType: null,
      block: null,
      onBeforeSubmit: {
        default: null,
        isFunc: true
      }
    });
    const formProps2 = inject(FORM_PROPS, {});
    const actions = inject(FORM_ACTIONS, null);
    const loading = ref(false);
    const submit = ref();
    const isNative = computed(() => formProps2.method && formProps2.action);
    const isInherit = computed(() => !!actions || props.inherit);
    async function handleSubmit() {
      var _a;
      if (props.disabled || !actions)
        return;
      loading.value = true;
      const errors = await actions.validate();
      if (errors.length) {
        emitEvent(props.onError, errors);
      } else {
        let result = true;
        if (typeof props.onBeforeSubmit === "function") {
          result = props.onBeforeSubmit();
          if (Je(result)) {
            result = await result;
          }
        }
        if (result !== false) {
          emitEvent(props.onSubmit);
          if (isNative.value) {
            (_a = submit.value) == null ? void 0 : _a.click();
          }
        }
      }
      loading.value = false;
    }
    return {
      props,
      nh: useNameHelper("form"),
      locale: useLocale("form"),
      loading,
      submit,
      isNative,
      isInherit,
      handleSubmit
    };
  }
});
function _sfc_render53(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Button = resolveComponent("Button");
  return openBlock(), createBlock(_component_Button, {
    inherit: _ctx.isInherit,
    class: normalizeClass(_ctx.nh.be("submit")),
    size: _ctx.props.size,
    type: _ctx.props.type,
    simple: _ctx.props.simple,
    ghost: _ctx.props.ghost,
    dashed: _ctx.props.dashed,
    text: _ctx.props.text,
    disabled: _ctx.props.disabled,
    loading: _ctx.loading,
    circle: _ctx.props.circle,
    "loading-icon": _ctx.props.loadingIcon,
    "loading-spin": _ctx.props.loadingSpin,
    icon: _ctx.props.icon,
    color: _ctx.props.color,
    "button-type": _ctx.props.buttonType,
    block: _ctx.props.block,
    tag: _ctx.props.tag,
    onClick: _ctx.handleSubmit
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.props.label || _ctx.locale.submit), 1)
      ]),
      _ctx.isNative ? (openBlock(), createElementBlock("button", {
        key: 0,
        ref: "submit",
        type: "submit",
        style: { "display": "none" },
        onClick: _cache[0] || (_cache[0] = withModifiers(() => {
        }, ["stop"]))
      }, null, 512)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["inherit", "class", "size", "type", "simple", "ghost", "dashed", "text", "disabled", "loading", "circle", "loading-icon", "loading-spin", "icon", "color", "button-type", "block", "tag", "onClick"]);
}
var FormSubmit = _export_sfc(_sfc_main53, [["render", _sfc_render53]]);

// node_modules/vexip-ui/es/components/grid/grid.mjs
var numberRE = /^\d+$/;
var justifyList2 = Object.freeze([
  "start",
  "end",
  "center",
  "space-around",
  "space-between",
  "space-evenly"
]);
var alignList2 = Object.freeze(["top", "middle", "bottom", "stretch"]);
var Grid = defineComponent({
  name: "Grid",
  props: gridProps,
  setup(_props, { slots }) {
    const props = useProps("grid", _props, {
      tag: "div",
      gap: 0,
      rows: "none",
      columns: 24,
      autoRows: "auto",
      autoColumns: "auto",
      dense: false,
      justify: {
        default: "start",
        validator: (value) => justifyList2.includes(value)
      },
      align: {
        default: "stretch",
        validator: (value) => alignList2.includes(value)
      },
      cellFlex: false
    });
    const nh = useNameHelper("grid");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bm(props.justify)]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.align)]: props.align !== "stretch",
        [nh.bm("dense")]: props.dense
      };
    });
    const style = computed(() => {
      const style2 = {};
      if (props.gap) {
        style2.gap = Array.isArray(props.gap) ? `${props.gap[0]}px ${props.gap[1]}px` : `${props.gap}px`;
      }
      style2.gridTemplateColumns = parseSizeLayout(props.columns);
      if (props.rows !== "none") {
        style2.gridTemplateRows = parseSizeLayout(props.rows);
      }
      if (props.autoRows !== "auto") {
        style2.gridAutoRows = parseAutoLayout(props.autoRows);
      }
      if (props.autoColumns !== "auto") {
        style2.gridAutoColumns = parseAutoLayout(props.autoColumns);
      }
      return style2;
    });
    const cellFlex = computed(() => {
      if (props.cellFlex === true) {
        return {
          justify: "start",
          align: "top"
        };
      } else if (props.cellFlex) {
        return {
          justify: "start",
          align: "top",
          ...props.cellFlex
        };
      }
      return false;
    });
    provide(GRID_STATE, reactive({ cellFlex, columns: toRef(props, "columns") }));
    function parseSizeLayout(value) {
      if (typeof value === "number") {
        return `repeat(${value}, 1fr)`;
      }
      if (typeof value === "string") {
        return numberRE.test(value.trim()) ? `repeat(${value}, 1fr)` : value;
      }
      if (Array.isArray(value)) {
        return value.map((item) => {
          if (typeof item === "number") {
            return `${item}fr`;
          }
          if (typeof item === "string") {
            return numberRE.test(item.trim()) ? `${item}fr` : item;
          }
          return item;
        }).join(" ");
      }
      return value;
    }
    function parseAutoLayout(value) {
      if (typeof value === "number") {
        return `${value}fr`;
      }
      if (typeof value === "string") {
        return numberRE.test(value.trim()) ? `repeat(${value}, 1fr)` : value;
      }
      if (Array.isArray(value)) {
        return value.map((item) => {
          if (typeof item === "number") {
            return `${item}fr`;
          }
          if (typeof item === "string") {
            return numberRE.test(item.trim()) ? `${item}fr` : item;
          }
          return item;
        }).join(" ");
      }
      return value;
    }
    return () => h(
      props.tag || "div",
      {
        class: className.value,
        style: style.value
      },
      {
        default: () => {
          var _a;
          return (_a = slots.default) == null ? void 0 : _a.call(slots);
        }
      }
    );
  }
});

// node_modules/vexip-ui/es/components/highlight/props.mjs
var highlightProps = buildProps({
  content: String,
  keyWords: Array,
  ignoreCase: booleanProp
});

// node_modules/vexip-ui/es/components/highlight/highlight.mjs
var _sfc_main54 = defineComponent({
  name: "Highlight",
  props: highlightProps,
  setup(_props) {
    const props = useProps("highlight", _props, {
      content: {
        default: "",
        static: true
      },
      keyWords: {
        default: () => [],
        static: true
      },
      ignoreCase: false
    });
    const nh = useNameHelper("highlight");
    const splitRE = computed(() => {
      var _a;
      const keyWords = (_a = props.keyWords) == null ? void 0 : _a.filter(Boolean);
      if (!(keyWords == null ? void 0 : keyWords.length)) {
        return null;
      }
      return new RegExp(
        `(${keyWords.sort((p, n) => n.length - p.length).join("|")})`,
        `${props.ignoreCase ? "i" : ""}g`
      );
    });
    const renderTexts = computed(() => {
      if (!splitRE.value || !props.content) {
        return [{ isKey: false, text: props.content }];
      }
      return props.content.split(splitRE.value).map((text) => {
        return { isKey: splitRE.value.test(text), text };
      });
    });
    return {
      nh,
      props,
      renderTexts
    };
  }
});
var _hoisted_125 = { key: 1 };
function _sfc_render54(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars"), _ctx.props.inherit && _ctx.nh.bm("inherit")])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderTexts, (item, index) => {
      return openBlock(), createElementBlock(Fragment, { key: index }, [
        item.isKey ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("key-word"))
        }, [
          renderSlot(_ctx.$slots, "light", {
            text: item.text
          }, () => [
            createTextVNode(toDisplayString(item.text), 1)
          ])
        ], 2)) : (openBlock(), createElementBlock("span", _hoisted_125, [
          renderSlot(_ctx.$slots, "default", {
            text: item.text
          }, () => [
            createTextVNode(toDisplayString(item.text), 1)
          ])
        ]))
      ], 64);
    }), 128))
  ], 2);
}
var Highlight = _export_sfc(_sfc_main54, [["render", _sfc_render54]]);

// node_modules/vexip-ui/es/components/menu/menu-rest.mjs
var MenuRest = defineComponent({
  name: "MenuRest",
  props: {
    menus: {
      type: Array,
      default: () => []
    }
  },
  setup(props) {
    const menuState = inject(MENU_STATE, null);
    const nh = useNameHelper("menu");
    const groupExpanded = ref(false);
    const sonSelected = ref(false);
    const popperShow = ref(false);
    const transfer = computed(() => {
      var _a;
      return (_a = menuState == null ? void 0 : menuState.transfer) != null ? _a : false;
    });
    const dropTrigger = computed(() => (menuState == null ? void 0 : menuState.trigger) || "hover");
    const wrapper = Do(handleClickOutside);
    const {
      reference,
      popper,
      transferTo,
      updatePopper
    } = qo({
      placement: ref("bottom"),
      transfer,
      wrapper
    });
    const itemState = reactive({
      el: wrapper,
      label: "",
      indent: 1,
      groupExpanded,
      showGroup: groupExpanded,
      isUsePopper: true,
      parentState: null,
      transfer,
      cachedExpanded: false,
      updateSonSelected,
      toggleGroupExpanded,
      handleMouseEnter,
      handleMouseLeave
    });
    provide(MENU_ITEM_STATE, itemState);
    watch(groupExpanded, (value) => {
      if (value) {
        popperShow.value = true;
        updatePopper();
      }
    });
    function updateSonSelected(selected) {
      sonSelected.value = selected;
    }
    function toggleGroupExpanded(expanded) {
      groupExpanded.value = expanded;
    }
    const {
      timer: timer2
    } = $o();
    function handleMouseEnter() {
      clearTimeout(timer2.hover);
      if (dropTrigger.value !== "hover")
        return;
      timer2.hover = setTimeout(() => {
        groupExpanded.value = true;
      }, 250);
    }
    function handleMouseLeave() {
      clearTimeout(timer2.hover);
      if (dropTrigger.value !== "hover")
        return;
      timer2.hover = setTimeout(() => {
        groupExpanded.value = false;
      }, 250);
    }
    function handleClick() {
      if (dropTrigger.value === "click") {
        groupExpanded.value = true;
      }
    }
    function handleClickOutside() {
      if (dropTrigger.value === "click") {
        nextTick(() => {
          groupExpanded.value = false;
        });
      }
    }
    function handlePopperHide() {
      popperShow.value = false;
    }
    function renderMenuItems() {
      var _a;
      if (!((_a = props.menus) == null ? void 0 : _a.length)) {
        return null;
      }
      return props.menus.map((item) => createVNode(MenuItem, {
        "label": item.label,
        "icon": item.icon,
        "icon-props": item.iconProps,
        "disabled": item.disabled,
        "children": item.children,
        "route": item.route
      }, {
        default: () => [item.name ? Fr(item.name) : item.label]
      }));
    }
    return () => {
      return createVNode("div", {
        "ref": wrapper,
        "class": nh.be("rest"),
        "onMouseenter": handleMouseEnter,
        "onMouseleave": handleMouseLeave
      }, [createVNode("div", {
        "ref": reference,
        "class": [nh.be("rest-handler"), sonSelected.value && nh.bem("rest-handler", "selected")],
        "onClick": handleClick
      }, [createVNode(Icon, null, {
        default: () => [createVNode(x6, null, null)]
      })]), createVNode(Portal, {
        "to": transferTo.value
      }, {
        default: () => [createVNode(Transition, {
          "name": nh.ns("drop"),
          "appear": true,
          "onAfterLeave": handlePopperHide
        }, {
          default: () => [popperShow.value && withDirectives(createVNode("div", {
            "ref": popper,
            "class": [nh.be("popper"), nh.bs("vars"), nh.bem("popper", "drop")]
          }, [createVNode("ul", {
            "class": [nh.be("list"), nh.bem("list", "theme")]
          }, [renderMenuItems()])]), [[vShow, groupExpanded.value]])]
        })]
      })]);
    };
  }
});

// node_modules/vexip-ui/es/components/menu/menu.mjs
var menuMarkerTypes = Object.freeze(["top", "right", "bottom", "left", "none"]);
var Menu = defineComponent({
  name: "Menu",
  components: {
    MenuRest,
    MenuItem,
    MenuGroup,
    Overflow
  },
  props: menuProps,
  emits: ["update:active"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const props = useProps("menu", _props, {
      active: {
        default: null,
        static: true
      },
      accordion: false,
      markerType: {
        default: "right",
        validator: (value) => menuMarkerTypes.includes(value)
      },
      reduced: false,
      horizontal: false,
      transfer: false,
      trigger: "hover",
      groupType: {
        default: "collapse",
        validator: (value) => ["collapse", "dropdown"].includes(value)
      },
      tooltipReverse: null,
      options: {
        default: () => [],
        static: true
      },
      router: null,
      manualRoute: false
    });
    const nh = useNameHelper("menu");
    const menuItemSet = /* @__PURE__ */ new Set();
    const currentActive = ref(props.active);
    const isReduced = ref(false);
    const wrapper = ref();
    const rest = ref();
    const markerType = computed(() => {
      var _a;
      if (props.horizontal && (props.markerType === "left" || props.markerType === "right")) {
        return "bottom";
      } else if (!props.horizontal && (props.markerType === "top" || props.markerType === "bottom")) {
        return "right";
      } else {
        return (_a = props.markerType) != null ? _a : props.horizontal ? "bottom" : "right";
      }
    });
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), nh.bm(`marker-${markerType.value}`), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("reduced")]: isReduced.value,
        [nh.bm("dropdown")]: props.groupType === "dropdown",
        [nh.bm("horizontal")]: props.horizontal
      }];
    });
    const menus = computed(() => {
      var _a, _b;
      if ((_a = props.options) == null ? void 0 : _a.length) {
        return props.options;
      }
      const routes = (_b = props.router) == null ? void 0 : _b.options.routes;
      if (!(routes == null ? void 0 : routes.length)) {
        return [];
      }
      return parseRoutesToMenus(routes);
    });
    const currentRoute = computed(() => {
      var _a;
      return (_a = props.router) == null ? void 0 : _a.currentRoute.value;
    });
    provide(MENU_STATE, reactive({
      currentActive,
      isReduced,
      horizontal: toRef(props, "horizontal"),
      accordion: toRef(props, "accordion"),
      groupType: toRef(props, "groupType"),
      tooltipReverse: toRef(props, "tooltipReverse"),
      transfer: toRef(props, "transfer"),
      trigger: toRef(props, "trigger"),
      markerType,
      handleSelect,
      handleExpand,
      increaseItem,
      decreaseItem,
      beforeExpand: () => {
        if (props.accordion) {
          for (const item of menuItemSet) {
            item.groupExpanded = false;
          }
        }
      }
    }));
    watch(() => props.active, (value) => {
      if (value !== currentActive.value) {
        currentActive.value = value;
      }
    });
    watch(() => props.reduced, (value) => {
      if (props.horizontal)
        return;
      if (value) {
        handleMenuReduce();
      } else {
        handleMenuExpand();
      }
    });
    watch(currentRoute, (value) => {
      var _a;
      if (!props.manualRoute && value) {
        currentActive.value = ((_a = value.meta) == null ? void 0 : _a.label) || value.path;
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (!props.horizontal && props.reduced)
          handleMenuReduce();
      });
    });
    expose({
      expandItemByLabel
    });
    function parseRoutesToMenus(routes) {
      const root = {
        label: "",
        children: []
      };
      const loop = Array.from(routes).map((route) => ({
        parent: root,
        route
      }));
      while (loop.length) {
        const {
          parent,
          route
        } = loop.shift();
        const routeMeta = route.meta || {};
        if (routeMeta.menu === false) {
          continue;
        }
        const options = {
          ...routeMeta,
          route,
          label: routeMeta.label || route.path,
          name: routeMeta.name || route.name
        };
        if (!parent.children) {
          parent.children = [];
        }
        parent.children.push(options);
        if (route.children) {
          loop.push(...route.children.map((route2) => ({
            parent: options,
            route: route2
          })));
        }
      }
      return root.children;
    }
    function increaseItem(state) {
      menuItemSet.add(state);
    }
    function decreaseItem(state) {
      menuItemSet.delete(state);
    }
    function handleSelect(label, meta, route) {
      if (currentActive.value !== label) {
        currentActive.value = label;
        emitEvent(props.onSelect, label, meta);
        emit("update:active", label);
        if (!props.manualRoute && props.router && route) {
          props.router.push(route);
        }
      }
    }
    function handleExpand(label, expanded, meta) {
      if (expanded) {
        emitEvent(props.onExpand, label, meta);
      } else {
        emitEvent(props.onReduce, label, meta);
      }
    }
    function handleMenuReduce() {
      if (props.horizontal)
        return;
      let firstExpandedItem = null;
      for (const item of menuItemSet) {
        item.cachedExpanded = item.showGroup;
        if (!firstExpandedItem && item.showGroup) {
          firstExpandedItem = item;
        }
        item.toggleGroupExpanded(false);
      }
      isReduced.value = true;
    }
    function handleMenuExpand() {
      if (props.horizontal)
        return;
      isReduced.value = false;
      if (wrapper.value) {
        const el = wrapper.value;
        const callback = () => {
          requestAnimationFrame(() => {
            el.removeEventListener("transitionend", callback);
            const selectedItem = Array.from(menuItemSet).find((item) => item.label === currentActive.value);
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                for (const item of menuItemSet) {
                  item.groupExpanded = item.cachedExpanded;
                }
                if (selectedItem) {
                  let parent = selectedItem.parentState;
                  while (parent) {
                    parent.groupExpanded = true;
                    parent = parent.parentState;
                  }
                }
              });
            });
          });
        };
        el.addEventListener("transitionend", callback);
      }
    }
    function expandItemByLabel(label) {
      for (const item of menuItemSet) {
        if (item.label === label) {
          item.toggleGroupExpanded(true, true);
        }
      }
    }
    function renderMenuItem(item) {
      return createVNode(MenuItem, {
        "label": item.label,
        "icon": item.icon,
        "icon-props": item.iconProps,
        "disabled": item.disabled,
        "children": item.children,
        "route": item.route
      }, {
        default: () => [item.name ? Fr(item.name) : item.label]
      });
    }
    function renderMenus() {
      return menus.value.map((menu) => menu.group ? createVNode(MenuGroup, {
        "label": menu.name ? Fr(menu.name) : menu.label
      }, {
        default: () => {
          var _a;
          return [((_a = menu.children) == null ? void 0 : _a.length) ? menu.children.map(renderMenuItem) : null];
        }
      }) : renderMenuItem(menu));
    }
    return () => {
      return createVNode("ul", {
        "ref": wrapper,
        "class": className.value,
        "role": "menu",
        "tabindex": -1
      }, [slots.default ? slots.default() : props.horizontal ? createVNode(Overflow, {
        "inherit": true
      }, {
        default: renderMenus,
        counter: ({
          count: count3
        }) => createVNode(MenuRest, {
          "ref": rest,
          "menus": menus.value.slice(-count3)
        }, null)
      }) : renderMenus()]);
    };
  }
});

// node_modules/vexip-ui/es/components/layout/layout-main.mjs
var LayoutMain = defineComponent({
  name: "LayoutMain",
  props: {
    tag: String
  },
  setup(_props, {
    slots
  }) {
    const props = useProps("layout", _props, {
      tag: "main"
    });
    const nh = useNameHelper("layout");
    const className = computed(() => {
      return [nh.be("main")];
    });
    return () => {
      const CustomTag = props.tag || "main";
      return createVNode(CustomTag, {
        "class": className.value
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      });
    };
  }
});

// node_modules/vexip-ui/es/components/switch/props.mjs
var switchProps = buildProps({
  size: sizeProp,
  state: stateProp,
  value: booleanProp,
  disabled: booleanProp,
  openColor: String,
  closeColor: String,
  loading: booleanProp,
  loadingIcon: Object,
  loadingSpin: booleanProp,
  openIcon: Object,
  closeIcon: Object,
  openText: String,
  closeText: String,
  onBeforeChange: Function,
  onChange: eventProp()
});

// node_modules/vexip-ui/es/components/switch/switch.mjs
var _sfc_main55 = defineComponent({
  name: "Switch",
  components: {
    Icon
  },
  props: switchProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, size, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = input.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("switch", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(false),
        static: true
      },
      disabled: () => disabled.value,
      openColor: "",
      closeColor: "",
      loading: () => loading.value,
      loadingIcon: h4,
      loadingSpin: false,
      openIcon: null,
      closeIcon: null,
      openText: "",
      closeText: "",
      onBeforeChange: {
        default: null,
        isFunc: true
      }
    });
    const nh = useNameHelper("switch");
    const currentValue = ref(props.value);
    const input = ref();
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("open")]: currentValue.value,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm("disabled")]: props.disabled,
          [nh.bm("loading")]: props.loading
        }
      ];
    });
    const style = computed(() => {
      return {
        backgroundColor: currentValue.value ? props.openColor : props.closeColor
      };
    });
    const signalStyle = computed(() => {
      return {
        color: currentValue.value ? props.openColor : props.closeColor
      };
    });
    const isDisabled = computed(() => {
      return props.disabled || props.loading;
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
      }
    );
    watch(currentValue, (value) => {
      setFieldValue(value);
      emitEvent(props.onChange, value);
      emit("update:value", value);
      validateField();
    });
    async function handleChange(checked = !currentValue.value) {
      if (checked === currentValue.value)
        return;
      let result = true;
      if (typeof props.onBeforeChange === "function") {
        result = props.onBeforeChange(checked);
        if (Je(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        currentValue.value = checked;
      }
    }
    return {
      props,
      nh,
      idFor,
      currentValue,
      className,
      style,
      signalStyle,
      isDisabled,
      input,
      handleChange
    };
  }
});
var _hoisted_126 = ["id", "aria-checked"];
var _hoisted_213 = ["checked", "disabled"];
function _sfc_render55(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("label", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    role: "switch",
    "aria-checked": _ctx.currentValue,
    style: normalizeStyle(_ctx.style)
  }, [
    createBaseVNode("span", {
      class: normalizeClass(_ctx.nh.be("placeholder"))
    }, [
      createBaseVNode("span", {
        class: normalizeClass(_ctx.nh.be("open-text"))
      }, [
        renderSlot(_ctx.$slots, "open", {}, () => [
          createTextVNode(toDisplayString(_ctx.props.openText), 1)
        ])
      ], 2),
      createBaseVNode("span", {
        class: normalizeClass(_ctx.nh.be("close-text"))
      }, [
        renderSlot(_ctx.$slots, "close", {}, () => [
          createTextVNode(toDisplayString(_ctx.props.closeText), 1)
        ])
      ], 2)
    ], 2),
    createBaseVNode("span", {
      class: normalizeClass(_ctx.nh.be("signal")),
      style: normalizeStyle(_ctx.signalStyle)
    }, [
      _ctx.props.loading ? renderSlot(_ctx.$slots, "loading", { key: 0 }, () => [
        createVNode(_component_Icon, {
          spin: _ctx.props.loadingSpin,
          pulse: !_ctx.props.loadingSpin,
          icon: _ctx.props.loadingIcon
        }, null, 8, ["spin", "pulse", "icon"])
      ]) : renderSlot(_ctx.$slots, "icon", {
        key: 1,
        value: _ctx.currentValue
      }, () => [
        _ctx.currentValue && _ctx.props.openIcon ? (openBlock(), createBlock(_component_Icon, {
          key: 0,
          icon: _ctx.props.openIcon
        }, null, 8, ["icon"])) : !_ctx.currentValue && _ctx.props.closeIcon ? (openBlock(), createBlock(_component_Icon, {
          key: 1,
          icon: _ctx.props.closeIcon
        }, null, 8, ["icon"])) : createCommentVNode("", true)
      ])
    ], 6),
    createBaseVNode("span", {
      class: normalizeClass(_ctx.nh.be("label"))
    }, [
      _ctx.currentValue ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("open-text"))
      }, [
        renderSlot(_ctx.$slots, "open", {}, () => [
          createTextVNode(toDisplayString(_ctx.props.openText), 1)
        ])
      ], 2)) : (openBlock(), createElementBlock("span", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("close-text"))
      }, [
        renderSlot(_ctx.$slots, "close", {}, () => [
          createTextVNode(toDisplayString(_ctx.props.closeText), 1)
        ])
      ], 2))
    ], 2),
    createBaseVNode("input", {
      ref: "input",
      type: "checkbox",
      class: normalizeClass(_ctx.nh.be("input")),
      checked: _ctx.currentValue,
      disabled: _ctx.isDisabled,
      onChange: _cache[0] || (_cache[0] = ($event) => _ctx.handleChange())
    }, null, 42, _hoisted_213)
  ], 14, _hoisted_126);
}
var Switch = _export_sfc(_sfc_main55, [["render", _sfc_render55]]);

// node_modules/vexip-ui/es/components/layout/props.mjs
var layoutProps = buildProps({
  noAside: booleanProp,
  footer: booleanProp,
  tag: String,
  menus: Object,
  menuProps: Object,
  logo: String,
  signName: String,
  config: Array,
  user: Object,
  actions: Array,
  reduced: booleanProp,
  avatarCircle: booleanProp,
  signType: String,
  headerFixed: booleanStringProp,
  asideFixed: booleanStringProp,
  copyright: String,
  links: Array,
  colors: Array,
  color: String,
  miniHeaderSign: booleanStringProp,
  verticalLinks: booleanStringProp,
  onReducedChange: eventProp(),
  onSignClick: eventProp(),
  onMenuSelect: eventProp(),
  onUserAction: eventProp(),
  onNavChange: eventProp(),
  onColorChange: eventProp()
});
var layoutAsideProps = buildProps({
  tag: String,
  expanded: booleanProp,
  reduced: booleanProp,
  menus: Array,
  menuProps: Object,
  logo: String,
  signName: String,
  fixed: booleanStringProp,
  onReducedChange: eventProp(),
  onExpandedChange: eventProp(),
  onSignClick: eventProp(),
  onMenuSelect: eventProp()
});
var layoutHeaderProps = buildProps({
  tag: String,
  logo: String,
  signName: String,
  user: Object,
  userDropped: booleanProp,
  avatarCircle: booleanProp,
  config: Array,
  actions: Array,
  signType: String,
  colors: Array,
  color: String,
  menus: Object,
  menuProps: Object,
  onNavChange: eventProp(),
  onColorChange: eventProp(),
  onUserAction: eventProp(),
  onSignClick: eventProp(),
  onDropChange: eventProp(),
  onReducedChange: eventProp(),
  onMenuSelect: eventProp()
});
var layoutFooterProps = buildProps({
  tag: String,
  copyright: String,
  links: Array,
  verticalLinks: booleanStringProp
});

// node_modules/vexip-ui/es/components/layout/symbol.mjs
var LAYOUT_STATE = Symbol("LAYOUT_STATE");

// node_modules/vexip-ui/es/components/layout/helper.mjs
var rootEl = V ? document.documentElement : void 0;
var rootStyle = rootEl && getComputedStyle(rootEl);
function computeSeriesColors(value, storageName = "") {
  if (!rootEl || !rootStyle)
    return;
  const colors = {
    light: [],
    opacity: [],
    dark: []
  };
  const black = N(
    rootStyle.getPropertyValue("--vxp-color-black") || { r: 0, g: 0, b: 0, a: 1 }
  );
  const white = N(
    rootStyle.getPropertyValue("--vxp-color-white") || { r: 255, g: 255, b: 255, a: 1 }
  );
  const style = rootEl.style;
  for (let i = 1; i < 10; ++i) {
    const light = bn(white, value, i * 0.1).toString();
    const opacity = yn(value, zt(1 - i * 0.1, 1)).toString();
    style.setProperty(`--vxp-color-primary-light-${i}`, light);
    style.setProperty(`--vxp-color-primary-opacity-${i}`, opacity);
    colors.light.push(light);
    colors.opacity.push(opacity);
  }
  for (let i = 1; i < 3; ++i) {
    const dark = bn(black, value, i * 0.1).toString();
    style.setProperty(`--vxp-color-primary-dark-${i}`, dark);
    colors.dark.push(dark);
  }
  style.setProperty("--vxp-color-primary-base", `${value}`);
  storageName && localStorage.setItem(storageName, `${value}`);
  return colors;
}
function useLayoutState() {
  return inject(
    LAYOUT_STATE,
    reactive({
      isLayout: false,
      locked: false,
      affixed: false,
      scrollY: 0,
      affixMatched: false,
      expanded: false,
      reduced: false,
      navConfig: false
    })
  );
}
var breakPoints3 = Object.freeze(["xs", "sm", "md", "lg", "xl", "xxl"]);
function useMediaQuery(query) {
  const matched = ref(false);
  if (!V)
    return matched;
  const computedStyle = getComputedStyle(document.documentElement);
  const computedQuery = computed(() => {
    if (breakPoints3.includes(query.value)) {
      const media = computedStyle.getPropertyValue(`--vxp-break-point-${query.value}`).trim();
      return `only screen and ${media}`;
    }
    return query.value;
  });
  let mediaQuery;
  const update = () => {
    if (typeof computedQuery.value === "boolean") {
      matched.value = computedQuery.value;
      return;
    }
    if (!computedQuery.value || computedQuery.value === "min") {
      matched.value = false;
      return;
    }
    if (computedQuery.value === "max") {
      matched.value = true;
      return;
    }
    if (!mediaQuery) {
      mediaQuery = matchMedia(computedQuery.value);
    }
    matched.value = mediaQuery.matches;
  };
  watch(computedQuery, () => {
    mediaQuery = void 0;
    update();
  });
  onBeforeMount(() => {
    update();
    mediaQuery == null ? void 0 : mediaQuery.addEventListener("change", update);
  });
  onBeforeUnmount(() => {
    mediaQuery == null ? void 0 : mediaQuery.removeEventListener("change", update);
  });
  return matched;
}
function useUpdateCounter() {
  const counter = ref(0);
  onMounted(() => {
    counter.value++;
  });
  onUpdated(() => {
    counter.value++;
  });
  return counter;
}

// node_modules/vexip-ui/es/components/layout/layout-header.mjs
var LayoutHeader = defineComponent({
  name: "LayoutHeader",
  props: layoutHeaderProps,
  emits: ["update:sign-type", "update:color", "update:user-dropped"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    var _a, _b, _c;
    const props = useProps("layout", _props, {
      tag: "header",
      logo: "",
      signName: "",
      user: {
        default: () => ({
          name: ""
        }),
        static: true
      },
      userDropped: false,
      avatarCircle: false,
      config: () => ["nav", "theme", "color"],
      actions: () => [],
      signType: "aside",
      colors: () => ["#339af0", "#f03e3e", "#be4bdb", "#7950f2", "#1b9e44", "#f76707"],
      color: "",
      menus: {
        default: () => [],
        static: true
      },
      menuProps: null,
      onNavChange: null,
      onColorChange: null,
      onUserAction: null,
      onSignClick: null
    });
    const nh = useNameHelper("layout");
    const locale = useLocale("layout");
    const layoutState = useLayoutState();
    const currentSignType = ref(props.signType);
    const currentUserDropped = ref(props.userDropped);
    const menu = ref(null);
    const {
      isMounted
    } = Io();
    const rootEl2 = computed(() => {
      isMounted.value;
      return V ? document.documentElement : null;
    });
    const currentColor = ref(props.color || ((_a = props.colors) == null ? void 0 : _a[0]) || getBaseColor());
    const isDark = ref((_c = (_b = rootEl2.value) == null ? void 0 : _b.classList.contains("dark")) != null ? _c : false);
    const className = computed(() => {
      return [nh.be("header"), {
        [nh.bs("vars")]: !layoutState.isLayout,
        [nh.bem("header", "inherit")]: layoutState.isLayout || props.inherit,
        [nh.bem("header", "affixed")]: layoutState.affixed
      }];
    });
    const userActions = computed(() => {
      var _a2;
      if (!((_a2 = props.actions) == null ? void 0 : _a2.length)) {
        return [{
          label: "signOut",
          name: locale.value.signOut,
          icon: B
        }];
      }
      return props.actions;
    });
    const hasLeft = computed(() => {
      return !!(props.logo || props.signName || slots.left);
    });
    const hasMenu = computed(() => {
      var _a2, _b2;
      return !!(((_a2 = props.menus) == null ? void 0 : _a2.length) || ((_b2 = props.menuProps) == null ? void 0 : _b2.router));
    });
    expose({
      menu,
      expandMenuByLabel
    });
    watch(() => props.signType, (value) => {
      currentSignType.value = value;
    });
    watch(() => props.color, (value) => {
      var _a2;
      currentColor.value = value || ((_a2 = props.colors) == null ? void 0 : _a2[0]) || getBaseColor();
    });
    watch(() => props.userDropped, (value) => {
      currentUserDropped.value = value;
    });
    watch(currentColor, computeSeriesColors);
    onBeforeMount(() => {
      computeSeriesColors(currentColor.value);
    });
    function getBaseColor() {
      if (rootEl2.value) {
        return getComputedStyle(rootEl2.value).getPropertyValue("--vxp-color-primary-base");
      }
      return "#339af0";
    }
    function handleUserActionSelect(label, meta) {
      emitEvent(props.onUserAction, label, meta);
    }
    function handleSignTypeChange(type) {
      const queue = [() => {
        layoutState.locked = true;
      }, () => {
        currentSignType.value = type;
        emitEvent(props.onNavChange, type);
        emit("update:sign-type", type);
      }, () => {
        layoutState.locked = false;
      }];
      const run = () => {
        var _a2;
        (_a2 = queue.shift()) == null ? void 0 : _a2();
        queue.length && requestAnimationFrame(run);
      };
      run();
    }
    function toggleReduce(target = !layoutState.reduced) {
      layoutState.reduced = target;
      emitEvent(props.onReducedChange, target);
    }
    function handleColorChange(color) {
      currentColor.value = color;
      emitEvent(props.onColorChange, color);
      emit("update:color", color);
    }
    function handleSignClick(event) {
      emitEvent(props.onSignClick, event);
    }
    function toggleUserDrop(target = !currentUserDropped.value) {
      currentUserDropped.value = target;
      emitEvent(props.onDropChange, target);
      emit("update:user-dropped", target);
    }
    function handleMenuSelect(label, meta) {
      toggleUserDrop(false);
      emitEvent(props.onMenuSelect, label, meta);
    }
    function expandMenuByLabel(label) {
      var _a2;
      (_a2 = menu.value) == null ? void 0 : _a2.expandItemByLabel(label);
    }
    function toggleTheme(darkMode) {
      if (!V)
        return;
      requestAnimationFrame(() => {
        isDark.value = darkMode;
        if (rootEl2.value) {
          if (darkMode) {
            rootEl2.value.classList.add("dark");
          } else {
            rootEl2.value.classList.remove("dark");
          }
        }
      });
    }
    function getSlotParams() {
      return {
        reduced: layoutState.reduced,
        toggleReduce,
        handleColorChange,
        toggleUserDrop
      };
    }
    function renderCheck() {
      return createVNode(Icon, null, {
        default: () => [createVNode(x, null, null)]
      });
    }
    function renderLayoutConfig() {
      return createVNode("div", {
        "class": nh.be("config-unit")
      }, [createVNode("div", {
        "class": [nh.be("brief-block"), nh.bem("brief-block", "aside")],
        "onClick": () => handleSignTypeChange("aside")
      }, [currentSignType.value === "aside" && renderCheck()]), createVNode("div", {
        "class": nh.be("brief-block"),
        "onClick": () => handleSignTypeChange("header")
      }, [currentSignType.value === "header" && renderCheck()])]);
    }
    function renderThemeConfig() {
      return createVNode("div", {
        "class": nh.be("config-unit")
      }, [createVNode(Switch, {
        "value": isDark.value,
        "class": [nh.be("theme-mode"), isDark.value && nh.bem("theme-mode", "dark")],
        "open-icon": $23,
        "close-icon": x13,
        "aria-label": "theme",
        "onChange": toggleTheme
      }, null)]);
    }
    function renderColorConfig() {
      var _a2;
      if (!((_a2 = props.colors) == null ? void 0 : _a2.length)) {
        return null;
      }
      return createVNode("div", {
        "class": nh.be("config-unit")
      }, [props.colors.map((color) => createVNode("div", {
        "class": nh.be("major-color"),
        "style": {
          backgroundColor: color
        },
        "onClick": () => handleColorChange(color)
      }, [currentColor.value === color && renderCheck()]))]);
    }
    return () => {
      const CustomTag = props.tag || "header";
      return createVNode(CustomTag, {
        "class": className.value
      }, {
        default: () => [hasLeft.value && createVNode("div", {
          "class": nh.be("header-left")
        }, [slots.left ? slots.left(getSlotParams()) : props.signType === "header" ? createVNode("div", {
          "class": nh.be("sign"),
          "onClick": handleSignClick
        }, [props.logo && createVNode("div", {
          "class": nh.be("logo")
        }, [createVNode("img", {
          "src": props.logo,
          "alt": "Logo"
        }, null)]), props.signName && createVNode("span", {
          "class": nh.be("sign-name")
        }, [props.signName])]) : null]), createVNode("div", {
          "class": nh.be("header-main")
        }, [slots.default ? slots.default(getSlotParams()) : hasMenu.value ? createVNode(Menu, mergeProps({
          "ref": menu
        }, props.menuProps || {}, {
          "horizontal": true,
          "transfer": true,
          "options": props.menus,
          "onSelect": handleMenuSelect
        }), null) : null]), slots.right && createVNode("div", {
          "class": nh.be("header-right")
        }, [slots.right(getSlotParams())]), slots.user ? slots.user(getSlotParams()) : createVNode(Dropdown, {
          "class": nh.be("user"),
          "transfer": true,
          "placement": "bottom-end",
          "visible": currentUserDropped.value,
          "trigger": "custom",
          "onClickOutside": () => toggleUserDrop(false)
        }, {
          default: () => {
            var _a2;
            if (slots.avatar) {
              return slots.avatar(getSlotParams());
            }
            if (typeof ((_a2 = props.user) == null ? void 0 : _a2.avatar) === "string") {
              return createVNode(Avatar, {
                "src": props.user.avatar,
                "icon": C5,
                "circle": props.avatarCircle,
                "onClick": () => toggleUserDrop()
              }, null);
            }
            return createVNode(Avatar, {
              "icon": props.user.avatar || C5,
              "circle": props.avatarCircle,
              "onClick": () => toggleUserDrop()
            }, null);
          },
          drop: () => createVNode(DropdownList, null, {
            default: () => {
              var _a2, _b2;
              return [((_a2 = props.user) == null ? void 0 : _a2.name) && createVNode("li", {
                "class": nh.be("user-profile")
              }, [createVNode("span", {
                "class": nh.be("user-name")
              }, [props.user.name]), props.user.email && createVNode("span", {
                "class": nh.be("user-email")
              }, [props.user.email])]), ((_b2 = props.config) == null ? void 0 : _b2.length) ? createVNode("li", {
                "class": nh.be("config")
              }, [props.config.includes("nav") && layoutState.navConfig && [createVNode("div", {
                "class": nh.be("config-label")
              }, [locale.value.signType]), renderLayoutConfig()], props.config.includes("theme") && [createVNode("div", {
                "class": nh.be("config-label")
              }, [locale.value.themeMode]), renderThemeConfig()], props.config.includes("color") && [createVNode("div", {
                "class": nh.be("config-label")
              }, [locale.value.majorColor]), renderColorConfig()]]) : null, userActions.value.map((action) => createVNode(DropdownItem, {
                "class": nh.be("user-action"),
                "label": action.label,
                "disabled": action.disabled,
                "divided": action.divided,
                "onSelect": () => handleUserActionSelect(action.label, action.meta || {})
              }, {
                default: () => [action.icon && createVNode(Icon, {
                  "icon": action.icon,
                  "style": {
                    marginRight: "6px"
                  }
                }, null), action.name || action.label]
              }))];
            }
          })
        })]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/linker/props.mjs
var linkerProps = buildProps({
  to: String,
  type: String,
  icon: Object,
  underline: booleanProp,
  disabled: booleanProp,
  target: String,
  onClick: eventProp()
});

// node_modules/vexip-ui/es/components/linker/linker.mjs
var linkerTypes = Object.freeze([
  "default",
  "primary",
  "success",
  "error",
  "warning",
  "info"
]);
var _sfc_main56 = defineComponent({
  name: "Linker",
  components: {
    Icon
  },
  props: linkerProps,
  setup(_props) {
    const props = useProps("linker", _props, {
      to: {
        default: null,
        static: true
      },
      type: {
        default: "default",
        validator: (value) => linkerTypes.includes(value)
      },
      icon: null,
      underline: false,
      disabled: false,
      target: "_blank"
    });
    const nh = useNameHelper("linker");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.type)]: props.type !== "default",
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("underline")]: props.underline
      };
    });
    function handleClick(event) {
      if (props.disabled) {
        event.preventDefault();
      }
      emitEvent(props.onClick, event);
    }
    return {
      props,
      nh,
      className,
      handleClick
    };
  }
});
var _hoisted_127 = ["href", "target"];
function _sfc_render56(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("a", {
    class: normalizeClass(_ctx.className),
    href: _ctx.props.to,
    tabindex: "0",
    target: _ctx.props.target,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "icon", {}, () => [
      _ctx.props.icon ? (openBlock(), createBlock(_component_Icon, {
        key: 0,
        class: normalizeClass(_ctx.nh.be("icon")),
        icon: _ctx.props.icon
      }, null, 8, ["class", "icon"])) : createCommentVNode("", true)
    ]),
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_127);
}
var Linker = _export_sfc(_sfc_main56, [["render", _sfc_render56]]);

// node_modules/vexip-ui/es/components/layout/layout-footer.mjs
var LayoutFooter = defineComponent({
  name: "LayoutFooter",
  props: layoutFooterProps,
  setup(_props, {
    slots
  }) {
    const props = useProps("layout", _props, {
      tag: "footer",
      copyright: "",
      links: () => [],
      verticalLinks: "md"
    });
    const nh = useNameHelper("layout");
    const layoutState = useLayoutState();
    const horizontalMatched = useMediaQuery(toRef(props, "verticalLinks"));
    const className = computed(() => {
      return {
        [nh.be("footer")]: true,
        [nh.bs("vars")]: !layoutState.isLayout,
        [nh.bem("footer", "inherit")]: layoutState.isLayout || props.inherit
      };
    });
    function renderLinks() {
      var _a;
      if (!((_a = props.links) == null ? void 0 : _a.length)) {
        return null;
      }
      return createVNode("div", {
        "class": [nh.be("links"), !horizontalMatched.value && nh.bem("links", "vertical")]
      }, [createVNode("div", {
        "class": nh.be("links-row")
      }, [props.links.map((group) => {
        var _a2;
        return createVNode("div", {
          "class": [nh.be("link-group"), !horizontalMatched.value && nh.bem("link-group", "vertical")]
        }, [createVNode("div", {
          "class": [nh.be("link-name"), nh.bem("link-name", "group")]
        }, [group.to ? createVNode(Linker, {
          "icon": group.icon,
          "to": group.to,
          "target": group.target
        }, {
          default: () => [group.name]
        }) : [group.icon && createVNode(Icon, {
          "icon": group.icon
        }, null), group.name], group.subname && createVNode("div", {
          "class": nh.be("link-subname")
        }, [`- ${group.subname}`])]), ((_a2 = group.children) == null ? void 0 : _a2.length) ? group.children.map((link) => createVNode("div", {
          "class": nh.be("link")
        }, [createVNode(Linker, {
          "icon": link.icon,
          "to": link.to,
          "target": link.target
        }, {
          default: () => [link.name]
        }), link.subname && createVNode("div", {
          "class": nh.be("link-subname")
        }, [`- ${link.subname}`])])) : null]);
      })])]);
    }
    return () => {
      const CustomTag = props.tag || "footer";
      return createVNode(CustomTag, {
        "class": className.value
      }, {
        default: () => [slots.links ? slots.links() : renderLinks(), createVNode("div", {
          "class": nh.be("copyright")
        }, [slots.copyright ? slots.copyright() : props.copyright])]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/layout/layout-aside.mjs
var LayoutAside = defineComponent({
  name: "LayoutAside",
  props: layoutAsideProps,
  emits: ["update:reduced", "update:expanded"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const props = useProps("layout", _props, {
      tag: "aside",
      reduced: false,
      menus: {
        default: () => [],
        static: true
      },
      menuProps: null,
      logo: "",
      signName: "",
      fixed: "lg",
      onReducedChange: null,
      onExpandedChange: null,
      onSignClick: null,
      onMenuSelect: null
    });
    const nh = useNameHelper("layout");
    const layoutState = useLayoutState();
    const currentReduced = ref(props.reduced);
    const currentExpanded = ref(props.expanded);
    const scrollHeight = ref("100%");
    const matched = useMediaQuery(toRef(props, "fixed"));
    const counter = useUpdateCounter();
    const top = ref();
    const bottom = ref();
    const menu = ref(null);
    const className = computed(() => {
      return [nh.be("aside"), {
        [nh.bs("vars")]: !layoutState.isLayout,
        [nh.bem("aside", "inherit")]: layoutState.isLayout || props.inherit,
        [nh.bem("aside", "fixed")]: matched.value,
        [nh.bem("aside", "expanded")]: currentExpanded.value,
        [nh.bem("aside", "reduced")]: currentReduced.value
      }];
    });
    const hasTop = computed(() => {
      return !!(props.logo || props.signName || slots.top);
    });
    const hasMenu = computed(() => {
      var _a, _b;
      return !!(((_a = props.menus) == null ? void 0 : _a.length) || ((_b = props.menuProps) == null ? void 0 : _b.router));
    });
    expose({
      menu,
      expandMenuByLabel
    });
    watch(() => props.reduced, (value) => {
      currentReduced.value = value;
    });
    watch(() => props.expanded, (value) => {
      currentExpanded.value = value;
    });
    watch(matched, (value) => {
      layoutState.expanded = !value;
    }, {
      immediate: true
    });
    watch(counter, () => computeScrollHeight);
    function computeScrollHeight() {
      let topHeight = 0;
      let bottomHeight = 0;
      if (top.value) {
        topHeight = top.value.offsetHeight;
      }
      if (bottom.value) {
        bottomHeight = bottom.value.offsetHeight;
      }
      if (topHeight || bottomHeight) {
        scrollHeight.value = `calc(100% - ${topHeight + bottomHeight}px)`;
      } else {
        scrollHeight.value = "100%";
      }
    }
    function toggleReduce(target = !currentReduced.value) {
      currentReduced.value = target;
      emitEvent(props.onReducedChange, target);
      emit("update:reduced", target);
    }
    function toggleExpand(target = !currentExpanded.value) {
      currentExpanded.value = target;
      emitEvent(props.onExpandedChange, target);
      emit("update:expanded", target);
    }
    function handleSignClick(event) {
      emitEvent(props.onSignClick, event);
    }
    function handleMenuSelect(label, meta) {
      emitEvent(props.onMenuSelect, label, meta);
    }
    function expandMenuByLabel(label) {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.expandItemByLabel(label);
    }
    function getSlotParams() {
      return {
        reduced: currentReduced.value,
        toggleReduce,
        toggleExpand
      };
    }
    return () => {
      const CustomTag = props.tag || "aside";
      return createVNode(CustomTag, {
        "class": className.value
      }, {
        default: () => [hasTop.value && createVNode("div", {
          "ref": top,
          "class": nh.be("aside-top")
        }, [slots.top ? slots.top(getSlotParams()) : createVNode("div", {
          "class": nh.be("sign"),
          "onClick": handleSignClick
        }, [props.logo && createVNode("div", {
          "class": nh.be("logo")
        }, [createVNode("img", {
          "src": props.logo,
          "alt": "Logo"
        }, null)]), props.signName && createVNode("span", {
          "class": nh.be("sign-name")
        }, [props.signName])])]), createVNode(NativeScroll, {
          "class": nh.be("aside-main"),
          "height": scrollHeight.value
        }, {
          default: () => [slots.default ? slots.default(getSlotParams()) : hasMenu.value ? createVNode(Menu, mergeProps({
            "ref": menu
          }, props.menuProps || {}, {
            "transfer": true,
            "options": props.menus,
            "reduced": currentReduced.value,
            "onSelect": handleMenuSelect
          }), null) : null]
        }), createVNode("div", {
          "ref": bottom,
          "class": nh.be("aside-bottom")
        }, [slots.bottom ? slots.bottom(getSlotParams()) : createVNode("div", {
          "class": nh.be("reduce-handler"),
          "onClick": () => toggleReduce()
        }, [createVNode(Icon, {
          "icon": currentReduced.value ? u2 : h3
        }, null)])]), createVNode("div", {
          "class": nh.be("expand-handler"),
          "onClick": () => toggleExpand()
        }, [slots.expand ? slots.expand(getSlotParams()) : createVNode(Icon, null, {
          default: () => [createVNode($13, null, null)]
        })])]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/layout/layout.mjs
var Layout = defineComponent({
  name: "Layout",
  components: {
    LayoutAside,
    LayoutFooter,
    LayoutHeader,
    LayoutMain,
    Menu,
    NativeScroll
  },
  props: layoutProps,
  emits: ["update:reduced", "update:sign-type", "update:color"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const props = useProps("layout", _props, {
      noAside: false,
      footer: false,
      tag: "section",
      menus: {
        default: () => [],
        static: true
      },
      menuProps: null,
      logo: "",
      signName: "",
      config: () => ["nav", "theme", "color"],
      user: null,
      actions: () => [],
      reduced: false,
      avatarCircle: false,
      signType: "aside",
      headerFixed: "lg",
      asideFixed: "lg",
      copyright: "",
      links: () => [],
      colors: () => ["#339af0", "#f03e3e", "#be4bdb", "#7950f2", "#1b9e44", "#f76707"],
      color: "",
      miniHeaderSign: "lg",
      verticalLinks: "md",
      onReducedChange: null,
      onSignClick: null,
      onMenuSelect: null,
      onUserAction: null
    });
    const nh = useNameHelper("layout");
    const scrollHeight = ref(0);
    const asideReduced = ref(props.reduced);
    const currentSignType = ref(props.signType);
    const userDropped = ref(false);
    const currentColor = ref(props.color);
    const {
      isMounted
    } = Io();
    const section = ref();
    const scroll = ref();
    const header = ref(null);
    const aside = ref(null);
    const affixMatched = useMediaQuery(toRef(props, "headerFixed"));
    const expandMatched = useMediaQuery(toRef(props, "asideFixed"));
    const signNameMatched = useMediaQuery(toRef(props, "miniHeaderSign"));
    const state = reactive({
      isLayout: true,
      locked: false,
      affixed: false,
      scrollY: 0,
      affixMatched,
      expanded: false,
      reduced: asideReduced,
      navConfig: computed(() => !props.noAside)
    });
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("no-aside")]: props.noAside,
        [nh.bm("header-main")]: currentSignType.value === "header"
      }];
    });
    const rootEl2 = computed(() => {
      isMounted.value;
      return V ? document.documentElement : null;
    });
    const signInHeader = computed(() => {
      return props.noAside || currentSignType.value === "header" || state.expanded;
    });
    const menu = computed(() => {
      var _a, _b;
      return ((_a = aside.value) == null ? void 0 : _a.menu) || ((_b = header.value) == null ? void 0 : _b.menu) || null;
    });
    provide(LAYOUT_STATE, state);
    expose({
      scroll,
      menu,
      expandMenuByLabel
    });
    watch(affixMatched, (value) => {
      state.affixMatched = value;
      state.affixed = !state.affixMatched && state.scrollY >= 50;
    });
    watch(() => props.reduced, (value) => {
      asideReduced.value = value;
    });
    watch(() => state.locked, (value) => {
      var _a;
      if (!section.value || !((_a = scroll.value) == null ? void 0 : _a.content))
        return;
      if (value) {
        section.value.style.transitionDuration = "0ms";
        scroll.value.content.style.transitionDuration = "0ms";
      } else {
        section.value.style.transitionDuration = "";
        scroll.value.content.style.transitionDuration = "";
      }
    });
    watch(currentSignType, (value) => {
      emitEvent(props.onNavChange, value);
      emit("update:sign-type", value);
    });
    watch(() => props.color, (value) => {
      var _a;
      currentColor.value = value || ((_a = props.colors) == null ? void 0 : _a[0]) || getBaseColor();
    });
    watch(currentColor, (value) => {
      emitEvent(props.onColorChange, value);
      emit("update:color", value);
    });
    function getBaseColor() {
      if (rootEl2.value) {
        return getComputedStyle(rootEl2.value).getPropertyValue("--vxp-color-primary-base");
      }
      return "#339af0";
    }
    function toggleReduce(target = !asideReduced.value) {
      asideReduced.value = target;
      emitEvent(props.onReducedChange, target);
      emit("update:reduced", target);
    }
    function handleSignClick(event) {
      emitEvent(props.onSignClick, event);
    }
    function handleMenuSelect(label, meta) {
      emitEvent(props.onMenuSelect, label, meta);
    }
    function handleScroll({
      clientY
    }) {
      state.scrollY = clientY;
      state.affixed = !state.affixMatched && clientY >= 50;
    }
    function handleUserAction(label, meta) {
      emitEvent(props.onUserAction, label, meta);
    }
    function expandMenuByLabel(label) {
      var _a;
      (_a = menu.value) == null ? void 0 : _a.expandItemByLabel(label);
    }
    function getSlotParams() {
      return {
        reduced: asideReduced.value,
        toggleReduce
      };
    }
    function renderSign() {
      if (!props.logo && !props.signName && !slots.sign) {
        return null;
      }
      if (slots.sign) {
        return slots.sign(getSlotParams());
      }
      const showSignName = props.signName && !(signInHeader.value && !signNameMatched.value);
      return createVNode("div", {
        "class": [nh.be("sign"), !showSignName && nh.bem("sign", "logo-only")],
        "onClick": handleSignClick
      }, [[props.logo && createVNode("div", {
        "class": nh.be("logo")
      }, [createVNode("img", {
        "src": props.logo,
        "alt": "Logo"
      }, null)]), showSignName && createVNode("span", {
        "class": nh.be("sign-name")
      }, [props.signName])]]);
    }
    function renderHeader() {
      if (slots.header) {
        return slots.header(getSlotParams());
      }
      return createVNode(LayoutHeader, {
        "ref": header,
        "sign-type": currentSignType.value,
        "onUpdate:sign-type": ($event) => currentSignType.value = $event,
        "user-dropped": userDropped.value,
        "onUpdate:user-dropped": ($event) => userDropped.value = $event,
        "color": currentColor.value,
        "onUpdate:color": ($event) => currentColor.value = $event,
        "user": props.user,
        "actions": props.actions,
        "config": props.config,
        "avatar-circle": props.avatarCircle,
        "menus": props.noAside ? props.menus : [],
        "menu-props": props.noAside ? props.menuProps : null,
        "colors": props.colors,
        "onUserAction": handleUserAction,
        "onReducedChange": toggleReduce,
        "onMenuSelect": handleMenuSelect
      }, {
        left: slots["header-left"] || slots.headerLeft || (() => signInHeader.value ? renderSign() : null),
        default: slots["header-main"] || slots.headerMain || null,
        right: slots["header-right"] || slots.headerRight || null,
        user: slots["header-user"] || slots.headerUser || null,
        avatar: slots["header-avatar"] || slots.headerAvatar || null
      });
    }
    function renderAside() {
      if (slots.aside) {
        return slots.aside(getSlotParams());
      }
      if (props.noAside) {
        return null;
      }
      return createVNode(LayoutAside, {
        "ref": aside,
        "reduced": asideReduced.value,
        "onUpdate:reduced": ($event) => asideReduced.value = $event,
        "menus": props.menus,
        "menu-props": props.menuProps,
        "fixed": props.asideFixed,
        "onReducedChange": toggleReduce,
        "onMenuSelect": handleMenuSelect
      }, {
        top: slots["aside-top"] || slots.asideTop || (() => !signInHeader.value ? renderSign() : null),
        default: slots["aside-main"] || slots.asideMain || null,
        bottom: slots["aside-bottom"] || slots.asideBottom || null,
        expand: slots["aside-expand"] || slots.asideExpand || null
      });
    }
    function renderMain() {
      if (slots.default) {
        return slots.default(getSlotParams());
      }
      return createVNode(LayoutMain, {
        "style": {
          minHeight: `${scrollHeight.value}px`
        }
      }, {
        default: slots.main
      });
    }
    function renderFooter() {
      if (slots.footer) {
        return slots.footer(getSlotParams());
      }
      return createVNode(LayoutFooter, {
        "copyright": props.copyright,
        "links": props.links,
        "vertical-links": props.verticalLinks
      }, {
        links: slots["footer-links"] || slots.footerLinks || null,
        copyright: slots["footer-copyright"] || slots.footerCopyright || null
      });
    }
    function renderScroll() {
      return createVNode(NativeScroll, {
        "ref": scroll,
        "scroll-class": [nh.be("scroll"), expandMatched.value && nh.bem("scroll", "away"), asideReduced.value && nh.bem("scroll", "reduced")],
        "height": "100%",
        "use-y-bar": true,
        "bar-class": nh.be("scrollbar"),
        "onScroll": handleScroll
      }, {
        default: () => [renderMain(), props.footer && renderFooter()]
      });
    }
    return () => {
      const CustomTag = props.tag || "section";
      return createVNode(CustomTag, {
        "class": className.value
      }, {
        default: () => [currentSignType.value === "aside" ? [renderAside(), createVNode("section", {
          "ref": section,
          "class": [nh.be("section"), {
            [nh.bem("section", "away")]: expandMatched.value,
            [nh.bem("section", "reduced")]: asideReduced.value,
            [nh.bem("section", "locked")]: state.locked
          }]
        }, [createVNode("div", {
          "class": nh.be("container")
        }, [renderHeader(), renderScroll()])])] : [renderHeader(), createVNode("section", {
          "class": nh.be("section")
        }, [createVNode("div", {
          "class": nh.be("container")
        }, [renderAside(), renderScroll()])])]]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/loading/loading.mjs
var _sfc_main57 = defineComponent({
  name: "Loading",
  setup() {
    const nh = useNameHelper("loading");
    const visible = ref(false);
    const strokeWidth = ref(2);
    const state = ref("default");
    const position = ref("top");
    const percent = ref(0);
    let maxPercent = 95;
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm(state.value)]: state.value !== "default"
      };
    });
    const style = computed(() => {
      return {
        [position.value]: "0",
        height: `${strokeWidth.value}px`
      };
    });
    const fillerStyle = computed(() => {
      return {
        transform: `translateX(${(percent.value - 100) / 2}%) scaleX(${percent.value / 100})`
      };
    });
    let timer2;
    let interval;
    function startLoading(options) {
      if (percent.value === 100) {
        clearTimeout(timer2);
        visible.value = false;
        percent.value = 0;
        state.value = "default";
        strokeWidth.value = 2;
        position.value = "top";
      }
      clearInterval(interval);
      const setLoading = () => {
        var _a, _b, _c, _d;
        percent.value = Fn(options.percent, 0, 100);
        state.value = (_a = options.state) != null ? _a : "default";
        strokeWidth.value = Fn((_b = options.strokeWidth) != null ? _b : 2, 1, 10);
        position.value = (_c = options.position) != null ? _c : "top";
        maxPercent = Fn((_d = options.maxPercent) != null ? _d : 95, percent.value, 95);
        if (percent.value === 100) {
          timer2 = setTimeout(() => {
            visible.value = false;
          }, 500);
        } else {
          interval = setInterval(() => {
            percent.value += Math.floor(Math.random() * 3 + 1);
            if (percent.value >= maxPercent) {
              percent.value = maxPercent;
              clearInterval(interval);
            }
          }, 500);
        }
      };
      maxPercent = 95;
      requestAnimationFrame(() => {
        if (visible.value) {
          setLoading();
        } else {
          visible.value = true;
          requestAnimationFrame(setLoading);
        }
      });
    }
    return {
      nh,
      visible,
      percent,
      className,
      style,
      fillerStyle,
      startLoading
    };
  }
});
var _hoisted_128 = ["aria-valuenow"];
function _sfc_render57(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, {
    name: _ctx.nh.ns("fade"),
    appear: ""
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        class: normalizeClass(_ctx.className),
        role: "progressbar",
        style: normalizeStyle(_ctx.style),
        "aria-valuenow": _ctx.percent,
        "aria-valuemin": "0",
        "aria-valuemax": "100"
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("filler")),
          style: normalizeStyle(_ctx.fillerStyle)
        }, null, 6)
      ], 14, _hoisted_128), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 1
  }, 8, ["name"]);
}
var Component3 = _export_sfc(_sfc_main57, [["render", _sfc_render57]]);

// node_modules/vexip-ui/es/components/loading/index.mjs
var LoadingManager = class {
  constructor(options = {}) {
    this._instance = null;
    this._innerApp = null;
    this._container = null;
    this.name = "Loading";
    this.defaults = {};
    this.config(options);
  }
  open(options) {
    if (!V)
      return;
    if (typeof options === "number") {
      options = { percent: options };
    }
    this._getInstance().startLoading({ ...this.defaults, ...options });
  }
  close() {
    this.open(100);
  }
  config(options) {
    this.defaults = { ...this.defaults, ...options };
  }
  destroy() {
    var _a;
    (_a = this._innerApp) == null ? void 0 : _a.unmount();
    Jn(this);
  }
  isDestroyed() {
    return false;
  }
  install(app, options = {}) {
    this.config(options);
    app.config.globalProperties.$loading = this;
  }
  _getInstance() {
    if (!this._instance) {
      this._container = document.createElement("div");
      this._innerApp = createApp(Component3);
      this._instance = this._innerApp.mount(this._container);
      document.body.appendChild(this._container.firstElementChild);
    }
    return this._instance;
  }
};
var Loading = new LoadingManager();

// node_modules/vexip-ui/es/components/popup/symbol.mjs
var DELETE_HANDLER = Symbol("DELETE_HANDLER");

// node_modules/vexip-ui/es/components/popup/popup-item.mjs
var _sfc_main58 = defineComponent({
  name: "PopupItem",
  components: {
    Renderer
  },
  props: {
    state: {
      type: Object,
      default: () => ({})
    },
    transitionName: {
      type: String,
      default: null
    },
    innerClass: {
      type: classProp,
      default: null
    }
  },
  setup(props) {
    const handleDelete = inject(DELETE_HANDLER, cn);
    const nh = useNameHelper("popup");
    const wrapper = ref();
    const transition = computed(() => props.transitionName || nh.ns("popup-top"));
    onMounted(() => {
      nextTick(() => {
        const state = props.state;
        if (state && wrapper.value) {
          state.height = wrapper.value.offsetHeight;
        }
      });
    });
    return {
      nh,
      zIndex: useZIndex(),
      transition,
      wrapper,
      handleDelete
    };
  }
});
var _hoisted_129 = ["vxp-index"];
function _sfc_render58(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  return openBlock(), createBlock(Transition, {
    appear: "",
    name: _ctx.transitionName,
    onAfterLeave: _cache[0] || (_cache[0] = ($event) => _ctx.handleDelete(_ctx.state.key))
  }, {
    default: withCtx(() => [
      withDirectives(createBaseVNode("div", {
        ref: "wrapper",
        class: normalizeClass(_ctx.nh.be("item")),
        style: normalizeStyle({ zIndex: _ctx.zIndex }),
        "vxp-index": _ctx.state.key
      }, [
        createBaseVNode("div", {
          class: normalizeClass([_ctx.nh.be("item-inner"), _ctx.innerClass])
        }, [
          renderSlot(_ctx.$slots, "default", { item: _ctx.state }, () => [
            typeof _ctx.state.renderer === "function" ? (openBlock(), createBlock(_component_Renderer, {
              key: 0,
              renderer: _ctx.state.renderer
            }, null, 8, ["renderer"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.state.content), 1)
            ], 64))
          ])
        ], 2)
      ], 14, _hoisted_129), [
        [vShow, _ctx.state.visible]
      ])
    ]),
    _: 3
  }, 8, ["name"]);
}
var PopupItem = _export_sfc(_sfc_main58, [["render", _sfc_render58]]);

// node_modules/vexip-ui/es/components/popup/popup.mjs
var popupPlacements = Object.freeze([
  "top-right",
  "top-center",
  "top-left",
  "bottom-right",
  "bottom-center",
  "bottom-left"
]);
var globalIndex = 0;
function getIndex() {
  return globalIndex++;
}
var _sfc_main59 = defineComponent({
  name: "Popup",
  components: {
    PopupItem
  },
  props: {
    transitionName: {
      type: String,
      default: null
    },
    innerClass: {
      type: classProp,
      default: null
    },
    startOffset: {
      type: Number,
      default: 30
    },
    placement: {
      default: "top-right",
      validator: (value) => popupPlacements.includes(value)
    },
    itemOffset: {
      type: Number,
      default: 16
    }
  },
  setup(props) {
    const nh = useNameHelper("popup");
    const items = ref([]);
    const queue = [];
    const wrapper = ref();
    let pending = false;
    const placementArray = computed(() => {
      return props.placement.split("-");
    });
    const transition = computed(() => props.transitionName || nh.ns("popup-top"));
    provide(DELETE_HANDLER, deleteItem);
    watch(
      () => props.startOffset,
      (value, prevValue) => {
        items.value.forEach((item) => {
          item.verticalPosition += value - prevValue;
        });
      }
    );
    function getItemStyle(item) {
      const [verticalStyle, horizontalStyle] = placementArray.value;
      const style = { [verticalStyle]: `${item.verticalPosition}px` };
      if (horizontalStyle === "center") {
        style.left = "50%";
        style.transform = "translateX(-50%)";
      } else {
        style[horizontalStyle] = "24px";
      }
      return style;
    }
    function add(options) {
      return new Promise((resolve) => {
        const onOpen = gt(options.onOpen) ? options.onOpen : cn;
        options.onOpen = (key) => {
          resolve(key);
          onOpen();
        };
        queue.push({
          type: "add",
          param: options
        });
        if (!pending) {
          pending = true;
          queueOut();
        }
      });
    }
    function remove(key) {
      return new Promise((resolve) => {
        const item = find(key);
        if (!item)
          return resolve(false);
        const onClose = gt(item.onClose) ? item.onClose : cn;
        item.onClose = (reslut) => {
          resolve(reslut);
          onClose(reslut);
        };
        queue.push({
          type: "clear",
          param: key
        });
        if (!pending) {
          pending = true;
          queueOut();
        }
      });
    }
    function queueOut() {
      if (queue.length) {
        const state = queue.shift();
        if (state.type === "add") {
          renderItem2(state.param);
        } else {
          removeItem(state.param);
        }
        requestAnimationFrame(queueOut);
      } else {
        pending = false;
      }
    }
    function renderItem2(options) {
      var _a;
      let item = options.key ? find(options.key) : null;
      if (!(item == null ? void 0 : item.visible)) {
        const index = getIndex();
        const key = (_a = options.key) != null ? _a : nh.bs(`${index}`);
        let currentVertical = props.startOffset;
        items.value.forEach((existingItem) => {
          if (existingItem.visible) {
            currentVertical += existingItem.height + props.itemOffset;
          }
        });
        item = reactive(
          Object.assign(
            {
              key,
              content: "",
              closable: false,
              onOpen: cn,
              onClose: cn
            },
            options,
            {
              height: 0,
              visible: true,
              verticalPosition: currentVertical
            }
          )
        );
        items.value.push(item);
      }
      gt(options.onOpen) && options.onOpen(item.key);
    }
    function removeItem(key) {
      const index = items.value.findIndex((item) => item.key === key);
      if (~index) {
        const item = items.value[index];
        const removeHeight = item.height;
        item.visible = false;
        for (let i = index + 1, len = items.value.length; i < len; ++i) {
          items.value[i].verticalPosition -= removeHeight + props.itemOffset;
        }
        gt(item.onClose) && item.onClose(true);
      }
    }
    function deleteItem(key) {
      const index = items.value.findIndex((item) => item.key === key);
      if (~index) {
        items.value.splice(index, 1);
      }
    }
    function has(key) {
      return !~items.value.findIndex((item) => item.key === key);
    }
    function find(key) {
      return items.value.find((item) => item.key === key);
    }
    function clear() {
      queue.length = 0;
      items.value = [];
    }
    return {
      nh,
      items,
      transition,
      wrapper,
      getItemStyle,
      add,
      remove,
      has,
      find,
      clear
    };
  }
});
function _sfc_render59(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopupItem = resolveComponent("PopupItem");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bm(_ctx.placement)])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item) => {
      return openBlock(), createBlock(_component_PopupItem, {
        key: item.key,
        ref_for: true,
        ref: "instances",
        state: item,
        "transition-name": _ctx.transition,
        "inner-class": _ctx.innerClass,
        style: normalizeStyle(_ctx.getItemStyle(item))
      }, {
        default: withCtx(({ item: itemData }) => [
          renderSlot(_ctx.$slots, "item", { item: itemData })
        ]),
        _: 2
      }, 1032, ["state", "transition-name", "inner-class", "style"]);
    }), 128))
  ], 2);
}
var Popup = _export_sfc(_sfc_main59, [["render", _sfc_render59]]);

// node_modules/vexip-ui/es/components/message/message.mjs
var _sfc_main60 = defineComponent({
  name: "Message",
  components: {
    Icon,
    Renderer,
    Popup,
    Xmark: L2
  },
  setup() {
    const placement = ref("top");
    const popup = ref();
    async function add(options) {
      return popup.value ? await popup.value.add(options) : null;
    }
    async function remove(key) {
      return !!popup.value && await popup.value.remove(key);
    }
    function clear() {
      popup.value && popup.value.clear();
    }
    return {
      nh: useNameHelper("message"),
      effectiveTypes: ["info", "success", "warning", "error"],
      assertiveTypes: ["success", "warning", "error"],
      placement,
      placementCenter: computed(() => {
        return `${placement.value}-center`;
      }),
      popup,
      add,
      remove,
      clear
    };
  }
});
var _hoisted_130 = ["aria-live"];
var _hoisted_214 = ["innerHTML"];
var _hoisted_35 = ["onClick"];
function _sfc_render60(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Icon = resolveComponent("Icon");
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Popup = resolveComponent("Popup");
  return openBlock(), createBlock(_component_Popup, {
    ref: "popup",
    class: normalizeClass(_ctx.nh.b()),
    "transition-name": _ctx.nh.ns(`popup-${_ctx.placement}`),
    placement: _ctx.placementCenter
  }, {
    item: withCtx(({ item }) => [
      createBaseVNode("div", {
        class: normalizeClass([
          {
            [_ctx.nh.be("item")]: true,
            [_ctx.nh.bs("vars")]: true,
            [_ctx.nh.bem("item", item.type)]: item.type && _ctx.effectiveTypes.includes(item.type),
            [_ctx.nh.bem("item", "background")]: item.background,
            [_ctx.nh.bem("item", "color")]: item.background && item.color,
            [_ctx.nh.bem("item", "color-only")]: !item.background && item.color,
            [_ctx.nh.bem("item", "has-icon")]: item.icon,
            [_ctx.nh.bem("item", "closable")]: item.closable
          },
          item.className
        ]),
        role: "alert",
        style: normalizeStyle([
          {
            color: typeof item.color === "string" ? item.color : void 0,
            backgroundColor: typeof item.background === "string" ? item.background : void 0
          },
          item.style || {}
        ]),
        "aria-atomic": "true",
        "aria-live": item.type && _ctx.assertiveTypes.includes(item.type) ? "assertive" : "polite"
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("wrapper"))
        }, [
          item.icon ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("icon")),
            style: normalizeStyle({ color: item.iconColor })
          }, [
            typeof item.icon === "function" ? (openBlock(), createBlock(_component_Renderer, {
              key: 0,
              renderer: item.icon,
              data: item
            }, null, 8, ["renderer", "data"])) : item.icon ? (openBlock(), createBlock(_component_Icon, {
              key: 1,
              icon: item.icon,
              style: normalizeStyle([{ color: item.iconColor }, item.icon.style])
            }, null, 8, ["icon", "style"])) : createCommentVNode("", true)
          ], 6)) : createCommentVNode("", true),
          typeof item.renderer === "function" ? (openBlock(), createBlock(_component_Renderer, {
            key: 1,
            renderer: item.renderer,
            data: item
          }, null, 8, ["renderer", "data"])) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
            item.parseHtml ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("content")),
              innerHTML: item.content
            }, null, 10, _hoisted_214)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(_ctx.nh.be("content"))
            }, toDisplayString(item.content || ""), 3))
          ], 64))
        ], 2),
        item.closable ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("close")),
          onClick: ($event) => _ctx.remove(item.key)
        }, [
          createVNode(_component_Icon, { label: "close" }, {
            default: withCtx(() => [
              createVNode(_component_Xmark)
            ]),
            _: 1
          })
        ], 10, _hoisted_35)) : createCommentVNode("", true)
      ], 14, _hoisted_130)
    ]),
    _: 1
  }, 8, ["class", "transition-name", "placement"]);
}
var Component4 = _export_sfc(_sfc_main60, [["render", _sfc_render60]]);

// node_modules/vexip-ui/es/components/message/index.mjs
var conveniences = {
  info: {
    icon: x3
  },
  success: {
    icon: x2
  },
  warning: {
    icon: $19
  },
  error: {
    icon: u
  }
};
var placementWhiteList = ["top", "bottom"];
var count = 1;
function getKey() {
  return `message-${count++}`;
}
var MessageManager = class {
  constructor(options = {}) {
    options = {
      ...options,
      duration: options.duration ? En(options.duration) : 3e3
    };
    this._instance = null;
    this._innerApp = null;
    this._container = null;
    this.name = "Message";
    this.defaults = {};
    this.config(options);
    this.open = (content, duration) => {
      return this._open(null, content, duration);
    };
    this.info = (content, duration) => {
      return this._open("info", content, duration);
    };
    this.success = (content, duration) => {
      return this._open("success", content, duration);
    };
    this.warning = (content, duration) => {
      return this._open("warning", content, duration);
    };
    this.error = (content, duration) => {
      return this._open("error", content, duration);
    };
  }
  judge(state, success, error, duration) {
    if (state) {
      this.success(success, duration);
    } else {
      this.error(error, duration);
    }
  }
  close(key) {
    if (qe(key)) {
      this.clear();
    } else {
      this._getInstance().remove(key);
    }
  }
  config({ placement, ...others }) {
    if (placement) {
      this._getInstance().placement = placementWhiteList.includes(placement) ? placement : placementWhiteList[0];
    }
    this.defaults = { ...this.defaults, ...others };
  }
  clone() {
    return new MessageManager(this.defaults);
  }
  clear() {
    this._getInstance().clear();
  }
  destroy() {
    var _a;
    (_a = this._innerApp) == null ? void 0 : _a.unmount();
    Jn(this);
  }
  isDestroyed() {
    return false;
  }
  install(app, options = {}) {
    const { property, ...others } = options;
    this.config(others);
    app.config.globalProperties[property || "$message"] = this;
  }
  _getInstance() {
    if (!this._instance) {
      this._container = document.createElement("div");
      this._innerApp = createApp(Component4);
      this._instance = this._innerApp.mount(this._container);
      document.body.appendChild(this._container.firstElementChild);
    }
    return this._instance;
  }
  _open(type, content, _duration) {
    var _a, _b;
    if (!V) {
      return cn;
    }
    const options = typeof content === "string" ? { content, duration: _duration } : content;
    const key = (_a = options.key) != null ? _a : getKey();
    const message = this._getInstance();
    const convenienceOptions = type ? (_b = conveniences[type]) != null ? _b : {} : {};
    let timer2;
    const userCloseFn = options.onClose;
    const onClose = () => {
      clearTimeout(timer2);
      if (typeof userCloseFn === "function") {
        return userCloseFn();
      }
    };
    const item = Object.assign({}, this.defaults, convenienceOptions, options, {
      key,
      type,
      onClose
    });
    if (item.icon && typeof item.icon !== "function") {
      item.icon = markRaw(item.icon);
    }
    message.add(item);
    const duration = typeof item.duration === "number" ? item.duration : 3e3;
    if (duration >= 500) {
      timer2 = setTimeout(() => {
        message.remove(key);
      }, duration);
    }
    return () => {
      clearTimeout(timer2);
      message.remove(key);
    };
  }
};
var Message = new MessageManager();

// node_modules/vexip-ui/es/components/notice/notice.mjs
var _sfc_main61 = defineComponent({
  name: "Notice",
  components: {
    Icon,
    Renderer,
    Popup,
    Xmark: L2
  },
  setup() {
    const placement = ref("top-right");
    const popup = ref();
    async function add(options) {
      return popup.value ? await popup.value.add(options) : null;
    }
    async function remove(key) {
      return !!popup.value && await popup.value.remove(key);
    }
    function clear() {
      popup.value && popup.value.clear();
    }
    return {
      nh: useNameHelper("notice"),
      effectiveTypes: ["info", "success", "warning", "error"],
      assertiveTypes: ["success", "warning", "error"],
      placement,
      popup,
      add,
      remove,
      clear
    };
  }
});
var _hoisted_131 = ["aria-live"];
var _hoisted_215 = ["innerHTML"];
var _hoisted_36 = ["innerHTML"];
var _hoisted_43 = ["onClick"];
function _sfc_render61(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Icon = resolveComponent("Icon");
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Popup = resolveComponent("Popup");
  return openBlock(), createBlock(_component_Popup, {
    ref: "popup",
    class: normalizeClass(_ctx.nh.b()),
    "transition-name": _ctx.nh.ns(`popup-${_ctx.placement.split("-")[1]}`),
    placement: _ctx.placement
  }, {
    item: withCtx(({ item }) => [
      createBaseVNode("div", {
        class: normalizeClass([
          {
            [_ctx.nh.be("item")]: true,
            [_ctx.nh.bs("vars")]: true,
            [_ctx.nh.bem("item", "title-only")]: !item.content && typeof item.renderer !== "function",
            [_ctx.nh.bem("item", "has-icon")]: item.icon,
            [_ctx.nh.bem("item", "content-only")]: !item.title,
            [_ctx.nh.bem("item", item.type)]: item.type && _ctx.effectiveTypes.includes(item.type),
            [_ctx.nh.bem("item", "background")]: item.background,
            [_ctx.nh.bem("item", "color")]: item.background && item.color,
            [_ctx.nh.bem("item", "color-only")]: !item.background && item.color,
            [_ctx.nh.bem("item", "marker")]: item.marker
          },
          item.className
        ]),
        role: "alert",
        style: normalizeStyle([
          {
            color: typeof item.color === "string" ? item.color : void 0,
            backgroundColor: typeof item.background === "string" ? item.background : void 0
          },
          item.style || {}
        ]),
        "aria-atomic": "true",
        "aria-live": item.type && _ctx.assertiveTypes.includes(item.type) ? "assertive" : "polite"
      }, [
        item.icon ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("icon")),
          style: normalizeStyle({ color: item.iconColor })
        }, [
          typeof item.icon === "function" ? (openBlock(), createBlock(_component_Renderer, {
            key: 0,
            renderer: item.icon,
            data: item
          }, null, 8, ["renderer", "data"])) : item.icon ? (openBlock(), createBlock(_component_Icon, {
            key: 1,
            icon: item.icon,
            scale: !item.content && typeof item.renderer !== "function" ? 1 : 2,
            style: normalizeStyle([{ color: item.iconColor }, item.icon.style])
          }, null, 8, ["icon", "scale", "style"])) : createCommentVNode("", true)
        ], 6)) : createCommentVNode("", true),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("wrapper"))
        }, [
          typeof item.renderer === "function" ? (openBlock(), createBlock(_component_Renderer, {
            key: 0,
            renderer: item.renderer,
            data: item
          }, null, 8, ["renderer", "data"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            item.title ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              item.parseHtml ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(_ctx.nh.be("title")),
                style: normalizeStyle({
                  color: typeof item.titleColor === "string" ? item.titleColor : void 0
                }),
                innerHTML: item.title
              }, null, 14, _hoisted_215)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(_ctx.nh.be("title")),
                style: normalizeStyle({
                  color: typeof item.titleColor === "string" ? item.titleColor : void 0
                })
              }, toDisplayString(item.title || ""), 7))
            ], 64)) : createCommentVNode("", true),
            item.content ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              item.parseHtml ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(_ctx.nh.be("content")),
                innerHTML: item.content
              }, null, 10, _hoisted_36)) : (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(_ctx.nh.be("content"))
              }, toDisplayString(item.content || ""), 3))
            ], 64)) : createCommentVNode("", true)
          ], 64))
        ], 2),
        item.closable ? (openBlock(), createElementBlock("button", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("close")),
          onClick: ($event) => _ctx.remove(item.key)
        }, [
          createVNode(_component_Icon, { label: "close" }, {
            default: withCtx(() => [
              createVNode(_component_Xmark)
            ]),
            _: 1
          })
        ], 10, _hoisted_43)) : createCommentVNode("", true)
      ], 14, _hoisted_131)
    ]),
    _: 1
  }, 8, ["class", "transition-name", "placement"]);
}
var Component5 = _export_sfc(_sfc_main61, [["render", _sfc_render61]]);

// node_modules/vexip-ui/es/components/notice/index.mjs
var conveniences2 = {
  info: {
    icon: x3
  },
  success: {
    icon: x2
  },
  warning: {
    icon: $19
  },
  error: {
    icon: u
  }
};
var placementWhiteList2 = [
  "top-right",
  "top-left",
  "bottom-right",
  "bottom-left"
];
var count2 = 1;
function getKey2() {
  return `notice-${count2++}`;
}
var NoticeManager = class {
  constructor(options = {}) {
    options = {
      ...options,
      marker: !!options.marker,
      duration: options.duration ? En(options.duration) : 4e3
    };
    this._instance = null;
    this._innerApp = null;
    this._container = null;
    this.name = "Notice";
    this.defaults = {};
    this.config(options);
    this.open = (title, content, duration) => {
      return this._open(null, title, content, duration);
    };
    this.info = (title, content, duration) => {
      return this._open("info", title, content, duration);
    };
    this.success = (title, content, duration) => {
      return this._open("success", title, content, duration);
    };
    this.warning = (title, content, duration) => {
      return this._open("warning", title, content, duration);
    };
    this.error = (title, content, duration) => {
      return this._open("error", title, content, duration);
    };
  }
  judge(state, success, error, duration) {
    if (state) {
      this.success(success, duration);
    } else {
      this.error(error, duration);
    }
  }
  close(key) {
    if (qe(key)) {
      this.clear();
    } else {
      this._getInstance().remove(key);
    }
  }
  config({ placement, ...others }) {
    if (placement) {
      this._getInstance().placement = placementWhiteList2.includes(placement) ? placement : placementWhiteList2[0];
    }
    this.defaults = { ...this.defaults, ...others };
  }
  clone() {
    return new NoticeManager(this.defaults);
  }
  clear() {
    this._getInstance().clear();
  }
  destroy() {
    var _a;
    (_a = this._innerApp) == null ? void 0 : _a.unmount();
    Jn(this);
  }
  isDestroyed() {
    return false;
  }
  install(app, options = {}) {
    const { property, ...others } = options;
    this.config(others);
    app.config.globalProperties[property || "$notice"] = this;
  }
  _getInstance() {
    if (!this._instance) {
      this._container = document.createElement("div");
      this._innerApp = createApp(Component5);
      this._instance = this._innerApp.mount(this._container);
      document.body.appendChild(this._container.firstElementChild);
    }
    return this._instance;
  }
  _open(type, title, content, _duration) {
    var _a, _b;
    if (!V) {
      return cn;
    }
    let options;
    if (L(title)) {
      options = title;
    } else {
      if (typeof content === "number") {
        options = { title, duration: content };
      } else if (!content) {
        options = { title, duration: _duration };
      } else {
        options = { title, content, duration: _duration };
      }
    }
    const key = (_a = options.key) != null ? _a : getKey2();
    const notice = this._getInstance();
    const convenienceOptions = type ? (_b = conveniences2[type]) != null ? _b : {} : {};
    let timer2;
    const userCloseFn = options.onClose;
    const onClose = () => {
      clearTimeout(timer2);
      if (typeof userCloseFn === "function") {
        return userCloseFn();
      }
    };
    const item = Object.assign({}, this.defaults, convenienceOptions, options, {
      key,
      type,
      onClose
    });
    if (item.icon && typeof item.icon !== "function") {
      item.icon = markRaw(item.icon);
    }
    notice.add(item);
    const duration = typeof item.duration === "number" ? item.duration : 4e3;
    if (duration >= 500) {
      timer2 = setTimeout(() => {
        notice.remove(key);
      }, duration);
    }
    return () => {
      clearTimeout(timer2);
      notice.remove(key);
    };
  }
};
var Notice = new NoticeManager();

// node_modules/vexip-ui/es/components/option/option-group.mjs
var _sfc_main62 = defineComponent({
  name: "OptionGroup",
  props: {
    label: {
      type: String,
      default: ""
    },
    divided: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      nh: useNameHelper("option-group")
    };
  }
});
function _sfc_render62(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass({
      [_ctx.nh.b()]: true,
      [_ctx.nh.ns("option-vars")]: true,
      [_ctx.nh.bm("divided")]: _ctx.divided
    })
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("label"))
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 2),
    createBaseVNode("ul", {
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)
  ], 2);
}
var OptionGroup = _export_sfc(_sfc_main62, [["render", _sfc_render62]]);

// node_modules/vexip-ui/es/components/pagination/props.mjs
var paginationProps = buildProps({
  size: sizeProp,
  total: Number,
  noBorder: booleanProp,
  background: booleanProp,
  pageSize: Number,
  sizeOptions: Array,
  maxCount: Number,
  active: Number,
  disabled: booleanProp,
  disableItem: Function,
  turnPageCount: Number,
  pageJump: booleanProp,
  pageCount: booleanProp,
  pageTotal: booleanProp,
  itemUnit: String,
  plugins: Array,
  noTitle: booleanProp,
  onChange: eventProp(),
  onPageSizeChange: eventProp()
});

// node_modules/vexip-ui/es/components/pagination/pagination.mjs
var PaginationMode = ((PaginationMode2) => {
  PaginationMode2["LEFT"] = "left";
  PaginationMode2["CENTER"] = "center";
  PaginationMode2["RIGHT"] = "right";
  return PaginationMode2;
})(PaginationMode || {});
var _sfc_main63 = defineComponent({
  name: "Pagination",
  components: {
    Icon,
    NumberInput,
    Select,
    ChevronRight: $17,
    ChevronLeft: $16,
    AnglesRight: C,
    AnglesLeft: $5,
    Ellipsis: x6
  },
  props: paginationProps,
  emits: ["update:active", "update:page-size"],
  setup(_props, { emit }) {
    const props = useProps("pagination", _props, {
      size: createSizeProp(),
      total: {
        default: 0,
        validator: (value) => value >= 0,
        static: true
      },
      noBorder: false,
      background: false,
      pageSize: {
        default: 10,
        validator: (value) => value > 0
      },
      sizeOptions: () => [10, 20, 50, 100],
      maxCount: {
        default: 7,
        validator: (value) => value === parseInt(value.toString()) && value > 6
      },
      active: {
        default: 1,
        validator: (value) => value > 0,
        static: true
      },
      disabled: false,
      disableItem: {
        default: () => false,
        isFunc: true
      },
      turnPageCount: 5,
      pageJump: false,
      pageCount: false,
      pageTotal: false,
      itemUnit: null,
      plugins: null,
      noTitle: false
    });
    const nh = useNameHelper("pagination");
    const currentPagers = ref([]);
    const currentActive = ref(props.active);
    const currentPageSize = ref(props.pageSize);
    const mode = ref("left");
    const inPrevEllipsis = ref(false);
    const inNextEllipsis = ref(false);
    const jumpValue = ref(props.active);
    const itemElList = ref([]);
    const locale = useLocale("pagination");
    const { target: wrapper } = No({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down || modifier.left || modifier.right) {
          event.preventDefault();
          const sign = modifier.up || modifier.left ? -1 : 1;
          if (V && document.activeElement) {
            const index = itemElList.value.findIndex((el) => el === document.activeElement);
            if (!~index)
              return;
            const target = itemElList.value[Fn(index + sign, 0, itemElList.value.length - 1)];
            target.focus();
          }
        } else if (modifier.enter || modifier.space) {
          event.preventDefault();
          if (document && document.activeElement) {
            const index = itemElList.value.findIndex((el) => el === document.activeElement);
            if (!~index) {
              const activeClass = nh.bem("item", "active");
              const activeEl = itemElList.value.find(
                (el) => el.classList.contains(activeClass)
              );
              activeEl == null ? void 0 : activeEl.focus();
            }
          }
        }
      }
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.size)]: props.size !== "default",
        [nh.bm("background")]: props.background,
        [nh.bm("no-border")]: props.noBorder,
        [nh.bm("disabled")]: props.disabled
      };
    });
    const pagerCount = computed(() => {
      return Math.ceil(props.total / (currentPageSize.value || 1)) || 1;
    });
    const disabledPrev = computed(() => {
      const count3 = queryEnabledActive(1, 1);
      return count3 >= pagerCount.value || currentActive.value === count3;
    });
    const disabledNext = computed(() => {
      const count3 = queryEnabledActive(pagerCount.value, -1);
      return count3 <= 1 || currentActive.value === count3;
    });
    const prevTurnPageTitle = computed(() => {
      return `${locale.value.prev} ${getCountWord(locale.value.page, props.turnPageCount)}`;
    });
    const nextTurnPageTitle = computed(() => {
      return `${locale.value.next} ${getCountWord(locale.value.page, props.turnPageCount)}`;
    });
    const useEllipsis = computed(() => {
      return pagerCount.value > props.maxCount;
    });
    const prevEllipsisTarget = computed(() => {
      if (!useEllipsis.value)
        return 0;
      let active = queryEnabledActive(currentActive.value - props.turnPageCount, -1);
      if (active < 1) {
        active = queryEnabledActive(active + 1, 1);
        if (active >= currentActive.value)
          return 0;
      }
      return active;
    });
    const nextEllipsisTarget = computed(() => {
      if (!useEllipsis.value)
        return 0;
      let active = queryEnabledActive(currentActive.value + props.turnPageCount, 1);
      if (active > pagerCount.value) {
        active = queryEnabledActive(active - 1, -1);
        if (active <= currentActive.value)
          return 0;
      }
      return active;
    });
    const sizeObjectOptions = computed(() => {
      return props.sizeOptions.map((size) => {
        return {
          value: size,
          label: `${size} ${locale.value.prePage}`
        };
      });
    });
    const usedPlugins = computed(() => {
      if (props.plugins) {
        return props.plugins;
      }
      const plugins = [void 0];
      props.pageTotal && plugins.push("total");
      props.pageCount && plugins.push("size");
      props.pageJump && plugins.push("jump");
      if (plugins.length) {
        pr(
          "[vexip-ui:Pagination] 'page-jump', 'page-count' and 'page-total' props have been deprecated, please using 'plugins' prop to instead them"
        );
      }
      return plugins;
    });
    const pluginOrders = computed(() => {
      const plugins = usedPlugins.value;
      const pagerPosition = plugins.findIndex(qe);
      return {
        total: plugins.findIndex((p) => p === "total") - pagerPosition,
        size: plugins.findIndex((p) => p === "size") - pagerPosition,
        jump: plugins.findIndex((p) => p === "jump") - pagerPosition
      };
    });
    const jumpInputWidth = computed(() => {
      if (!usedPlugins.value.includes("jump"))
        return 0;
      let pageCount = 0;
      if (usedPlugins.value.includes("size")) {
        pageCount = Math.ceil(props.total / (Math.min(...props.sizeOptions) || 10));
      } else {
        pageCount = Math.ceil(props.total / (props.pageSize || 10));
      }
      return pageCount.toString().length * 10 + 30;
    });
    watch(
      () => props.active,
      (value) => {
        changeActive(value, false);
      }
    );
    watch(currentActive, (value) => {
      computePagers();
      jumpValue.value = value;
      emitEvent(props.onChange, value);
      emit("update:active", value);
    });
    watch(() => props.maxCount, computePagers);
    watch(pagerCount, computePagers);
    watch(
      () => props.pageSize,
      (value) => {
        currentPageSize.value = value;
      }
    );
    watch(currentPageSize, (value, prevValue) => {
      emitEvent(props.onPageSizeChange, value);
      emit("update:page-size", value);
      const anchor = Math.ceil((prevValue * (currentActive.value - 1) + 1) / value);
      let active = queryEnabledActive(anchor, 1);
      if (active > pagerCount.value) {
        active = queryEnabledActive(anchor - 1, -1);
        if (active < 1)
          active = 0;
      }
      currentActive.value = active;
    });
    onMounted(() => {
      nextTick(computePagers);
    });
    onBeforeUpdate(() => {
      itemElList.value.length = 0;
    });
    function queryEnabledActive(active, step) {
      step = step / Math.abs(step);
      while (props.disableItem(active)) {
        active += step;
        if (active < 1 || active > pagerCount.value)
          break;
      }
      return active;
    }
    function changeActive(active, focus = true) {
      active = parseInt(active.toString());
      if (props.disabled || active < 1 || active > pagerCount.value || props.disableItem(active)) {
        return;
      }
      currentActive.value = active;
      if (V && focus) {
        const activeEl = itemElList.value.find((el) => el === document.activeElement);
        activeEl == null ? void 0 : activeEl.blur();
        nextTick(() => {
          const el = itemElList.value.find((el2) => el2.tabIndex >= 0);
          el == null ? void 0 : el.focus();
        });
      }
    }
    function handlePrev() {
      if (!disabledPrev.value && !props.disabled) {
        const active = queryEnabledActive(currentActive.value - 1, -1);
        if (active >= 1)
          changeActive(active);
      }
    }
    function handleNext() {
      if (!disabledNext.value && !props.disabled) {
        const active = queryEnabledActive(currentActive.value + 1, 1);
        if (active <= pagerCount.value)
          changeActive(active);
      }
    }
    function computePagers() {
      let pagers;
      if (pagerCount.value <= props.maxCount) {
        pagers = un(pagerCount.value);
      } else {
        const numberCount = props.maxCount - 2;
        const criticalCount = Math.ceil(props.maxCount / 2);
        if (currentActive.value < criticalCount) {
          pagers = un(numberCount);
          pagers.push(pagerCount.value);
          mode.value = "left";
        } else if (currentActive.value <= pagerCount.value - criticalCount) {
          let count3 = numberCount - 2;
          if (count3 % 2 === 0) {
            count3 -= 1;
          }
          pagers = un(count3, currentActive.value - (count3 - 1) / 2);
          pagers.unshift(1);
          pagers.push(pagerCount.value);
          mode.value = "center";
        } else {
          pagers = un(numberCount, pagerCount.value - numberCount + 1);
          pagers.unshift(1);
          mode.value = "right";
        }
      }
      if (pagers.length === 1) {
        currentPagers.value = [];
      }
      currentPagers.value = pagers.slice(1, -1);
    }
    function handleEnterPrevEllipsis() {
      inPrevEllipsis.value = true;
    }
    function handleLeavePrevEllipsis() {
      inPrevEllipsis.value = false;
    }
    function handleClickPrevEllipsis() {
      if (!props.disabled && prevEllipsisTarget.value) {
        changeActive(prevEllipsisTarget.value);
      }
    }
    function handleEnterNextEllipsis() {
      inNextEllipsis.value = true;
    }
    function handleLeaveNextEllipsis() {
      inNextEllipsis.value = false;
    }
    function handleClickNextEllipsis() {
      if (!props.disabled && nextEllipsisTarget.value) {
        changeActive(nextEllipsisTarget.value);
      }
    }
    function handleJumpPage(active) {
      active = Math.max(Math.min(parseInt(active.toString()), pagerCount.value), 1);
      const originActive = active;
      if (active !== currentActive.value) {
        const step = active > currentActive.value ? 1 : -1;
        active = queryEnabledActive(originActive, step);
        if (step > 0 ? active > pagerCount.value : active < 1) {
          active = queryEnabledActive(originActive, -step);
          if (step > 0 ? active < 1 : active > pagerCount.value) {
            active = 0;
          }
        }
        currentActive.value = active;
      }
      nextTick(() => {
        jumpValue.value = currentActive.value;
      });
    }
    return {
      props,
      nh,
      locale,
      currentPagers,
      currentActive,
      currentPageSize,
      mode,
      inPrevEllipsis,
      inNextEllipsis,
      jumpValue,
      itemElList,
      className,
      pagerCount,
      disabledPrev,
      disabledNext,
      prevTurnPageTitle,
      nextTurnPageTitle,
      useEllipsis,
      prevEllipsisTarget,
      nextEllipsisTarget,
      sizeObjectOptions,
      usedPlugins,
      pluginOrders,
      jumpInputWidth,
      wrapper,
      isFunction: gt,
      getCountWord,
      getCountWordOnly,
      changeActive,
      handlePrev,
      handleNext,
      handleEnterPrevEllipsis,
      handleLeavePrevEllipsis,
      handleClickPrevEllipsis,
      handleEnterNextEllipsis,
      handleLeaveNextEllipsis,
      handleClickNextEllipsis,
      handleJumpPage
    };
  }
});
var _hoisted_132 = ["aria-disabled"];
var _hoisted_216 = ["title", "aria-label", "aria-hidden"];
var _hoisted_37 = ["title", "tabindex", "aria-setsize", "aria-disabled"];
var _hoisted_44 = ["title", "aria-label"];
var _hoisted_5 = ["tabindex", "aria-posinset", "aria-setsize", "aria-disabled", "onClick", "onKeydown"];
var _hoisted_6 = ["title", "aria-label"];
var _hoisted_7 = ["title", "tabindex", "aria-posinset", "aria-setsize", "aria-disabled"];
var _hoisted_8 = ["title", "aria-label", "aria-hidden"];
function _sfc_render63(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_ChevronLeft = resolveComponent("ChevronLeft");
  const _component_Icon = resolveComponent("Icon");
  const _component_AnglesLeft = resolveComponent("AnglesLeft");
  const _component_Ellipsis = resolveComponent("Ellipsis");
  const _component_AnglesRight = resolveComponent("AnglesRight");
  const _component_ChevronRight = resolveComponent("ChevronRight");
  const _component_Select = resolveComponent("Select");
  const _component_NumberInput = resolveComponent("NumberInput");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className)
  }, [
    createBaseVNode("ul", {
      ref: "wrapper",
      class: normalizeClass(_ctx.nh.be("list")),
      role: "menubar",
      "aria-label": "Pagination",
      "aria-disabled": _ctx.props.disabled ? "true" : void 0
    }, [
      createBaseVNode("li", {
        ref: (el) => el && !_ctx.disabledPrev && _ctx.itemElList.push(el),
        class: normalizeClass([
          _ctx.nh.be("item"),
          _ctx.nh.bem("item", "prev"),
          _ctx.disabledPrev ? _ctx.nh.bem("item", "disabled") : ""
        ]),
        title: _ctx.props.noTitle ? void 0 : _ctx.locale.prevPage,
        role: "menuitem",
        tabindex: "-1",
        "aria-label": _ctx.locale.prevPage,
        "aria-hidden": _ctx.disabledPrev ? "true" : void 0,
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handlePrev && _ctx.handlePrev(...args)),
        onKeydown: [
          _cache[1] || (_cache[1] = withKeys((...args) => _ctx.handlePrev && _ctx.handlePrev(...args), ["enter"])),
          _cache[2] || (_cache[2] = withKeys((...args) => _ctx.handlePrev && _ctx.handlePrev(...args), ["space"]))
        ]
      }, [
        renderSlot(_ctx.$slots, "prev", {}, () => [
          createVNode(_component_Icon, { scale: 0.8 }, {
            default: withCtx(() => [
              createVNode(_component_ChevronLeft)
            ]),
            _: 1
          }, 8, ["scale"])
        ])
      ], 42, _hoisted_216),
      createBaseVNode("li", {
        ref: (el) => el && _ctx.itemElList.push(el),
        class: normalizeClass({
          [_ctx.nh.be("item")]: true,
          [_ctx.nh.bem("item", "disabled")]: _ctx.props.disableItem(1),
          [_ctx.nh.bem("item", "active")]: _ctx.currentActive === 1
        }),
        title: _ctx.props.noTitle ? void 0 : "1",
        role: "menuitemradio",
        tabindex: _ctx.currentActive === 1 ? "0" : "-1",
        "aria-posinset": "1",
        "aria-setsize": _ctx.pagerCount,
        "aria-disabled": _ctx.props.disableItem(1) ? "true" : void 0,
        onClick: _cache[3] || (_cache[3] = ($event) => _ctx.changeActive(1)),
        onKeydown: [
          _cache[4] || (_cache[4] = withKeys(($event) => _ctx.changeActive(1), ["enter"])),
          _cache[5] || (_cache[5] = withKeys(($event) => _ctx.changeActive(1), ["space"]))
        ]
      }, [
        renderSlot(_ctx.$slots, "item", { page: 1 }, () => [
          createTextVNode(toDisplayString(1))
        ])
      ], 42, _hoisted_37),
      _ctx.useEllipsis && _ctx.mode !== "left" ? (openBlock(), createElementBlock("li", {
        key: 0,
        ref: (el) => el && _ctx.itemElList.push(el),
        class: normalizeClass({
          [_ctx.nh.be("item")]: true,
          [_ctx.nh.bem("item", "more")]: true,
          [_ctx.nh.bem("item", "disabled")]: !_ctx.prevEllipsisTarget
        }),
        title: _ctx.props.noTitle ? void 0 : _ctx.prevTurnPageTitle,
        role: "menuitem",
        tabindex: "-1",
        "aria-label": _ctx.prevTurnPageTitle,
        onClick: _cache[6] || (_cache[6] = (...args) => _ctx.handleClickPrevEllipsis && _ctx.handleClickPrevEllipsis(...args)),
        onKeydown: [
          _cache[7] || (_cache[7] = withKeys((...args) => _ctx.handleClickPrevEllipsis && _ctx.handleClickPrevEllipsis(...args), ["enter"])),
          _cache[8] || (_cache[8] = withKeys((...args) => _ctx.handleClickPrevEllipsis && _ctx.handleClickPrevEllipsis(...args), ["space"]))
        ],
        onMouseenter: _cache[9] || (_cache[9] = (...args) => _ctx.handleEnterPrevEllipsis && _ctx.handleEnterPrevEllipsis(...args)),
        onMouseleave: _cache[10] || (_cache[10] = (...args) => _ctx.handleLeavePrevEllipsis && _ctx.handleLeavePrevEllipsis(...args))
      }, [
        createVNode(Transition, {
          name: _ctx.nh.ns("fade")
        }, {
          default: withCtx(() => [
            _ctx.inPrevEllipsis ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              scale: 0.8
            }, {
              default: withCtx(() => [
                createVNode(_component_AnglesLeft)
              ]),
              _: 1
            }, 8, ["scale"])) : (openBlock(), createBlock(_component_Icon, {
              key: 1,
              scale: 0.8,
              style: { "position": "absolute" }
            }, {
              default: withCtx(() => [
                createVNode(_component_Ellipsis)
              ]),
              _: 1
            }, 8, ["scale"]))
          ]),
          _: 1
        }, 8, ["name"])
      ], 42, _hoisted_44)) : createCommentVNode("", true),
      _ctx.currentPagers.length ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.currentPagers, (page, index) => {
        return openBlock(), createElementBlock("li", {
          key: index,
          ref_for: true,
          ref: (el) => el && _ctx.itemElList.push(el),
          class: normalizeClass({
            [_ctx.nh.be("item")]: true,
            [_ctx.nh.bem("item", "disabled")]: _ctx.props.disableItem(page),
            [_ctx.nh.bem("item", "active")]: _ctx.currentActive === page
          }),
          role: "menuitemradio",
          tabindex: _ctx.currentActive === page ? "0" : "-1",
          "aria-posinset": page,
          "aria-setsize": _ctx.pagerCount,
          "aria-disabled": _ctx.props.disableItem(page) ? "true" : void 0,
          onClick: ($event) => _ctx.changeActive(page),
          onKeydown: [
            withKeys(($event) => _ctx.changeActive(page), ["enter"]),
            withKeys(($event) => _ctx.changeActive(page), ["space"])
          ]
        }, [
          renderSlot(_ctx.$slots, "item", { page }, () => [
            createTextVNode(toDisplayString(page), 1)
          ])
        ], 42, _hoisted_5);
      }), 128)) : createCommentVNode("", true),
      _ctx.useEllipsis && _ctx.mode !== "right" ? (openBlock(), createElementBlock("li", {
        key: 2,
        ref: (el) => el && _ctx.itemElList.push(el),
        class: normalizeClass({
          [_ctx.nh.be("item")]: true,
          [_ctx.nh.bem("item", "more")]: true,
          [_ctx.nh.bem("item", "disabled")]: !_ctx.nextEllipsisTarget
        }),
        title: _ctx.props.noTitle ? void 0 : _ctx.nextTurnPageTitle,
        role: "menuitem",
        tabindex: "-1",
        "aria-label": _ctx.nextTurnPageTitle,
        onClick: _cache[11] || (_cache[11] = (...args) => _ctx.handleClickNextEllipsis && _ctx.handleClickNextEllipsis(...args)),
        onKeydown: [
          _cache[12] || (_cache[12] = withKeys((...args) => _ctx.handleClickNextEllipsis && _ctx.handleClickNextEllipsis(...args), ["enter"])),
          _cache[13] || (_cache[13] = withKeys((...args) => _ctx.handleClickNextEllipsis && _ctx.handleClickNextEllipsis(...args), ["space"]))
        ],
        onMouseenter: _cache[14] || (_cache[14] = (...args) => _ctx.handleEnterNextEllipsis && _ctx.handleEnterNextEllipsis(...args)),
        onMouseleave: _cache[15] || (_cache[15] = (...args) => _ctx.handleLeaveNextEllipsis && _ctx.handleLeaveNextEllipsis(...args))
      }, [
        createVNode(Transition, {
          name: _ctx.nh.ns("fade")
        }, {
          default: withCtx(() => [
            _ctx.inNextEllipsis ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              scale: 0.8
            }, {
              default: withCtx(() => [
                createVNode(_component_AnglesRight)
              ]),
              _: 1
            }, 8, ["scale"])) : (openBlock(), createBlock(_component_Icon, {
              key: 1,
              scale: 0.8,
              style: { "position": "absolute" }
            }, {
              default: withCtx(() => [
                createVNode(_component_Ellipsis)
              ]),
              _: 1
            }, 8, ["scale"]))
          ]),
          _: 1
        }, 8, ["name"])
      ], 42, _hoisted_6)) : createCommentVNode("", true),
      _ctx.pagerCount > 1 ? (openBlock(), createElementBlock("li", {
        key: 3,
        ref: (el) => el && _ctx.itemElList.push(el),
        class: normalizeClass({
          [_ctx.nh.be("item")]: true,
          [_ctx.nh.bem("item", "disabled")]: _ctx.props.disableItem(_ctx.pagerCount),
          [_ctx.nh.bem("item", "active")]: _ctx.currentActive === _ctx.pagerCount
        }),
        title: _ctx.props.noTitle ? void 0 : `${_ctx.pagerCount}`,
        role: "menuitemradio",
        tabindex: _ctx.currentActive === _ctx.pagerCount ? "0" : "-1",
        "aria-posinset": _ctx.pagerCount,
        "aria-setsize": _ctx.pagerCount,
        "aria-disabled": _ctx.props.disableItem(_ctx.pagerCount) ? "true" : void 0,
        onClick: _cache[16] || (_cache[16] = ($event) => _ctx.changeActive(_ctx.pagerCount)),
        onKeydown: [
          _cache[17] || (_cache[17] = withKeys(($event) => _ctx.changeActive(_ctx.pagerCount), ["enter"])),
          _cache[18] || (_cache[18] = withKeys(($event) => _ctx.changeActive(_ctx.pagerCount), ["space"]))
        ]
      }, [
        renderSlot(_ctx.$slots, "item", { page: _ctx.pagerCount }, () => [
          createTextVNode(toDisplayString(_ctx.pagerCount), 1)
        ])
      ], 42, _hoisted_7)) : createCommentVNode("", true),
      createBaseVNode("li", {
        ref: (el) => el && !_ctx.disabledNext && _ctx.itemElList.push(el),
        class: normalizeClass([
          _ctx.nh.be("item"),
          _ctx.nh.bem("item", "next"),
          _ctx.disabledNext ? _ctx.nh.bem("item", "disabled") : ""
        ]),
        title: _ctx.props.noTitle ? void 0 : _ctx.locale.nextPage,
        role: "menuitem",
        tabindex: "-1",
        "aria-label": _ctx.locale.nextPage,
        "aria-hidden": _ctx.disabledNext ? "true" : void 0,
        onClick: _cache[19] || (_cache[19] = (...args) => _ctx.handleNext && _ctx.handleNext(...args)),
        onKeydown: [
          _cache[20] || (_cache[20] = withKeys((...args) => _ctx.handleNext && _ctx.handleNext(...args), ["enter"])),
          _cache[21] || (_cache[21] = withKeys((...args) => _ctx.handleNext && _ctx.handleNext(...args), ["space"]))
        ]
      }, [
        renderSlot(_ctx.$slots, "next", {}, () => [
          createVNode(_component_Icon, { scale: 0.8 }, {
            default: withCtx(() => [
              createVNode(_component_ChevronRight)
            ]),
            _: 1
          }, 8, ["scale"])
        ])
      ], 42, _hoisted_8)
    ], 10, _hoisted_132),
    _ctx.usedPlugins.includes("total") ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("total"), _ctx.pluginOrders.total < 0 && _ctx.nh.bem("total", "prefix")]),
      style: normalizeStyle({ order: _ctx.pluginOrders.total })
    }, toDisplayString(`${_ctx.locale.total} ${_ctx.getCountWord((_a = _ctx.props.itemUnit) != null ? _a : _ctx.locale.itemUnit, _ctx.props.total)}`), 7)) : createCommentVNode("", true),
    _ctx.usedPlugins.includes("size") ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass([_ctx.nh.be("size"), _ctx.pluginOrders.size < 0 && _ctx.nh.bem("size", "prefix")]),
      style: normalizeStyle({ order: _ctx.pluginOrders.size })
    }, [
      createVNode(_component_Select, {
        value: _ctx.currentPageSize,
        "onUpdate:value": _cache[22] || (_cache[22] = ($event) => _ctx.currentPageSize = $event),
        inherit: "",
        class: normalizeClass(_ctx.nh.be("size-select")),
        options: _ctx.sizeObjectOptions,
        filter: false,
        multiple: false,
        clearable: false
      }, null, 8, ["value", "class", "options"])
    ], 6)) : createCommentVNode("", true),
    _ctx.usedPlugins.includes("jump") ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass([_ctx.nh.be("jump"), _ctx.pluginOrders.jump < 0 && _ctx.nh.bem("jump", "prefix")]),
      style: normalizeStyle({ order: _ctx.pluginOrders.jump })
    }, [
      createTextVNode(toDisplayString(_ctx.locale.jumpTo) + " ", 1),
      createVNode(_component_NumberInput, {
        value: _ctx.jumpValue,
        "onUpdate:value": _cache[23] || (_cache[23] = ($event) => _ctx.jumpValue = $event),
        inherit: "",
        class: normalizeClass(_ctx.nh.be("jump-input")),
        clearable: false,
        sync: false,
        style: normalizeStyle({ width: `${_ctx.jumpInputWidth}px` }),
        onChange: _ctx.handleJumpPage
      }, null, 8, ["value", "class", "style", "onChange"]),
      createTextVNode(" " + toDisplayString(_ctx.getCountWordOnly(_ctx.locale.page, 1)), 1)
    ], 6)) : createCommentVNode("", true)
  ], 2);
}
var Pagination = _export_sfc(_sfc_main63, [["render", _sfc_render63]]);

// node_modules/vexip-ui/es/components/progress/props.mjs
var progressProps = buildProps({
  percentage: Number,
  strokeWidth: Number,
  infoType: String,
  precision: Number,
  activated: booleanProp,
  strokeColor: [String, Array, Function]
});

// node_modules/vexip-ui/es/components/progress/progress.mjs
var infoTypes = Object.freeze([
  "outside",
  "inside",
  "bubble",
  "bubble-top",
  "bubble-bottom",
  "none"
]);
var _sfc_main64 = defineComponent({
  name: "Progress",
  components: {
    Bubble
  },
  props: progressProps,
  setup(_props) {
    const props = useProps("progress", _props, {
      percentage: {
        default: 0,
        validator: (value) => value >= 0 && value <= 100,
        static: true
      },
      strokeWidth: 8,
      infoType: {
        default: "outside",
        validator: (value) => infoTypes.includes(value)
      },
      precision: 2,
      activated: false,
      strokeColor: {
        default: null,
        validator: (value) => !(Array.isArray(value) && (!value[0] || !value[1]))
      }
    });
    const nh = useNameHelper("progress");
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        nh.bm(`info-${props.infoType}`),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("activated")]: props.activated
        }
      ];
    });
    const trackStyle = computed(() => {
      return {
        height: `${props.strokeWidth}px`,
        borderRadius: `${props.strokeWidth}px`
      };
    });
    const fillerStyle = computed(() => {
      const style = {
        borderRadius: `${props.strokeWidth}px`,
        transform: `translateX(${(props.percentage - 100) / 2}%) scaleX(${props.percentage / 100})`
      };
      let strokeColor = props.strokeColor;
      if (typeof strokeColor === "function") {
        strokeColor = strokeColor(props.percentage);
      }
      if (typeof strokeColor === "string") {
        style.backgroundColor = strokeColor;
      } else if (Array.isArray(strokeColor)) {
        style.backgroundImage = `linear-gradient(to right, ${strokeColor[0]} 0%, ${strokeColor[1]} 100%)`;
      }
      return style;
    });
    const infoStyle = computed(() => {
      return {
        transform: `translateX(${props.percentage - 100}%)`
      };
    });
    const useBubble = computed(() => {
      return props.infoType.includes("bubble");
    });
    const bubbleType = computed(() => {
      if (useBubble.value) {
        return props.infoType.split("-").pop() === "bottom" ? "bottom" : "top";
      }
      return "top";
    });
    const bubbleStyle = computed(() => {
      if (!useBubble.value)
        return {};
      const type = bubbleType.value === "top" ? "bottom" : "top";
      return {
        [type]: `${props.strokeWidth}px`
      };
    });
    const percentValue = computed(() => zt(props.percentage, props.precision));
    return {
      props,
      nh,
      className,
      trackStyle,
      fillerStyle,
      infoStyle,
      useBubble,
      bubbleType,
      bubbleStyle,
      percentValue
    };
  }
});
var _hoisted_133 = ["aria-valuenow"];
function _sfc_render64(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Bubble = resolveComponent("Bubble");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "progressbar",
    "aria-valuenow": _ctx.percentValue,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("track")),
      style: normalizeStyle(_ctx.trackStyle)
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("filler")),
        style: normalizeStyle(_ctx.fillerStyle)
      }, null, 6),
      _ctx.props.infoType === "inside" ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("info")),
        style: normalizeStyle(_ctx.infoStyle)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createBaseVNode("span", {
            class: normalizeClass(_ctx.nh.be("percentage"))
          }, toDisplayString(`${_ctx.percentValue}%`), 3)
        ])
      ], 6)) : _ctx.useBubble ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("reference")),
        style: normalizeStyle(_ctx.infoStyle)
      }, [
        createVNode(_component_Bubble, {
          inherit: "",
          class: normalizeClass(_ctx.nh.be("bubble")),
          style: normalizeStyle(_ctx.bubbleStyle),
          placement: _ctx.bubbleType,
          "content-class": _ctx.nh.be("info")
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createBaseVNode("span", {
                class: normalizeClass(_ctx.nh.be("percentage"))
              }, toDisplayString(`${_ctx.percentValue}%`), 3)
            ])
          ]),
          _: 3
        }, 8, ["class", "style", "placement", "content-class"])
      ], 6)) : createCommentVNode("", true)
    ], 6),
    _ctx.props.infoType === "outside" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("info"))
    }, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createBaseVNode("span", {
          class: normalizeClass(_ctx.nh.be("percentage"))
        }, toDisplayString(`${_ctx.percentValue}%`), 3)
      ])
    ], 2)) : createCommentVNode("", true)
  ], 10, _hoisted_133);
}
var Progress = _export_sfc(_sfc_main64, [["render", _sfc_render64]]);

// node_modules/vexip-ui/es/components/radio/props.mjs
var radioProps = buildProps({
  size: sizeProp,
  state: stateProp,
  value: [String, Number],
  label: [String, Number],
  labelClass: classProp,
  disabled: booleanProp,
  border: booleanProp,
  tabIndex: [String, Number],
  loading: booleanProp,
  loadingLock: booleanProp,
  onChange: eventProp()
});
var radioGroupProps = buildProps({
  size: sizeProp,
  state: stateProp,
  value: [String, Number],
  vertical: booleanProp,
  disabled: booleanProp,
  button: booleanProp,
  border: booleanProp,
  options: Array,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  onChange: eventProp()
});

// node_modules/vexip-ui/es/components/radio/symbol.mjs
var GROUP_STATE4 = Symbol("RADIO_GROUP_STATE");

// node_modules/vexip-ui/es/components/radio/radio.mjs
var _sfc_main65 = defineComponent({
  name: "Radio",
  components: {
    CollapseTransition,
    Icon
  },
  props: radioProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const props = useProps("radio", _props, {
      size: createSizeProp(),
      state: createStateProp(),
      value: {
        default: null,
        static: true
      },
      label: {
        default: null,
        validator: y,
        static: true
      },
      labelClass: null,
      disabled: false,
      border: false,
      tabIndex: 0,
      loading: false,
      loadingLock: false
    });
    const groupState = inject(GROUP_STATE4, null);
    const nh = useNameHelper("radio");
    const currentValue = ref(props.value);
    const input = ref();
    const size = computed(() => (groupState == null ? void 0 : groupState.size) || props.size);
    const state = computed(() => (groupState == null ? void 0 : groupState.state) || props.state);
    const isDisabled = computed(() => (groupState == null ? void 0 : groupState.disabled) || props.disabled);
    const isButton = computed(() => groupState == null ? void 0 : groupState.button);
    const isBorder = computed(() => (groupState == null ? void 0 : groupState.border) || props.border);
    const isLoading = computed(() => (groupState == null ? void 0 : groupState.loading) || props.loading);
    const LoadingIcon = computed(() => (groupState == null ? void 0 : groupState.loadingIcon) || null);
    const isLoadingLock = computed(() => (groupState == null ? void 0 : groupState.loadingLock) || false);
    const isLoadingSpin = computed(() => (groupState == null ? void 0 : groupState.loadingSpin) || false);
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("checked")]: currentValue.value === props.label,
          [nh.bm("disabled")]: isDisabled.value,
          [nh.bm("loading")]: isLoading.value && isLoadingLock.value,
          [nh.bm(size.value)]: size.value !== "default",
          [nh.bm("border")]: isBorder.value,
          [nh.bm(state.value)]: state.value !== "default"
        }
      ];
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
      }
    );
    watch(currentValue, (value) => {
      emitEvent(props.onChange, value);
      emit("update:value", value);
      if (groupState && value === props.label) {
        groupState.updateValue(value);
      }
    });
    if (groupState) {
      watch(
        () => groupState.currentValue,
        (value) => {
          currentValue.value = value;
        },
        { immediate: true }
      );
      onMounted(() => {
        groupState.registerInput(input);
      });
      onBeforeUnmount(() => {
        groupState.unregisterInput(input);
      });
    }
    function handleChange() {
      if (isDisabled.value || isLoading.value && isLoadingLock.value) {
        return;
      }
      currentValue.value = props.label;
    }
    return {
      props,
      nh,
      currentValue,
      className,
      isDisabled,
      isButton,
      isLoading,
      computedLoadingIcon: LoadingIcon,
      isLoadingSpin,
      input,
      handleChange
    };
  }
});
var _hoisted_134 = ["checked", "disabled", "tabindex"];
function _sfc_render65(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(_ctx.className)
  }, [
    createBaseVNode("span", {
      class: normalizeClass([_ctx.nh.be("signal"), _ctx.isLoading && _ctx.nh.bem("signal", "active")])
    }, null, 2),
    createBaseVNode("span", {
      class: normalizeClass([_ctx.nh.be("label"), _ctx.props.labelClass])
    }, [
      _ctx.isButton ? (openBlock(), createBlock(_component_CollapseTransition, {
        key: 0,
        appear: "",
        horizontal: "",
        "fade-effect": ""
      }, {
        default: withCtx(() => [
          _ctx.isLoading ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("loading"))
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.isLoadingSpin,
              pulse: !_ctx.isLoadingSpin,
              icon: _ctx.computedLoadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.props.label), 1)
      ])
    ], 2),
    createBaseVNode("input", {
      ref: "input",
      type: "radio",
      class: normalizeClass(_ctx.nh.be("input")),
      checked: _ctx.currentValue === _ctx.props.label,
      disabled: _ctx.isDisabled,
      tabindex: _ctx.props.tabIndex,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 42, _hoisted_134)
  ], 2);
}
var Radio = _export_sfc(_sfc_main65, [["render", _sfc_render65]]);

// node_modules/vexip-ui/es/components/radio/radio-group.mjs
var _sfc_main66 = defineComponent({
  name: "RadioGroup",
  components: {
    Radio
  },
  props: radioGroupProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, size, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a, _b;
      return (_b = (_a = Array.from(inputSet)[0]) == null ? void 0 : _a.value) == null ? void 0 : _b.focus();
    });
    const props = useProps("radioGroup", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      vertical: false,
      disabled: () => disabled.value,
      button: false,
      border: false,
      options: {
        default: () => [],
        static: true
      },
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false
    });
    const nh = useNameHelper("radio-group");
    const currentValue = ref(props.value);
    const inputSet = /* @__PURE__ */ new Set();
    const className = computed(() => {
      return [
        nh.b(),
        nh.ns("radio-vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("vertical")]: props.vertical,
          [nh.bm("button")]: !props.vertical && props.button,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("border")]: props.border,
          [nh.bm(props.state)]: props.state !== "default"
        }
      ];
    });
    const groupState = reactive({
      currentValue,
      size: toRef(props, "size"),
      state: toRef(props, "state"),
      disabled: toRef(props, "disabled"),
      button: toRef(props, "button"),
      border: toRef(props, "border"),
      loading: toRef(props, "loading"),
      loadingIcon: toRef(props, "loadingIcon"),
      loadingLock: toRef(props, "loadingLock"),
      loadingSpin: toRef(props, "loadingSpin"),
      updateValue: Mr(updateValue),
      registerInput,
      unregisterInput
    });
    provide(GROUP_STATE4, groupState);
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
      }
    );
    watch(currentValue, (value) => {
      setFieldValue(value);
      emitEvent(props.onChange, value);
      emit("update:value", value);
      validateField();
    });
    function updateValue(value) {
      currentValue.value = value;
    }
    function registerInput(input) {
      inputSet.add(input);
    }
    function unregisterInput(input) {
      inputSet.delete(input);
    }
    return {
      props,
      idFor,
      className,
      isObject: L
    };
  }
});
var _hoisted_135 = ["id"];
function _sfc_render66(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Radio = resolveComponent("Radio");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    role: "radiogroup"
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.options, (item) => {
        return openBlock(), createElementBlock(Fragment, { key: item }, [
          _ctx.isObject(item) ? (openBlock(), createBlock(_component_Radio, {
            key: 0,
            inherit: "",
            label: item.label
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item.content || item.label), 1)
            ]),
            _: 2
          }, 1032, ["label"])) : (openBlock(), createBlock(_component_Radio, {
            key: 1,
            inherit: "",
            label: item
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item), 1)
            ]),
            _: 2
          }, 1032, ["label"]))
        ], 64);
      }), 128))
    ])
  ], 10, _hoisted_135);
}
var RadioGroup = _export_sfc(_sfc_main66, [["render", _sfc_render66]]);

// node_modules/vexip-ui/es/components/skeleton/props.mjs
var skeletonProps = buildProps({
  size: sizeProp,
  width: [Number, String],
  height: [Number, String],
  repeat: Number,
  tag: String,
  activated: booleanProp,
  image: booleanProp,
  imageIcon: Object,
  iconScale: Number,
  round: booleanProp,
  circle: booleanProp,
  block: booleanProp,
  spread: Number,
  loading: booleanProp
});
var skeletonGroupProps = buildProps({
  size: sizeProp,
  tag: booleanStringProp,
  itemTag: String,
  activated: booleanProp,
  round: booleanProp,
  circle: booleanProp,
  block: booleanProp,
  loading: booleanProp
});

// node_modules/vexip-ui/es/components/skeleton/symbol.mjs
var GROUP_STATE5 = Symbol("GROUP_STATE");

// node_modules/vexip-ui/es/components/skeleton/skeleton.mjs
var Skeleton = defineComponent({
  name: "Skeleton",
  inheritAttrs: false,
  props: skeletonProps,
  setup(_props, {
    attrs,
    slots
  }) {
    const props = useProps("skeleton", _props, {
      size: null,
      width: null,
      height: null,
      repeat: {
        default: 1,
        validator: (value) => value > 0
      },
      tag: "div",
      activated: null,
      image: false,
      imageIcon: null,
      iconScale: 4,
      round: null,
      circle: null,
      block: null,
      spread: 0,
      loading: null
    });
    const groupState = inject(GROUP_STATE5, {});
    const nh = useNameHelper("skeleton");
    const activated = computed(() => {
      var _a, _b;
      return (_b = (_a = props.activated) != null ? _a : groupState.activated) != null ? _b : false;
    });
    const round = computed(() => {
      var _a, _b;
      return (_b = (_a = props.round) != null ? _a : groupState.round) != null ? _b : false;
    });
    const circle = computed(() => {
      var _a, _b;
      return (_b = (_a = props.circle) != null ? _a : groupState.circle) != null ? _b : false;
    });
    const block = computed(() => {
      var _a, _b;
      return (_b = (_a = props.block) != null ? _a : groupState.block) != null ? _b : false;
    });
    const loading = computed(() => {
      var _a, _b;
      return (_b = (_a = props.loading) != null ? _a : groupState.loading) != null ? _b : true;
    });
    const tag = computed(() => {
      return props.tag || groupState.itemTag || "div";
    });
    const className = computed(() => {
      var _a;
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: Object.keys(groupState).length || props.inherit,
        [nh.bm(props.size)]: (_a = props.size) != null ? _a : groupState == null ? void 0 : groupState.size,
        [nh.bm("block")]: block.value,
        [nh.bm("image")]: props.image,
        [nh.bm("round")]: round.value && !circle.value,
        [nh.bm("circle")]: circle.value,
        [nh.bm("activated")]: activated.value
      };
    });
    const style = computed(() => {
      const style2 = {};
      if (props.width !== null) {
        style2[nh.cv("width")] = parseSize(props.width);
      }
      if (props.height !== null) {
        style2[nh.cv("height")] = parseSize(props.height);
      }
      if (props.spread) {
        style2[nh.cv("spread")] = parseSize(props.spread);
      }
      return style2;
    });
    function parseSize(value) {
      if (typeof value === "number") {
        return `${value}px`;
      }
      value = value.trim();
      if (/\d$/.test(value)) {
        return `${value}px`;
      }
      return value;
    }
    function renderSkeleton() {
      if (!loading.value) {
        return renderSlot(slots, "default");
      }
      return h(tag.value || "div", {
        ...attrs,
        class: [className.value, attrs.class],
        style: [style.value, attrs.style]
      }, props.image ? [createVNode(Icon, {
        "icon": props.imageIcon || $25,
        "scale": props.iconScale
      }, null)] : []);
    }
    return () => {
      if (props.repeat > 1) {
        return Array.from({
          length: props.repeat
        }, () => renderSkeleton());
      }
      return renderSkeleton();
    };
  }
});

// node_modules/vexip-ui/es/components/skeleton/skeleton-group.mjs
var SkeletonGroup = defineComponent({
  name: "SkeletonGroup",
  props: skeletonGroupProps,
  setup(_props, { slots }) {
    const props = useProps("skeletonGroup", _props, {
      size: null,
      tag: false,
      itemTag: null,
      activated: false,
      round: false,
      circle: false,
      block: false,
      loading: true
    });
    const nh = useNameHelper("skeletonGroup");
    provide(GROUP_STATE5, props);
    return () => {
      if (props.tag) {
        return h(
          typeof props.tag === "string" ? props.tag : "div",
          {
            class: [nh.b(), props.inherit && nh.bm("inherit")],
            role: "group"
          },
          {
            default: () => {
              var _a;
              return (_a = slots.default) == null ? void 0 : _a.call(slots);
            }
          }
        );
      }
      return renderSlot(slots, "default");
    };
  }
});

// node_modules/vexip-ui/es/components/slider/slider-trigger.mjs
var _sfc_main67 = defineComponent({
  name: "SliderTrigger",
  components: {
    Tooltip
  },
  props: {
    value: {
      type: Number,
      default: 0
    },
    tipTransfer: {
      type: [Boolean, String],
      default: false
    },
    hideTip: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    disabled: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    reverse: {
      type: Boolean,
      default: false
    },
    sliding: {
      type: Boolean,
      default: false
    }
  },
  emits: ["key-minus", "key-plus"],
  setup(props, { emit }) {
    const isTipShow = ref(false);
    const tooltip = ref(null);
    const handler = ref();
    const { timer: timer2 } = $o();
    const { target: wrapper } = No({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down || modifier.left || modifier.right) {
          disableEvent(event);
          const extraType = event.ctrlKey ? "ctrl" : event.shiftKey ? "shift" : event.altKey ? "alt" : void 0;
          if (modifier.up || modifier.left) {
            emit("key-minus", extraType);
          } else {
            emit("key-plus", extraType);
          }
        }
      }
    });
    function showTooltip() {
      clearTimeout(timer2.hover);
      if (!props.disabled) {
        timer2.hover = setTimeout(() => {
          isTipShow.value = true;
        }, 250);
      }
    }
    function hideTooltip() {
      clearTimeout(timer2.hover);
      timer2.hover = setTimeout(() => {
        isTipShow.value = false;
      }, 250);
    }
    function disableEvent(event) {
      if (event.cancelable) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
    function updateTooltip() {
      if (tooltip.value) {
        tooltip.value.updatePopper();
      }
    }
    function focus() {
      var _a;
      (_a = handler.value) == null ? void 0 : _a.focus();
    }
    return {
      nh: useNameHelper("slider"),
      isTipShow,
      wrapper,
      tooltip,
      handler,
      showTooltip,
      hideTooltip,
      disableEvent,
      updateTooltip,
      focus
    };
  }
});
var _hoisted_136 = ["aria-valuenow", "aria-valuemin", "aria-valuemax", "aria-disabled"];
function _sfc_render67(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Tooltip = resolveComponent("Tooltip");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("trigger")),
    tabindex: "-1",
    onTouchstart: _cache[2] || (_cache[2] = (...args) => _ctx.disableEvent && _ctx.disableEvent(...args))
  }, [
    createVNode(_component_Tooltip, {
      ref: "tooltip",
      theme: "dark",
      trigger: "custom",
      transfer: _ctx.tipTransfer,
      visible: _ctx.isTipShow || _ctx.sliding,
      "tip-class": _ctx.nh.be("tip"),
      disabled: _ctx.hideTip,
      placement: _ctx.vertical ? "right" : "top",
      onTipEnter: _ctx.showTooltip,
      onTipLeave: _ctx.hideTooltip
    }, {
      trigger: withCtx(() => [
        createBaseVNode("div", {
          ref: "handler",
          class: normalizeClass({
            [_ctx.nh.be("handler")]: true,
            [_ctx.nh.bem("handler", "active")]: _ctx.loading,
            [_ctx.nh.bem("handler", "sliding")]: _ctx.sliding
          }),
          role: "slider",
          tabindex: "0",
          "aria-valuenow": _ctx.value,
          "aria-valuemin": _ctx.min,
          "aria-valuemax": _ctx.max,
          "aria-disabled": _ctx.disabled,
          onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.showTooltip && _ctx.showTooltip(...args)),
          onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.hideTooltip && _ctx.hideTooltip(...args))
        }, null, 42, _hoisted_136)
      ]),
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "tip", { value: _ctx.value }, () => [
          createTextVNode(toDisplayString(_ctx.value), 1)
        ])
      ]),
      _: 3
    }, 8, ["transfer", "visible", "tip-class", "disabled", "placement", "onTipEnter", "onTipLeave"])
  ], 34);
}
var SliderTrigger = _export_sfc(_sfc_main67, [["render", _sfc_render67]]);

// node_modules/vexip-ui/es/components/slider/props.mjs
var sliderProps = buildProps({
  state: stateProp,
  value: [Number, Array],
  min: Number,
  max: Number,
  step: Number,
  vertical: booleanProp,
  hideTip: booleanProp,
  tipTransfer: booleanStringProp,
  disabled: booleanProp,
  loading: booleanProp,
  loadingLock: booleanProp,
  reverse: booleanProp,
  range: booleanProp,
  markers: Object,
  markerOnly: booleanProp,
  onChange: eventProp(),
  onInput: eventProp()
});

// node_modules/vexip-ui/es/components/slider/slider.mjs
var TriggerType = ((TriggerType2) => {
  TriggerType2[TriggerType2["START"] = 0] = "START";
  TriggerType2[TriggerType2["END"] = 1] = "END";
  return TriggerType2;
})(TriggerType || {});
var _sfc_main68 = defineComponent({
  name: "Slider",
  components: {
    SliderTrigger
  },
  props: sliderProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = startTrigger.value || endTrigger.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("slider", _props, {
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(0),
        static: true
      },
      min: 0,
      max: 100,
      step: {
        default: 1,
        validator: (value) => value > 0 && Math.ceil(value) === value
      },
      vertical: false,
      hideTip: false,
      tipTransfer: null,
      disabled: () => disabled.value,
      loading: () => loading.value,
      loadingLock: false,
      reverse: false,
      range: false,
      markers: () => ({}),
      markerOnly: false
    });
    const nh = useNameHelper("slider");
    const currentValue = ref([0, 0]);
    const sliding = ref([false, false]);
    const triggerType = ref(1);
    const { timer: timer2 } = $o();
    const track = ref();
    const startTrigger = ref();
    const endTrigger = ref();
    const markerPercent = computed(() => {
      return Object.keys(props.markers).map(parseFloat).filter((percent) => {
        return !Number.isNaN(percent) && percent >= 0 && percent <= 100;
      });
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.state)]: props.state !== "default",
        [nh.bm("vertical")]: props.vertical,
        [nh.bm("sliding")]: sliding.value[1] || sliding.value[0],
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("loading")]: props.loading && props.loadingLock,
        [nh.bm("reverse")]: props.reverse,
        [nh.bm("with-marker")]: markerPercent.value.length
      };
    });
    const stepMin = computed(() => Math.round(Math.min(props.min, props.max) / props.step));
    const stepMax = computed(() => Math.round(Math.max(props.min, props.max) / props.step));
    const truthValue = computed(() => {
      return [
        Math.round(currentValue.value[0] * props.step),
        Math.round(currentValue.value[1] * props.step)
      ];
    });
    const total = computed(() => stepMax.value - stepMin.value || 1);
    const triggerPercent = computed(() => {
      return [
        (currentValue.value[0] - stepMin.value) / total.value * 100,
        (currentValue.value[1] - stepMin.value) / total.value * 100
      ];
    });
    const fillerStyle = computed(() => {
      const { vertical, reverse } = props;
      const offset = props.range ? Math.min(triggerPercent.value[0], triggerPercent.value[1]) : 0;
      return {
        transform: `
          translate${vertical ? "Y" : "X"}(${reverse ? "-" : ""}${offset}%)
          translateZ(0)
          scale${vertical ? "Y" : "X"}(${Math.abs(triggerPercent.value[0] - triggerPercent.value[1]) / 100})
        `,
        transformOrigin: `${vertical ? 50 : reverse ? 100 : 0}% ${vertical ? reverse ? 100 : 0 : 50}%`
      };
    });
    const startTriggerStyle = computed(() => {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${triggerPercent.value[0]}%` : "50%",
        [reverse ? "right" : "left"]: vertical ? "50%" : `${triggerPercent.value[0]}%`,
        zIndex: triggerType.value === 0 ? 1 : void 0,
        transform: `translate(${reverse ? "" : "-"}50%, ${reverse ? "" : "-"}50%)`
      };
    });
    const endTriggerStyle = computed(() => {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${triggerPercent.value[1]}%` : "50%",
        [reverse ? "right" : "left"]: vertical ? "50%" : `${triggerPercent.value[1]}%`,
        zIndex: triggerType.value === 1 ? 1 : void 0,
        transform: `translate(${reverse ? "" : "-"}50%, ${reverse ? "" : "-"}50%)`
      };
    });
    parseValue(props.value);
    verifyValue();
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
        verifyValue();
      }
    );
    function parseValue(value) {
      if (props.range) {
        const values = Array.isArray(value) ? value : [value, 100];
        currentValue.value = [values[0] / props.step, values[1] / props.step];
      } else {
        currentValue.value = [stepMin.value, (Array.isArray(value) ? value[0] : value) / props.step];
      }
    }
    function verifyValue() {
      currentValue.value = currentValue.value.map((value) => {
        let computedValue = Math.max(stepMin.value, Math.min(stepMax.value, Math.round(value)));
        if (props.markerOnly && markerPercent.value.length) {
          let nearest = 100;
          let nearestPercent = 0;
          for (const percent of markerPercent.value) {
            const delta = Math.abs((computedValue - stepMin.value) / total.value * 100 - percent);
            if (nearest > delta) {
              nearest = delta;
              nearestPercent = percent;
            }
          }
          computedValue = nearestPercent / 100 * total.value + stepMin.value;
        }
        return computedValue;
      });
    }
    function emitChange() {
      const [start, end] = truthValue.value;
      const value = props.range ? start > end ? [end, start] : [start, end] : end;
      setFieldValue(value);
      emitEvent(props.onChange, value);
      emit("update:value", value);
      validateField();
    }
    let trackRect = null;
    function computeValue(event) {
      if (!trackRect)
        return;
      const vertical = props.vertical;
      const reverse = props.reverse;
      const client = vertical ? event.clientY : event.clientX;
      currentValue.value[triggerType.value] = (reverse ? -1 : 1) * ((client - trackRect[vertical ? reverse ? "bottom" : "top" : reverse ? "right" : "left"]) / trackRect[vertical ? "height" : "width"]) * total.value + stepMin.value;
    }
    let lastValue;
    function isEqualValue(prev, current) {
      if (Array.isArray(prev) && Array.isArray(current)) {
        return prev[0] === current[0] && prev[1] === current[1];
      }
      return prev === current;
    }
    const throttleMove = br((event) => {
      if (!trackRect || props.disabled)
        return;
      event.preventDefault();
      computeValue(event);
      verifyValue();
      if (startTrigger.value) {
        startTrigger.value.updateTooltip();
      }
      if (endTrigger.value) {
        endTrigger.value.updateTooltip();
      }
      const [start, end] = truthValue.value;
      const value = props.range ? start > end ? [end, start] : [start, end] : end;
      if (!isEqualValue(lastValue, value)) {
        lastValue = value;
        emitEvent(props.onInput, value);
      }
    });
    function handleTrackDown(event) {
      if (!track.value || props.disabled || props.loading && props.loadingLock)
        return;
      clearTimeout(timer2.sliding);
      event.stopPropagation();
      event.preventDefault();
      trackRect = track.value.getBoundingClientRect();
      if (props.range) {
        const { vertical, reverse } = props;
        const client = vertical ? event.clientY : event.clientX;
        const downPercent = (reverse ? trackRect[vertical ? "bottom" : "right"] - client : client - trackRect[vertical ? "top" : "left"]) / trackRect[vertical ? "height" : "width"] * 100;
        triggerType.value = Math.abs(downPercent - triggerPercent.value[0]) < Math.abs(downPercent - triggerPercent.value[1]) ? 0 : 1;
      } else {
        triggerType.value = 1;
      }
      sliding.value[triggerType.value] = true;
      computeValue(event);
      verifyValue();
      document.addEventListener("pointermove", handleMove);
      document.addEventListener("pointerup", handleMoveEnd);
    }
    function handleMove(event) {
      throttleMove(event);
    }
    function handleMoveEnd() {
      trackRect = null;
      document.removeEventListener("pointermove", handleMove);
      document.removeEventListener("pointerup", handleMoveEnd);
      emitChange();
      timer2.sliding = setTimeout(() => {
        sliding.value[triggerType.value] = false;
      }, 250);
    }
    function disableEvent(event) {
      if (event.cancelable) {
        event.stopPropagation();
        event.preventDefault();
      }
    }
    function getPointStyle(percent) {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${percent}%` : "50%",
        [reverse ? "right" : "left"]: vertical ? "50%" : `${percent}%`,
        transform: `translate(${reverse ? "" : "-"}50%, ${reverse ? "" : "-"}50%)`
      };
    }
    function getMarkerStyle(percent) {
      const { vertical, reverse } = props;
      return {
        [reverse ? "bottom" : "top"]: vertical ? `${percent}%` : void 0,
        [reverse ? "right" : "left"]: vertical ? void 0 : `${percent}%`,
        transform: `translate${vertical ? "Y" : "X"}(${reverse ? "" : "-"}50%)`
      };
    }
    function isPercentInRange(percent) {
      const numberPercent = parseFloat(percent);
      if (Number.isNaN(numberPercent))
        return false;
      if (props.range) {
        const min = Math.min(triggerPercent.value[0], triggerPercent.value[1]);
        const max = Math.max(triggerPercent.value[0], triggerPercent.value[1]);
        return numberPercent >= min && numberPercent <= max;
      } else {
        return numberPercent <= triggerPercent.value[1];
      }
    }
    return {
      props,
      nh,
      idFor,
      sliding,
      markerPercent,
      className,
      truthValue,
      fillerStyle,
      startTriggerStyle,
      endTriggerStyle,
      track,
      startTrigger,
      endTrigger,
      handleTrackDown,
      disableEvent,
      getPointStyle,
      getMarkerStyle,
      isPercentInRange
    };
  }
});
var _hoisted_137 = ["id"];
function _sfc_render68(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SliderTrigger = resolveComponent("SliderTrigger");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    tabindex: "-1",
    onPointerdown: _cache[0] || (_cache[0] = (...args) => _ctx.handleTrackDown && _ctx.handleTrackDown(...args)),
    onTouchstart: _cache[1] || (_cache[1] = (...args) => _ctx.disableEvent && _ctx.disableEvent(...args))
  }, [
    createBaseVNode("div", {
      ref: "track",
      class: normalizeClass(_ctx.nh.be("track"))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("filler")),
        style: normalizeStyle(_ctx.fillerStyle)
      }, null, 6)
    ], 2),
    _ctx.markerPercent.length ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("points"))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.markers, (_, percent) => {
          return openBlock(), createElementBlock("div", {
            key: percent,
            class: normalizeClass([_ctx.nh.be("point"), _ctx.isPercentInRange(percent) && _ctx.nh.bem("point", "in-range")]),
            style: normalizeStyle(_ctx.getPointStyle(percent))
          }, null, 6);
        }), 128))
      ], 2),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("markers"))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.markers, (marker, percent) => {
          return openBlock(), createElementBlock(Fragment, { key: percent }, [
            typeof marker === "string" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("marker")),
              style: normalizeStyle(_ctx.getMarkerStyle(percent))
            }, [
              renderSlot(_ctx.$slots, "marker", {
                marker: { label: marker },
                percent,
                inRange: _ctx.isPercentInRange(percent)
              }, () => [
                createTextVNode(toDisplayString(marker), 1)
              ])
            ], 6)) : (openBlock(), createElementBlock("div", mergeProps({
              key: 1,
              class: [_ctx.nh.be("marker"), marker.class],
              style: [
                _ctx.getMarkerStyle(percent),
                marker.style
              ]
            }, marker.attrs), [
              renderSlot(_ctx.$slots, "marker", {
                marker,
                percent,
                inRange: _ctx.isPercentInRange(percent)
              }, () => [
                createTextVNode(toDisplayString(marker.label), 1)
              ])
            ], 16))
          ], 64);
        }), 128))
      ], 2)
    ], 64)) : createCommentVNode("", true),
    _ctx.props.range ? (openBlock(), createBlock(_component_SliderTrigger, {
      key: 1,
      ref: "startTrigger",
      value: _ctx.truthValue[0],
      "tip-transfer": _ctx.props.tipTransfer,
      "hide-tip": _ctx.props.hideTip,
      vertical: _ctx.props.vertical,
      min: _ctx.props.min,
      max: _ctx.props.max,
      disabled: _ctx.props.disabled,
      loading: _ctx.props.loading,
      reverse: _ctx.props.reverse,
      sliding: _ctx.sliding[0],
      style: normalizeStyle(_ctx.startTriggerStyle)
    }, {
      tip: withCtx(({ value: startValue }) => [
        renderSlot(_ctx.$slots, "tip", { value: startValue }, () => [
          createTextVNode(toDisplayString(startValue), 1)
        ])
      ]),
      _: 3
    }, 8, ["value", "tip-transfer", "hide-tip", "vertical", "min", "max", "disabled", "loading", "reverse", "sliding", "style"])) : createCommentVNode("", true),
    createVNode(_component_SliderTrigger, {
      ref: "endTrigger",
      value: _ctx.truthValue[1],
      "tip-transfer": _ctx.props.tipTransfer,
      "hide-tip": _ctx.props.hideTip,
      vertical: _ctx.props.vertical,
      min: _ctx.props.min,
      max: _ctx.props.max,
      disabled: _ctx.props.disabled,
      loading: _ctx.props.loading,
      reverse: _ctx.props.reverse,
      sliding: _ctx.sliding[1],
      style: normalizeStyle(_ctx.endTriggerStyle)
    }, {
      tip: withCtx(({ value: endValue }) => [
        renderSlot(_ctx.$slots, "tip", { value: endValue }, () => [
          createTextVNode(toDisplayString(endValue), 1)
        ])
      ]),
      _: 3
    }, 8, ["value", "tip-transfer", "hide-tip", "vertical", "min", "max", "disabled", "loading", "reverse", "sliding", "style"])
  ], 42, _hoisted_137);
}
var Slider = _export_sfc(_sfc_main68, [["render", _sfc_render68]]);

// node_modules/vexip-ui/es/components/space/props.mjs
var spaceProps = buildProps({
  vertical: booleanProp,
  inline: booleanProp,
  tag: String,
  align: String,
  justify: String,
  noWrap: booleanProp,
  size: [String, Number, Array],
  itemStyle: styleProp,
  gapDisabled: booleanProp
});

// node_modules/vexip-ui/es/components/space/helper.mjs
function flatVNodes(children) {
  const result = [];
  const loop = Array.isArray(children) ? [...children] : [];
  while (loop.length) {
    const vnode = loop.shift();
    if (vnode === null)
      continue;
    if (Array.isArray(vnode)) {
      loop.unshift(...vnode);
    }
    if (!isVNode(vnode) || vnode.type === Comment)
      continue;
    if (vnode.type === Fragment && Array.isArray(vnode.children)) {
      loop.unshift(vnode.children);
    } else if (typeof vnode === "string" || typeof vnode === "number") {
      result.push(createTextVNode(vnode));
    } else {
      result.push(vnode);
    }
  }
  return result;
}

// node_modules/vexip-ui/es/components/space/space.mjs
var justifyList3 = Object.freeze(["start", "end", "center", "space-around", "space-between", "space-evenly"]);
var alignList3 = Object.freeze(["start", "end", "center", "baseline", "stretch"]);
var useFlexGap = Ar();
function parseFlexStyle(value) {
  return value === "start" || value === "end" ? `flex-${value}` : value;
}
var Space = defineComponent({
  name: "Space",
  props: spaceProps,
  setup(_props, {
    slots
  }) {
    const props = useProps("space", _props, {
      vertical: false,
      inline: false,
      tag: "div",
      align: {
        default: "stretch",
        validator: (value) => alignList3.includes(value)
      },
      justify: {
        default: "start",
        validator: (value) => justifyList3.includes(value)
      },
      noWrap: false,
      size: "default",
      itemStyle: null,
      gapDisabled: !useFlexGap
    });
    const nh = useNameHelper("space");
    const varMap = {
      h: `var(${nh.cv("h-gap")})`,
      hh: `calc(var(${nh.cv("h-gap")}) * 0.5)`,
      mhh: `calc(var(${nh.cv("h-gap")}) * -0.5)`,
      v: `var(${nh.cv("v-gap")})`,
      hv: `calc(var(${nh.cv("v-gap")}) * 0.5)`,
      mhv: `calc(var(${nh.cv("v-gap")}) * -0.5)`
    };
    const className = computed(() => {
      const className2 = {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("inline")]: props.inline,
        [nh.bm("vertical")]: props.vertical,
        [nh.bm("no-wrap")]: props.vertical || props.noWrap,
        [nh.bm("no-gap")]: props.gapDisabled
      };
      if (typeof props.size === "string" && props.size !== "default") {
        className2[nh.bm(props.size)] = true;
      }
      return className2;
    });
    const style = computed(() => {
      const {
        justify,
        align,
        size
      } = props;
      const style2 = {
        alignItems: parseFlexStyle(align),
        justifyContent: parseFlexStyle(justify)
      };
      if (typeof size !== "string") {
        const normalizedSize = Array.isArray(size) ? size : [size, size];
        style2[nh.cv("h-gap")] = `${normalizedSize[0]}px`;
        style2[nh.cv("v-gap")] = `${normalizedSize[1]}px`;
      }
      if (props.gapDisabled && !props.vertical) {
        style2.marginTop = varMap.mhv;
        style2.marginBottom = varMap.mhv;
      }
      return style2;
    });
    return () => {
      const children = renderSlot(slots, "default").children;
      if (!(children == null ? void 0 : children.length))
        return null;
      const vnodes = flatVNodes(children);
      const lastIndex = vnodes.length - 1;
      const justify = props.justify;
      const justifySpace = justify.startsWith("space");
      const notBetween = justify !== "space-between";
      return h(props.tag || "div", {
        class: className.value,
        style: style.value
      }, vnodes.map((vnode, index) => createVNode("div", {
        "class": nh.be("item"),
        "role": "none",
        "style": [props.itemStyle, !props.gapDisabled ? "" : props.vertical ? {
          marginBottom: index !== lastIndex ? varMap.v : void 0
        } : {
          paddingTop: varMap.hv,
          paddingBottom: varMap.hv,
          marginRight: justifySpace ? notBetween || index !== lastIndex ? varMap.hh : void 0 : index !== lastIndex ? varMap.h : void 0,
          marginLeft: justifySpace ? notBetween || index !== 0 ? varMap.hh : void 0 : void 0
        }]
      }, [vnode])));
    };
  }
});

// node_modules/vexip-ui/es/components/spin/props.mjs
var spinProps = buildProps({
  active: booleanProp,
  icon: Object,
  spin: booleanProp,
  inner: booleanProp,
  delay: {
    type: [Boolean, Number, Array],
    default: null
  },
  tip: String,
  hideMask: booleanProp,
  maskColor: String,
  maskClass: classProp,
  transitionName: String,
  onMaskClick: eventProp(),
  onShow: eventProp(),
  onHide: eventProp()
});

// node_modules/vexip-ui/es/components/spin/spin.mjs
var _sfc_main69 = defineComponent({
  name: "Spin",
  components: {
    Icon
  },
  props: spinProps,
  setup(_props, { slots }) {
    const nh = useNameHelper("spin");
    const props = useProps("spin", _props, {
      active: {
        default: false,
        static: true
      },
      icon: h4,
      spin: false,
      inner: false,
      delay: false,
      tip: "",
      hideMask: false,
      maskColor: "",
      maskClass: null,
      transitionName: () => nh.ns("fade")
    });
    const currentActive = ref(props.active);
    const hasTip = computed(() => !!(props.tip || slots.tip));
    const maskStyle = computed(() => {
      const style = {};
      if (props.maskColor) {
        style[nh.cv("mask-bg-color")] = props.maskColor;
      }
      return style;
    });
    const delayTime = computed(() => {
      if (props.delay) {
        if (props.delay === true) {
          return { enter: 500, leave: 500 };
        }
        if (typeof props.delay === "number") {
          return { enter: props.delay, leave: props.delay };
        }
        if (Array.isArray(props.delay)) {
          return { enter: En(props.delay[0]), leave: En(props.delay[1]) };
        }
      }
      return { enter: 0, leave: 0 };
    });
    let timer2;
    watch(
      () => props.active,
      (value) => {
        clearTimeout(timer2);
        const delay = value ? delayTime.value.enter : delayTime.value.leave;
        if (delay) {
          timer2 = setTimeout(() => {
            currentActive.value = value;
          }, delay);
        } else {
          currentActive.value = value;
        }
      }
    );
    function handleMaskClick(event) {
      emitEvent(props.onMaskClick, event);
    }
    function handleShow() {
      emitEvent(props.onShow);
    }
    function handleHide() {
      emitEvent(props.onHide);
    }
    return {
      props,
      nh,
      currentActive,
      hasTip,
      maskStyle,
      handleMaskClick,
      handleShow,
      handleHide
    };
  }
});
var _hoisted_138 = ["aria-busy"];
function _sfc_render69(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return !_ctx.props.inner ? (openBlock(), createElementBlock("div", {
    key: 0,
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars"), _ctx.props.inherit && _ctx.nh.bm("inherit")]),
    "aria-busy": _ctx.currentActive ? "true" : void 0
  }, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(Transition, {
      appear: "",
      name: _ctx.props.transitionName,
      onAfterEnter: _ctx.handleShow,
      onAfterLeave: _ctx.handleHide
    }, {
      default: withCtx(() => [
        _ctx.currentActive ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("loading"))
        }, [
          !_ctx.props.hideMask ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("mask"), _ctx.props.maskClass]),
            style: normalizeStyle(_ctx.maskStyle),
            onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMaskClick && _ctx.handleMaskClick(...args))
          }, null, 6)) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, "content", {}, () => [
            createBaseVNode("div", {
              class: normalizeClass(_ctx.nh.be("icon"))
            }, [
              renderSlot(_ctx.$slots, "icon", {}, () => [
                _ctx.props.spin ? (openBlock(), createBlock(_component_Icon, {
                  key: 0,
                  spin: "",
                  icon: _ctx.props.icon
                }, null, 8, ["icon"])) : (openBlock(), createBlock(_component_Icon, {
                  key: 1,
                  pulse: "",
                  icon: _ctx.props.icon
                }, null, 8, ["icon"]))
              ])
            ], 2),
            _ctx.hasTip ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("tip"))
            }, [
              renderSlot(_ctx.$slots, "tip", {}, () => [
                createTextVNode(toDisplayString(_ctx.props.tip), 1)
              ])
            ], 2)) : createCommentVNode("", true)
          ])
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])
  ], 10, _hoisted_138)) : (openBlock(), createBlock(Transition, {
    key: 1,
    appear: "",
    name: _ctx.props.transitionName,
    onAfterEnter: _ctx.handleShow,
    onAfterLeave: _ctx.handleHide
  }, {
    default: withCtx(() => [
      _ctx.currentActive ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars"), _ctx.nh.bm("inner")])
      }, [
        !_ctx.props.hideMask ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([_ctx.nh.be("mask"), _ctx.props.maskClass]),
          style: normalizeStyle(_ctx.maskStyle),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleMaskClick && _ctx.handleMaskClick(...args))
        }, null, 6)) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "content", {}, () => [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("icon"))
          }, [
            renderSlot(_ctx.$slots, "icon", {}, () => [
              _ctx.props.spin ? (openBlock(), createBlock(_component_Icon, {
                key: 0,
                spin: "",
                icon: _ctx.props.icon
              }, null, 8, ["icon"])) : (openBlock(), createBlock(_component_Icon, {
                key: 1,
                pulse: "",
                icon: _ctx.props.icon
              }, null, 8, ["icon"]))
            ])
          ], 2),
          _ctx.hasTip ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("tip"))
          }, [
            renderSlot(_ctx.$slots, "tip", {}, () => [
              createTextVNode(toDisplayString(_ctx.props.tip), 1)
            ])
          ], 2)) : createCommentVNode("", true)
        ])
      ], 2)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["name", "onAfterEnter", "onAfterLeave"]));
}
var Spin = _export_sfc(_sfc_main69, [["render", _sfc_render69]]);

// node_modules/vexip-ui/es/components/split/props.mjs
var splitProps = buildProps({
  value: Number,
  min: Number,
  max: Number,
  vertical: booleanProp,
  noTransition: booleanProp,
  lazy: booleanProp,
  canFull: booleanProp,
  onChange: eventProp(),
  onFull: eventProp(),
  onReset: eventProp(),
  onMoveStart: eventProp(),
  onMove: eventProp(),
  onMoveEnd: eventProp()
});

// node_modules/vexip-ui/es/components/split/split.mjs
var _sfc_main70 = defineComponent({
  name: "Split",
  components: {
    Icon
  },
  props: splitProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const props = useProps("split", _props, {
      value: {
        default: 0.5,
        validator: (value) => value > 0 && value < 1,
        static: true
      },
      min: 0.1,
      max: 0.9,
      vertical: false,
      noTransition: false,
      lazy: false,
      canFull: false
    });
    const nh = useNameHelper("split");
    const currentValue = ref(props.value);
    const currentFull = ref(0);
    const transition = ref(false);
    const wrapper = ref();
    const guide = ref();
    const { target: handler, moving } = jo({
      lazy: true,
      capture: false,
      onStart: (state, event) => {
        if (currentFull.value || !wrapper.value || event.button > 0) {
          return false;
        }
        const { min, max, vertical, lazy } = props;
        const outer = wrapper.value[offset.value];
        const computedMin = min <= 1 ? min : min / outer;
        const computedMax = max <= 1 ? max : max / outer;
        state.outer = outer;
        state.min = computedMin;
        state.max = computedMax;
        state.vertical = vertical;
        state.splitLazy = lazy;
        state.start = currentValue.value * outer;
        state.target = currentValue.value;
        if (lazy && guide.value) {
          guide.value.style[position.value[0]] = `${currentValue.value * 100}`;
          guide.value.style.display = "block";
        }
        emitEvent(props.onMoveStart, currentValue.value);
      },
      onMove: (state) => {
        const outer = state.outer;
        const min = state.min;
        const max = state.max;
        const delta = state.vertical ? state.deltaY : state.deltaX;
        const start = state.start;
        const value = Math.min(Math.max(min, (start + delta) / outer), max);
        if (state.splitLazy) {
          if (guide.value) {
            guide.value.style[position.value[0]] = `${value * 100}%`;
          }
          state.target = value;
        } else {
          currentValue.value = value;
        }
        emitEvent(props.onMove, value);
      },
      onEnd: (state) => {
        if (guide.value) {
          guide.value.style.display = "";
        }
        const target = state.target;
        if (state.splitLazy) {
          if (Math.abs(target - currentValue.value) > 0.01) {
            setTransition();
          }
          currentValue.value = target;
        }
        emitEvent(props.onMoveEnd, currentValue.value);
      }
    });
    const className = computed(() => {
      let fullType = "";
      if (currentFull.value) {
        if (props.vertical) {
          fullType = currentFull.value < 0 ? "top" : "bottom";
        } else {
          fullType = currentFull.value < 0 ? "left" : "right";
        }
      }
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.vertical ? "vertical" : "horizontal")]: true,
        [nh.bm("moving")]: moving.value,
        [nh.bm(`${fullType}-full`)]: !!fullType,
        [nh.bm("transition")]: transition.value
      };
    });
    const offset = computed(() => {
      return props.vertical ? "offsetHeight" : "offsetWidth";
    });
    const position = computed(() => {
      return props.vertical ? ["top", "bottom"] : ["left", "right"];
    });
    const leftPaneStyle = computed(() => {
      return {
        [position.value[1]]: currentFull.value < 0 ? "0" : currentFull.value > 0 ? "100%" : `${(1 - currentValue.value) * 100}%`
      };
    });
    const rightPaneStyle = computed(() => {
      return {
        [position.value[0]]: currentFull.value < 0 ? "100%" : currentFull.value > 0 ? "0" : `${currentValue.value * 100}%`
      };
    });
    const triggerStyle = computed(() => {
      return {
        [position.value[0]]: currentFull.value < 0 ? "100%" : currentFull.value > 0 ? "0" : `calc(${currentValue.value * 100}% - var(${nh.cv("handler-size")}) * 0.5)`
      };
    });
    const fullIcons = computed(() => {
      return props.vertical ? [$15, $18] : [$17, $16];
    });
    watch(
      () => props.value,
      (value) => {
        if (value.toFixed(5) !== currentValue.value.toFixed(5)) {
          currentValue.value = value;
          setTransition();
        }
      }
    );
    watch(currentValue, (value) => {
      emitEvent(props.onChange, value);
      emit("update:value", value);
      if (guide.value) {
        guide.value.style[position.value[0]] = `${value * 100}%`;
      }
    });
    watch(currentFull, (value) => {
      setTransition();
      if (value) {
        let type;
        if (props.vertical) {
          type = value < 0 ? "top" : "bottom";
        } else {
          type = value < 0 ? "left" : "right";
        }
        emitEvent(props.onFull, type);
      } else {
        emitEvent(props.onReset);
      }
    });
    function setTransition() {
      transition.value = !props.noTransition && !moving.value;
    }
    function removeTransition() {
      transition.value = false;
    }
    function handleFull(type) {
      if (!props.canFull) {
        return;
      }
      if (currentFull.value) {
        currentFull.value = 0;
      } else {
        currentFull.value = type;
      }
    }
    return {
      props,
      nh,
      className,
      position,
      leftPaneStyle,
      rightPaneStyle,
      triggerStyle,
      fullIcons,
      wrapper,
      guide,
      handler,
      removeTransition,
      handleFull
    };
  }
});
function _sfc_render70(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onTransitionend: _cache[4] || (_cache[4] = (...args) => _ctx.removeTransition && _ctx.removeTransition(...args))
  }, [
    createBaseVNode("div", {
      class: normalizeClass([_ctx.nh.be("panel"), _ctx.nh.bem("panel", _ctx.props.vertical ? "top" : "left")]),
      style: normalizeStyle(_ctx.leftPaneStyle)
    }, [
      renderSlot(_ctx.$slots, "left")
    ], 6),
    createBaseVNode("div", {
      class: normalizeClass([_ctx.nh.be("panel"), _ctx.nh.bem("panel", _ctx.props.vertical ? "bottom" : "right")]),
      style: normalizeStyle(_ctx.rightPaneStyle)
    }, [
      renderSlot(_ctx.$slots, "right")
    ], 6),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("trigger")),
      style: normalizeStyle(_ctx.triggerStyle)
    }, [
      createBaseVNode("div", {
        ref: "handler",
        class: normalizeClass(_ctx.nh.be("handler"))
      }, [
        _ctx.props.canFull ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("button", {
            class: normalizeClass([_ctx.nh.be("button"), _ctx.nh.bem("button", `${_ctx.props.vertical ? "top" : "left"}-full`)]),
            onPointerdown: _cache[0] || (_cache[0] = withModifiers(() => {
            }, ["stop"])),
            onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.handleFull(-1), ["left"]))
          }, [
            createVNode(_component_Icon, {
              icon: _ctx.fullIcons[0],
              scale: 0.6
            }, null, 8, ["icon", "scale"])
          ], 34),
          createBaseVNode("button", {
            class: normalizeClass([
              _ctx.nh.be("button"),
              _ctx.nh.bem("button", `${_ctx.props.vertical ? "bottom" : "right"}-full`)
            ]),
            onPointerdown: _cache[2] || (_cache[2] = withModifiers(() => {
            }, ["stop"])),
            onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.handleFull(1), ["left"]))
          }, [
            createVNode(_component_Icon, {
              icon: _ctx.fullIcons[1],
              scale: 0.6
            }, null, 8, ["icon", "scale"])
          ], 34)
        ], 64)) : renderSlot(_ctx.$slots, "handler", { key: 1 }, () => [
          (openBlock(), createElementBlock(Fragment, null, renderList(6, (n) => {
            return createBaseVNode("span", {
              key: n,
              class: normalizeClass(_ctx.nh.be("pointer"))
            }, null, 2);
          }), 64))
        ])
      ], 2)
    ], 6),
    createBaseVNode("div", {
      ref: "guide",
      class: normalizeClass(_ctx.nh.be("guide"))
    }, null, 2)
  ], 34);
}
var Split = _export_sfc(_sfc_main70, [["render", _sfc_render70]]);

// node_modules/vexip-ui/es/components/tab-nav/symbol.mjs
var TAB_NAV_STATE = Symbol("TAB_NAV_STATE");

// node_modules/vexip-ui/es/components/tab-nav/tab-nav-item.mjs
var _sfc_main71 = defineComponent({
  name: "TabNavItem",
  components: {
    Icon,
    Xmark: L2
  },
  props: {
    label: {
      type: [String, Number],
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    icon: {
      type: Object,
      default: null
    },
    closable: {
      type: Boolean,
      default: null
    },
    onToggle: eventProp()
  },
  emits: [],
  setup(props) {
    const tabNavState = inject(TAB_NAV_STATE, null);
    const nh = useNameHelper("tab-nav");
    const active = ref(false);
    const currentLabel = ref(props.label);
    const index = ref(0);
    const total = ref(0);
    const wrapper = ref();
    const contentClass = computed(() => {
      const baseClass = nh.be("content");
      return {
        [baseClass]: true,
        [`${baseClass}--disabled`]: props.disabled,
        [`${baseClass}--active`]: !props.disabled && active.value
      };
    });
    const isClosable = computed(() => {
      var _a;
      if (y(props.closable)) {
        return props.closable;
      }
      return (_a = tabNavState == null ? void 0 : tabNavState.closable) != null ? _a : false;
    });
    watch(
      () => props.label,
      (value) => {
        currentLabel.value = value;
        tabNavState == null ? void 0 : tabNavState.refreshLabels();
      }
    );
    watch(active, (value) => {
      emitEvent(props.onToggle, value);
    });
    if (tabNavState) {
      const state = reactive({
        el: wrapper,
        label: currentLabel,
        index,
        total
      });
      watch(currentLabel, () => {
        active.value = currentLabel.value === tabNavState.currentActive;
      });
      watch(
        () => tabNavState.currentActive,
        (value) => {
          active.value = currentLabel.value === value;
        },
        { immediate: true }
      );
      tabNavState.increaseItem(state);
      onBeforeUnmount(() => {
        tabNavState.decreaseItem(state);
      });
    }
    function handleSelect() {
      if (props.disabled) {
        return;
      }
      tabNavState == null ? void 0 : tabNavState.handleActive(currentLabel.value);
    }
    function handleClose() {
      if (props.disabled) {
        return;
      }
      tabNavState == null ? void 0 : tabNavState.handleClose(currentLabel.value);
    }
    return {
      nh,
      index,
      total,
      contentClass,
      isClosable,
      wrapper,
      handleSelect,
      handleClose
    };
  }
});
var _hoisted_139 = ["aria-disabled", "aria-setsize", "aria-posinset"];
function _sfc_render71(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Xmark = resolveComponent("Xmark");
  return openBlock(), createElementBlock("li", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("item")),
    role: "none"
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("pad"))
    }, null, 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.contentClass),
      role: "tab",
      tabindex: "0",
      "aria-disabled": _ctx.disabled,
      "aria-setsize": _ctx.total || void 0,
      "aria-posinset": _ctx.index || void 0,
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleSelect && _ctx.handleSelect(...args)),
      onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.handleSelect && _ctx.handleSelect(...args), ["stop"]), ["enter"]))
    }, [
      _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
        key: 0,
        class: normalizeClass(_ctx.nh.be("icon")),
        icon: _ctx.icon
      }, null, 8, ["class", "icon"])) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ]),
      _ctx.isClosable ? (openBlock(), createElementBlock("button", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("close")),
        onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClose && _ctx.handleClose(...args), ["stop"]))
      }, [
        createVNode(_component_Icon, null, {
          default: withCtx(() => [
            createVNode(_component_Xmark)
          ]),
          _: 1
        })
      ], 2)) : createCommentVNode("", true)
    ], 42, _hoisted_139)
  ], 2);
}
var TabNavItem = _export_sfc(_sfc_main71, [["render", _sfc_render71]]);

// node_modules/vexip-ui/es/components/tab-nav/props.mjs
var tabNavProps = buildProps({
  active: [String, Number],
  card: booleanProp,
  options: Array,
  align: String,
  placement: String,
  closable: booleanProp,
  showAdd: booleanProp,
  onChange: eventProp(),
  onAdd: eventProp(),
  onClose: eventProp()
});

// node_modules/vexip-ui/es/components/tab-nav/tab-nav.mjs
var trackStyleMap = {
  top: ["left", "width"],
  right: ["top", "height"],
  bottom: ["left", "width"],
  left: ["top", "height"]
};
var _sfc_main72 = defineComponent({
  name: "TabNav",
  components: {
    Icon,
    ResizeObserver,
    TabNavItem,
    Plus: x10
  },
  props: tabNavProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const props = useProps("tabNav", _props, {
      active: {
        default: null,
        static: true
      },
      card: false,
      options: {
        default: () => [],
        static: true
      },
      align: "left",
      placement: "top",
      closable: false,
      showAdd: false
    });
    const nh = useNameHelper("tab-nav");
    const currentActive = ref(props.active);
    const markerPosition = ref(0);
    const markerSize = ref(0);
    const itemStates = /* @__PURE__ */ new Set();
    const wrapper = Ao(updateMarkerPosition);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(`align-${props.align}`)]: true,
        [nh.bm(props.placement)]: true,
        [nh.bm("card")]: props.card
      };
    });
    const markerStyle = computed(() => {
      const [position, length] = trackStyleMap[props.placement];
      return {
        [position]: `${markerPosition.value}px`,
        [length]: `${markerSize.value}px`
      };
    });
    const items = computed(() => {
      return props.options.map((item) => {
        if (typeof item === "string" || typeof item === "number") {
          return { label: item };
        }
        return item;
      });
    });
    const refreshLabels = Mr(() => {
      const total = itemStates.size;
      Array.from(itemStates).forEach((item, index) => {
        item.index = index + 1;
        item.total = total;
        if (qe(item.label)) {
          item.label = index + 1;
        }
      });
      if (itemStates.size >= 1 && isActiveEmpty()) {
        currentActive.value = Array.from(itemStates)[0].label;
      }
    });
    provide(
      TAB_NAV_STATE,
      reactive({
        currentActive,
        closable: toRef(props, "closable"),
        increaseItem,
        decreaseItem,
        handleActive,
        handleClose,
        refreshLabels
      })
    );
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    watch(
      () => props.placement,
      () => {
        requestAnimationFrame(updateMarkerPosition);
      }
    );
    onMounted(updateMarkerPosition);
    function isActiveEmpty() {
      return qe(currentActive.value) || currentActive.value === "";
    }
    function increaseItem(item) {
      itemStates.add(item);
      refreshLabels();
    }
    function decreaseItem(item) {
      itemStates.delete(item);
      refreshLabels();
    }
    function handleActive(label) {
      currentActive.value = label;
      updateMarkerPosition();
      emitEvent(props.onChange, label);
      emit("update:active", label);
    }
    function handleAdd() {
      emitEvent(props.onAdd);
    }
    function handleClose(label) {
      emitEvent(props.onClose, label);
      requestAnimationFrame(updateMarkerPosition);
    }
    function updateMarkerPosition() {
      const activeItem = Array.from(itemStates).find((item) => item.label === currentActive.value);
      if (activeItem == null ? void 0 : activeItem.el) {
        if (props.placement === "top" || props.placement === "bottom") {
          markerPosition.value = activeItem.el.offsetLeft;
          markerSize.value = activeItem.el.offsetWidth;
        } else {
          markerPosition.value = activeItem.el.offsetTop;
          markerSize.value = activeItem.el.offsetHeight;
        }
      } else {
        markerPosition.value = 0;
        markerSize.value = 0;
      }
    }
    return {
      props,
      nh,
      className,
      markerStyle,
      items,
      wrapper,
      updateMarkerPosition,
      handleAdd
    };
  }
});
function _sfc_render72(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_TabNavItem = resolveComponent("TabNavItem");
  const _component_Plus = resolveComponent("Plus");
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    tabindex: "-1"
  }, [
    createBaseVNode("ul", {
      class: normalizeClass(_ctx.nh.be("list")),
      role: "tablist"
    }, [
      createVNode(_component_ResizeObserver, { "on-resize": _ctx.updateMarkerPosition }, {
        default: withCtx(() => [
          createBaseVNode("li", {
            class: normalizeClass([_ctx.nh.be("extra"), _ctx.nh.bem("extra", "prefix")])
          }, [
            _ctx.$slots.prefix ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("prefix"))
            }, [
              renderSlot(_ctx.$slots, "prefix")
            ], 2)) : createCommentVNode("", true)
          ], 2)
        ]),
        _: 3
      }, 8, ["on-resize"]),
      renderSlot(_ctx.$slots, "default", {}, () => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item) => {
          return openBlock(), createBlock(_component_TabNavItem, {
            key: item.label,
            label: item.label,
            icon: item.icon,
            disabled: item.disabled,
            closable: item.closable,
            onToggle: item.onToggle
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(item.content || item.label), 1)
            ]),
            _: 2
          }, 1032, ["label", "icon", "disabled", "closable", "onToggle"]);
        }), 128))
      ]),
      _ctx.props.showAdd || _ctx.$slots.add ? (openBlock(), createElementBlock("li", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("item")),
        role: "none"
      }, [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("pad"))
        }, null, 2),
        createBaseVNode("button", {
          class: normalizeClass(_ctx.nh.be("add")),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleAdd && _ctx.handleAdd(...args))
        }, [
          renderSlot(_ctx.$slots, "add", {}, () => [
            createVNode(_component_Icon, { scale: 1.2 }, {
              default: withCtx(() => [
                createVNode(_component_Plus)
              ]),
              _: 1
            }, 8, ["scale"])
          ])
        ], 2)
      ], 2)) : createCommentVNode("", true),
      createVNode(_component_ResizeObserver, { "on-resize": _ctx.updateMarkerPosition }, {
        default: withCtx(() => [
          createBaseVNode("li", {
            class: normalizeClass([_ctx.nh.be("extra"), _ctx.nh.bem("extra", "suffix")])
          }, [
            _ctx.$slots.suffix ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("suffix"))
            }, [
              renderSlot(_ctx.$slots, "suffix")
            ], 2)) : createCommentVNode("", true)
          ], 2)
        ]),
        _: 3
      }, 8, ["on-resize"])
    ], 2),
    !_ctx.props.card ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("track")),
      style: normalizeStyle(_ctx.markerStyle)
    }, [
      renderSlot(_ctx.$slots, "marker", {}, () => [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("marker"))
        }, null, 2)
      ])
    ], 6)) : createCommentVNode("", true)
  ], 2);
}
var TabNav = _export_sfc(_sfc_main72, [["render", _sfc_render72]]);

// node_modules/vexip-ui/es/components/tabs/symbol.mjs
var TABS_STATE = Symbol("TABS_STATE");

// node_modules/vexip-ui/es/components/tabs/tab-panel.mjs
var _sfc_main73 = defineComponent({
  name: "TabPanel",
  props: {
    label: {
      type: [String, Number],
      default: null
    },
    name: {
      type: String,
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    icon: {
      type: Object,
      default: null
    },
    closable: {
      type: Boolean,
      default: null
    },
    onToggle: eventProp()
  },
  emits: [],
  setup(props, { slots }) {
    const tabsState = inject(TABS_STATE, null);
    const nh = useNameHelper("tabs");
    const active = ref(false);
    const currentLabel = ref(props.label);
    const className = computed(() => {
      const baseClass = nh.be("panel");
      return {
        [baseClass]: true,
        [`${baseClass}--disabled`]: props.disabled,
        [`${baseClass}--active`]: !props.disabled && active.value
      };
    });
    watch(
      () => props.label,
      (value) => {
        currentLabel.value = value;
        tabsState == null ? void 0 : tabsState.refreshLabels();
      }
    );
    watch(active, (value) => {
      emitEvent(props.onToggle, value);
    });
    if (tabsState) {
      const state = reactive({
        label: currentLabel,
        name: toRef(props, "name"),
        icon: toRef(props, "icon"),
        disabled: toRef(props, "disabled"),
        closable: toRef(props, "closable"),
        labelRenderer: null
      });
      watch(
        () => slots.label,
        (value) => {
          state.labelRenderer = value ? (data) => value(data) : null;
        },
        { immediate: true }
      );
      watch(currentLabel, (value, prevValue) => {
        active.value = currentLabel.value === tabsState.currentActive;
      });
      watch(
        () => tabsState.currentActive,
        (value) => {
          active.value = currentLabel.value === value;
        },
        { immediate: true }
      );
      tabsState.increaseItem(state);
      onBeforeUnmount(() => {
        tabsState.decreaseItem(state);
      });
    }
    return {
      active,
      className
    };
  }
});
var _hoisted_140 = ["aria-hidden"];
function _sfc_render73(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "tabpanel",
    "aria-hidden": !_ctx.active
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 10, _hoisted_140);
}
var TabPanel = _export_sfc(_sfc_main73, [["render", _sfc_render73]]);

// node_modules/vexip-ui/es/components/table/symbol.mjs
var DEFAULT_KEY_FIELD = "id";
var TABLE_STORE = Symbol("TABLE_STORE");
var TABLE_ACTION = Symbol("TABLE_ACTION");
var TABLE_HEAD_KEY = Symbol("TABLE_HEAD_KEY");

// node_modules/vexip-ui/es/components/table/table-head-cell.mjs
var columnTypes = ["order", "selection", "expand"];
var _sfc_main74 = defineComponent({
  name: "TableHeadCell",
  components: {
    Button,
    Checkbox,
    Icon,
    Renderer,
    Tooltip,
    CaretUp: $14,
    CaretDown: $12,
    Filter: x8
  },
  props: {
    column: {
      type: Object,
      default: () => ({})
    },
    index: {
      type: Number,
      default: -1
    }
  },
  setup(props) {
    const { state, getters, mutations } = inject(TABLE_STORE);
    const tableAction = inject(TABLE_ACTION);
    const nh = useNameHelper("table");
    const filterVisible = ref(false);
    const wrapper = ref();
    const className = computed(() => {
      let customClass = null;
      if (typeof state.headClass === "function") {
        customClass = state.headClass(props.column, props.index);
      } else {
        customClass = state.headClass;
      }
      return [
        nh.be("head-cell"),
        {
          [nh.bem("head-cell", "center")]: columnTypes.includes(props.column.type)
        },
        props.column.className || null,
        customClass
      ];
    });
    const style = computed(() => {
      var _a;
      const width = state.widths[props.column.key];
      let customStyle = "";
      if (typeof state.headStyle === "function") {
        customStyle = state.headStyle(props.column, props.index);
      } else {
        customStyle = state.headStyle;
      }
      return [
        {
          flex: `${width} 0 auto`,
          width: `${(_a = props.column.width) != null ? _a : width}px`,
          maxWidth: `${props.column.width}px`
        },
        props.column.style || "",
        customStyle
      ];
    });
    const attrs = computed(() => {
      let customAttrs;
      if (typeof state.headAttrs === "function") {
        customAttrs = state.headAttrs(props.column, props.index);
      } else {
        customAttrs = state.headAttrs;
      }
      return { ...props.column.attrs || {}, ...customAttrs || {} };
    });
    const sorter = computed(() => {
      return state.sorters[props.column.key] || {};
    });
    const filter = computed(() => {
      return state.filters[props.column.key] || {};
    });
    const hasFilterActive = computed(() => {
      var _a;
      const options = (_a = filter.value.options) != null ? _a : [];
      for (let i = 0, len = options.length; i < len; ++i) {
        if (options[i].active) {
          return true;
        }
      }
      return false;
    });
    const checkboxDisabled = computed(() => {
      if (!isSelection(props.column)) {
        return false;
      }
      const records = Object.values(getters.disableCheckRows);
      return getters.processedData.length === records.length && !Object.values(getters.disableCheckRows).includes(false);
    });
    onMounted(() => {
      setTimeout(() => {
        if (wrapper.value) {
          mutations.setColumnWidth(props.column.key, wrapper.value.getBoundingClientRect().width);
        }
      }, 0);
    });
    function isSelection(column) {
      return column.type === "selection";
    }
    function buildEventPayload(event) {
      return {
        column: props.column,
        index: props.index,
        event
      };
    }
    function handleMouseEnter(event) {
      if (tableAction) {
        tableAction.emitHeadEnter(buildEventPayload(event));
      }
    }
    function handleMouseLeave(event) {
      if (tableAction) {
        tableAction.emitHeadLeave(buildEventPayload(event));
      }
    }
    function handleClick(event) {
      if (tableAction) {
        tableAction.emitHeadClick(buildEventPayload(event));
      }
    }
    function handleDblclick(event) {
      if (tableAction) {
        tableAction.emitHeadDblclick(buildEventPayload(event));
      }
    }
    function handleContextmenu(event) {
      if (tableAction) {
        tableAction.emitHeadContextmenu(buildEventPayload(event));
      }
    }
    function handleSortAsc() {
      const key = props.column.key;
      const type = sorter.value.type === "asc" ? null : "asc";
      mutations.handleSort(key, type);
      tableAction.emitRowSort();
    }
    function handleSortDesc() {
      const key = props.column.key;
      const type = sorter.value.type === "desc" ? null : "desc";
      mutations.handleSort(key, type);
      tableAction.emitRowSort();
    }
    function handleFilterItemSelect(value, active) {
      mutations.toggleFilterItemActive({
        key: props.column.key,
        value,
        active,
        disableOthers: true
      });
      mutations.handleFilter(props.column.key, value);
      filterVisible.value = false;
      tableAction.emitRowFilter();
    }
    function handleFilterCheck(value, checked) {
      mutations.toggleFilterItemActive({
        key: props.column.key,
        value,
        active: checked
      });
    }
    function handleFilterMutiple() {
      var _a;
      const options = (_a = filter.value.options) != null ? _a : [];
      const activeValues = [];
      for (let i = 0, len = options.length; i < len; ++i) {
        const option = options[i];
        if (option.active) {
          activeValues.push(option.value);
        }
      }
      mutations.handleFilter(props.column.key, activeValues);
      filterVisible.value = false;
      tableAction.emitRowFilter();
    }
    function handleResetFilter() {
      filterVisible.value = false;
      mutations.handleFilter(props.column.key, null);
      mutations.toggleFilterItemActive({
        key: props.column.key,
        value: null,
        disableOthers: true
      });
      tableAction.emitRowFilter();
    }
    function handleCheckAllRow() {
      mutations.handleCheckAll();
      tableAction.emitAllRowCheck(state.checkedAll, state.partial);
    }
    return {
      nh,
      locale: useLocale("table"),
      filterVisible,
      checkedAll: toRef(state, "checkedAll"),
      partial: toRef(state, "partial"),
      className,
      style,
      attrs,
      sorter,
      filter,
      hasFilterActive,
      checkboxDisabled,
      wrapper,
      isFunction: gt,
      isSelection,
      handleMouseEnter,
      handleMouseLeave,
      handleClick,
      handleDblclick,
      handleContextmenu,
      handleSortAsc,
      handleSortDesc,
      handleFilterItemSelect,
      handleFilterCheck,
      handleFilterMutiple,
      handleResetFilter,
      handleCheckAllRow
    };
  }
});
var _hoisted_141 = ["aria-sort"];
function _sfc_render74(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Renderer = resolveComponent("Renderer");
  const _component_CaretUp = resolveComponent("CaretUp");
  const _component_Icon = resolveComponent("Icon");
  const _component_CaretDown = resolveComponent("CaretDown");
  const _component_Filter = resolveComponent("Filter");
  const _component_Button = resolveComponent("Button");
  const _component_Tooltip = resolveComponent("Tooltip");
  return openBlock(), createElementBlock("div", mergeProps({
    ref: "wrapper",
    class: _ctx.className,
    role: "columnheader",
    style: _ctx.style,
    "aria-sort": _ctx.sorter.type ? _ctx.sorter.type === "asc" ? "ascending" : "descending" : "none"
  }, _ctx.attrs, {
    onMouseenter: _cache[5] || (_cache[5] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[6] || (_cache[6] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onClick: _cache[7] || (_cache[7] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onDblclick: _cache[8] || (_cache[8] = (...args) => _ctx.handleDblclick && _ctx.handleDblclick(...args)),
    onContextmenu: _cache[9] || (_cache[9] = (...args) => _ctx.handleContextmenu && _ctx.handleContextmenu(...args))
  }), [
    _ctx.isSelection(_ctx.column) ? (openBlock(), createBlock(_component_Checkbox, {
      key: 0,
      inherit: "",
      control: "",
      class: normalizeClass(_ctx.nh.be("selection")),
      checked: _ctx.checkedAll,
      partial: _ctx.partial,
      disabled: _ctx.checkboxDisabled,
      size: _ctx.column.checkboxSize || "default",
      onClick: withModifiers(_ctx.handleCheckAllRow, ["prevent"])
    }, null, 8, ["class", "checked", "partial", "disabled", "size", "onClick"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      _ctx.isFunction(_ctx.column.headRenderer) ? (openBlock(), createBlock(_component_Renderer, {
        key: 0,
        renderer: _ctx.column.headRenderer,
        data: { column: _ctx.column, index: _ctx.index }
      }, null, 8, ["renderer", "data"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createTextVNode(toDisplayString(_ctx.column.name), 1)
      ], 64))
    ], 64)),
    _ctx.sorter.able ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(_ctx.nh.be("sorter"))
    }, [
      createBaseVNode("span", {
        class: normalizeClass({
          [_ctx.nh.bem("sorter", "asc")]: true,
          [_ctx.nh.bem("sorter", "active")]: _ctx.sorter.type === "asc"
        }),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleSortAsc())
      }, [
        createVNode(_component_Icon, null, {
          default: withCtx(() => [
            createVNode(_component_CaretUp)
          ]),
          _: 1
        })
      ], 2),
      createBaseVNode("span", {
        class: normalizeClass({
          [_ctx.nh.bem("sorter", "desc")]: true,
          [_ctx.nh.bem("sorter", "active")]: _ctx.sorter.type === "desc"
        }),
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleSortDesc())
      }, [
        createVNode(_component_Icon, null, {
          default: withCtx(() => [
            createVNode(_component_CaretDown)
          ]),
          _: 1
        })
      ], 2)
    ], 2)) : createCommentVNode("", true),
    _ctx.filter.able ? (openBlock(), createBlock(_component_Tooltip, {
      key: 3,
      visible: _ctx.filterVisible,
      "onUpdate:visible": _cache[4] || (_cache[4] = ($event) => _ctx.filterVisible = $event),
      transfer: "",
      placement: "bottom",
      trigger: "click",
      class: normalizeClass({
        [_ctx.nh.be("filter")]: true,
        [_ctx.nh.bem("filter", "visible")]: _ctx.filterVisible,
        [_ctx.nh.bem("filter", "active")]: _ctx.filter.active
      }),
      "tip-class": {
        [_ctx.nh.be("filter-wrapper")]: true,
        [_ctx.nh.bs("vars")]: true,
        [_ctx.nh.bem("filter-wrapper", "multiple")]: _ctx.filter.multiple
      }
    }, createSlots({
      trigger: withCtx(() => [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("filter-trigger"))
        }, [
          createVNode(_component_Icon, null, {
            default: withCtx(() => [
              createVNode(_component_Filter)
            ]),
            _: 1
          })
        ], 2)
      ]),
      _: 2
    }, [
      _ctx.filter.multiple ? {
        name: "default",
        fn: withCtx(() => [
          createBaseVNode("div", {
            vertical: "",
            class: normalizeClass(_ctx.nh.be("filter-group"))
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filter.options, (item) => {
              return openBlock(), createBlock(_component_Checkbox, {
                key: item.value,
                inherit: "",
                checked: item.active,
                label: item.label,
                value: item.value,
                onChange: ($event) => _ctx.handleFilterCheck(item.value, $event)
              }, null, 8, ["checked", "label", "value", "onChange"]);
            }), 128))
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("filter-actions"))
          }, [
            createVNode(_component_Button, {
              inherit: "",
              text: "",
              size: "small",
              disabled: !_ctx.hasFilterActive,
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.handleFilterMutiple())
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.locale.filterConfirm), 1)
              ]),
              _: 1
            }, 8, ["disabled"]),
            createVNode(_component_Button, {
              inherit: "",
              text: "",
              size: "small",
              onClick: _ctx.handleResetFilter
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.locale.filterReset), 1)
              ]),
              _: 1
            }, 8, ["onClick"])
          ], 2)
        ]),
        key: "0"
      } : {
        name: "default",
        fn: withCtx(() => [
          createBaseVNode("div", {
            class: normalizeClass({
              [_ctx.nh.be("filter-item")]: true,
              [_ctx.nh.bem("filter-item", "active")]: !_ctx.filter.active
            }),
            onClick: _cache[3] || (_cache[3] = (...args) => _ctx.handleResetFilter && _ctx.handleResetFilter(...args))
          }, toDisplayString(_ctx.locale.filterAll), 3),
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.filter.options, (item) => {
            return openBlock(), createElementBlock("div", {
              key: item.value,
              class: normalizeClass({
                [_ctx.nh.be("filter-item")]: true,
                [_ctx.nh.bem("filter-item", "active")]: item.active
              }),
              onClick: ($event) => _ctx.handleFilterItemSelect(item.value, !item.active)
            }, toDisplayString(item.label), 11, ["onClick"]);
          }), 128))
        ]),
        key: "1"
      }
    ]), 1032, ["visible", "class", "tip-class"])) : createCommentVNode("", true)
  ], 16, _hoisted_141);
}
var TableHeadCell = _export_sfc(_sfc_main74, [["render", _sfc_render74]]);

// node_modules/vexip-ui/es/components/table/table-row.mjs
var _sfc_main75 = defineComponent({
  name: "TableRow",
  components: {
    CollapseTransition,
    Renderer
  },
  props: {
    row: {
      type: Object,
      default: () => ({})
    },
    index: {
      type: Number,
      default: null
    },
    isHead: {
      type: Boolean,
      default: false
    },
    isFixed: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const { state, mutations } = inject(TABLE_STORE);
    const tableAction = inject(TABLE_ACTION);
    const nh = useNameHelper("table");
    const wrapper = ref();
    const rowElement = ref();
    const expandElement = ref();
    const instance = reactive({
      el: wrapper,
      row: toRef(props, "row")
    });
    const rowKey = computed(() => props.isHead ? TABLE_HEAD_KEY : props.row.key);
    const className = computed(() => {
      let customClass = null;
      if (!props.isHead) {
        if (typeof state.rowClass === "function") {
          customClass = state.rowClass(props.row.data, props.index);
        } else {
          customClass = state.rowClass;
        }
      }
      return [
        nh.be("row"),
        {
          [nh.bem("row", "hover")]: !props.isHead && state.highlight && props.row.hover,
          [nh.bem("row", "stripe")]: props.index % 2 === 1,
          [nh.bem("row", "checked")]: props.row.checked
        },
        customClass
      ];
    });
    const style = computed(() => {
      let customStyle = "";
      if (!props.isHead) {
        if (typeof state.rowStyle === "function") {
          customStyle = state.rowStyle(props.row.data, props.index);
        } else {
          customStyle = state.rowStyle;
        }
      }
      return [
        {
          minHeight: !state.rowHeight ? `${state.rowMinHeight}px` : void 0
        },
        customStyle
      ];
    });
    const attrs = computed(() => {
      if (!props.isHead) {
        if (typeof state.rowAttrs === "function") {
          return state.rowAttrs(props.row.data, props.index);
        } else {
          return state.rowAttrs;
        }
      }
      return null;
    });
    const draggable = computed(() => !props.isHead && state.rowDraggable);
    const dragging = computed(() => state.dragging);
    const expandColumn = computed(() => {
      return state.columns.find((column) => column.type === "expand");
    });
    const expandRenderer = computed(() => state.expandRenderer);
    const expandStyle = computed(() => {
      return props.isFixed ? {
        width: "1px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        visibility: "hidden"
      } : {};
    });
    const leftFixed = computed(() => computeFixedWidth(state.leftFixedColumns));
    const rightFixed = computed(() => computeFixedWidth(state.rightFixedColumns));
    function getRowHeight(row) {
      if (!row)
        return 0;
      return (row.borderHeight || 0) + (row.height || 0) + (row.expandHeight || 0);
    }
    function computeFixedWidth(columns) {
      if (!(columns == null ? void 0 : columns.length)) {
        return 0;
      }
      const widths = state.widths;
      let width = 0;
      for (let i = 0, len = columns.length; i < len; ++i) {
        const column = columns[i];
        const key = column.key;
        const columnWidth = widths[key];
        width += columnWidth;
      }
      return width;
    }
    function computeRectHeight() {
      if (!Object.keys(props.row).length || props.row.hidden)
        return;
      computeBorderHeight();
      computeRowHeight();
      if (state.heightBITree && !props.isFixed) {
        nextTick(() => {
          const height = getRowHeight(props.row);
          const tree = state.heightBITree;
          const prev = tree.get(props.index);
          if (height !== prev) {
            tree.add(props.index, height - prev);
            mutations.updateTotalHeight();
          }
        });
      }
    }
    watch(
      () => props.row.hidden,
      (value) => {
        !value && computeRectHeight();
      }
    );
    watch(
      () => props.row,
      () => {
        computeRectHeight();
      }
    );
    onMounted(() => {
      computeRectHeight();
      mutations.updateTotalHeight();
    });
    onUpdated(() => {
      if (!state.rowHeight) {
        computeRectHeight();
      } else if (!props.row.hidden) {
        computeBorderHeight();
      }
    });
    function computeRowHeight() {
      if (state.rowHeight) {
        mutations.setRowHeight(rowKey.value, state.rowHeight);
        nextTick(() => {
          if (rowElement.value) {
            rowElement.value.style.height = `${state.rowHeight}px`;
            rowElement.value.style.maxHeight = `${state.rowHeight}px`;
          }
        });
      } else {
        nextTick(() => {
          if (!props.isFixed) {
            if (rowElement.value) {
              mutations.setRowHeight(rowKey.value, rowElement.value.offsetHeight);
            }
          } else {
            setTimeout(() => {
              if (rowElement.value) {
                rowElement.value.style.height = `${props.row.height}px`;
              }
            }, 0);
          }
        });
      }
    }
    function computeBorderHeight() {
      var _a;
      if (wrapper.value) {
        const style2 = getComputedStyle(wrapper.value);
        const borderHeight = parseFloat(style2.borderTopWidth) + parseFloat(style2.borderBottomWidth);
        mutations.setBorderHeight(rowKey.value, borderHeight);
        mutations.setRowExpandHeight(rowKey.value, ((_a = expandElement.value) == null ? void 0 : _a.offsetHeight) || 0);
      }
    }
    function buildEventPayload(event) {
      return {
        row: props.row.data,
        key: props.row.key,
        index: props.index,
        event
      };
    }
    function handleMouseEnter(event) {
      mutations.setRowHover(rowKey.value, true);
      if (!props.isHead && tableAction) {
        const { data, key, index } = props.row;
        tableAction.emitRowEnter({ row: data, key, index, event });
      }
    }
    function handleMouseLeave(event) {
      mutations.setRowHover(rowKey.value, false);
      if (!props.isHead && tableAction) {
        tableAction.emitRowLeave(buildEventPayload(event));
      }
    }
    function handleClick(event) {
      if (!props.isHead && tableAction) {
        tableAction.emitRowClick(buildEventPayload(event));
      }
    }
    function handleDblclick(event) {
      if (!props.isHead && tableAction) {
        tableAction.emitRowDblclick(buildEventPayload(event));
      }
    }
    function handleContextmenu(event) {
      if (!props.isHead && tableAction) {
        tableAction.emitRowContextmenu(buildEventPayload(event));
      }
    }
    function handleDragStart(event) {
      if (!draggable.value)
        return;
      tableAction.handleRowDragStart(instance, event);
    }
    function handleDragOver(event) {
      if (!draggable.value || !dragging.value)
        return;
      event.stopPropagation();
      event.preventDefault();
      tableAction.handleRowDragOver(instance, event);
    }
    function handleDrop(event) {
      if (!draggable.value || !dragging.value)
        return;
      event.stopPropagation();
      event.preventDefault();
      tableAction.handleRowDrop(instance, event);
    }
    function handleDragEnd(event) {
      if (!draggable.value || !dragging.value)
        return;
      event.stopPropagation();
      tableAction.handleRowDragEnd(event);
    }
    return {
      nh,
      className,
      style,
      attrs,
      draggable,
      expandColumn,
      expandRenderer,
      expandStyle,
      leftFixed,
      rightFixed,
      wrapper,
      rowEl: rowElement,
      expand: expandElement,
      isFunction: gt,
      handleMouseEnter,
      handleMouseLeave,
      handleClick,
      handleDblclick,
      handleContextmenu,
      handleDragStart,
      handleDragOver,
      handleDrop,
      handleDragEnd,
      computeRectHeight
    };
  }
});
var _hoisted_142 = ["draggable"];
var _hoisted_217 = ["aria-rowindex"];
function _sfc_render75(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return !_ctx.row.hidden ? (openBlock(), createElementBlock("div", {
    key: 0,
    ref: "wrapper",
    class: normalizeClass([_ctx.nh.be("group"), _ctx.row.checked && _ctx.nh.bem("group", "checked")]),
    draggable: _ctx.draggable,
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onDblclick: _cache[3] || (_cache[3] = (...args) => _ctx.handleDblclick && _ctx.handleDblclick(...args)),
    onContextmenu: _cache[4] || (_cache[4] = (...args) => _ctx.handleContextmenu && _ctx.handleContextmenu(...args)),
    onDragstart: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
    onDragover: _cache[6] || (_cache[6] = (...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args)),
    onDragend: _cache[7] || (_cache[7] = (...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args)),
    onDrop: _cache[8] || (_cache[8] = (...args) => _ctx.handleDrop && _ctx.handleDrop(...args))
  }, [
    createBaseVNode("div", mergeProps({
      ref: "rowEl",
      class: _ctx.className,
      role: "row",
      style: _ctx.style,
      "aria-rowindex": _ctx.index
    }, _ctx.attrs), [
      renderSlot(_ctx.$slots, "default")
    ], 16, _hoisted_217),
    !!_ctx.expandColumn ? (openBlock(), createBlock(_component_CollapseTransition, {
      key: 0,
      appear: "",
      onAfterEnter: _ctx.computeRectHeight,
      onAfterLeave: _ctx.computeRectHeight
    }, {
      default: withCtx(() => [
        _ctx.row.expanded ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "expand",
          class: normalizeClass(_ctx.nh.be("collapse")),
          style: normalizeStyle(_ctx.expandStyle)
        }, [
          _ctx.isFunction(_ctx.expandColumn.renderer) ? (openBlock(), createBlock(_component_Renderer, {
            key: 0,
            renderer: _ctx.expandColumn.renderer,
            data: { leftFixed: _ctx.leftFixed, rightFixed: _ctx.rightFixed, row: _ctx.row.data, rowIndex: _ctx.index }
          }, null, 8, ["renderer", "data"])) : _ctx.isFunction(_ctx.expandRenderer) ? (openBlock(), createBlock(_component_Renderer, {
            key: 1,
            renderer: _ctx.expandRenderer,
            data: { leftFixed: _ctx.leftFixed, rightFixed: _ctx.rightFixed, row: _ctx.row.data, rowIndex: _ctx.index }
          }, null, 8, ["renderer", "data"])) : createCommentVNode("", true)
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["onAfterEnter", "onAfterLeave"])) : createCommentVNode("", true)
  ], 42, _hoisted_142)) : createCommentVNode("", true);
}
var TableRow = _export_sfc(_sfc_main75, [["render", _sfc_render75]]);

// node_modules/vexip-ui/es/components/table/table-head.mjs
var _sfc_main76 = defineComponent({
  name: "TableHead",
  components: {
    TableHeadCell,
    TableRow
  },
  props: {
    fixed: {
      type: String,
      default: null,
      validator: (value) => {
        return value === "left" || value === "right";
      }
    }
  },
  setup(props) {
    const { state } = inject(TABLE_STORE);
    const currentColumns = computed(() => {
      if (props.fixed === "left") {
        return state.leftFixedColumns;
      }
      if (props.fixed === "right") {
        return state.rightFixedColumns;
      }
      return state.columns;
    });
    const style = computed(() => {
      const widths = state.widths;
      const columns = currentColumns.value;
      let width = 0;
      for (let i = 0, len = columns.length; i < len; ++i) {
        const column = columns[i];
        const key = column.key;
        const columnWidth = widths[key];
        width += columnWidth;
      }
      return {
        minWidth: `${width}px`
      };
    });
    const headRow = computed(() => state.dataMap[TABLE_HEAD_KEY] || { key: TABLE_HEAD_KEY });
    return {
      nh: useNameHelper("table"),
      currentColumns,
      style,
      headRow
    };
  }
});
function _sfc_render76(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TableHeadCell = resolveComponent("TableHeadCell");
  const _component_TableRow = resolveComponent("TableRow");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.nh.be("head")),
    role: "rowgroup",
    style: normalizeStyle(_ctx.style)
  }, [
    createVNode(_component_TableRow, {
      "is-head": "",
      row: _ctx.headRow
    }, {
      default: withCtx(() => [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentColumns, (item, index) => {
          return openBlock(), createBlock(_component_TableHeadCell, {
            key: index,
            column: item,
            index
          }, null, 8, ["column", "index"]);
        }), 128))
      ]),
      _: 1
    }, 8, ["row"])
  ], 6);
}
var TableHead = _export_sfc(_sfc_main76, [["render", _sfc_render76]]);

// node_modules/vexip-ui/es/components/table/table-cell.mjs
var columnTypes2 = ["order", "selection", "expand"];
var _sfc_main77 = defineComponent({
  name: "TableCell",
  components: {
    Checkbox,
    Ellipsis,
    Icon,
    Renderer,
    AngleRight: $3
  },
  props: {
    row: {
      type: Object,
      default: () => ({})
    },
    rowIndex: {
      type: Number,
      default: -1
    },
    column: {
      type: Object,
      default: () => ({})
    },
    columnIndex: {
      type: Number,
      default: -1
    }
  },
  setup(props) {
    const { state, getters, mutations } = inject(TABLE_STORE);
    const tableAction = inject(TABLE_ACTION);
    const nh = useNameHelper("table");
    const className = computed(() => {
      let customClass = null;
      if (typeof state.cellClass === "function") {
        customClass = state.cellClass(
          props.row.data,
          props.column,
          props.rowIndex,
          props.columnIndex
        );
      } else {
        customClass = state.cellClass;
      }
      return [
        nh.be("cell"),
        {
          [nh.bem("cell", "center")]: columnTypes2.includes(props.column.type),
          [nh.bem("cell", "wrap")]: props.column.noEllipsis
        },
        props.column.className || null,
        customClass
      ];
    });
    const style = computed(() => {
      var _a;
      const width = state.widths[props.column.key];
      let customStyle = "";
      if (typeof state.cellStyle === "function") {
        customStyle = state.cellStyle(
          props.row.data,
          props.column,
          props.rowIndex,
          props.columnIndex
        );
      } else {
        customStyle = state.cellStyle;
      }
      return [
        {
          flex: `${width} 0 auto`,
          width: `${(_a = props.column.width) != null ? _a : width}px`,
          maxWidth: `${props.column.width}px`
        },
        props.column.style || "",
        customStyle
      ];
    });
    const attrs = computed(() => {
      let customAttrs;
      if (typeof state.cellAttrs === "function") {
        customAttrs = state.cellAttrs(
          props.row.data,
          props.column,
          props.rowIndex,
          props.columnIndex
        );
      } else {
        customAttrs = state.cellAttrs;
      }
      return { ...props.column.attrs || {}, ...customAttrs || {} };
    });
    function isSelection(column) {
      return column.type === "selection";
    }
    function isOrder(column) {
      return column.type === "order";
    }
    function isExpand(column) {
      return column.type === "expand";
    }
    function isTypeColumn(column) {
      return isSelection(column) || isOrder(column) || isExpand(column);
    }
    function buildEventPayload(event) {
      return {
        row: props.row.data,
        key: props.row.key,
        rowIndex: props.rowIndex,
        column: props.column,
        columnIndex: props.columnIndex,
        event
      };
    }
    function handleMouseEnter(event) {
      if (tableAction) {
        tableAction.emitCellEnter(buildEventPayload(event));
      }
    }
    function handleMouseLeave(event) {
      if (tableAction) {
        tableAction.emitCellLeave(buildEventPayload(event));
      }
    }
    function handleClick(event) {
      if (tableAction) {
        tableAction.emitCellClick(buildEventPayload(event));
      }
    }
    function handleDblclick(event) {
      if (tableAction) {
        tableAction.emitCellDblclick(buildEventPayload(event));
      }
    }
    function handleContextmenu(event) {
      if (tableAction) {
        tableAction.emitCellContextmenu(buildEventPayload(event));
      }
    }
    function handleCheckRow(row) {
      if (!getters.disableCheckRows[row.key]) {
        const checked = !row.checked;
        const { data, key, index } = row;
        mutations.handleCheck(key, checked);
        tableAction.emitRowCheck({ row: data, key, index, checked });
      }
    }
    function handleExpandRow(row) {
      if (!getters.disableExpandRows[row.key]) {
        const expanded = !row.expanded;
        const { data, key, index } = row;
        mutations.handleExpand(key, expanded);
        tableAction.emitRowExpand({ row: data, key, index, expanded });
      }
    }
    return {
      nh,
      className,
      style,
      attrs,
      tooltipTheme: toRef(state, "tooltipTheme"),
      tooltipWidth: toRef(state, "tooltipWidth"),
      disableCheckRows: toRef(getters, "disableCheckRows"),
      disableExpandRows: toRef(getters, "disableExpandRows"),
      isFunction: gt,
      isSelection,
      isOrder,
      isExpand,
      isTypeColumn,
      handleMouseEnter,
      handleMouseLeave,
      handleClick,
      handleDblclick,
      handleContextmenu,
      handleCheckRow,
      handleExpandRow
    };
  }
});
function _sfc_render77(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_AngleRight = resolveComponent("AngleRight");
  const _component_Icon = resolveComponent("Icon");
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Ellipsis = resolveComponent("Ellipsis");
  return _ctx.isTypeColumn(_ctx.column) ? (openBlock(), createElementBlock("div", mergeProps({
    key: 0,
    class: _ctx.className,
    role: "cell",
    style: _ctx.style
  }, _ctx.attrs, {
    onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onClick: _cache[4] || (_cache[4] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onDblclick: _cache[5] || (_cache[5] = (...args) => _ctx.handleDblclick && _ctx.handleDblclick(...args)),
    onContextmenu: _cache[6] || (_cache[6] = (...args) => _ctx.handleContextmenu && _ctx.handleContextmenu(...args))
  }), [
    _ctx.isSelection(_ctx.column) ? (openBlock(), createBlock(_component_Checkbox, {
      key: 0,
      inherit: "",
      class: normalizeClass(_ctx.nh.be("selection")),
      checked: _ctx.row.checked,
      size: _ctx.column.checkboxSize || "default",
      disabled: _ctx.disableCheckRows[_ctx.row.key],
      onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.handleCheckRow(_ctx.row), ["prevent", "stop"]))
    }, null, 8, ["class", "checked", "size", "disabled"])) : _ctx.isOrder(_ctx.column) ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(_ctx.nh.be("order"))
    }, toDisplayString(_ctx.column.orderLabel && _ctx.column.orderLabel(_ctx.column.truthIndex ? _ctx.row.index : _ctx.rowIndex)), 3)) : _ctx.isExpand(_ctx.column) ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
      !_ctx.disableExpandRows[_ctx.row.key] ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass({
          [_ctx.nh.be("expand")]: true,
          [_ctx.nh.bem("expand", "active")]: _ctx.row.expanded
        }),
        onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.handleExpandRow(_ctx.row), ["stop"]))
      }, [
        createVNode(_component_Icon, null, {
          default: withCtx(() => [
            createVNode(_component_AngleRight)
          ]),
          _: 1
        })
      ], 2)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true)
  ], 16)) : (openBlock(), createElementBlock("div", mergeProps({
    key: 1,
    class: _ctx.className,
    role: "cell",
    style: _ctx.style
  }, _ctx.attrs, {
    onMouseenter: _cache[7] || (_cache[7] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[8] || (_cache[8] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onClick: _cache[9] || (_cache[9] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onDblclick: _cache[10] || (_cache[10] = (...args) => _ctx.handleDblclick && _ctx.handleDblclick(...args)),
    onContextmenu: _cache[11] || (_cache[11] = (...args) => _ctx.handleContextmenu && _ctx.handleContextmenu(...args))
  }), [
    !_ctx.column.noEllipsis ? (openBlock(), createBlock(_component_Ellipsis, {
      key: 0,
      inherit: "",
      "tooltip-theme": _ctx.tooltipTheme,
      "tip-max-width": _ctx.tooltipWidth
    }, {
      default: withCtx(() => [
        _ctx.isFunction(_ctx.column.renderer) ? (openBlock(), createBlock(_component_Renderer, {
          key: 0,
          renderer: _ctx.column.renderer,
          data: { row: _ctx.row.data, rowIndex: _ctx.rowIndex, column: _ctx.column, columnIndex: _ctx.columnIndex }
        }, null, 8, ["renderer", "data"])) : _ctx.isFunction(_ctx.column.accessor) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          createTextVNode(toDisplayString(_ctx.column.accessor(_ctx.row.data, _ctx.rowIndex)), 1)
        ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
          createTextVNode(toDisplayString(_ctx.row.data[_ctx.column.key]), 1)
        ], 64))
      ]),
      _: 1
    }, 8, ["tooltip-theme", "tip-max-width"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      _ctx.isFunction(_ctx.column.renderer) ? (openBlock(), createBlock(_component_Renderer, {
        key: 0,
        renderer: _ctx.column.renderer,
        data: { row: _ctx.row.data, rowIndex: _ctx.rowIndex, column: _ctx.column, columnIndex: _ctx.columnIndex }
      }, null, 8, ["renderer", "data"])) : _ctx.isFunction(_ctx.column.accessor) ? (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createTextVNode(toDisplayString(_ctx.column.accessor(_ctx.row.data, _ctx.rowIndex)), 1)
      ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
        createTextVNode(toDisplayString(_ctx.row.data[_ctx.column.key]), 1)
      ], 64))
    ], 64))
  ], 16));
}
var TableCell = _export_sfc(_sfc_main77, [["render", _sfc_render77]]);

// node_modules/vexip-ui/es/components/table/table-body.mjs
var _sfc_main78 = defineComponent({
  name: "TableBody",
  components: {
    TableCell,
    TableRow
  },
  props: {
    fixed: {
      type: String,
      default: null,
      validator: (value) => {
        return value === "left" || value === "right";
      }
    }
  },
  setup(props) {
    const { state, getters } = inject(TABLE_STORE);
    const currentColumns = computed(() => {
      if (props.fixed === "left") {
        return state.leftFixedColumns;
      }
      if (props.fixed === "right") {
        return state.rightFixedColumns;
      }
      return state.columns;
    });
    const renderData = computed(() => state.virtual ? state.virtualData : getters.processedData);
    const style = computed(() => {
      const { widths, totalHeight } = state;
      const columns = currentColumns.value;
      let width = 0;
      for (let i = 0, len = columns.length; i < len; ++i) {
        const column = columns[i];
        const key = column.key;
        const columnWidth = widths[key];
        width += columnWidth;
      }
      return {
        minWidth: `${width}px`,
        minHeight: `${totalHeight}px`
      };
    });
    const listStyle = computed(() => {
      return {
        transform: state.virtual ? `translate3d(0, ${state.padTop}px, 0)` : void 0
      };
    });
    const emptyStyle = computed(() => {
      const { rowHeight, rowMinHeight } = state;
      return {
        minHeight: `${rowHeight || rowMinHeight}px`
      };
    });
    return {
      nh: useNameHelper("table"),
      emptyText: toRef(state, "emptyText"),
      currentColumns,
      style,
      listStyle,
      emptyStyle,
      renderData
    };
  }
});
function _sfc_render78(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TableCell = resolveComponent("TableCell");
  const _component_TableRow = resolveComponent("TableRow");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.nh.be("body")),
    role: "rowgroup",
    style: normalizeStyle(_ctx.style)
  }, [
    _ctx.renderData.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("row-list")),
      style: normalizeStyle(_ctx.listStyle)
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderData, (row) => {
        return openBlock(), createBlock(_component_TableRow, {
          key: row.index,
          row,
          index: row.index,
          "is-fixed": !!_ctx.fixed
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentColumns, (column, columnIndex) => {
              return openBlock(), createBlock(_component_TableCell, {
                key: columnIndex,
                row,
                "row-index": row.index,
                column,
                "column-index": columnIndex
              }, null, 8, ["row", "row-index", "column", "column-index"]);
            }), 128))
          ]),
          _: 2
        }, 1032, ["row", "index", "is-fixed"]);
      }), 128))
    ], 6)) : (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(_ctx.nh.be("empty")),
      style: normalizeStyle(_ctx.emptyStyle)
    }, [
      renderSlot(_ctx.$slots, "empty", {
        isFixed: !!_ctx.fixed
      }, () => [
        !_ctx.fixed ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createTextVNode(toDisplayString(_ctx.emptyText), 1)
        ], 64)) : createCommentVNode("", true)
      ])
    ], 6))
  ], 6);
}
var TableBody = _export_sfc(_sfc_main78, [["render", _sfc_render78]]);

// node_modules/vexip-ui/es/components/table/props.mjs
var tableProps = buildProps({
  columns: Array,
  data: Array,
  dataKey: String,
  width: [Number, String],
  height: Number,
  rowClass: [String, Object, Array, Function],
  rowStyle: [String, Object, Array, Function],
  rowAttrs: [Object, Function],
  stripe: booleanProp,
  border: booleanProp,
  highlight: booleanProp,
  useYBar: booleanProp,
  barFade: Number,
  scrollDeltaY: Number,
  rowDraggable: booleanProp,
  rowHeight: Number,
  rowMinHeight: Number,
  virtual: booleanProp,
  bufferCount: Number,
  scrollClass: Object,
  expandRenderer: Function,
  currentPage: Number,
  pageSize: Number,
  transparent: booleanProp,
  emptyText: String,
  tooltipTheme: String,
  tooltipWidth: [Number, String],
  singleSorter: booleanProp,
  singleFilter: booleanProp,
  cellClass: [String, Object, Array, Function],
  cellStyle: [String, Object, Array, Function],
  cellAttrs: [Object, Function],
  headClass: [String, Object, Array, Function],
  headStyle: [String, Object, Array, Function],
  headAttrs: [Object, Function],
  onBodyScroll: eventProp(),
  onRowEnter: eventProp(),
  onRowLeave: eventProp(),
  onRowClick: eventProp(),
  onRowDblclick: eventProp(),
  onRowContextmenu: eventProp(),
  onRowCheck: eventProp(),
  onRowCheckAll: eventProp(),
  onRowExpand: eventProp(),
  onRowDragStart: eventProp(),
  onRowDragOver: eventProp(),
  onRowDrop: eventProp(),
  onRowDragEnd: eventProp(),
  onRowFilter: eventProp(),
  onRowSort: eventProp(),
  onCellEnter: eventProp(),
  onCellLeave: eventProp(),
  onCellClick: eventProp(),
  onCellDblclick: eventProp(),
  onCellContextmenu: eventProp(),
  onHeadEnter: eventProp(),
  onHeadLeave: eventProp(),
  onHeadClick: eventProp(),
  onHeadDblclick: eventProp(),
  onHeadContextmenu: eventProp()
});
var tableColumnProps = buildProps({
  idKey: [Number, String],
  name: String,
  accessor: Function,
  fixed: {
    type: [Boolean, String],
    default: null
  },
  className: classProp,
  style: styleProp,
  attrs: Object,
  type: String,
  width: Number,
  filter: Object,
  sorter: {
    type: [Boolean, Object],
    default: null
  },
  renderer: Function,
  headRenderer: Function,
  order: Number,
  noEllipsis: booleanProp,
  checkboxSize: sizeProp,
  disableRow: Function,
  truthIndex: booleanProp,
  orderLabel: Function,
  metaData: Object
});

// node_modules/vexip-ui/es/components/table/store.mjs
var indexId = 1;
function getIndexId() {
  return `__vtr-${indexId++}`;
}
function defaultIndexLabel(index) {
  return index + 1;
}
function useStore(options) {
  var _a;
  const state = reactive({
    columns: [],
    data: [],
    rowClass: "",
    rowStyle: "",
    rowAttrs: null,
    cellClass: "",
    cellStyle: "",
    cellAttrs: null,
    headClass: "",
    headStyle: "",
    headAttrs: null,
    width: 0,
    dataKey: (_a = options.dataKey) != null ? _a : DEFAULT_KEY_FIELD,
    highlight: false,
    currentPage: 1,
    pageSize: 0,
    rowHeight: options.rowHeight,
    rowMinHeight: options.rowMinHeight || 36,
    virtual: options.virtual,
    rowDraggable: !!options.rowDraggable,
    emptyText: options.emptyText,
    tooltipTheme: options.tooltipTheme,
    tooltipWidth: options.tooltipWidth,
    singleSorter: options.singleSorter,
    singleFilter: options.singleFilter,
    expandRenderer: options.expandRenderer,
    rowData: [],
    rightFixedColumns: [],
    leftFixedColumns: [],
    dataMap: {},
    idMaps: /* @__PURE__ */ new WeakMap(),
    checkedAll: false,
    partial: false,
    widths: {},
    sorters: {},
    filters: {},
    bodyScroll: 0,
    padTop: 0,
    startRow: 0,
    endRow: 0,
    dragging: false,
    heightBITree: null,
    virtualData: [],
    totalHeight: options.rowMinHeight * options.data.length
  });
  setColumns(state, options.columns);
  setData(state, options.data);
  setCurrentPage(state, options.currentPage);
  setPageSize(state, options.pageSize);
  setRowClass(state, options.rowClass);
  setRowStyle(state, options.rowStyle);
  setRowAttrs(state, options.rowAttrs);
  setCellClass(state, options.cellClass);
  setCellStyle(state, options.cellStyle);
  setCellAttrs(state, options.cellAttrs);
  setHeadClass(state, options.headClass);
  setHeadStyle(state, options.headStyle);
  setHeadAttrs(state, options.headAttrs);
  setHighlight(state, options.highlight);
  setVirtual(state, options.virtual);
  const filteredData = computed(() => {
    return filterData(state.filters, state.rowData, state.singleFilter);
  });
  const sortedData = computed(() => {
    return sortData(state.sorters, filteredData.value, state.columns, state.singleSorter);
  });
  const processedData = computed(() => {
    return pageData(state.currentPage, state.pageSize, sortedData.value);
  });
  const disableCheckRows = computed(() => {
    const rowData = processedData.value;
    const selection = state.columns.find((item) => item.type === "selection");
    const disableCheckRows2 = {};
    if (selection && typeof selection.disableRow === "function") {
      const isDisabled = selection.disableRow;
      for (let i = 0, len = rowData.length; i < len; ++i) {
        const row = rowData[i];
        if (isDisabled(row.data)) {
          disableCheckRows2[row.key] = true;
        }
      }
    }
    return disableCheckRows2;
  });
  const disableExpandRows = computed(() => {
    const rowData = processedData.value;
    const expand = state.columns.find((item) => item.type === "expand");
    const disableExpandRows2 = {};
    if (expand && typeof expand.disableRow === "function") {
      const isDisabled = expand.disableRow;
      for (let i = 0, len = rowData.length; i < len; ++i) {
        const row = rowData[i];
        if (isDisabled(row.data)) {
          const key = row.key;
          disableExpandRows2[key] = true;
        }
      }
    }
    return disableExpandRows2;
  });
  watchEffect(() => {
    state.heightBITree = markRaw(
      Sn(filteredData.value.length, state.rowHeight || state.rowMinHeight)
    );
    updateTotalHeight(state);
  });
  const getters = reactive({
    filteredData,
    sortedData,
    processedData,
    disableCheckRows,
    disableExpandRows
  });
  const mutations = {
    setColumns: Mr(setColumns.bind(null, state)),
    setData: Mr(setData.bind(null, state)),
    setDataKey: setDataKey.bind(null, state),
    setCurrentPage: setCurrentPage.bind(null, state),
    setPageSize: setPageSize.bind(null, state),
    setRowClass: setRowClass.bind(null, state),
    setRowStyle: setRowStyle.bind(null, state),
    setRowAttrs: setRowAttrs.bind(null, state),
    setCellClass: setCellClass.bind(null, state),
    setCellStyle: setCellStyle.bind(null, state),
    setCellAttrs: setCellAttrs.bind(null, state),
    setHeadClass: setHeadClass.bind(null, state),
    setHeadStyle: setHeadStyle.bind(null, state),
    setHeadAttrs: setHeadAttrs.bind(null, state),
    setTableWidth: setTableWidth.bind(null, state),
    setColumnWidth: setColumnWidth.bind(null, state),
    setRowHeight: setRowHeight.bind(null, state),
    setBorderHeight: setBorderHeight.bind(null, state),
    setGlobalRowHeight: setGlobalRowHeight.bind(null, state),
    setMinRowHeight: setMinRowHeight.bind(null, state),
    setVirtual: setVirtual.bind(null, state),
    setRowDraggable: setRowDraggable.bind(null, state),
    setRowExpandHeight: setRowExpandHeight.bind(null, state),
    setBodyScroll: setBodyScroll.bind(null, state),
    setHighlight: setHighlight.bind(null, state),
    setRowHover: setRowHover.bind(null, state),
    setEmptyText: setEmptyText.bind(null, state),
    setTooltipTheme: setTooltipTheme.bind(null, state),
    setTooltipWidth: setTooltipWidth.bind(null, state),
    setSingleSorter: setSingleSorter.bind(null, state),
    setSingleFilter: setSingleFilter.bind(null, state),
    setDragging: setDragging.bind(null, state),
    handleSort: handleSort.bind(null, state),
    clearSort: clearSort.bind(null, state),
    handleFilter: handleFilter.bind(null, state),
    clearFilter: clearFilter.bind(null, state),
    toggleFilterItemActive: toggleFilterItemActive.bind(null, state),
    refreshRowIndex: refreshRowIndex.bind(null, state),
    updateTotalHeight: Mr(updateTotalHeight.bind(null, state)),
    handleCheck: handleCheck.bind(null, state, getters),
    handleCheckAll: handleCheckAll.bind(null, state, getters),
    clearCheckAll: clearCheckAll.bind(null, state, getters),
    setRenderRows: setRenderRows.bind(null, state, getters),
    handleExpand: handleExpand.bind(null, state, getters)
  };
  function setColumns(state2, columns) {
    columns = Array.from(columns).sort((prev, next) => {
      return (prev.order || 0) - (next.order || 0);
    });
    const { widths, sorters, filters } = state2;
    const normalColumns = [];
    const rightFixedColumns = [];
    const leftFixedColumns = [];
    const columnTypes4 = ["order", "selection", "expand"];
    for (let i = 0, len = columns.length; i < len; ++i) {
      const column = { ...columns[i] };
      if ("type" in column && columnTypes4.includes(column.type)) {
        switch (column.type) {
          case "order": {
            column.truthIndex = !!column.truthIndex;
            if (typeof column.orderLabel !== "function") {
              column.orderLabel = defaultIndexLabel;
            }
            if (qe(column.width))
              column.width = 60;
            break;
          }
          case "selection": {
            column.checkboxSize = column.checkboxSize || "default";
            if (typeof column.disableRow !== "function") {
              column.disableRow = () => false;
            }
            if (qe(column.width))
              column.width = 40;
            break;
          }
          case "expand": {
            if (typeof column.disableRow !== "function") {
              column.disableRow = () => false;
            }
            if (qe(column.width))
              column.width = 40;
            break;
          }
        }
      }
      let key = column.key;
      if (qe(key)) {
        key = getIndexId();
        console.error("[vexip-ui:Table] Table column requires key prop, but missing");
      }
      const fixed = column.fixed;
      widths[key] = column.width || 100;
      sorters[key] = parseSorter(column.sorter);
      filters[key] = parseFilter(column.filter);
      column.key = key;
      if (fixed === true || fixed === "left") {
        leftFixedColumns.push(column);
      } else if (fixed === "right") {
        rightFixedColumns.push(column);
      } else {
        normalColumns.push(column);
      }
    }
    state2.columns = leftFixedColumns.concat(normalColumns, rightFixedColumns);
    if (leftFixedColumns.length) {
      state2.leftFixedColumns = leftFixedColumns;
    }
    if (rightFixedColumns.length) {
      state2.rightFixedColumns = rightFixedColumns;
    }
  }
  function setDataKey(state2, field) {
    const oldDataKey = state2.dataKey;
    if (!qe(field) && oldDataKey !== field) {
      const { rowData, idMaps } = state2;
      state2.dataKey = field;
      rowData.forEach((row) => {
        let key = row.data[field];
        if (qe(key)) {
          key = getIndexId();
        }
        row.key = key;
        idMaps.set(row.data, key);
      });
    }
  }
  function setData(state2, data) {
    const clonedData = [];
    const dataMap = {};
    const { dataKey, idMaps } = state2;
    const oldDataMap = state2.dataMap;
    const hidden = !!state2.virtual;
    dataMap[TABLE_HEAD_KEY] = oldDataMap[TABLE_HEAD_KEY] || {
      key: TABLE_HEAD_KEY
    };
    for (let i = 0, len = data.length; i < len; ++i) {
      const item = data[i];
      let key = item[dataKey];
      if (qe(key)) {
        key = idMaps.get(item);
        if (qe(key)) {
          key = getIndexId();
        }
      }
      let row;
      if (oldDataMap[key]) {
        row = oldDataMap[key];
        if (row.data !== item) {
          const { checked, height, expanded } = Object.assign(row.data, item);
          row.checked = !qe(checked) ? !!checked : row.checked;
          row.height = !qe(height) ? En(height) : row.height;
          row.expanded = !qe(expanded) ? !!expanded : row.expanded;
        }
      } else {
        const { checked, height, expanded } = item;
        row = {
          key,
          hidden,
          checked: !!checked,
          height: En(height),
          borderHeight: 0,
          expanded: !!expanded,
          hover: false,
          expandHeight: 0,
          index: -1,
          data: item
        };
        idMaps.set(item, key);
      }
      row.index = i;
      clonedData.push(row);
      dataMap[key] = row;
    }
    state2.rowData = clonedData;
    state2.dataMap = dataMap;
    computePartial(state2);
  }
  function setCurrentPage(state2, currentPage) {
    state2.currentPage = currentPage != null ? currentPage : 1;
  }
  function setPageSize(state2, pageSize) {
    state2.pageSize = pageSize || state2.rowData.length;
  }
  function setRowClass(state2, rowClass) {
    state2.rowClass = rowClass != null ? rowClass : "";
  }
  function setRowStyle(state2, rowStyle) {
    state2.rowStyle = rowStyle != null ? rowStyle : "";
  }
  function setRowAttrs(state2, rowAttrs) {
    state2.rowAttrs = rowAttrs != null ? rowAttrs : null;
  }
  function setCellClass(state2, cellClass) {
    state2.cellClass = cellClass != null ? cellClass : "";
  }
  function setCellStyle(state2, cellStyle) {
    state2.cellStyle = cellStyle != null ? cellStyle : "";
  }
  function setCellAttrs(state2, cellAttrs) {
    state2.cellAttrs = cellAttrs != null ? cellAttrs : null;
  }
  function setHeadClass(state2, headClass) {
    state2.headClass = headClass != null ? headClass : "";
  }
  function setHeadStyle(state2, headStyle) {
    state2.headStyle = headStyle != null ? headStyle : "";
  }
  function setHeadAttrs(state2, headAttrs) {
    state2.headAttrs = headAttrs != null ? headAttrs : null;
  }
  function setTableWidth(state2, width) {
    width = En(width);
    const { columns, widths } = state2;
    const hasWidthColumns = [];
    const flexColumns = [];
    let flexWidth = width;
    for (let i = 0, len = columns.length; i < len; ++i) {
      const column = columns[i];
      if (column.width) {
        flexWidth -= column.width;
        hasWidthColumns.push(column);
      } else {
        flexColumns.push(column);
      }
    }
    const flexColumnCount = flexColumns.length;
    let flexUnitWidth = 100;
    if (flexColumnCount) {
      flexUnitWidth = flexWidth / flexColumnCount;
    }
    for (let i = 0; i < flexColumnCount; ++i) {
      const column = flexColumns[i];
      const key = column.key;
      widths[key] = flexUnitWidth;
    }
    state2.width = width;
  }
  function setColumnWidth(state2, key, width) {
    if (state2.widths[key]) {
      state2.widths[key] = width;
    }
  }
  function setRowHeight(state2, key, height) {
    if (state2.dataMap[key] && state2.dataMap[key].height !== height) {
      state2.dataMap[key].height = height;
    }
  }
  function setBorderHeight(state2, key, height) {
    if (state2.dataMap[key]) {
      state2.dataMap[key].borderHeight = height;
    }
  }
  function setGlobalRowHeight(state2, height) {
    state2.rowHeight = height;
  }
  function setMinRowHeight(state2, height) {
    state2.rowMinHeight = height;
  }
  function setRowDraggable(state2, draggable) {
    state2.rowDraggable = !!draggable;
  }
  function setRowExpandHeight(state2, key, height) {
    if (state2.dataMap[key]) {
      state2.dataMap[key].expandHeight = height;
    }
  }
  function setBodyScroll(state2, scroll) {
    state2.bodyScroll = scroll;
  }
  function setHighlight(state2, able) {
    state2.highlight = !!able;
  }
  function setVirtual(state2, virtual) {
    state2.virtual = !!virtual;
  }
  function setRowHover(state2, key, hover) {
    if (state2.dataMap[key]) {
      state2.dataMap[key].hover = hover;
    }
  }
  function setEmptyText(state2, text) {
    state2.emptyText = text;
  }
  function setTooltipTheme(state2, theme) {
    state2.tooltipTheme = theme;
  }
  function setTooltipWidth(state2, theme) {
    state2.tooltipWidth = theme;
  }
  function setSingleSorter(state2, able) {
    state2.singleSorter = !!able;
  }
  function setSingleFilter(state2, able) {
    state2.singleFilter = !!able;
  }
  function setDragging(state2, dragging) {
    state2.dragging = !!dragging;
  }
  function handleSort(state2, key, type) {
    if (state2.sorters[key]) {
      if (state2.singleSorter && type) {
        clearSort(state2);
      }
      state2.sorters[key].type = type;
    }
  }
  function clearSort(state2) {
    const sorters = state2.sorters;
    for (const key of Object.keys(sorters)) {
      sorters[key].type = null;
    }
  }
  function handleFilter(state2, key, active) {
    if (state2.filters[key]) {
      if (state2.singleFilter && (Array.isArray(active) ? active.length : active)) {
        clearFilter(state2);
      }
      state2.filters[key].active = active;
    }
  }
  function clearFilter(state2) {
    const filters = state2.filters;
    for (const key of Object.keys(filters)) {
      filters[key].active = null;
      for (const option of filters[key].options) {
        option.active = false;
      }
    }
  }
  function handleCheck(state2, getters2, key, checked) {
    const { dataMap } = state2;
    const { disableCheckRows: disableCheckRows2 } = getters2;
    if (dataMap[key] && !disableCheckRows2[key]) {
      dataMap[key].checked = !!checked;
    }
    computePartial(state2);
  }
  function handleCheckAll(state2, getters2) {
    const { rowData, checkedAll } = state2;
    const { disableCheckRows: disableCheckRows2 } = getters2;
    let checked = !checkedAll;
    if (Object.keys(disableCheckRows2).length) {
      let partialCheckedAll = true;
      for (const row of rowData) {
        if (!disableCheckRows2[row.key] && !row.checked) {
          partialCheckedAll = false;
          break;
        }
      }
      checked = !partialCheckedAll;
    }
    for (const row of rowData) {
      if (!disableCheckRows2[row.key]) {
        row.checked = checked;
      }
    }
    state2.checkedAll = checked;
    state2.partial = false;
    computePartial(state2);
  }
  function clearCheckAll(state2, getters2) {
    const { rowData } = state2;
    const { disableCheckRows: disableCheckRows2 } = getters2;
    for (const row of rowData) {
      if (!disableCheckRows2[row.key]) {
        row.checked = false;
      }
    }
    state2.checkedAll = false;
    state2.partial = false;
    computePartial(state2);
  }
  function computePartial(state2) {
    const data = state2.rowData;
    let hasChecked = false;
    let hasNotChecked = false;
    let partial = false;
    for (let i = 0, len = data.length; i < len; ++i) {
      const row = data[i];
      if (row.checked) {
        hasChecked = true;
      } else {
        hasNotChecked = true;
      }
      if (hasChecked && hasNotChecked) {
        partial = true;
        break;
      }
    }
    if (hasChecked && !partial) {
      state2.checkedAll = true;
    } else {
      state2.checkedAll = false;
    }
    state2.partial = partial;
  }
  function setRenderRows(state2, getters2, start, end) {
    var _a2;
    const { startRow, endRow, heightBITree, virtualData } = state2;
    if (start === startRow && end === endRow)
      return;
    const { processedData: processedData2 } = getters2;
    virtualData.length = 0;
    if (processedData2[0]) {
      let i = processedData2.length;
      while (i--) {
        const data = processedData2[i];
        data.hidden = !(i >= start && i < end);
        !data.hidden && virtualData.push(data);
      }
      virtualData.reverse();
      state2.padTop = (_a2 = heightBITree == null ? void 0 : heightBITree.sum(start)) != null ? _a2 : 0;
      state2.startRow = start;
      state2.endRow = end;
    }
  }
  function handleExpand(state2, getters2, key, expanded) {
    const { dataMap } = state2;
    const { disableExpandRows: disableExpandRows2 } = getters2;
    if (dataMap[key] && !disableExpandRows2[key]) {
      dataMap[key].expanded = !!expanded;
    }
  }
  function toggleFilterItemActive(state2, options2) {
    const { key, value, active = false, disableOthers = false } = options2;
    if (state2.filters[key]) {
      const filterOptions = state2.filters[key].options;
      if (disableOthers) {
        for (let i = 0, len = filterOptions.length; i < len; ++i) {
          filterOptions[i].active = false;
        }
      }
      const item = filterOptions.find((item2) => item2.value === value);
      if (item) {
        item.active = active;
      }
    }
  }
  function refreshRowIndex(state2) {
    const data = state2.rowData;
    for (let i = 0, len = data.length; i < len; ++i) {
      data[i].index = i;
    }
  }
  function updateTotalHeight(state2) {
    var _a2;
    const { heightBITree, currentPage, pageSize, rowData } = state2;
    if (heightBITree) {
      if (currentPage && pageSize > 0 && pageSize < rowData.length) {
        state2.totalHeight = heightBITree.sum(currentPage * pageSize) - heightBITree.sum((currentPage - 1) * pageSize);
      } else {
        state2.totalHeight = (_a2 = heightBITree.sum()) != null ? _a2 : 0;
      }
    } else {
      state2.totalHeight = 0;
    }
  }
  function parseSorter(sorter = false) {
    const raw = typeof sorter === "boolean" ? { able: sorter } : sorter;
    const { able = false, type = null, order = 0, method = null } = raw;
    return { able, type, order, method };
  }
  function parseFilter(filter = { able: false, options: [] }) {
    var _a2, _b;
    const { able = false, multiple = false, active = null, method = null } = filter;
    const options2 = we((_a2 = filter.options) != null ? _a2 : []);
    const formattedOptions = [];
    for (let i = 0, len = options2.length; i < len; ++i) {
      const item = options2[i];
      const option = typeof item === "string" ? { value: item } : { ...item };
      option.label = (_b = option.label) != null ? _b : option.value.toString();
      let isActive = false;
      if (multiple && Array.isArray(active)) {
        isActive = active.includes(option.value);
      } else if (!qe(active)) {
        isActive = Object.is(option.value, active);
      }
      option.active = isActive;
      formattedOptions.push(option);
    }
    return { able, options: formattedOptions, multiple, active, method };
  }
  function filterData(filters, data, isSingle) {
    const keys = Object.keys(filters);
    const usedFilter = [];
    const filterData2 = [];
    for (let i = 0, len = keys.length; i < len; ++i) {
      const key = keys[i];
      const filter = filters[key];
      const { able, active, method } = filter;
      if (able && active && typeof method === "function") {
        usedFilter.push(filter);
        if (isSingle)
          break;
      }
    }
    const usedFilterCount = usedFilter.length;
    for (let i = 0, len = data.length; i < len; ++i) {
      const row = data[i];
      let isFilter = true;
      for (let j = 0; j < usedFilterCount; j++) {
        const { active, method } = usedFilter[j];
        isFilter = method(active, row.data);
        if (!isFilter) {
          break;
        }
      }
      if (isFilter) {
        filterData2.push(row);
      }
    }
    return filterData2;
  }
  function sortData(sorters, data, columns, isSingle) {
    const keys = Object.keys(sorters);
    const usedSorter = [];
    for (let i = 0, len = keys.length; i < len; ++i) {
      const key = keys[i];
      const { able, type, order, method } = sorters[key];
      if (able && type) {
        const column = columns.find((item) => item.key === key);
        const accessor = column == null ? void 0 : column.accessor;
        usedSorter.push({
          able,
          key,
          order,
          type,
          method: method != null ? method : void 0,
          accessor(row) {
            if (typeof accessor === "function") {
              return accessor(row.data, row.index);
            }
            return row.data[key];
          }
        });
        if (isSingle)
          break;
      }
    }
    usedSorter.sort((prev, next) => prev.order - next.order);
    return Or(data, usedSorter);
  }
  function pageData(currentPage, pageSize, data) {
    return data.slice((currentPage - 1) * pageSize, currentPage * pageSize);
  }
  return { state, getters, mutations };
}

// node_modules/vexip-ui/es/components/table/table.mjs
var _sfc_main79 = defineComponent({
  name: "Table",
  components: {
    Scroll,
    Scrollbar,
    TableHead,
    TableBody
  },
  props: tableProps,
  emits: [],
  setup(_props) {
    var _a;
    const props = useProps("table", _props, {
      columns: {
        default: () => [],
        static: true
      },
      data: {
        default: () => [],
        static: true
      },
      dataKey: DEFAULT_KEY_FIELD,
      width: null,
      height: null,
      rowClass: null,
      rowStyle: null,
      rowAttrs: null,
      stripe: false,
      border: false,
      highlight: false,
      useYBar: false,
      barFade: 1500,
      scrollDeltaY: 36,
      rowDraggable: false,
      rowHeight: null,
      rowMinHeight: {
        default: 36,
        validator: (value) => value > 0
      },
      virtual: false,
      bufferCount: {
        default: 5,
        validator: (value) => value >= 0
      },
      scrollClass: () => ({}),
      expandRenderer: {
        default: null,
        isFunc: true
      },
      currentPage: {
        default: 1,
        validator: (value) => value > 0,
        static: true
      },
      pageSize: 0,
      transparent: false,
      emptyText: null,
      tooltipTheme: {
        default: "dark",
        validator: (value) => ["light", "dark"].includes(value)
      },
      tooltipWidth: 500,
      singleSorter: false,
      singleFilter: false,
      cellClass: null,
      cellStyle: null,
      cellAttrs: null,
      headClass: null,
      headStyle: null,
      headAttrs: null
    });
    const nh = useNameHelper("table");
    const bodyHeight = ref(props.height);
    const xScrollPercent = ref(0);
    const yScrollPercent = ref(0);
    const headHeight = ref(0);
    const indicatorShow = ref(false);
    const templateColumns = ref(/* @__PURE__ */ new Set());
    const tableWidth = ref(null);
    const yScrollEnable = ref(false);
    const wrapper = ref();
    const thead = ref();
    const mainScroll = ref();
    const indicator = ref();
    const scrollbar = ref();
    const locale = useLocale("table");
    const store = useStore({
      columns: props.columns,
      data: props.data,
      rowClass: props.rowClass,
      rowStyle: props.rowStyle,
      rowAttrs: props.rowAttrs,
      cellClass: props.cellClass,
      cellStyle: props.cellStyle,
      cellAttrs: props.cellAttrs,
      headClass: props.headClass,
      headStyle: props.headStyle,
      headAttrs: props.headAttrs,
      dataKey: props.dataKey,
      highlight: props.highlight,
      currentPage: props.currentPage,
      pageSize: props.pageSize,
      rowHeight: props.rowHeight,
      rowMinHeight: props.rowMinHeight,
      virtual: props.virtual,
      rowDraggable: props.rowDraggable,
      emptyText: (_a = props.emptyText) != null ? _a : locale.value.empty,
      tooltipTheme: props.tooltipTheme,
      tooltipWidth: props.tooltipWidth,
      singleSorter: props.singleSorter,
      singleFilter: props.singleFilter,
      expandRenderer: props.expandRenderer
    });
    provide(TABLE_STORE, store);
    provide(TABLE_ACTION, {
      increaseColumn,
      decreaseColumn,
      emitRowEnter,
      emitRowLeave,
      emitRowClick,
      emitRowDblclick,
      emitRowContextmenu,
      emitRowCheck,
      emitAllRowCheck,
      emitRowExpand,
      emitRowFilter,
      emitRowSort,
      handleRowDragStart,
      handleRowDragOver,
      handleRowDrop,
      handleRowDragEnd,
      emitCellEnter,
      emitCellLeave,
      emitCellClick,
      emitCellDblclick,
      emitCellContextmenu,
      emitHeadEnter,
      emitHeadLeave,
      emitHeadClick,
      emitHeadDblclick,
      emitHeadContextmenu
    });
    const { state, getters, mutations } = store;
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("stripe")]: props.stripe,
        [nh.bm("border")]: props.border,
        [nh.bm("highlight")]: props.highlight,
        [nh.bm("use-y-bar")]: props.useYBar,
        [nh.bm("transparent")]: props.transparent,
        [nh.bm("virtual")]: props.virtual
      };
    });
    const style = computed(() => {
      var _a2;
      const width = (_a2 = tableWidth.value) != null ? _a2 : props.width;
      if (width !== null) {
        if (typeof width === "string" && parseFloat(width).toString() !== width) {
          return {
            width
          };
        }
        return {
          width: `${width}px`,
          minWidth: `${width}px`
        };
      }
      return {};
    });
    const useXScroll = computed(() => {
      return !!(props.width && (state.leftFixedColumns.length || state.rightFixedColumns.length));
    });
    const bodyScrollHeight = computed(() => {
      const { totalHeight } = state;
      if (Number.isNaN(totalHeight)) {
        return bodyHeight.value;
      }
      return bodyHeight.value ? Math.min(bodyHeight.value, totalHeight) : bodyHeight.value;
    });
    const barLength = computed(() => {
      const { totalHeight } = state;
      if (bodyScrollHeight.value && totalHeight) {
        return Math.max(Math.min(bodyScrollHeight.value / totalHeight * 100, 99), 5) || 35;
      }
      return 35;
    });
    const allColumns = computed(() => {
      return [...templateColumns.value].concat(props.columns);
    });
    const emptyText = computed(() => {
      var _a2;
      return (_a2 = props.emptyText) != null ? _a2 : locale.value.empty;
    });
    const {
      setColumns,
      setData,
      setPageSize,
      setRowClass,
      setHighlight,
      setCurrentPage,
      setTableWidth,
      setBodyScroll,
      setRenderRows,
      setGlobalRowHeight,
      setRowDraggable,
      setEmptyText,
      setTooltipTheme,
      setTooltipWidth,
      setSingleSorter,
      setSingleFilter,
      setDragging,
      clearSort,
      clearFilter,
      refreshRowIndex,
      clearCheckAll
    } = mutations;
    watch(
      allColumns,
      (value) => {
        setColumns(value);
      },
      { immediate: true, deep: true }
    );
    watch(
      () => props.data,
      (value) => {
        setPageSize(props.pageSize || value.length);
        setData(value);
        refreshPercentScroll();
      },
      { deep: true }
    );
    watch(() => props.width, computeTableWidth);
    watch(
      () => props.height,
      () => {
        nextTick(computeBodyHeight);
      }
    );
    watch(() => props.rowClass, setRowClass);
    watch(() => props.highlight, setHighlight);
    watch(() => props.currentPage, setCurrentPage);
    watch(() => props.pageSize, setPageSize);
    watch(() => props.rowHeight, setGlobalRowHeight);
    watch(() => props.rowDraggable, setRowDraggable);
    watch(emptyText, setEmptyText);
    watch(() => props.tooltipTheme, setTooltipTheme);
    watch(() => props.tooltipWidth, setTooltipWidth);
    watch(() => props.singleSorter, setSingleSorter);
    watch(() => props.singleFilter, setSingleFilter);
    function syncBarScroll() {
      var _a2;
      (_a2 = scrollbar.value) == null ? void 0 : _a2.handleScroll(yScrollPercent.value);
    }
    const handlerResize = yr(refresh);
    onMounted(() => {
      watch(bodyScrollHeight, refreshPercentScroll);
      refresh();
      window.addEventListener("resize", handlerResize);
    });
    onBeforeUnmount(() => {
      window.removeEventListener("resize", handlerResize);
    });
    function computeTableWidth() {
      const width = props.width;
      if (y(width)) {
        if (typeof width === "string" && parseFloat(width).toString() !== width) {
          tableWidth.value = width;
          nextTick(() => {
            wrapper.value && setTableWidth(wrapper.value.offsetWidth);
          });
        } else {
          const numberWidth = En(width);
          tableWidth.value = `${numberWidth}px`;
          setTableWidth(numberWidth);
        }
      } else {
        nextTick(() => {
          wrapper.value && setTableWidth(wrapper.value.offsetWidth);
        });
      }
    }
    function computeBodyHeight() {
      var _a2;
      const height = props.height;
      if (y(height)) {
        const tableHead = (_a2 = thead.value) == null ? void 0 : _a2.$el;
        if (tableHead) {
          headHeight.value = tableHead.offsetHeight;
          bodyHeight.value = height - headHeight.value;
        } else {
          bodyHeight.value = height - (props.rowHeight || props.rowMinHeight);
        }
      } else {
        bodyHeight.value = void 0;
      }
    }
    function handleBodyScroll({ clientY, percentY }) {
      yScrollPercent.value = percentY;
      setBodyScroll(clientY);
      syncBarScroll();
      emitYScroll(clientY, percentY);
    }
    function handleXScroll({ percentX }) {
      xScrollPercent.value = percentX;
    }
    function handleYScrollEnableChange(able) {
      yScrollEnable.value = able;
    }
    function handleYBarScroll(percent) {
      var _a2;
      const { totalHeight } = state;
      const client = percent * (totalHeight - ((_a2 = bodyScrollHeight.value) != null ? _a2 : 0)) / 100;
      yScrollPercent.value = percent;
      setBodyScroll(client);
      wr(computeRenderRows);
      emitEvent(props.onBodyScroll, { client, percent });
    }
    function emitYScroll(client, percent) {
      wr(computeRenderRows);
      emitEvent(props.onBodyScroll, { client, percent });
    }
    function increaseColumn(column) {
      templateColumns.value.add(column);
    }
    function decreaseColumn(column) {
      templateColumns.value.delete(column);
    }
    function emitRowEnter(payload) {
      emitEvent(props.onRowEnter, payload);
    }
    function emitRowLeave(payload) {
      emitEvent(props.onRowLeave, payload);
    }
    function emitRowClick(payload) {
      emitEvent(props.onRowClick, payload);
    }
    function emitRowDblclick(payload) {
      emitEvent(props.onRowDblclick, payload);
    }
    function emitRowContextmenu(payload) {
      emitEvent(props.onRowContextmenu, payload);
    }
    function emitRowCheck(payload) {
      emitEvent(props.onRowCheck, payload);
    }
    function emitAllRowCheck(checked, partial) {
      emitEvent(props.onRowCheckAll, checked, partial);
    }
    function emitRowExpand(payload) {
      emitEvent(props.onRowExpand, payload);
    }
    function emitRowFilter() {
      const { columns, filters } = state;
      const columnMap = Tr(columns, "key");
      const profiles = Object.keys(filters).filter((key) => filters[key].active).map((key) => {
        const column = columnMap[key];
        return {
          name: column.name,
          key: column.key,
          metaData: column.metaData,
          active: filters[key].active
        };
      });
      emitEvent(
        props.onRowFilter,
        profiles,
        getters.filteredData.map((row) => row.data)
      );
    }
    function emitRowSort() {
      const { columns, sorters } = state;
      const columnMap = Tr(columns, "key");
      const profiles = Object.keys(sorters).filter((key) => sorters[key].type).map((key) => {
        const column = columnMap[key];
        return {
          name: column.name,
          key: column.key,
          metaData: column.metaData,
          type: sorters[key].type
        };
      });
      emitEvent(
        props.onRowSort,
        profiles,
        getters.sortedData.map((row) => row.data)
      );
    }
    let dragState;
    function handleRowDragStart(rowInstance, event) {
      dragState = {
        draggingRow: rowInstance.row,
        tableRect: wrapper.value.getBoundingClientRect()
      };
      setDragging(true);
      emitEvent(props.onRowDragStart, rowInstance.row.data, event);
    }
    function handleRowDragOver(rowInstance, event) {
      if (!dragState || !rowInstance.el)
        return;
      const dropRowRect = rowInstance.el.getBoundingClientRect();
      const tableRect = dragState.tableRect;
      const prevPercent = 0.5;
      const distance = event.clientY - dropRowRect.top;
      const dropRowHeight = dropRowRect.height;
      let dropType = "none";
      let indicatorTop = -9999;
      if (distance < dropRowHeight * prevPercent) {
        dropType = "before";
        indicatorTop = dropRowRect.top - tableRect.top;
      } else {
        dropType = "after";
        indicatorTop = dropRowRect.bottom - tableRect.top;
      }
      indicator.value.style.top = `${indicatorTop - 2}px`;
      dragState.dropType = dropType;
      indicatorShow.value = true;
      emitEvent(props.onRowDragOver, rowInstance.row.data, event);
    }
    function handleRowDrop(rowInstance, event) {
      if (!dragState)
        return;
      const { draggingRow, dropType } = dragState;
      const willDropRow = rowInstance.row;
      if (draggingRow.key === willDropRow.key)
        return;
      const rowData = state.rowData;
      let index = rowData.findIndex((row) => row.key === willDropRow.key);
      if (~index) {
        const originIndex = rowData.findIndex((row) => row.key === draggingRow.key);
        kr(rowData, (row) => row.key === draggingRow.key);
        if (originIndex > index && dropType === "after") {
          index += 1;
        } else if (originIndex < index && dropType === "before") {
          index -= 1;
        }
        rowData.splice(index, 0, draggingRow);
        refreshRowIndex();
        emitEvent(props.onRowDrop, rowInstance.row.data, dropType, event);
      }
    }
    function handleRowDragEnd(event) {
      if (!dragState)
        return;
      const { draggingRow } = dragState;
      dragState = null;
      indicatorShow.value = false;
      setDragging(false);
      emitEvent(
        props.onRowDragEnd,
        draggingRow.data,
        state.rowData.map((row) => row.data),
        event
      );
    }
    function emitCellEnter(payload) {
      emitEvent(props.onCellEnter, payload);
    }
    function emitCellLeave(payload) {
      emitEvent(props.onCellLeave, payload);
    }
    function emitCellClick(payload) {
      emitEvent(props.onCellClick, payload);
    }
    function emitCellDblclick(payload) {
      emitEvent(props.onCellDblclick, payload);
    }
    function emitCellContextmenu(payload) {
      emitEvent(props.onCellContextmenu, payload);
    }
    function emitHeadEnter(payload) {
      emitEvent(props.onHeadEnter, payload);
    }
    function emitHeadLeave(payload) {
      emitEvent(props.onHeadLeave, payload);
    }
    function emitHeadClick(payload) {
      emitEvent(props.onHeadClick, payload);
    }
    function emitHeadDblclick(payload) {
      emitEvent(props.onHeadDblclick, payload);
    }
    function emitHeadContextmenu(payload) {
      emitEvent(props.onHeadContextmenu, payload);
    }
    function computeRenderRows() {
      const { totalHeight, bodyScroll, heightBITree } = state;
      const { processedData } = getters;
      const rowCount = processedData.length;
      if (!props.virtual) {
        setRenderRows(0, rowCount);
        return;
      }
      const viewHeight = Math.min(bodyHeight.value || 0, bodyScrollHeight.value || 0);
      if (!viewHeight) {
        setRenderRows(0, 0);
      }
      let viewStart = bodyScroll;
      let viewEnd = bodyScroll + viewHeight;
      if (viewEnd > totalHeight) {
        viewEnd = totalHeight;
        viewStart = viewEnd - viewHeight;
      }
      const start = heightBITree.boundIndex(viewStart);
      const end = heightBITree.boundIndex(viewEnd);
      const renderStart = Math.max(start - props.bufferCount, 0);
      const renderEnd = Math.min(end + props.bufferCount + 1, rowCount);
      setRenderRows(renderStart, renderEnd);
    }
    function refresh() {
      setTimeout(() => {
        computeTableWidth();
        computeBodyHeight();
        refreshPercentScroll();
        wr(computeRenderRows);
      }, 0);
    }
    function syncVerticalScroll() {
      if (mainScroll.value) {
        setBodyScroll(-mainScroll.value.currentScroll.y);
      }
    }
    const { timer: timer2 } = $o();
    function refreshPercentScroll() {
      clearTimeout(timer2.scroll);
      timer2.scroll = setTimeout(() => {
        var _a2;
        const { totalHeight, bodyScroll } = state;
        yScrollPercent.value = Math.max(
          Math.min(bodyScroll / (totalHeight - ((_a2 = bodyScrollHeight.value) != null ? _a2 : 0) || 1) * 100, 100),
          0
        );
        syncBarScroll();
        nextTick(computeBodyHeight);
        wr(computeRenderRows);
      }, 10);
    }
    function getSelected() {
      const data = state.rowData;
      const selectedData = [];
      for (let i = 0, len = data.length; i < len; ++i) {
        const row = data[i];
        if (row.checked) {
          selectedData.push(row.data);
        }
      }
      return selectedData;
    }
    return {
      props,
      nh,
      bodyHeight,
      xScrollPercent,
      yScrollPercent,
      headHeight,
      indicatorShow,
      leftFixedColumns: toRef(state, "leftFixedColumns"),
      rightFixedColumns: toRef(state, "rightFixedColumns"),
      bodyScroll: toRef(state, "bodyScroll"),
      className,
      style,
      useXScroll,
      barLength,
      bodyScrollHeight,
      totalHeight: toRef(state, "totalHeight"),
      store,
      wrapper,
      thead,
      mainScroll,
      indicator,
      scrollbar,
      handleBodyScroll,
      handleXScroll,
      handleYScrollEnableChange,
      handleYBarScroll,
      syncVerticalScroll,
      clearSort,
      clearFilter,
      clearSelected: clearCheckAll,
      refresh,
      getSelected
    };
  }
});
var _hoisted_143 = ["aria-rowcount"];
var _hoisted_218 = { role: "none" };
function _sfc_render79(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TableHead = resolveComponent("TableHead");
  const _component_TableBody = resolveComponent("TableBody");
  const _component_Scroll = resolveComponent("Scroll");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    role: "table",
    style: normalizeStyle(_ctx.style),
    "aria-rowcount": _ctx.props.data.length
  }, [
    withDirectives(createBaseVNode("div", _hoisted_218, [
      renderSlot(_ctx.$slots, "default")
    ], 512), [
      [vShow, false]
    ]),
    _ctx.useXScroll ? (openBlock(), createBlock(_component_Scroll, {
      key: 0,
      inherit: "",
      "use-x-bar": "",
      mode: "horizontal",
      class: normalizeClass([_ctx.nh.be("wrapper"), _ctx.props.scrollClass.horizontal]),
      "bar-class": _ctx.nh.bem("bar", "horizontal"),
      width: _ctx.props.width,
      "bar-fade": _ctx.props.barFade,
      "delta-x": 50,
      onScroll: _ctx.handleXScroll
    }, {
      default: withCtx(() => [
        createVNode(_component_TableHead, { ref: "thead" }, null, 512),
        createVNode(_component_Scroll, {
          inherit: "",
          class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.major]),
          height: _ctx.bodyScrollHeight,
          "scroll-y": _ctx.bodyScroll,
          onScroll: _ctx.handleBodyScroll,
          onYEnabledChange: _ctx.handleYScrollEnableChange,
          onReady: _ctx.syncVerticalScroll
        }, {
          default: withCtx(() => [
            createVNode(_component_TableBody, null, {
              empty: withCtx(({ isFixed }) => [
                renderSlot(_ctx.$slots, "empty", { isFixed })
              ]),
              _: 3
            })
          ]),
          _: 3
        }, 8, ["class", "height", "scroll-y", "onScroll", "onYEnabledChange", "onReady"])
      ]),
      _: 3
    }, 8, ["class", "bar-class", "width", "bar-fade", "onScroll"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
      createVNode(_component_TableHead, { ref: "thead" }, null, 512),
      createVNode(_component_Scroll, {
        ref: "mainScroll",
        inherit: "",
        class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.major]),
        height: _ctx.bodyScrollHeight,
        "scroll-y": _ctx.bodyScroll,
        "delta-y": _ctx.props.scrollDeltaY,
        onScroll: _ctx.handleBodyScroll,
        onYEnabledChange: _ctx.handleYScrollEnableChange,
        onReady: _ctx.syncVerticalScroll
      }, {
        default: withCtx(() => [
          createVNode(_component_TableBody, null, {
            empty: withCtx(({ isFixed }) => [
              renderSlot(_ctx.$slots, "empty", { isFixed })
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["class", "height", "scroll-y", "delta-y", "onScroll", "onYEnabledChange", "onReady"])
    ], 64)),
    _ctx.leftFixedColumns.length ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass({
        [_ctx.nh.bem("fixed", "left")]: true,
        [_ctx.nh.bem("fixed", "active")]: _ctx.xScrollPercent
      })
    }, [
      createVNode(_component_TableHead, { fixed: "left" }),
      createVNode(_component_Scroll, {
        ref: "mainScroll",
        inherit: "",
        class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.left]),
        height: _ctx.bodyScrollHeight,
        "scroll-y": _ctx.bodyScroll,
        "delta-y": _ctx.props.scrollDeltaY,
        onScroll: _ctx.handleBodyScroll
      }, {
        default: withCtx(() => [
          createVNode(_component_TableBody, { fixed: "left" }, {
            empty: withCtx(({ isFixed }) => [
              renderSlot(_ctx.$slots, "empty", { isFixed })
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["class", "height", "scroll-y", "delta-y", "onScroll"])
    ], 2)) : createCommentVNode("", true),
    _ctx.rightFixedColumns.length ? (openBlock(), createElementBlock("div", {
      key: 3,
      class: normalizeClass({
        [_ctx.nh.bem("fixed", "right")]: true,
        [_ctx.nh.bem("fixed", "active")]: _ctx.xScrollPercent !== 100
      })
    }, [
      createVNode(_component_TableHead, { fixed: "right" }),
      createVNode(_component_Scroll, {
        inherit: "",
        class: normalizeClass([_ctx.nh.be("body-wrapper"), _ctx.props.scrollClass.right]),
        height: _ctx.bodyScrollHeight,
        "scroll-y": _ctx.bodyScroll,
        "delta-y": _ctx.props.scrollDeltaY,
        onScroll: _ctx.handleBodyScroll
      }, {
        default: withCtx(() => [
          createVNode(_component_TableBody, { fixed: "right" }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          })
        ]),
        _: 3
      }, 8, ["class", "height", "scroll-y", "delta-y", "onScroll"])
    ], 2)) : createCommentVNode("", true),
    _ctx.props.useYBar && _ctx.bodyScrollHeight ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 4,
      ref: "scrollbar",
      inherit: "",
      placement: "right",
      class: normalizeClass(_ctx.nh.bem("bar", "vertical")),
      fade: _ctx.props.barFade,
      disabled: !!_ctx.bodyHeight && _ctx.totalHeight <= _ctx.bodyHeight,
      "bar-length": _ctx.barLength,
      style: normalizeStyle({ top: `${_ctx.headHeight}px` }),
      onScroll: _ctx.handleYBarScroll
    }, null, 8, ["class", "fade", "disabled", "bar-length", "style", "onScroll"])) : createCommentVNode("", true),
    _ctx.props.rowDraggable ? withDirectives((openBlock(), createElementBlock("div", {
      key: 5,
      ref: "indicator",
      class: normalizeClass(_ctx.nh.be("indicator"))
    }, null, 2)), [
      [vShow, _ctx.indicatorShow]
    ]) : createCommentVNode("", true)
  ], 14, _hoisted_143);
}
var Table = _export_sfc(_sfc_main79, [["render", _sfc_render79]]);

// node_modules/vexip-ui/es/components/table/helper.mjs
function defineFilter(filter) {
  return filter;
}
function defineSorter(sorter) {
  return sorter;
}
function defineColumn(column) {
  return column;
}
function defineColumns(columns) {
  return columns;
}

// node_modules/vexip-ui/es/components/table/table-column.mjs
var propKeys = Object.keys(tableColumnProps);
var aliases = {
  idKey: "key"
};
var deepProps = ["className", "style", "attrs", "filter", "sorter", "metaData"];
var columnTypes3 = ["order", "selection", "expand"];
var TableColumn = defineComponent({
  name: "TableColumn",
  props: tableColumnProps,
  setup(_props, { slots }) {
    const props = useProps("tableColumn", _props, {
      idKey: {
        default: null,
        validator: (value) => !qe(value),
        static: true
      },
      name: {
        default: "",
        static: true
      },
      accessor: {
        default: null,
        isFunc: true,
        static: true
      },
      fixed: {
        default: false,
        static: true
      },
      className: null,
      style: null,
      attrs: null,
      type: {
        default: null,
        validator: (value) => columnTypes3.includes(value),
        static: true
      },
      width: null,
      filter: () => ({}),
      sorter: false,
      renderer: {
        default: null,
        isFunc: true,
        static: true
      },
      headRenderer: {
        default: null,
        isFunc: true,
        static: true
      },
      order: {
        default: 0,
        static: true
      },
      noEllipsis: false,
      checkboxSize: createSizeProp(),
      disableRow: {
        default: null,
        isFunc: true
      },
      truthIndex: false,
      orderLabel: {
        default: null,
        isFunc: true
      },
      metaData: {
        default: () => ({}),
        validator: (value) => !qe(value)
      }
    });
    const tableAction = inject(TABLE_ACTION, null);
    const options = reactive({});
    for (const key of propKeys) {
      if (key === "renderer" || key === "headRenderer")
        continue;
      const aliasKey = aliases[key] || key;
      options[aliasKey] = props[key];
      if (key === "idKey") {
        watch(
          () => props[key],
          (value) => {
            if (qe(value) && props.type) {
              options[aliasKey] = value = `__vxp_${props.type}`;
            } else {
              options[aliasKey] = value;
            }
          }
        );
      } else {
        watch(
          () => props[key],
          (value) => {
            options[aliasKey] = value;
          },
          { deep: deepProps.includes(key) }
        );
      }
    }
    watch(() => slots.default, setRenderer);
    watch(() => props.renderer, setRenderer);
    watch(() => slots.head, setHeadRenderer);
    watch(() => props.headRenderer, setHeadRenderer);
    setRenderer();
    setHeadRenderer();
    tableAction == null ? void 0 : tableAction.increaseColumn(options);
    onBeforeUnmount(() => {
      tableAction == null ? void 0 : tableAction.decreaseColumn(options);
    });
    function setRenderer() {
      options.renderer = (data) => {
        if (typeof slots.default === "function") {
          return slots.default(data);
        }
        if (typeof props.renderer === "function") {
          return props.renderer(data);
        }
        const row = data.row;
        const rowIndex = data.rowIndex;
        if (typeof props.accessor === "function") {
          const result2 = props.accessor(row, rowIndex);
          return qe(result2) ? "" : String(result2);
        }
        const result = row[options.key];
        return qe(result) ? "" : String(result);
      };
    }
    function setHeadRenderer() {
      options.headRenderer = (data) => {
        if (typeof slots.head === "function") {
          return slots.head(data);
        }
        if (typeof props.headRenderer === "function") {
          return props.headRenderer(data);
        }
        return props.name;
      };
    }
    return () => null;
  }
});

// node_modules/vexip-ui/es/components/tabs/props.mjs
var tabsProps = omitProps(tabNavProps, ["options"]);

// node_modules/vexip-ui/es/components/tabs/tabs.mjs
var _sfc_main80 = defineComponent({
  name: "Tabs",
  components: {
    Renderer,
    TabNav,
    TabNavItem
  },
  props: tabsProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const props = useProps("tabs", _props, {
      active: {
        default: null,
        static: true
      },
      card: false,
      align: "left",
      placement: "top",
      closable: false,
      showAdd: false
    });
    const currentActive = ref(props.active);
    const currentIndex = ref(0);
    const itemStates = ref(/* @__PURE__ */ new Set());
    const isTransition = ref(false);
    const mainStyle = computed(() => {
      return {
        transform: `translateX(-${currentIndex.value}00%) translateZ(0)`
      };
    });
    const itemList = computed(() => {
      return Array.from(itemStates.value);
    });
    const refreshLabels = Mr(() => {
      itemList.value.forEach((item, index) => {
        if (qe(item.label)) {
          item.label = index + 1;
        }
      });
      if (itemList.value.length >= 1 && isActiveEmpty()) {
        currentActive.value = itemList.value[0].label;
      }
    });
    const computeIndex = Mr(() => {
      const index = Array.from(itemStates.value).findIndex(
        (item) => item.label === currentActive.value
      );
      if (~index) {
        currentIndex.value = index;
      }
    });
    provide(
      TABS_STATE,
      reactive({
        currentActive,
        handleActive,
        increaseItem,
        decreaseItem,
        refreshLabels
      })
    );
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    onMounted(computeIndex);
    function isActiveEmpty() {
      return qe(currentActive.value) || currentActive.value === "";
    }
    function increaseItem(item) {
      itemStates.value.add(item);
      refreshLabels();
    }
    function decreaseItem(item) {
      itemStates.value.delete(item);
      refreshLabels();
    }
    function handleActive(label) {
      currentActive.value = label;
      computeIndex();
      emitEvent(props.onChange, label);
      emit("update:active", label);
    }
    function handleAdd() {
      emitEvent(props.onAdd);
    }
    function handleClose(label) {
      emitEvent(props.onClose, label);
    }
    return {
      props,
      nh: useNameHelper("tabs"),
      currentActive,
      isTransition,
      mainStyle,
      itemList,
      isFunction: gt,
      handleActive,
      handleAdd,
      handleClose
    };
  }
});
function _sfc_render80(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_TabNavItem = resolveComponent("TabNavItem");
  const _component_TabNav = resolveComponent("TabNav");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bm(_ctx.props.placement), _ctx.props.inherit && _ctx.nh.bm("inherit")])
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("header"))
    }, [
      createVNode(_component_TabNav, {
        inherit: "",
        active: _ctx.currentActive,
        card: _ctx.props.card,
        align: _ctx.props.align,
        placement: _ctx.props.placement,
        closable: _ctx.props.closable,
        "show-add": _ctx.props.showAdd,
        onChange: _ctx.handleActive,
        onAdd: _ctx.handleAdd,
        onClose: _ctx.handleClose
      }, createSlots({
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.itemList, (item, index) => {
            return openBlock(), createBlock(_component_TabNavItem, {
              key: index,
              label: item.label,
              icon: item.icon,
              disabled: item.disabled,
              closable: item.closable
            }, {
              default: withCtx(() => [
                _ctx.isFunction(item.labelRenderer) ? (openBlock(), createBlock(_component_Renderer, {
                  key: 0,
                  renderer: item.labelRenderer,
                  data: { label: item.label, disabled: item.disabled }
                }, null, 8, ["renderer", "data"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(item.name || item.label), 1)
                ], 64))
              ]),
              _: 2
            }, 1032, ["label", "icon", "disabled", "closable"]);
          }), 128)),
          _ctx.$slots.add ? renderSlot(_ctx.$slots, "add", { key: 0 }) : createCommentVNode("", true)
        ]),
        _: 2
      }, [
        _ctx.$slots.prefix ? {
          name: "prefix",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "prefix")
          ]),
          key: "0"
        } : void 0,
        _ctx.$slots.suffix ? {
          name: "suffix",
          fn: withCtx(() => [
            renderSlot(_ctx.$slots, "suffix")
          ]),
          key: "1"
        } : void 0
      ]), 1032, ["active", "card", "align", "placement", "closable", "show-add", "onChange", "onAdd", "onClose"])
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass({
        [_ctx.nh.be("main")]: true,
        [_ctx.nh.bem("main", "transition")]: _ctx.isTransition
      }),
      onTransitionend: _cache[0] || (_cache[0] = ($event) => _ctx.isTransition = false)
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 34)
  ], 2);
}
var Tabs = _export_sfc(_sfc_main80, [["render", _sfc_render80]]);

// node_modules/vexip-ui/es/components/textarea/props.mjs
var textareaProps = buildProps({
  state: stateProp,
  value: String,
  placeholder: String,
  rows: Number,
  noResize: booleanProp,
  autofocus: booleanProp,
  spellcheck: booleanProp,
  autocomplete: booleanProp,
  readonly: booleanProp,
  disabled: booleanProp,
  debounce: booleanProp,
  maxLength: Number,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  sync: booleanProp,
  onFocus: eventProp(),
  onBlur: eventProp(),
  onInput: eventProp(),
  onChange: eventProp(),
  onEnter: eventProp(),
  onKeyDown: eventProp(),
  onKeyPress: eventProp(),
  onKeyUp: eventProp()
});

// node_modules/vexip-ui/es/components/textarea/textarea.mjs
var _sfc_main81 = defineComponent({
  name: "Textarea",
  components: {
    Icon
  },
  props: textareaProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const { idFor, state, disabled, loading, validateField, getFieldValue, setFieldValue } = useFieldStore(() => {
      var _a;
      return (_a = textarea.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("textarea", _props, {
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      placeholder: null,
      rows: 2,
      noResize: false,
      autofocus: false,
      spellcheck: false,
      autocomplete: false,
      readonly: false,
      disabled: () => disabled.value,
      debounce: false,
      maxLength: 0,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      sync: false
    });
    const nh = useNameHelper("textarea");
    const focused = ref(false);
    const currentValue = ref(props.value);
    const currentLength = ref(props.value ? props.value.length : 0);
    const textarea = ref();
    let lastValue = props.value;
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("focused")]: focused.value,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("loading")]: props.loading && props.loadingLock,
        [nh.bm("no-resize")]: props.noResize,
        [nh.bm(props.state)]: props.state !== "default"
      };
    });
    const isReadonly = computed(() => {
      return props.loading && props.loadingLock || props.readonly;
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
        lastValue = value;
      }
    );
    function handleFocus(event) {
      focused.value = true;
      emitEvent(props.onFocus, event);
    }
    function handleBlur(event) {
      focused.value = false;
      emitEvent(props.onBlur, event);
    }
    function handleChange(event) {
      const type = event.type;
      const value = event.target.value;
      if (props.maxLength && value.length > props.maxLength) {
        currentValue.value = value.slice(0, props.maxLength);
      } else {
        currentValue.value = value;
      }
      currentLength.value = currentValue.value.length;
      event.target.value = currentValue.value;
      if (type === "change") {
        if (lastValue === currentValue.value)
          return;
        lastValue = currentValue.value;
        setFieldValue(currentValue.value);
        emitEvent(props.onChange, currentValue.value);
        if (!props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      } else {
        emitEvent(props.onInput, currentValue.value);
        if (props.sync) {
          emit("update:value", currentValue.value);
          validateField();
        }
      }
    }
    function handleEnter() {
      emitEvent(props.onEnter);
    }
    function handleKeyDown(event) {
      emitEvent(props.onKeyDown, event);
    }
    function handleKeyPress(event) {
      emitEvent(props.onKeyPress, event);
    }
    function handleKeyUp(event) {
      emitEvent(props.onKeyUp, event);
    }
    function copyValue() {
      const textarea2 = document.createElement("textarea");
      textarea2.style.height = "0";
      textarea2.setAttribute("readonly", "readonly");
      textarea2.value = currentValue.value;
      document.body.appendChild(textarea2);
      textarea2.select();
      const isSuccess = document.execCommand("copy");
      document.body.removeChild(textarea2);
      return isSuccess;
    }
    return {
      props,
      nh,
      locale: useLocale("input"),
      idFor,
      currentValue,
      currentLength,
      className,
      isReadonly,
      textarea,
      handleFocus,
      handleBlur,
      handleInput: props.debounce ? yr(handleChange) : br(handleChange),
      handleChange,
      handleEnter,
      handleKeyDown,
      handleKeyPress,
      handleKeyUp,
      copyValue
    };
  }
});
var _hoisted_144 = ["id"];
var _hoisted_219 = ["value", "rows", "autofocus", "autocomplete", "spellcheck", "disabled", "readonly", "placeholder", "maxlength"];
function _sfc_render81(_ctx, _cache, $props, $setup, $data, $options) {
  var _a;
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    class: normalizeClass(_ctx.className),
    onClick: _cache[8] || (_cache[8] = ($event) => {
      var _a2;
      return (_a2 = _ctx.textarea) == null ? void 0 : _a2.focus();
    })
  }, [
    createBaseVNode("textarea", {
      ref: "textarea",
      class: normalizeClass(_ctx.nh.be("control")),
      value: _ctx.currentValue,
      rows: _ctx.props.rows,
      autofocus: _ctx.props.autofocus,
      autocomplete: _ctx.props.autocomplete ? "on" : "off",
      spellcheck: _ctx.props.spellcheck,
      disabled: _ctx.props.disabled,
      readonly: _ctx.isReadonly,
      placeholder: (_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder,
      maxlength: _ctx.props.maxLength > 0 ? _ctx.props.maxLength : void 0,
      onBlur: _cache[0] || (_cache[0] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args)),
      onFocus: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onKeyup: [
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.handleEnter && _ctx.handleEnter(...args), ["enter"])),
        _cache[3] || (_cache[3] = (...args) => _ctx.handleKeyUp && _ctx.handleKeyUp(...args))
      ],
      onKeypress: _cache[4] || (_cache[4] = (...args) => _ctx.handleKeyPress && _ctx.handleKeyPress(...args)),
      onKeydown: _cache[5] || (_cache[5] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args)),
      onInput: _cache[6] || (_cache[6] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
      onChange: _cache[7] || (_cache[7] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 42, _hoisted_219),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("extra"))
    }, [
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("loading"))
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"]),
      _ctx.props.maxLength > 0 ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("count"))
      }, [
        renderSlot(_ctx.$slots, "count", { value: _ctx.currentValue }, () => [
          createTextVNode(toDisplayString(`${_ctx.currentLength}/${_ctx.props.maxLength}`), 1)
        ])
      ], 2)) : createCommentVNode("", true)
    ], 2)
  ], 10, _hoisted_144);
}
var Textarea = _export_sfc(_sfc_main81, [["render", _sfc_render81]]);

// node_modules/vexip-ui/es/components/time-ago/helper.mjs
var id = 1;
function getId() {
  return id++;
}
var recordMap = /* @__PURE__ */ new Map();
var timer;
var isRunning;
function subscribe(id2, record) {
  recordMap.set(id2, record);
  if (recordMap.size && !isRunning) {
    clearInterval(timer);
    timer = setInterval(() => {
      isRunning = true;
      const current = Date.now();
      recordMap.forEach((record2) => {
        if (!record2.interval)
          return;
        if (current - record2.updated > record2.interval) {
          record2.timeAgo.value = computeTimeAgo(
            record2.datetime,
            current,
            record2.locale.value,
            record2.wordSpace.value
          );
          record2.updated = current;
        }
      });
    }, 5e3);
  }
}
function unsubscribe(id2) {
  recordMap.delete(id2);
  if (!recordMap.size) {
    clearInterval(timer);
    isRunning = false;
  }
}
function computeTimeAgo(date, current, locale, wordSpace) {
  const diff = Math.abs(current - date.getTime());
  const type = current > date.getTime() ? locale.ago : locale.late;
  let label;
  let usedDiff;
  let noFormat = false;
  if (diff < 10 * R) {
    label = locale.justNow;
    noFormat = true;
  } else if (diff < jt) {
    label = locale.second;
    usedDiff = Math.floor(diff / R);
  } else if (diff < Qt) {
    label = locale.minute;
    usedDiff = Math.floor(diff / jt);
  } else if (diff < Zt) {
    label = locale.hour;
    usedDiff = Math.floor(diff / Qt);
  } else if (diff < 30 * Zt) {
    usedDiff = Math.floor(diff / Zt);
    if (usedDiff === 1) {
      label = locale.yesterday;
      noFormat = true;
    } else {
      label = locale.days;
    }
  } else if (diff < 365 * Zt) {
    usedDiff = Math.floor(diff / (30 * Zt));
    if (usedDiff === 1) {
      label = locale.lastMonth;
      noFormat = true;
    } else {
      label = locale.months;
    }
  } else {
    usedDiff = Math.floor(diff / 365 / Zt);
    if (usedDiff === 1) {
      label = locale.lastYear;
      noFormat = true;
    } else {
      label = locale.years;
    }
  }
  if (noFormat) {
    return label;
  }
  return makeSentence(`${getCountWord(label, usedDiff)} ${type}`, wordSpace);
}

// node_modules/vexip-ui/es/components/time-ago/props.mjs
var timeAgoProps = buildProps({
  datetime: [String, Number, Date],
  interval: booleanNumberProp,
  title: booleanStringProp,
  titleFormat: String
});

// node_modules/vexip-ui/es/components/time-ago/time-ago.mjs
var _sfc_main82 = defineComponent({
  name: "TimeAgo",
  props: timeAgoProps,
  setup(_props) {
    const props = useProps("timeAgo", _props, {
      datetime: {
        default: () => Date.now(),
        static: true
      },
      interval: {
        default: false,
        validator: (value) => value && value >= 5
      },
      title: false,
      titleFormat: "yyyy-MM-dd HH:mm:ss"
    });
    const nh = useNameHelper("time-ago");
    const datetime = toDateValue(props.datetime);
    const locale = useLocale("timeAgo");
    const wordSpace = computed(() => {
      var _a;
      return ((_a = useLocale()) == null ? void 0 : _a.value.wordSpace) || false;
    });
    const timeAgo = ref(computeTimeAgo(datetime, Date.now(), locale.value, wordSpace.value));
    const id2 = getId();
    const record = {
      datetime,
      timeAgo,
      locale,
      wordSpace,
      interval: parseInterval(props.interval),
      updated: Date.now()
    };
    const currentTitle = computed(() => {
      if (!props.title)
        return void 0;
      if (typeof props.title === "string")
        return props.title;
      return Rn(props.datetime, props.titleFormat);
    });
    subscribe(id2, record);
    watch(
      () => props.datetime,
      (value) => {
        record.datetime = toDateValue(value);
        timeAgo.value = computeTimeAgo(datetime, Date.now(), locale.value, wordSpace.value);
      }
    );
    watch(
      () => props.interval,
      (value) => {
        record.interval = parseInterval(value);
      }
    );
    onBeforeUnmount(() => {
      unsubscribe(id2);
    });
    function parseInterval(interval) {
      return interval && (interval === true ? 1e4 : interval * 1e3);
    }
    function toDateValue(value) {
      if (typeof value === "string") {
        value = value.replace(/-/g, "/");
      }
      return l(value);
    }
    return {
      nh,
      props,
      timeAgo,
      currentTitle
    };
  }
});
var _hoisted_145 = ["title"];
function _sfc_render82(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("span", {
    class: normalizeClass([_ctx.nh.b(), _ctx.props.inherit && _ctx.nh.bm("inherit")]),
    title: _ctx.currentTitle
  }, toDisplayString(_ctx.timeAgo), 11, _hoisted_145);
}
var TimeAgo = _export_sfc(_sfc_main82, [["render", _sfc_render82]]);

// node_modules/vexip-ui/es/components/date-picker/time-control.mjs
var _sfc_main83 = defineComponent({
  name: "TimeControl",
  props: {
    unitType: {
      type: String,
      default: "hour"
    },
    enabled: {
      type: Object,
      default: () => ({})
    },
    activated: {
      type: Object,
      default: () => ({})
    },
    timeValue: {
      type: Object,
      default: () => ({})
    },
    separator: {
      type: String,
      default: ":"
    },
    visible: {
      type: Boolean,
      default: false
    },
    focused: {
      type: Boolean,
      default: false
    },
    filler: {
      type: String,
      default: "-",
      validator: (value) => value.length === 1
    },
    noFiller: {
      type: Boolean,
      default: false
    },
    steps: {
      type: Array,
      default: () => [1, 1, 1]
    },
    ctrlSteps: {
      type: Array,
      default: () => [5, 5, 5]
    },
    labels: {
      type: Object,
      default: () => ({})
    },
    hasError: {
      type: Boolean,
      default: false
    }
  },
  emits: [
    "input",
    "plus",
    "minus",
    "enter",
    "cancel",
    "unit-focus",
    "unit-blur",
    "prev-unit",
    "next-unit"
  ],
  setup(props, { emit }) {
    const nh = useNameHelper("time-picker");
    const wrapper = ref();
    const formattedHour = computed(() => {
      return formatValue("hour");
    });
    const formattedMinute = computed(() => {
      return formatValue("minute");
    });
    const formattedSecond = computed(() => {
      return formatValue("second");
    });
    watch(
      () => props.unitType,
      (_, prev) => {
        prev && emit("unit-blur", prev);
      }
    );
    function formatValue(type) {
      return props.noFiller || props.activated[type] ? m(props.timeValue[type]) : `${props.filler}${props.filler}`;
    }
    function handleInputFocus(type) {
      emit("unit-focus", type);
    }
    function handleInput(event) {
      if (!props.visible)
        return;
      const type = handleKeyEnter(event);
      switch (type) {
        case "next": {
          emit("next-unit");
          break;
        }
        case "prev": {
          emit("prev-unit");
          break;
        }
        case "up": {
          emit("minus", event.ctrlKey);
          break;
        }
        case "down": {
          emit("plus", event.ctrlKey);
          break;
        }
        case "ok": {
          handleEnter();
          break;
        }
        case "esc": {
          handleCancel();
          break;
        }
        default: {
          if (typeof type === "number") {
            emit("input", type);
          }
        }
      }
    }
    function handleEnter() {
      emit("enter");
    }
    function handleCancel() {
      emit("cancel");
    }
    return {
      nh,
      formattedHour,
      formattedMinute,
      formattedSecond,
      wrapper,
      handleInputFocus,
      handleInput,
      focus: () => {
        var _a;
        (_a = wrapper.value) == null ? void 0 : _a.focus();
      },
      blur: () => {
        var _a;
        (_a = wrapper.value) == null ? void 0 : _a.blur();
      }
    };
  }
});
function _sfc_render83(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass([_ctx.nh.be("input"), _ctx.hasError && _ctx.nh.bem("input", "error")]),
    tabindex: "-1",
    onKeydown: _cache[3] || (_cache[3] = (...args) => _ctx.handleInput && _ctx.handleInput(...args))
  }, [
    _ctx.enabled.hour ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "hour" && _ctx.nh.bem("unit", "focused")]),
      onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleInputFocus("hour"))
    }, toDisplayString(_ctx.formattedHour), 3)) : createCommentVNode("", true),
    _ctx.labels.hour ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: normalizeClass(_ctx.nh.be("label"))
    }, toDisplayString(_ctx.labels.hour), 3)) : createCommentVNode("", true),
    _ctx.enabled.minute ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
      _ctx.enabled.hour ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("separator"))
      }, toDisplayString(_ctx.separator), 3)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "minute" && _ctx.nh.bem("unit", "focused")]),
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handleInputFocus("minute"))
      }, toDisplayString(_ctx.formattedMinute), 3),
      _ctx.labels.minute ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("label"))
      }, toDisplayString(_ctx.labels.minute), 3)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true),
    _ctx.enabled.second ? (openBlock(), createElementBlock(Fragment, { key: 3 }, [
      _ctx.enabled.minute || _ctx.enabled.hour ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.nh.be("separator"))
      }, toDisplayString(_ctx.separator), 3)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass([_ctx.nh.be("unit"), _ctx.visible && _ctx.unitType === "second" && _ctx.nh.bem("unit", "focused")]),
        onClick: _cache[2] || (_cache[2] = ($event) => _ctx.handleInputFocus("second"))
      }, toDisplayString(_ctx.formattedSecond), 3),
      _ctx.labels.second ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass(_ctx.nh.be("label"))
      }, toDisplayString(_ctx.labels.second), 3)) : createCommentVNode("", true)
    ], 64)) : createCommentVNode("", true)
  ], 34);
}
var TimeControl = _export_sfc(_sfc_main83, [["render", _sfc_render83]]);

// node_modules/vexip-ui/es/components/date-picker/time-picker.mjs
var TIME_REG = /^((?:\d{1,2}))((?::\d{1,2}))?((?::\d{1,2}))?$/;
var _sfc_main84 = defineComponent({
  name: "TimePicker",
  components: {
    Button,
    Icon,
    Portal,
    TimeControl,
    TimeWheel,
    CircleXmark: u,
    ArrowRightArrowLeft: $8
  },
  props: timePickerProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const initValue = Rn(Date.now(), "HH:mm:ss");
    const nh = useNameHelper("time-picker");
    const props = useProps("timePicker", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      visible: false,
      placement: {
        default: "bottom-start",
        validator: (value) => Wo.includes(value)
      },
      transfer: false,
      format: "HH:mm:ss",
      separator: ":",
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      filler: {
        default: "-",
        validator: (value) => value.length === 1
      },
      noFiller: false,
      clearable: false,
      noAction: false,
      noArrow: false,
      pointer: Fe,
      candidate: {
        default: 3,
        validator: (value) => [0, 1, 2, 3].includes(value)
      },
      steps: () => [1, 1, 1],
      labels: () => ({}),
      shortcuts: () => [],
      isRange: false,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      confirmText: null,
      cancelText: null,
      ctrlSteps: () => [5, 5, 5],
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      exchange: false,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      min: null,
      max: null
    });
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const currentVisible = ref(props.visible);
    const focused = ref(false);
    const lastValue = ref("");
    const startState = createTimeState();
    const endState = createTimeState();
    const currentState = ref("start");
    const { timer: timer2 } = $o();
    const wrapper = Do(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = qo({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = Co(reference);
    const { isTimeDisabled } = useTimeBound(toRef(props, "min"), toRef(props, "max"));
    const startInput = ref();
    const endInput = ref();
    const className = computed(() => {
      return [
        nh.b(),
        nh.ns("input-vars"),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("disabled")]: props.disabled,
          [nh.bm(props.size)]: props.size !== "default",
          [nh.bm("no-hour")]: !startState.enabled.hour,
          [nh.bm("no-minute")]: !startState.enabled.minute,
          [nh.bm("no-second")]: !startState.enabled.second,
          [nh.bm("visible")]: currentVisible.value,
          [nh.bm(props.state)]: props.state !== "default",
          [nh.bm("is-range")]: props.isRange
        }
      ];
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--focused`]: focused.value,
        [`${baseCls}--${props.state}`]: props.state !== "default"
      };
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const currentValue = computed(() => {
      const values = [startState, endState].map((state2) => {
        return Object.values(state2.timeValue).map(m).join(":");
      });
      return props.isRange ? values : values[0];
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && !!lastValue.value;
    });
    const startError = computed(() => {
      const { hour, minute, second } = startState.timeValue;
      return isTimeDisabled.hour(hour) || isTimeDisabled.minute(hour, minute) || isTimeDisabled.second(hour, minute, second);
    });
    const endError = computed(() => {
      if (!props.isRange)
        return false;
      const { hour, minute, second } = endState.timeValue;
      return isTimeDisabled.hour(hour) || isTimeDisabled.minute(hour, minute) || isTimeDisabled.second(hour, minute, second);
    });
    parseValue(props.value, false);
    if (props.noFiller) {
      lastValue.value = getStringValue();
    }
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
      }
    );
    watch(() => props.format, parseFormat, { immediate: true });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        updatePopper();
      } else {
        emitChange();
      }
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(focused, (value) => {
      if (value) {
        emitEvent(props.onFocus);
      } else {
        emitEvent(props.onBlur);
      }
    });
    watch(currentState, (value) => {
      if (currentVisible.value) {
        emitEvent(props.onChangeCol, getCurrentState().column, value);
      }
    });
    watch(
      () => startState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "start") {
          emitEvent(props.onChangeCol, value, "start");
        }
      }
    );
    watch(
      () => endState.column,
      (value) => {
        if (currentVisible.value && currentState.value === "end") {
          emitEvent(props.onChangeCol, value, "end");
        }
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
          handleBlur();
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    function createTimeState() {
      const { currentColumn, enabled, resetColumn, enterColumn: enterColumn2 } = useColumn([
        "hour",
        "minute",
        "second"
      ]);
      const timeValue = reactive({
        hour: 0,
        minute: 0,
        second: 0
      });
      const activated = reactive({
        hour: false,
        minute: false,
        second: false
      });
      return reactive({
        column: currentColumn,
        enabled,
        activated,
        timeValue,
        resetColumn,
        enterColumn: enterColumn2
      });
    }
    function getCurrentState() {
      return currentState.value === "start" ? startState : endState;
    }
    function parseValue(value, updateActivated = true) {
      if (!Array.isArray(value)) {
        value = [value, value];
      }
      for (let i = 0; i < 2; ++i) {
        const match = TIME_REG.exec(value[i] || initValue);
        const state2 = i === 0 ? startState : endState;
        const { activated, timeValue } = state2;
        if (match) {
          if (updateActivated) {
            activated.hour = !!match[1];
            activated.minute = !!match[2];
            activated.second = !!match[3];
          }
          const hour = parseInt(match[1]);
          const minute = match[2] ? parseInt(match[2].slice(1)) : 0;
          const second = match[3] ? parseInt(match[3].slice(1)) : 0;
          const date = new Date(2e3, 1, 1, hour, minute, second);
          timeValue.hour = date.getHours();
          timeValue.minute = date.getMinutes();
          timeValue.second = date.getSeconds();
        } else {
          timeValue.hour = 0;
          timeValue.minute = 0;
          timeValue.second = 0;
          if (updateActivated) {
            activated.hour = false;
            activated.minute = false;
            activated.second = false;
          }
        }
        if (!props.isRange)
          break;
      }
    }
    function parseFormat() {
      [startState, endState].forEach((state2) => {
        state2.enabled.hour = props.format.includes("H");
        state2.enabled.minute = props.format.includes("m");
        state2.enabled.second = props.format.includes("s");
      });
    }
    function toggleActivated(value) {
      [startState, endState].forEach((state2) => {
        Object.keys(state2.activated).forEach((type) => {
          state2.activated[type] = value;
        });
      });
    }
    function getStringValue() {
      return Array.isArray(currentValue.value) ? currentValue.value.join("|") : currentValue.value;
    }
    function verifyTime() {
      if (startError.value || props.isRange && endError.value) {
        if (lastValue.value) {
          parseValue(lastValue.value.split("|"));
        } else {
          parseValue(props.value);
        }
      }
    }
    function emitChange() {
      verifyTime();
      if (lastValue.value !== getStringValue()) {
        lastValue.value = getStringValue();
        toggleActivated(true);
        setFieldValue(currentValue.value);
        emitEvent(props.onChange, currentValue.value);
        emit("update:value", currentValue.value);
        validateField();
      }
    }
    function handleFocused() {
      if (props.disabled)
        return;
      focused.value = true;
      timer2.focus = setTimeout(() => {
        var _a, _b;
        if (focused.value) {
          if (currentState.value === "start") {
            (_a = startInput.value) == null ? void 0 : _a.focus();
          } else {
            (_b = endInput.value) == null ? void 0 : _b.focus();
          }
        }
      }, 120);
    }
    function handleBlur() {
      var _a, _b;
      clearTimeout(timer2.focus);
      focused.value = false;
      (_a = startInput.value) == null ? void 0 : _a.blur();
      (_b = endInput.value) == null ? void 0 : _b.blur();
    }
    function showPanel(event) {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      const target = event.target;
      const lastVisible = currentVisible.value;
      currentVisible.value = true;
      handleFocused();
      if (!lastVisible && wrapper.value && target) {
        const units = Array.from(wrapper.value.querySelectorAll(`.${nh.be("unit")}`));
        if (!units.some((unit) => unit === target || unit.contains(target))) {
          emitEvent(props.onChangeCol, getCurrentState().column, currentState.value);
        }
      }
    }
    function finishInput() {
      currentVisible.value = false;
      startState.resetColumn();
      endState.resetColumn();
    }
    function handleClear() {
      if (props.clearable) {
        lastValue.value = "";
        finishInput();
        nextTick(() => {
          parseValue("");
          emitEvent(props.onChange, currentValue.value);
          emit("update:value", currentValue.value);
          emitEvent(props.onClear);
          clearField(currentValue.value);
          nextTick(() => {
            toggleActivated(false);
          });
        });
      }
    }
    function handleWheelChange(type) {
      if (currentVisible.value) {
        getCurrentState().activated[type] = true;
      }
    }
    function handleInputFocus(type) {
      getCurrentState().column = type;
    }
    function handleInput(value) {
      const state2 = getCurrentState();
      handleInputNumber(state2.column, value);
      if (state2.column !== "second" && state2.timeValue[state2.column] >= 10) {
        state2.enterColumn("next", false);
      }
    }
    function handleInputNumber(type, number) {
      const state2 = getCurrentState();
      const prev = state2.timeValue[type];
      if ((props.noFiller || state2.activated[type]) && prev > 0 && prev < 10) {
        state2.timeValue[type] = prev * 10 + number;
      } else {
        state2.timeValue[type] = number;
      }
      verifyValue(type);
      state2.activated[type] = true;
      emitEvent(props.onInput, type, state2.timeValue[type]);
    }
    function verifyValue(type) {
      const timeValue = getCurrentState().timeValue;
      timeValue[type] = Fn(timeValue[type], 0, type === "hour" ? 23 : 59);
      timeValue[type] = Math.round(timeValue[type] / getStep(type)) * getStep(type);
    }
    function handlePlus(ctrlKey) {
      const state2 = getCurrentState();
      const type = state2.column;
      if (state2.enabled[type]) {
        state2.timeValue[type] += ctrlKey ? getCtrlStep(type) : getStep(type);
        verifyValue(type);
        emitEvent(props.onPlus, type, state2.timeValue[type]);
      }
    }
    function handleMinus(ctrlKey) {
      const state2 = getCurrentState();
      const type = state2.column;
      if (state2.enabled[type]) {
        state2.timeValue[type] -= ctrlKey ? getCtrlStep(type) : getStep(type);
        verifyValue(type);
        emitEvent(props.onMinus, type, state2.timeValue[type]);
      }
    }
    function getStep(type) {
      return props.steps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function getCtrlStep(type) {
      return props.ctrlSteps[type === "hour" ? 0 : type === "minute" ? 1 : 2] || 1;
    }
    function handleEnter() {
      finishInput();
      emitEvent(props.onEnter);
    }
    function handleCancel() {
      parseValue(props.value);
      finishInput();
      emitEvent(props.onCancel);
    }
    function handleShortcut(index) {
      let { value, name } = props.shortcuts[index];
      if (typeof value === "function") {
        value = value();
      }
      parseValue(value);
      emitEvent(props.onShortcut, name, value);
      finishInput();
    }
    function toggleCurrentState(type) {
      currentState.value = type;
    }
    function enterColumn(type) {
      if (props.isRange) {
        const state2 = getCurrentState();
        const currentColumn = state2.column;
        state2.enterColumn(type, false);
        if (currentColumn === state2.column) {
          const isStart = currentState.value === "start";
          const otherState = isStart ? endState : startState;
          otherState.resetColumn(type === "prev" ? "second" : "hour", type === "prev");
          toggleCurrentState(isStart ? "end" : "start");
        }
      } else {
        startState.enterColumn(type);
      }
    }
    function handleStartInput(type) {
      toggleCurrentState("start");
      handleInputFocus(type);
    }
    function handleEndInput(type) {
      toggleCurrentState("end");
      handleInputFocus(type);
    }
    function exchangeValue() {
      Object.keys(startState.timeValue).forEach((type) => {
        const temp = endState.timeValue[type];
        endState.timeValue[type] = startState.timeValue[type];
        startState.timeValue[type] = temp;
      });
    }
    function handleExchangeClick(event) {
      if (props.exchange) {
        !currentVisible.value && event.stopPropagation();
        exchangeValue();
      }
    }
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      finishInput();
      handleBlur();
    }
    function handlePanelClosed() {
      const { hour, minute } = startState.enabled;
      handleStartInput(hour ? "hour" : minute ? "minute" : "second");
    }
    return {
      ClockR: x19,
      props,
      nh,
      locale: useLocale("timePicker"),
      idFor,
      isHover,
      currentVisible,
      focused,
      transferTo,
      lastValue,
      startState,
      endState,
      currentState,
      currentValue,
      className,
      selectorClass,
      hasPrefix,
      showClear,
      isTimeDisabled,
      startError,
      endError,
      wrapper,
      reference,
      popper,
      start: startInput,
      end: endInput,
      handleFocused,
      showPanel,
      handleClear,
      handleShortcut,
      handleWheelChange,
      handleInputFocus,
      handleInput,
      handlePlus,
      handleMinus,
      handleEnter,
      finishInput,
      handleCancel,
      toggleCurrentState,
      enterColumn,
      handleStartInput,
      handleEndInput,
      handleExchangeClick,
      handlePanelClosed,
      focus: handleFocused,
      blur: handleBlur,
      updatePopper
    };
  }
});
var _hoisted_146 = ["id"];
var _hoisted_220 = ["title", "onClick"];
var _hoisted_38 = { style: { "display": "flex" } };
function _sfc_render84(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_TimeControl = resolveComponent("TimeControl");
  const _component_ArrowRightArrowLeft = resolveComponent("ArrowRightArrowLeft");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_TimeWheel = resolveComponent("TimeWheel");
  const _component_Button = resolveComponent("Button");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[14] || (_cache[14] = (...args) => _ctx.showPanel && _ctx.showPanel(...args))
  }, [
    createBaseVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers((...args) => _ctx.showPanel && _ctx.showPanel(...args), ["prevent"]), ["space"]))
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        createVNode(_component_TimeControl, {
          ref: "start",
          "unit-type": _ctx.currentState === "start" ? _ctx.startState.column : void 0,
          enabled: _ctx.startState.enabled,
          activated: _ctx.startState.activated,
          "time-value": _ctx.startState.timeValue,
          steps: _ctx.props.steps,
          "ctrl-steps": _ctx.props.ctrlSteps,
          focused: _ctx.focused,
          visible: _ctx.currentVisible,
          separator: _ctx.props.separator,
          filler: _ctx.props.filler,
          "no-filler": _ctx.props.noFiller,
          labels: _ctx.props.labels,
          "has-error": _ctx.startError,
          onInput: _ctx.handleInput,
          onPlus: _ctx.handlePlus,
          onMinus: _ctx.handleMinus,
          onEnter: _ctx.handleEnter,
          onCancel: _ctx.handleCancel,
          onUnitFocus: _ctx.handleStartInput,
          onPrevUnit: _cache[0] || (_cache[0] = ($event) => _ctx.enterColumn("prev")),
          onNextUnit: _cache[1] || (_cache[1] = ($event) => _ctx.enterColumn("next"))
        }, null, 8, ["unit-type", "enabled", "activated", "time-value", "steps", "ctrl-steps", "focused", "visible", "separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"]),
        _ctx.props.isRange ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", {
            class: normalizeClass([_ctx.nh.be("exchange"), _ctx.props.exchange ? _ctx.nh.bem("exchange", "enabled") : ""]),
            onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleExchangeClick && _ctx.handleExchangeClick(...args))
          }, [
            renderSlot(_ctx.$slots, "exchange", {}, () => [
              createVNode(_component_Icon, { style: { "padding-top": "1px" } }, {
                default: withCtx(() => [
                  createVNode(_component_ArrowRightArrowLeft)
                ]),
                _: 1
              })
            ])
          ], 2),
          createVNode(_component_TimeControl, {
            ref: "end",
            "unit-type": _ctx.currentState === "end" ? _ctx.endState.column : void 0,
            enabled: _ctx.endState.enabled,
            activated: _ctx.endState.activated,
            "time-value": _ctx.endState.timeValue,
            steps: _ctx.props.steps,
            "ctrl-steps": _ctx.props.ctrlSteps,
            focused: _ctx.focused,
            visible: _ctx.currentVisible,
            separator: _ctx.props.separator,
            filler: _ctx.props.filler,
            "no-filler": _ctx.props.noFiller,
            labels: _ctx.props.labels,
            "has-error": _ctx.endError,
            onInput: _ctx.handleInput,
            onPlus: _ctx.handlePlus,
            onMinus: _ctx.handleMinus,
            onEnter: _ctx.handleEnter,
            onCancel: _ctx.handleCancel,
            onUnitFocus: _ctx.handleEndInput,
            onPrevUnit: _cache[3] || (_cache[3] = ($event) => _ctx.enterColumn("prev")),
            onNextUnit: _cache[4] || (_cache[4] = ($event) => _ctx.enterColumn("next"))
          }, null, 8, ["unit-type", "enabled", "activated", "time-value", "steps", "ctrl-steps", "focused", "visible", "separator", "filler", "no-filler", "labels", "has-error", "onInput", "onPlus", "onMinus", "onEnter", "onCancel", "onUnitFocus"])
        ], 64)) : createCommentVNode("", true)
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.suffix || _ctx.ClockR
          }, null, 8, ["icon"])
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          !_ctx.props.disabled && _ctx.props.clearable && _ctx.isHover && _ctx.lastValue ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onAfterLeave: _ctx.handlePanelClosed
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[13] || (_cache[13] = withModifiers((...args) => _ctx.handleFocused && _ctx.handleFocused(...args), ["stop"]))
            }, [
              createBaseVNode("div", {
                class: normalizeClass(_ctx.nh.be("panel"))
              }, [
                _ctx.props.shortcuts.length ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass([_ctx.nh.be("list"), _ctx.nh.bem("list", "sub")])
                }, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.shortcuts, (item, index) => {
                    return openBlock(), createElementBlock("div", {
                      key: index,
                      class: normalizeClass(_ctx.nh.be("shortcut")),
                      title: item.name,
                      onClick: ($event) => _ctx.handleShortcut(index)
                    }, toDisplayString(item.name), 11, _hoisted_220);
                  }), 128))
                ], 2)) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: normalizeClass(_ctx.nh.be("list"))
                }, [
                  createBaseVNode("div", _hoisted_38, [
                    createVNode(_component_TimeWheel, {
                      hour: _ctx.startState.timeValue.hour,
                      "onUpdate:hour": _cache[7] || (_cache[7] = ($event) => _ctx.startState.timeValue.hour = $event),
                      minute: _ctx.startState.timeValue.minute,
                      "onUpdate:minute": _cache[8] || (_cache[8] = ($event) => _ctx.startState.timeValue.minute = $event),
                      second: _ctx.startState.timeValue.second,
                      "onUpdate:second": _cache[9] || (_cache[9] = ($event) => _ctx.startState.timeValue.second = $event),
                      "no-arrow": _ctx.props.noArrow,
                      candidate: _ctx.props.candidate,
                      steps: _ctx.props.steps,
                      pointer: _ctx.props.pointer,
                      "disabled-time": _ctx.isTimeDisabled,
                      onChange: _ctx.handleWheelChange,
                      onToggleCol: _ctx.handleStartInput
                    }, null, 8, ["hour", "minute", "second", "no-arrow", "candidate", "steps", "pointer", "disabled-time", "onChange", "onToggleCol"]),
                    _ctx.isRange ? (openBlock(), createBlock(_component_TimeWheel, {
                      key: 0,
                      hour: _ctx.endState.timeValue.hour,
                      "onUpdate:hour": _cache[10] || (_cache[10] = ($event) => _ctx.endState.timeValue.hour = $event),
                      minute: _ctx.endState.timeValue.minute,
                      "onUpdate:minute": _cache[11] || (_cache[11] = ($event) => _ctx.endState.timeValue.minute = $event),
                      second: _ctx.endState.timeValue.second,
                      "onUpdate:second": _cache[12] || (_cache[12] = ($event) => _ctx.endState.timeValue.second = $event),
                      "no-arrow": _ctx.props.noArrow,
                      candidate: _ctx.props.candidate,
                      steps: _ctx.props.steps,
                      pointer: _ctx.props.pointer,
                      "disabled-time": _ctx.isTimeDisabled,
                      onChange: _ctx.handleWheelChange,
                      onToggleCol: _ctx.handleEndInput
                    }, null, 8, ["hour", "minute", "second", "no-arrow", "candidate", "steps", "pointer", "disabled-time", "onChange", "onToggleCol"])) : createCommentVNode("", true)
                  ]),
                  !_ctx.props.noAction ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: normalizeClass(_ctx.nh.be("action"))
                  }, [
                    createVNode(_component_Button, {
                      inherit: "",
                      text: "",
                      size: "small",
                      onClick: withModifiers(_ctx.handleCancel, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
                      ]),
                      _: 1
                    }, 8, ["onClick"]),
                    createVNode(_component_Button, {
                      inherit: "",
                      type: "primary",
                      size: "small",
                      disabled: _ctx.startError || _ctx.endError,
                      onClick: withModifiers(_ctx.finishInput, ["stop"])
                    }, {
                      default: withCtx(() => [
                        createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
                      ]),
                      _: 1
                    }, 8, ["disabled", "onClick"])
                  ], 2)) : createCommentVNode("", true)
                ], 2)
              ], 2)
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name", "onAfterLeave"])
      ]),
      _: 1
    }, 8, ["to"])
  ], 10, _hoisted_146);
}
var TimePicker = _export_sfc(_sfc_main84, [["render", _sfc_render84]]);

// node_modules/vexip-ui/es/components/timeline/props.mjs
var timelineProps = buildProps({
  pending: booleanProp,
  bothSides: booleanProp,
  dashed: booleanProp,
  lineColor: String,
  spacing: [Number, String],
  flip: booleanProp,
  horizontal: booleanProp,
  onSignalClick: eventProp()
});
var timelineItemProps = buildProps({
  type: String,
  color: String,
  label: [Number, String],
  dashed: booleanProp,
  lineColor: String,
  spacing: [Number, String],
  onSignalClick: eventProp()
});

// node_modules/vexip-ui/es/components/timeline/symbol.mjs
var TIMELINE_STATE = Symbol("TTIMELINE_STATE");

// node_modules/vexip-ui/es/components/timeline/timeline.mjs
var _sfc_main85 = defineComponent({
  name: "Timeline",
  props: timelineProps,
  emits: [],
  setup(_props) {
    const props = useProps("timeline", _props, {
      pending: false,
      bothSides: false,
      dashed: false,
      lineColor: null,
      spacing: null,
      flip: false,
      horizontal: false
    });
    const nh = useNameHelper("timeline");
    const itemStates = reactive(/* @__PURE__ */ new Set());
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("pending")]: props.pending,
        [nh.bm("both-sides")]: props.bothSides,
        [nh.bm("flip")]: props.flip,
        [nh.bm("horizontal")]: props.horizontal
      };
    });
    const height = computed(() => {
      return Math.max(...Array.from(itemStates).map((state2) => state2.height)) * 2;
    });
    const refreshLabels = Mr(() => {
      const total = itemStates.size;
      Array.from(itemStates).forEach((item, index) => {
        item.index = index + 1;
        item.total = total;
        if (qe(item.label)) {
          item.label = index + 1;
        }
      });
    });
    const state = reactive({
      dashed: toRef(props, "dashed"),
      lineColor: toRef(props, "lineColor"),
      spacing: toRef(props, "spacing"),
      bothSides: toRef(props, "bothSides"),
      horizontal: toRef(props, "horizontal"),
      increaseItem,
      decreaseItem,
      handleSignalClick
    });
    provide(TIMELINE_STATE, state);
    function increaseItem(item) {
      itemStates.add(item);
      refreshLabels();
    }
    function decreaseItem(item) {
      itemStates.delete(item);
      refreshLabels();
    }
    function handleSignalClick(label) {
      emitEvent(props.onSignalClick, label);
    }
    return {
      nh,
      props,
      className,
      height,
      itemStates
    };
  }
});
function _sfc_render85(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    style: normalizeStyle({ height: _ctx.props.horizontal && _ctx.props.bothSides ? `${_ctx.height}px` : void 0 })
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var Timeline = _export_sfc(_sfc_main85, [["render", _sfc_render85]]);

// node_modules/vexip-ui/es/components/timeline/timeline-item.mjs
var timelineItemTypes = Object.freeze([
  "default",
  "success",
  "error",
  "warning",
  "disabled"
]);
var _sfc_main86 = defineComponent({
  name: "TimelineItem",
  props: timelineItemProps,
  emits: [],
  setup(_props) {
    const props = useProps("timelineItem", _props, {
      type: {
        default: "default",
        validator: (value) => timelineItemTypes.includes(value)
      },
      color: "",
      label: {
        default: null,
        static: true
      },
      dashed: null,
      lineColor: null,
      spacing: null
    });
    const timelineState = inject(TIMELINE_STATE, null);
    const nh = useNameHelper("timeline");
    const currentLabel = ref(props.label);
    const content = ref();
    const className = computed(() => {
      return {
        [nh.be("item")]: true,
        [nh.bem("item", props.type)]: props.type !== "default"
      };
    });
    const itemStyle = computed(() => {
      const spacing = props.spacing || props.spacing === 0 ? props.spacing : timelineState == null ? void 0 : timelineState.spacing;
      const style = {
        [nh.cv("item-span")]: typeof spacing === "number" ? `${spacing}px` : spacing
      };
      if (props.color) {
        style[nh.cv("pointer-color")] = props.color;
        style[nh.cv("pointer-b-color")] = props.color;
      }
      return style;
    });
    const lineStyle = computed(() => {
      var _a, _b, _c;
      const isDashed = (_b = (_a = props.dashed) != null ? _a : timelineState == null ? void 0 : timelineState.dashed) != null ? _b : false;
      const color = (_c = props.lineColor) != null ? _c : timelineState == null ? void 0 : timelineState.lineColor;
      return {
        borderLeftStyle: isDashed ? "dashed" : void 0,
        borderLeftColor: color
      };
    });
    if (timelineState) {
      let updateHeight = function() {
        requestAnimationFrame(() => {
          if ((timelineState == null ? void 0 : timelineState.horizontal) && content.value) {
            state.height = content.value.scrollHeight;
          }
        });
      };
      const state = reactive({
        label: currentLabel,
        index: 0,
        total: 0,
        height: 0
      });
      timelineState.increaseItem(state);
      watch(() => timelineState.bothSides, updateHeight);
      watch(() => timelineState.horizontal, updateHeight);
      onMounted(updateHeight);
      onUpdated(updateHeight);
      onBeforeUnmount(() => {
        timelineState.decreaseItem(state);
      });
    }
    function handleSignalClick() {
      emitEvent(props.onSignalClick, currentLabel.value);
      timelineState == null ? void 0 : timelineState.handleSignalClick(currentLabel.value);
    }
    return {
      nh,
      className,
      itemStyle,
      lineStyle,
      content,
      handleSignalClick
    };
  }
});
function _sfc_render86(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.itemStyle)
  }, [
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("signal")),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleSignalClick && _ctx.handleSignalClick(...args))
    }, [
      renderSlot(_ctx.$slots, "signal", {}, () => [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("pointer"))
        }, null, 2)
      ])
    ], 2),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.nh.be("line")),
      style: normalizeStyle(_ctx.lineStyle)
    }, null, 6),
    createBaseVNode("div", {
      ref: "content",
      class: normalizeClass(_ctx.nh.be("content"))
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2)
  ], 6);
}
var TimelineItem = _export_sfc(_sfc_main86, [["render", _sfc_render86]]);

// node_modules/vexip-ui/es/components/toast/props.mjs
var toastProps = buildProps({
  bodyWidth: Number,
  icon: [Object, Function],
  iconProps: Object,
  position: String,
  transitionName: String,
  closable: booleanProp,
  maskClose: booleanProp,
  showMask: booleanProp,
  maskClass: classProp,
  maskStyle: styleProp,
  parseHtml: booleanProp,
  renderer: Function
});

// node_modules/vexip-ui/es/components/toast/toast.mjs
var _sfc_main87 = defineComponent({
  name: "Toast",
  components: {
    Icon,
    Renderer
  },
  props: toastProps,
  emits: [],
  setup(_props) {
    const nh = useNameHelper("toast");
    const props = useProps("toast", _props, {
      bodyWidth: 100,
      icon: null,
      iconProps: () => ({}),
      position: "center",
      transitionName: () => nh.ns("ease"),
      closable: false,
      maskClose: false,
      showMask: false,
      maskClass: null,
      maskStyle: null,
      renderer: {
        default: null,
        isFunc: true,
        static: true
      },
      parseHtml: false
    });
    const state = reactive({
      visible: false,
      zIndex: 0,
      content: "",
      icon: props.icon,
      iconProps: props.iconProps,
      position: props.position,
      transition: props.transitionName,
      closable: props.closable,
      maskClose: props.maskClose,
      showMask: props.showMask,
      maskClass: props.maskClass,
      maskStyle: props.maskStyle,
      parseHtml: props.parseHtml,
      textOnly: false,
      renderer: props.renderer,
      onClose: null
    });
    const mounted = new Promise((resolve) => {
      onMounted(() => {
        nextTick(resolve);
      });
    });
    async function openToast(options) {
      var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k;
      state.zIndex = useZIndex().value;
      await mounted;
      state.content = (_a = options.content) != null ? _a : "";
      state.icon = (_b = options.icon) != null ? _b : props.icon;
      state.iconProps = (_c = options.iconProps) != null ? _c : props.iconProps;
      state.position = (_d = options.position) != null ? _d : props.position;
      state.transition = (_e2 = options.transitionName) != null ? _e2 : props.transitionName;
      state.closable = (_f = options.closable) != null ? _f : props.closable;
      state.maskClose = (_g = options.maskClose) != null ? _g : props.maskClose;
      state.showMask = (_h = options.showMask) != null ? _h : props.showMask;
      state.maskClass = (_i = options.maskClass) != null ? _i : props.maskClass;
      state.maskStyle = (_j = options.maskStyle) != null ? _j : props.maskStyle;
      state.parseHtml = (_k = options.parseHtml) != null ? _k : props.parseHtml;
      state.renderer = gt(options.renderer) ? options.renderer : props.renderer;
      state.onClose = options.onClose || null;
      state.textOnly = !state.icon;
      if (gt(state.renderer)) {
        const render2 = state.renderer;
        state.renderer = () => render2(options);
        state.textOnly = false;
      }
      state.visible = true;
    }
    function cloasToast() {
      state.visible = false;
      if (gt(state.onClose)) {
        state.onClose();
      }
    }
    function handleReset() {
      if (state.visible)
        return;
      state.content = "";
      state.icon = props.icon;
      state.iconProps = props.iconProps;
      state.position = props.position;
      state.transition = props.transitionName;
      state.closable = props.closable;
      state.maskClose = props.maskClose;
      state.showMask = props.showMask;
      state.maskClass = props.maskClass;
      state.maskStyle = props.maskStyle;
      state.parseHtml = props.parseHtml;
      state.textOnly = false;
      state.renderer = props.renderer;
      state.onClose = null;
    }
    function handleWrapperClick() {
      if (state.visible && state.closable) {
        cloasToast();
      }
    }
    function handleMaskClick() {
      if (state.visible && state.maskClose) {
        cloasToast();
      }
    }
    return {
      props,
      nh,
      state,
      isFunction: gt,
      openToast,
      cloasToast,
      handleReset,
      handleWrapperClick,
      handleMaskClick
    };
  }
});
var _hoisted_147 = ["innerHTML"];
function _sfc_render87(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass({
      [_ctx.nh.b()]: true,
      [_ctx.nh.bs("vars")]: true,
      [_ctx.nh.bm("text-only")]: _ctx.state.textOnly
    }),
    style: normalizeStyle({
      zIndex: _ctx.state.zIndex
    })
  }, [
    createVNode(Transition, {
      name: _ctx.nh.ns("fade")
    }, {
      default: withCtx(() => [
        _ctx.state.showMask && _ctx.state.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([_ctx.nh.be("mask"), _ctx.state.maskClass]),
          style: normalizeStyle(_ctx.state.maskStyle),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMaskClick && _ctx.handleMaskClick(...args))
        }, null, 6)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["name"]),
    createVNode(Transition, {
      name: _ctx.state.transition
    }, {
      default: withCtx(() => [
        _ctx.state.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass({
            [_ctx.nh.be("wrapper")]: true,
            [_ctx.nh.bem("wrapper", _ctx.state.position)]: _ctx.state.position !== "center",
            [_ctx.nh.bem("wrapper", "closable")]: _ctx.state.closable
          }),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleWrapperClick && _ctx.handleWrapperClick(...args))
        }, [
          _ctx.isFunction(_ctx.state.renderer) ? (openBlock(), createBlock(_component_Renderer, {
            key: 0,
            renderer: _ctx.state.renderer
          }, null, 8, ["renderer"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            _ctx.state.icon ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("icon"))
            }, [
              _ctx.isFunction(_ctx.icon) ? (openBlock(), createBlock(_component_Renderer, {
                key: 0,
                renderer: _ctx.icon
              }, null, 8, ["renderer"])) : (openBlock(), createBlock(_component_Icon, mergeProps({
                key: 1,
                icon: _ctx.state.icon,
                scale: 1.8
              }, _ctx.state.iconProps), null, 16, ["icon", "scale"]))
            ], 2)) : createCommentVNode("", true),
            _ctx.state.parseHtml ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(_ctx.nh.be("content")),
              innerHTML: _ctx.state.content
            }, null, 10, _hoisted_147)) : (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.nh.be("content"))
            }, toDisplayString(_ctx.state.content), 3))
          ], 64))
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["name"])
  ], 6);
}
var Component6 = _export_sfc(_sfc_main87, [["render", _sfc_render87]]);

// node_modules/vexip-ui/es/components/toast/index.mjs
var conveniences3 = {
  success: {
    icon: x
  },
  warning: {
    icon: $20
  },
  error: {
    icon: L2
  },
  loading: {
    icon: h4,
    showMask: true,
    iconProps: {
      pulse: true
    }
  }
};
var ToastManager = class {
  constructor(options = {}) {
    options = {
      ...options,
      duration: options.duration ? En(options.duration) : 2e3
    };
    this._mountedApp = null;
    this._instance = null;
    this._container = null;
    this._timer = null;
    this.name = "Toast";
    this.defaults = {};
    this.config(options);
    this.open = (content, duration) => {
      return this._open(null, content, duration);
    };
    this.success = (content, duration) => {
      return this._open("success", content, duration);
    };
    this.warning = (content, duration) => {
      return this._open("warning", content, duration);
    };
    this.error = (content, duration) => {
      return this._open("error", content, duration);
    };
    this.loading = (content, duration) => {
      return this._open("loading", content, duration);
    };
  }
  close() {
    var _a;
    this._timer && clearTimeout(this._timer);
    (_a = this._getInstance()) == null ? void 0 : _a.cloasToast();
  }
  config(options) {
    this.defaults = { ...this.defaults, ...options };
  }
  clone() {
    return new ToastManager(this.defaults);
  }
  destroy() {
    this._container && render(null, this._container);
    Jn(this);
  }
  isDestroyed() {
    return false;
  }
  install(app, options = {}) {
    const { property, ...others } = options;
    this.config(others);
    app.config.globalProperties[property || "$toast"] = this;
    this._mountedApp = app;
  }
  _getInstance() {
    if (!this._mountedApp) {
      console.warn("[vexip-ui:Toast]: App missing, the plugin maybe not installed.");
      return null;
    }
    if (!this._instance) {
      const vnode = createVNode(Component6, null, null);
      this._container = document.createElement("div");
      vnode.appContext = this._mountedApp._context;
      render(vnode, this._container, false);
      document.body.appendChild(this._container.firstElementChild);
      this._instance = vnode.component.proxy;
    }
    return this._instance;
  }
  _open(type, content, _duration) {
    var _a;
    if (!V) {
      return cn;
    }
    this._timer && clearTimeout(this._timer);
    const options = typeof content === "string" ? { content, duration: _duration } : content;
    const convenienceOptions = type ? (_a = conveniences3[type]) != null ? _a : {} : {};
    const userCloseFn = options.onClose;
    const onClose = () => {
      this._timer && clearTimeout(this._timer);
      if (typeof userCloseFn === "function") {
        return userCloseFn();
      }
    };
    const toast = this._getInstance();
    const item = { ...this.defaults, ...convenienceOptions, ...options, onClose };
    if (item.icon && typeof item.icon !== "function") {
      item.icon = markRaw(item.icon);
    }
    toast == null ? void 0 : toast.openToast(item);
    const duration = typeof item.duration === "number" ? item.duration : 2e3;
    if (duration >= 500) {
      this._timer = setTimeout(() => {
        toast == null ? void 0 : toast.cloasToast();
      }, duration);
    }
    return () => {
      this._timer && clearTimeout(this._timer);
      toast == null ? void 0 : toast.cloasToast();
    };
  }
};
var Toast = new ToastManager();

// node_modules/vexip-ui/es/components/transfer/transfer-panel.vue_vue_type_script_lang.mjs
var _sfc_main88 = defineComponent({
  name: "TransferPanel",
  components: {
    Checkbox,
    CollapseTransition,
    Icon,
    Input,
    NumberInput,
    Renderer,
    ResizeObserver,
    VirtualList,
    Retweet: x12,
    ChevronRight: $17,
    ChevronLeft: $16
  },
  props: {
    type: {
      type: String,
      default: null
    },
    state: {
      type: stateProp,
      default: "default"
    },
    selected: {
      type: Set,
      default: () => /* @__PURE__ */ new Set()
    },
    paged: {
      type: Boolean,
      default: false
    },
    filter: {
      type: Function,
      default: null
    },
    disabled: {
      type: Boolean,
      default: false
    },
    title: {
      type: String,
      default: ""
    },
    options: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String,
      default: "\u6682\u65E0\u6570\u636E"
    },
    optionHeight: {
      type: Number,
      default: 32
    },
    deepState: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    loadingIcon: {
      type: Object,
      default: null
    },
    loadingLock: {
      type: Boolean,
      default: false
    },
    loadingSpin: {
      type: Boolean,
      default: false
    }
  },
  emits: ["update:selected", "select", "enter", "switch"],
  setup(props, {
    slots,
    emit
  }) {
    const nh = useNameHelper("transfer");
    const locale = useLocale("transfer");
    const currentSelected = ref(new Set(props.selected));
    const pageSize = ref(10);
    const currentPage = ref(1);
    const currentMark = ref(null);
    const currentHitting = ref(-1);
    const currentFilter = ref("");
    const searching = ref(false);
    const header = ref();
    const body = ref();
    const footer = ref();
    const search = ref();
    const input = ref();
    const list = ref();
    let bodyRealHeight = 0;
    let lastSelected = null;
    let keyUsed = false;
    const {
      target: wrapper,
      modifier
    } = No({
      passive: false,
      onKeyDown: (event, modifier2) => {
        if (modifier2.up || modifier2.down) {
          if (!keyUsed && currentHitting.value < 0) {
            keyUsed = true;
            if (lastSelected) {
              currentHitting.value = props.options.findIndex((option) => option.value === lastSelected);
            } else if (list.value) {
              currentHitting.value = Math.round(list.value.scrollOffset / props.optionHeight);
            }
            currentHitting.value = currentHitting.value === -1 ? 0 : currentHitting.value;
          } else {
            currentHitting.value = Fn(findEnabledIndex(currentHitting.value + (modifier2.up ? -1 : 1), modifier2.up ? -1 : 1), 0, currentOptions.value.length - 1);
          }
          if (!props.paged) {
            ensureOptionInView(currentHitting.value, modifier2.up ? "top" : "bottom");
          }
          event.preventDefault();
        } else if (props.paged && (modifier2.left || modifier2.right) && event.ctrlKey) {
          handlePageChange(currentPage.value + (modifier2.left ? -1 : 1));
          currentHitting.value = 0;
          event.preventDefault();
        } else if (props.type === "source" && modifier2.right || props.type === "target" && modifier2.left) {
          keyUsed = false;
          currentHitting.value = -1;
          lastSelected = null;
          emit("switch");
          event.preventDefault();
        } else if (modifier2.space) {
          const option = currentOptions.value[currentHitting.value];
          if (option) {
            currentSelected.value[currentSelected.value.has(option.value) ? "delete" : "add"](option.value);
            emitSelectedChange();
          }
          event.preventDefault();
        } else if (modifier2.enter) {
          event.preventDefault();
          emit("enter");
          event.preventDefault();
        } else if (typeof props.filter === "function" && input.value && modifier2["ctrl+f"]) {
          event.preventDefault();
          event.stopPropagation();
          input.value.focus();
          event.preventDefault();
        }
      }
    });
    const className = computed(() => {
      return {
        [nh.be("panel")]: true,
        [nh.bem("panel", props.state)]: props.state !== "default",
        [nh.bem("panel", "disabled")]: props.disabled
      };
    });
    const visibleOptions = computed(() => {
      const filter = props.filter;
      const filterValue = currentFilter.value;
      if (filter && filterValue) {
        return props.options.filter((option) => filter(filterValue, option));
      }
      return props.options;
    });
    const optionSize = computed(() => visibleOptions.value.length);
    const pagedOptions = computed(() => {
      return visibleOptions.value.slice((currentPage.value - 1) * pageSize.value, currentPage.value * pageSize.value);
    });
    const currentOptions = computed(() => props.paged ? pagedOptions.value : visibleOptions.value);
    const totalPages = computed(() => Math.ceil(optionSize.value / (pageSize.value || 1)));
    watch(() => props.selected, (value) => {
      currentSelected.value = value;
    });
    watch(optionSize, () => {
      keyUsed = false;
      currentHitting.value = -1;
      lastSelected = null;
    });
    const partial = ref(false);
    const allSelected = ref(false);
    watchEffect(() => {
      const options = visibleOptions.value;
      const selected = currentSelected.value;
      let hasSelected = false;
      let hasUnselected = false;
      for (let i = 0, len = optionSize.value; i < len; ++i) {
        const option = options[i];
        if (!option.disabled) {
          if (selected.has(option.value)) {
            hasSelected = true;
          } else {
            hasUnselected = true;
          }
        }
        if (hasSelected && hasUnselected) {
          break;
        }
      }
      allSelected.value = hasSelected && !hasUnselected;
      partial.value = !allSelected.value && selected.size > 0;
    });
    function computePageSize() {
      requestAnimationFrame(() => {
        var _a;
        const bodyEl = body.value || ((_a = list.value) == null ? void 0 : _a.wrapper);
        if (bodyEl) {
          const style = getComputedStyle(bodyEl);
          const paddingTop = parseInt(style.paddingTop);
          const paddingBottom = parseInt(style.paddingBottom);
          const innerHeight = bodyEl.offsetHeight - paddingTop - paddingBottom;
          bodyRealHeight = innerHeight;
          pageSize.value = Math.floor(innerHeight / (props.optionHeight || 1));
        }
      });
    }
    function toggleSelect(option) {
      if (props.disabled || option.disabled)
        return;
      if (currentMark.value && modifier.shift) {
        handleRangeSelect(currentMark.value, option.value);
        return;
      }
      if (currentSelected.value.has(option.value)) {
        currentSelected.value.delete(option.value);
      } else {
        currentSelected.value.add(option.value);
      }
      keyUsed = false;
      currentHitting.value = -1;
      lastSelected = option.value;
      currentMark.value = option.value;
      emitSelectedChange();
    }
    function handleRangeSelect(start, end) {
      var _a;
      const options = visibleOptions.value;
      let startIndex = -1;
      let endIndex = -1;
      for (let i = 0, len = options.length; i < len; ++i) {
        const option = options[i];
        if (option.value === start) {
          startIndex = i;
        } else if (option.value === end) {
          endIndex = i;
        }
        if (startIndex > 0 && endIndex > 0)
          break;
      }
      const method = currentSelected.value.has((_a = options[startIndex]) == null ? void 0 : _a.value) ? "add" : "delete";
      if (startIndex > endIndex) {
        [startIndex, endIndex] = [endIndex, startIndex];
      }
      for (let i = startIndex; i <= endIndex; ++i) {
        const option = options[i];
        if (!option.disabled) {
          currentSelected.value[method](option.value);
        }
      }
      emitSelectedChange();
    }
    function toggleSelectAll() {
      if (props.disabled)
        return;
      if (allSelected.value) {
        for (const option of visibleOptions.value) {
          !option.disabled && currentSelected.value.delete(option.value);
        }
      } else {
        for (const option of visibleOptions.value) {
          !option.disabled && currentSelected.value.add(option.value);
        }
      }
      currentMark.value = null;
      emitSelectedChange();
    }
    function handleReverse() {
      if (props.disabled)
        return;
      if (partial.value) {
        const prevSelected = new Set(currentSelected.value);
        for (const option of visibleOptions.value) {
          if (!option.disabled) {
            if (prevSelected.has(option.value)) {
              currentSelected.value.delete(option.value);
            } else {
              currentSelected.value.add(option.value);
            }
          }
        }
        currentMark.value = null;
        emitSelectedChange();
      } else {
        toggleSelectAll();
      }
    }
    function handleBlur() {
      currentMark.value = null;
      modifier.resetAll();
    }
    function emitSelectedChange() {
      emit("update:selected", currentSelected.value);
      emit("select");
    }
    function handlePageChange(page) {
      currentPage.value = Fn(page, 1, totalPages.value);
    }
    function queryEnabledIndex(index, step) {
      var _a;
      const options = currentOptions.value;
      step = step / Math.abs(step);
      while ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index += step;
        if (index < 0 || index >= options.length)
          break;
      }
      return index;
    }
    function findEnabledIndex(index, sign = 1) {
      var _a;
      const options = currentOptions.value;
      if ((_a = options[index]) == null ? void 0 : _a.disabled) {
        index = queryEnabledIndex(index, sign);
        if (sign > 0 ? index >= options.length : index < 0) {
          index = queryEnabledIndex(index, -sign);
          if (sign > 0 ? index < 0 : index >= options.length)
            index = -1;
        }
      }
      return index;
    }
    function ensureOptionInView(index, direction) {
      const option = props.options[index];
      if (props.paged || !option || !list.value)
        return;
      if (direction === "bottom") {
        const target = (index + 1) * props.optionHeight;
        if (list.value.scrollOffset + bodyRealHeight < target) {
          list.value.scrollTo((index - pageSize.value + 1) * props.optionHeight);
        }
      } else {
        const target = index * props.optionHeight;
        if (list.value.scrollOffset > target) {
          list.value.scrollTo(target);
        }
      }
    }
    function getSlotPayload() {
      return {
        type: props.type,
        currentPage: currentPage.value,
        pageSize: pageSize.value,
        totalPages: totalPages.value,
        allSelected: allSelected.value,
        partial: partial.value,
        selected: Array.from(currentSelected.value),
        options: visibleOptions.value,
        toggleSelectAll,
        handleReverse
      };
    }
    function renderOption({
      option,
      index
    }) {
      const disabled = props.disabled || option.disabled;
      const handleCheck = (event) => {
        event.preventDefault();
        event.stopPropagation();
        toggleSelect(option);
      };
      return createVNode("li", {
        "class": {
          [nh.be("option")]: true,
          [nh.bem("option", "disabled")]: disabled,
          [nh.bem("option", "hitting")]: currentHitting.value === index
        },
        "role": "option",
        "aria-disabled": disabled ? "true" : void 0,
        "onClick": () => toggleSelect(option)
      }, [slots.option ? slots.option({
        type: props.type,
        option,
        index
      }) : [createVNode(Checkbox, {
        "class": nh.be("checkbox"),
        "state": props.deepState ? props.state : void 0,
        "checked": currentSelected.value.has(option.value),
        "disabled": disabled,
        "tab-index": -1,
        "onClick": handleCheck
      }, null), createVNode("span", {
        "class": nh.be("label")
      }, [slots.label ? slots.label({
        option,
        index
      }) : option.label])]]);
    }
    return {
      MagnifyingGlass: $21,
      nh,
      locale,
      currentSelected,
      pageSize,
      currentPage,
      currentMark,
      currentFilter,
      searching,
      className,
      visibleOptions,
      partial,
      allSelected,
      pagedOptions,
      totalPages,
      wrapper,
      header,
      body,
      footer,
      search,
      input,
      list,
      computePageSize,
      toggleSelect,
      toggleSelectAll,
      handleReverse,
      handlePageChange,
      handleBlur,
      getSlotPayload,
      renderOption
    };
  }
});

// node_modules/vexip-ui/es/components/transfer/transfer-panel.mjs
var _hoisted_148 = ["title"];
var _hoisted_221 = createBaseVNode("span", { style: { "margin": "0 4px" } }, "/", -1);
function _sfc_render88(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Retweet = resolveComponent("Retweet");
  const _component_Icon = resolveComponent("Icon");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  const _component_Input = resolveComponent("Input");
  const _component_Renderer = resolveComponent("Renderer");
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_VirtualList = resolveComponent("VirtualList");
  const _component_ChevronLeft = resolveComponent("ChevronLeft");
  const _component_NumberInput = resolveComponent("NumberInput");
  const _component_ChevronRight = resolveComponent("ChevronRight");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    tabindex: "0",
    onBlur: _cache[8] || (_cache[8] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
  }, [
    createBaseVNode("div", {
      ref: "header",
      class: normalizeClass(_ctx.nh.be("header"))
    }, [
      renderSlot(_ctx.$slots, "header", normalizeProps(guardReactiveProps(_ctx.getSlotPayload())), () => [
        createVNode(_component_Checkbox, {
          inherit: "",
          control: "",
          class: normalizeClass(_ctx.nh.be("checkbox")),
          state: _ctx.deepState ? _ctx.state : void 0,
          checked: _ctx.allSelected,
          partial: _ctx.partial,
          disabled: _ctx.disabled,
          "tab-index": -1,
          onClick: withModifiers(_ctx.toggleSelectAll, ["prevent"])
        }, null, 8, ["class", "state", "checked", "partial", "disabled", "onClick"]),
        createBaseVNode("div", {
          class: normalizeClass([_ctx.nh.be("reverse"), _ctx.disabled && _ctx.nh.bem("reverse", "disabled")]),
          title: _ctx.locale.reverse,
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleReverse && _ctx.handleReverse(...args))
        }, [
          createVNode(_component_Icon, { scale: 1.2 }, {
            default: withCtx(() => [
              createVNode(_component_Retweet)
            ]),
            _: 1
          }, 8, ["scale"])
        ], 10, _hoisted_148),
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("counter"))
        }, toDisplayString(`${_ctx.currentSelected.size}/${_ctx.visibleOptions.length}`), 3),
        _ctx.title || _ctx.$slots.title ? (openBlock(), createElementBlock("span", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("title"))
        }, [
          renderSlot(_ctx.$slots, "title", normalizeProps(guardReactiveProps(_ctx.getSlotPayload())), () => [
            createTextVNode(toDisplayString(_ctx.title), 1)
          ])
        ], 2)) : createCommentVNode("", true),
        createVNode(_component_CollapseTransition, {
          appear: "",
          horizontal: "",
          "fade-effect": ""
        }, {
          default: withCtx(() => [
            _ctx.loading ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("loading"))
            }, [
              createVNode(_component_Icon, {
                spin: _ctx.loadingSpin,
                pulse: !_ctx.loadingSpin,
                icon: _ctx.loadingIcon
              }, null, 8, ["spin", "pulse", "icon"])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 1
        })
      ])
    ], 2),
    typeof _ctx.filter === "function" ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: "search",
      class: normalizeClass(_ctx.nh.be("filter"))
    }, [
      createVNode(_component_Input, {
        ref: "input",
        value: _ctx.currentFilter,
        "onUpdate:value": _cache[1] || (_cache[1] = ($event) => _ctx.currentFilter = $event),
        inherit: "",
        clearable: "",
        disabled: _ctx.disabled,
        suffix: _ctx.MagnifyingGlass,
        placeholder: _ctx.searching ? void 0 : _ctx.locale.search,
        onKeydown: _cache[2] || (_cache[2] = withModifiers(() => {
        }, ["stop"])),
        onInput: _cache[3] || (_cache[3] = ($event) => _ctx.currentFilter = $event),
        onFocus: _cache[4] || (_cache[4] = ($event) => _ctx.searching = true),
        onBlur: _cache[5] || (_cache[5] = ($event) => _ctx.searching = false)
      }, null, 8, ["value", "disabled", "suffix", "placeholder"])
    ], 2)) : createCommentVNode("", true),
    _ctx.paged || _ctx.$slots.body ? (openBlock(), createBlock(_component_ResizeObserver, {
      key: 1,
      throttle: "",
      onResize: _ctx.computePageSize
    }, {
      default: withCtx(() => [
        createBaseVNode("ul", {
          ref: "body",
          class: normalizeClass(_ctx.nh.be("body")),
          role: "listbox"
        }, [
          renderSlot(_ctx.$slots, "body", normalizeProps(guardReactiveProps(_ctx.getSlotPayload())), () => [
            _ctx.pagedOptions.length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.pagedOptions, (option, index) => {
              return openBlock(), createBlock(_component_Renderer, {
                key: index,
                renderer: _ctx.renderOption,
                data: { option, index }
              }, null, 8, ["renderer", "data"]);
            }), 128)) : (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(_ctx.nh.be("empty"))
            }, toDisplayString(_ctx.emptyText || _ctx.locale.empty), 3))
          ])
        ], 2)
      ]),
      _: 3
    }, 8, ["onResize"])) : (openBlock(), createBlock(_component_VirtualList, {
      key: 2,
      ref: "list",
      inherit: "",
      class: normalizeClass(_ctx.nh.be("body")),
      items: _ctx.visibleOptions,
      "item-size": _ctx.optionHeight,
      "item-fixed": "",
      "use-y-bar": "",
      "id-key": "value",
      "items-attrs": { role: "listbox", ariaLabel: _ctx.type },
      onResize: _ctx.computePageSize
    }, {
      default: withCtx(({ item: option, index }) => [
        createVNode(_component_Renderer, {
          renderer: _ctx.renderOption,
          data: { option, index }
        }, null, 8, ["renderer", "data"])
      ]),
      empty: withCtx(() => [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("empty"))
        }, toDisplayString(_ctx.emptyText || _ctx.locale.empty), 3)
      ]),
      _: 1
    }, 8, ["class", "items", "item-size", "items-attrs", "onResize"])),
    _ctx.paged || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
      key: 3,
      ref: "footer",
      class: normalizeClass(_ctx.nh.be("footer"))
    }, [
      renderSlot(_ctx.$slots, "footer", normalizeProps(guardReactiveProps(_ctx.getSlotPayload())), () => [
        createBaseVNode("div", {
          class: normalizeClass(_ctx.nh.be("pagination"))
        }, [
          createVNode(_component_Icon, {
            class: normalizeClass([_ctx.nh.be("page-plus"), _ctx.currentPage <= 1 && _ctx.nh.bem("page-plus", "disabled")]),
            onClick: _cache[6] || (_cache[6] = ($event) => _ctx.handlePageChange(_ctx.currentPage - 1))
          }, {
            default: withCtx(() => [
              createVNode(_component_ChevronLeft)
            ]),
            _: 1
          }, 8, ["class"]),
          createVNode(_component_NumberInput, {
            inherit: "",
            value: _ctx.currentPage,
            class: normalizeClass(_ctx.nh.be("page-input")),
            size: "small",
            min: 1,
            max: _ctx.totalPages,
            onChange: _ctx.handlePageChange
          }, null, 8, ["value", "class", "max", "onChange"]),
          _hoisted_221,
          createBaseVNode("span", null, toDisplayString(_ctx.totalPages), 1),
          createVNode(_component_Icon, {
            class: normalizeClass([
              _ctx.nh.be("page-minus"),
              _ctx.currentPage >= _ctx.totalPages && _ctx.nh.bem("page-minus", "disabled")
            ]),
            onClick: _cache[7] || (_cache[7] = ($event) => _ctx.handlePageChange(_ctx.currentPage + 1))
          }, {
            default: withCtx(() => [
              createVNode(_component_ChevronRight)
            ]),
            _: 1
          }, 8, ["class"])
        ], 2)
      ])
    ], 2)) : createCommentVNode("", true)
  ], 34);
}
var TransferPanel = _export_sfc(_sfc_main88, [["render", _sfc_render88]]);

// node_modules/vexip-ui/es/components/transfer/props.mjs
var transferProps = buildProps({
  state: stateProp,
  options: Array,
  value: Array,
  disabled: booleanProp,
  paged: booleanProp,
  filter: {
    type: [Boolean, Function],
    default: null
  },
  emptyText: String,
  keyConfig: Object,
  optionHeight: Number,
  ignoreCase: booleanProp,
  sourceTitle: String,
  targetTitle: String,
  deepState: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  onChange: eventProp(),
  onSelect: eventProp()
});

// node_modules/vexip-ui/es/components/transfer/transfer.mjs
var defaultKeyConfig3 = {
  value: "value",
  label: "label",
  disabled: "disabled"
};
var Transfer = defineComponent({
  name: "Transfer",
  components: {
    Button,
    TransferPanel
  },
  props: transferProps,
  emits: ["update:value"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      validateField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a, _b;
      return (_b = (_a = source.value) == null ? void 0 : _a.$el) == null ? void 0 : _b.focus();
    });
    const props = useProps("transfer", _props, {
      state: createStateProp(state),
      options: {
        default: () => [],
        static: true
      },
      value: {
        default: () => getFieldValue([]),
        static: true
      },
      disabled: () => disabled.value,
      paged: false,
      filter: false,
      emptyText: null,
      keyConfig: () => ({}),
      optionHeight: {
        default: 32,
        validator: (value) => value > 0
      },
      ignoreCase: false,
      sourceTitle: null,
      targetTitle: null,
      deepState: false,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false
    });
    const nh = useNameHelper("transfer");
    const locale = useLocale("transfer");
    const currentValue = ref(null);
    const sourceSelected = ref(/* @__PURE__ */ new Set());
    const targetSelected = ref(/* @__PURE__ */ new Set());
    const sourceOptions = ref([]);
    const targetOptions = ref([]);
    const optionStates = ref([]);
    const source = ref();
    const target = ref();
    const keyConfig = computed(() => ({
      ...defaultKeyConfig3,
      ...props.keyConfig
    }));
    let optionValueMap = /* @__PURE__ */ new Map();
    let emittedValue = props.value;
    const updateTrigger = ref(0);
    watchEffect(() => {
      props.keyConfig.value;
      props.keyConfig.label;
      props.keyConfig.disabled;
      props.options;
      updateTrigger.value++;
    });
    watch(updateTrigger, initOptions, {
      immediate: true
    });
    watchEffect(() => {
      if (!currentValue.value.size) {
        sourceOptions.value = Array.from(optionStates.value);
        targetOptions.value = [];
        return;
      }
      const selectedValues = new Set(currentValue.value);
      const target2 = [];
      const source2 = [];
      for (const option of optionStates.value) {
        if (selectedValues.has(option.value)) {
          target2.push(option);
        } else {
          source2.push(option);
        }
      }
      targetOptions.value = target2;
      sourceOptions.value = source2;
    });
    function initOptions() {
      const {
        value: valueKey,
        label: labelKey,
        disabled: disabledKey
      } = keyConfig.value;
      const oldMap = optionValueMap;
      const map = /* @__PURE__ */ new Map();
      props.options.forEach((option) => {
        var _a, _b;
        const rawOption = typeof option === "string" ? {
          [valueKey]: option
        } : option;
        const value = rawOption[valueKey];
        if (qe(value))
          return;
        const label = rawOption[labelKey] || String(value);
        const {
          [disabledKey]: disabled2 = false
        } = rawOption;
        const oldState = oldMap.get(rawOption.value);
        const optionState = reactive({
          disabled: disabled2,
          value,
          label,
          hidden: (_a = oldState == null ? void 0 : oldState.hidden) != null ? _a : false,
          hitting: (_b = oldState == null ? void 0 : oldState.hitting) != null ? _b : false,
          data: option
        });
        map.set(value, optionState);
      });
      optionValueMap = map;
      optionStates.value = Array.from(map.values());
      currentValue.value = new Set(emittedValue);
    }
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.state)]: props.state !== "default"
      }];
    });
    const actionType = computed(() => {
      return props.deepState && props.state !== "default" ? props.state : "primary";
    });
    const toTargetEnabled = computed(() => !!sourceSelected.value.size);
    const toSourceEnabled = computed(() => !!targetSelected.value.size);
    const defaultFilter = computed(() => {
      return props.ignoreCase ? (value, option) => String(option.value).toLocaleLowerCase().includes(value) : (value, option) => String(option.value).includes(value);
    });
    const sourceFilter = computed(() => getFilterMethod("source"));
    const targetFilter = computed(() => getFilterMethod("target"));
    watch(() => props.value, (value) => {
      emittedValue = value;
      currentValue.value = new Set(emittedValue);
    });
    expose({
      handleToTarget,
      handleToSource,
      handlePanelFocus,
      handlePanelBlur
    });
    function getFilterMethod(type) {
      const filter = props.filter;
      if (!filter)
        return void 0;
      if (typeof filter === "function") {
        return (value, option) => filter(value, option, type);
      }
      return defaultFilter.value;
    }
    function handleChange() {
      emittedValue = Array.from(currentValue.value);
      setFieldValue(emittedValue);
      emitEvent(props.onChange, emittedValue);
      emit("update:value", emittedValue);
      validateField();
    }
    function handleToTarget() {
      for (const value of sourceSelected.value) {
        currentValue.value.add(value);
      }
      sourceSelected.value.clear();
      handleChange();
    }
    function handleToSource() {
      for (const value of targetSelected.value) {
        currentValue.value.delete(value);
      }
      targetSelected.value.clear();
      handleChange();
    }
    function handleSelect(type) {
      const selected = {
        source: Array.from(sourceSelected.value),
        target: Array.from(targetSelected.value)
      };
      const data = {
        source: selected.source.map((value) => {
          var _a, _b;
          return (_b = (_a = optionValueMap.get(value)) == null ? void 0 : _a.data) != null ? _b : "";
        }),
        target: selected.target.map((value) => {
          var _a, _b;
          return (_b = (_a = optionValueMap.get(value)) == null ? void 0 : _a.data) != null ? _b : "";
        })
      };
      emitEvent(props.onSelect, type, selected, data);
    }
    function handlePanelFocus(type) {
      var _a, _b;
      if (type === "source") {
        (_a = source.value) == null ? void 0 : _a.$el.focus();
      } else {
        (_b = target.value) == null ? void 0 : _b.$el.focus();
      }
    }
    function handlePanelBlur() {
      var _a, _b;
      (_a = source.value) == null ? void 0 : _a.$el.blur();
      (_b = target.value) == null ? void 0 : _b.$el.blur();
    }
    return () => {
      return createVNode("div", {
        "id": idFor.value,
        "class": className.value
      }, [createVNode(TransferPanel, {
        "ref": source,
        "selected": sourceSelected.value,
        "onUpdate:selected": ($event) => sourceSelected.value = $event,
        "type": "source",
        "class": nh.bem("panel", "source"),
        "state": props.state,
        "paged": props.paged,
        "filter": sourceFilter.value,
        "disabled": props.disabled,
        "title": props.sourceTitle || locale.value.source,
        "options": sourceOptions.value,
        "empty-text": props.emptyText || locale.value.empty,
        "option-height": props.optionHeight,
        "ignore-case": props.ignoreCase,
        "deep-state": props.deepState,
        "loading": props.loading,
        "loading-icon": props.loadingIcon,
        "loading-lock": props.loadingLock,
        "loading-spin": props.loadingSpin,
        "onSelect": () => handleSelect("source"),
        "onEnter": handleToTarget,
        "onSwitch": () => handlePanelFocus("target")
      }, {
        header: slots["source-header"] || slots.sourceHeader || slots.header,
        title: slots["source-title"] || slots.sourceTitle || slots.title,
        body: slots["source-body"] || slots.sourceBody || slots.body,
        footer: slots["source-footer"] || slots.sourceFooter || slots.footer,
        option: slots["source-option"] || slots.sourceOption || slots.option
      }), createVNode("div", {
        "class": nh.be("actions")
      }, [slots.actions ? slots.actions({
        handleToTarget,
        handleToSource
      }) : [createVNode(Button, {
        "inherit": true,
        "class": nh.be("action"),
        "type": actionType.value,
        "size": "small",
        "disabled": props.disabled || !toTargetEnabled.value,
        "loading": props.loading && props.loadingLock,
        "loading-icon": props.loadingIcon,
        "loading-spin": props.loadingSpin,
        "style": {
          marginBottom: "6px"
        },
        "onClick": handleToTarget
      }, {
        icon: () => createVNode(Icon, {
          "label": "to right"
        }, {
          default: () => [createVNode($17, null, null)]
        })
      }), createVNode(Button, {
        "inherit": true,
        "class": nh.be("action"),
        "type": actionType.value,
        "size": "small",
        "disabled": props.disabled || !toSourceEnabled.value,
        "loading": props.loading && props.loadingLock,
        "loading-icon": props.loadingIcon,
        "loading-spin": props.loadingSpin,
        "style": {
          margin: "0"
        },
        "onClick": handleToSource
      }, {
        icon: () => createVNode(Icon, {
          "label": "to left"
        }, {
          default: () => [createVNode($16, null, null)]
        })
      })]]), createVNode(TransferPanel, {
        "ref": target,
        "selected": targetSelected.value,
        "onUpdate:selected": ($event) => targetSelected.value = $event,
        "type": "target",
        "class": nh.bem("panel", "target"),
        "state": props.state,
        "paged": props.paged,
        "filter": targetFilter.value,
        "disabled": props.disabled,
        "title": props.targetTitle || locale.value.target,
        "options": targetOptions.value,
        "empty-text": props.emptyText || locale.value.empty,
        "option-height": props.optionHeight,
        "ignore-case": props.ignoreCase,
        "deep-state": props.deepState,
        "loading": props.loading,
        "loading-icon": props.loadingIcon,
        "loading-lock": props.loadingLock,
        "loading-spin": props.loadingSpin,
        "onSelect": () => handleSelect("target"),
        "onEnter": handleToSource,
        "onSwitch": () => handlePanelFocus("source")
      }, {
        header: slots["target-header"] || slots.targetHeader || slots.header,
        title: slots["target-title"] || slots.targetTitle || slots.title,
        body: slots["target-body"] || slots.targetBody || slots.body,
        footer: slots["target-footer"] || slots.targetFooter || slots.footer,
        option: slots["target-option"] || slots.targetOption || slots.option
      })]);
    };
  }
});

// node_modules/vexip-ui/es/components/tree/symbol.mjs
var DropType = ((DropType2) => {
  DropType2["BEFORE"] = "before";
  DropType2["INNER"] = "inner";
  DropType2["AFTER"] = "after";
  return DropType2;
})(DropType || {});
var TREE_STATE = Symbol("TREE_STATE");
var TREE_NODE_STATE = Symbol("TREE_NODE_STATE");

// node_modules/vexip-ui/es/components/tree/tree-node.mjs
var _sfc_main89 = defineComponent({
  name: "TreeNode",
  components: {
    Checkbox,
    CollapseTransition,
    Icon,
    Renderer,
    ChevronRight: $17,
    Spinner: h4
  },
  inheritAttrs: false,
  props: {
    node: {
      type: Object,
      default: () => ({})
    },
    data: {
      type: Object,
      default: () => ({})
    },
    arrow: {
      type: [Boolean, String],
      default: "auto",
      validator: (value) => typeof value === "boolean" || value === "auto"
    },
    checkbox: {
      type: Boolean,
      default: null
    },
    appear: {
      type: Boolean,
      default: false
    },
    visible: {
      type: Boolean,
      default: true
    },
    selected: {
      type: Boolean,
      default: false
    },
    expanded: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    labelKey: {
      type: String,
      default: "label"
    },
    checked: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    loaded: {
      type: Boolean,
      default: false
    },
    partial: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    indent: {
      type: [String, Number],
      default: "16px"
    },
    draggable: {
      type: Boolean,
      default: false
    },
    floorSelect: {
      type: Boolean,
      default: false
    },
    matched: {
      type: Boolean,
      default: true
    },
    childMatched: {
      type: Boolean,
      default: false
    },
    upperMatched: {
      type: Boolean,
      default: false
    },
    nodeProps: {
      type: Function,
      default: cn
    }
  },
  setup(props) {
    const treeState = inject(TREE_STATE);
    const parentState = inject(TREE_NODE_STATE);
    const nh = useNameHelper("tree");
    const nodeElement = ref();
    const arrowElement = ref();
    No({
      target: nodeElement,
      passive: false,
      onKeyDown: (event, modifier) => {
        var _a;
        const prevent = () => {
          event.preventDefault();
          event.stopPropagation();
        };
        if (modifier.up || modifier.down) {
          prevent();
          treeState.handleHittingChange(modifier.up ? "up" : "down");
        } else if (modifier.left || modifier.right) {
          prevent();
          const hasChild = ((_a = props.node.children) == null ? void 0 : _a.length) > 0;
          if (modifier.right && props.expanded && hasChild) {
            treeState.handleHittingChange("down");
          } else if (modifier.left && (!props.expanded || !hasChild)) {
            treeState.handleNodeHitting(parentState.el);
          } else {
            handleToggleExpand(modifier.right);
          }
        } else if (hasCheckbox.value && modifier.space) {
          prevent();
          handleToggleCheck();
        } else if (modifier.enter) {
          prevent();
          handleToggleSelect();
        }
      }
    });
    const loaded = ref(props.loaded);
    const dragging = ref(false);
    const isDragOver = ref(false);
    const focused = ref(false);
    const isDisabled = computed(() => parentState.disabled || props.disabled);
    const isReadonly = computed(() => parentState.readonly || props.readonly);
    const depth = computed(() => parentState.depth + 1);
    const secondary = computed(() => !props.matched && (props.childMatched || props.upperMatched));
    const className = computed(() => {
      return {
        [nh.be("node")]: true,
        [nh.bem("node", "selected")]: props.selected,
        [nh.bem("node", "expanded")]: props.expanded,
        [nh.bem("node", "disabled")]: isDisabled.value,
        [nh.bem("node", "readonly")]: isReadonly.value,
        [nh.bem("node", "secondary")]: secondary.value,
        [nh.bem("node", "dragging")]: dragging.value,
        [nh.bem("node", "drag-over")]: isDragOver.value
      };
    });
    const contentStyle = computed(() => {
      let indent = props.indent;
      if (typeof indent === "number") {
        indent = `${indent}px`;
      }
      return {
        paddingLeft: depth.value ? depth.value === 1 ? indent : `calc(${depth.value} * ${indent})` : 0
      };
    });
    const showChildren = computed(() => {
      var _a;
      return props.expanded && ((_a = props.node.children) == null ? void 0 : _a.length) > 0;
    });
    const hasArrow = computed(() => {
      var _a;
      const arrow = props.arrow;
      let arrowSign = "auto";
      let asyncLoad = false;
      if (qe(arrow) || arrow === "auto") {
        if (treeState) {
          arrowSign = treeState.arrow;
          asyncLoad = treeState.boundAsyncLoad;
        }
      } else {
        arrowSign = arrow;
      }
      return arrowSign === "auto" ? !!((_a = props.node.children) == null ? void 0 : _a.length) || !loaded.value && asyncLoad : !!arrowSign;
    });
    const hasCheckbox = computed(() => {
      const checkbox = props.checkbox;
      return qe(checkbox) ? treeState.checkbox : checkbox;
    });
    const renderer = computed(() => treeState.renderer);
    const suffixCheckbox = computed(() => treeState.suffixCheckbox);
    provide(
      TREE_NODE_STATE,
      reactive({
        el: nodeElement,
        depth,
        disabled: isDisabled,
        readonly: isReadonly
      })
    );
    watch(
      () => props.loaded,
      (value) => {
        loaded.value = value;
      }
    );
    function updateVisible() {
      treeState.updateVisibleNodeEls();
    }
    function setValue(key, value) {
      props.node[key] = value;
    }
    function handleClick() {
      treeState.handleNodeClick(props.node);
    }
    function handleToggleCheck(able = !props.checked) {
      if (isDisabled.value)
        return;
      setValue("checked", able);
      setValue("partial", false);
      nextTick(() => {
        treeState.computeCheckedState(props.node, able);
      });
    }
    async function handleToggleExpand(able = !props.expanded) {
      if (props.loading || isDisabled.value)
        return;
      if (able && treeState.boundAsyncLoad && !loaded.value) {
        setValue("loading", true);
        const result = await treeState.handleAsyncLoad(props.node);
        asyncLoadCallback(result);
      } else {
        setValue("expanded", able);
        if (able) {
          treeState.handleNodeExpand(props.node);
        } else {
          treeState.handleNodeReduce(props.node);
        }
      }
    }
    function handleToggleSelect(able = !props.selected) {
      if (isDisabled.value)
        return;
      if (props.floorSelect) {
        return handleToggleExpand();
      }
      setValue("selected", !isReadonly.value && able);
      if (isReadonly.value || able) {
        treeState.handleNodeSelect(props.node);
      } else {
        treeState.handleNodeCancel(props.node);
      }
    }
    function handleLabelClick() {
      treeState.handleLabelClick(props.node);
      handleToggleSelect();
    }
    function asyncLoadCallback(success = true) {
      setValue("loading", false);
      setValue("expanded", success !== false);
      if (success) {
        loaded.value = true;
        treeState.handleNodeExpand(props.node);
      }
    }
    function getNodeState() {
      return {
        el: nodeElement.value,
        arrow: arrowElement.value,
        node: props.node
      };
    }
    function handleDragStart() {
      if (!props.draggable)
        return;
      dragging.value = true;
      treeState.handleNodeDragStart(getNodeState());
    }
    function handleDragOver(event) {
      if (!props.draggable || !treeState.dragging)
        return;
      event.stopPropagation();
      event.preventDefault();
      isDragOver.value = true;
      treeState.handleNodeDragOver(getNodeState(), event);
    }
    function handleDragLeave(event) {
      if (!props.draggable)
        return;
      event.preventDefault();
      isDragOver.value = false;
    }
    function handleDrop(event) {
      if (!props.draggable || !treeState.dragging)
        return;
      event.stopPropagation();
      event.preventDefault();
      isDragOver.value = false;
      treeState.handleNodeDrop(getNodeState());
    }
    function handleDragEnd(event) {
      if (!props.draggable || !treeState.dragging)
        return;
      event.stopPropagation();
      dragging.value = false;
      treeState.handleNodeDragEnd(getNodeState());
    }
    function getNodeChildren(node) {
      return node.children;
    }
    return {
      nh,
      dragging,
      focused,
      isDisabled,
      isReadonly,
      depth,
      secondary,
      className,
      contentStyle,
      showChildren,
      hasArrow,
      hasCheckbox,
      renderer,
      suffixCheckbox,
      wrapper: nodeElement,
      arrowEl: arrowElement,
      updateVisible,
      handleClick,
      handleToggleCheck,
      handleToggleExpand,
      handleToggleSelect,
      handleLabelClick,
      handleDragStart,
      handleDragOver,
      handleDragLeave,
      handleDrop,
      handleDragEnd,
      getNodeChildren
    };
  }
});
var _hoisted_149 = ["draggable", "aria-disabled", "aria-grabbed"];
var _hoisted_222 = ["aria-hidden"];
function _sfc_render89(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Spinner = resolveComponent("Spinner");
  const _component_Icon = resolveComponent("Icon");
  const _component_ChevronRight = resolveComponent("ChevronRight");
  const _component_Checkbox = resolveComponent("Checkbox");
  const _component_Renderer = resolveComponent("Renderer");
  const _component_TreeNode = resolveComponent("TreeNode", true);
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.visible && (_ctx.matched || _ctx.childMatched) ? (openBlock(), createElementBlock("li", mergeProps({
      key: 0,
      ref: "wrapper"
    }, _ctx.$attrs, {
      class: _ctx.className,
      draggable: _ctx.draggable,
      tabindex: "-1",
      "aria-disabled": _ctx.isDisabled,
      "aria-grabbed": _ctx.draggable && _ctx.dragging ? "true" : void 0,
      onClick: _cache[4] || (_cache[4] = withModifiers((...args) => _ctx.handleClick && _ctx.handleClick(...args), ["left"])),
      onFocus: _cache[5] || (_cache[5] = ($event) => _ctx.focused = true),
      onBlur: _cache[6] || (_cache[6] = ($event) => _ctx.focused = false),
      onDragstart: _cache[7] || (_cache[7] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
      onDragover: _cache[8] || (_cache[8] = (...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args)),
      onDragleave: _cache[9] || (_cache[9] = (...args) => _ctx.handleDragLeave && _ctx.handleDragLeave(...args)),
      onDragend: _cache[10] || (_cache[10] = (...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args)),
      onDrop: _cache[11] || (_cache[11] = (...args) => _ctx.handleDrop && _ctx.handleDrop(...args))
    }), [
      renderSlot(_ctx.$slots, "default", {
        data: _ctx.node.data,
        node: _ctx.node,
        depth: _ctx.depth,
        focused: _ctx.focused,
        toggleCheck: _ctx.handleToggleCheck,
        toggleExpand: _ctx.handleToggleExpand,
        toggleSelect: _ctx.handleToggleSelect
      }, () => {
        var _a;
        return [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("content")),
            style: normalizeStyle(_ctx.contentStyle)
          }, [
            createBaseVNode("span", {
              ref: "arrowEl",
              class: normalizeClass({
                [_ctx.nh.be("arrow")]: true,
                [_ctx.nh.bem("arrow", "transparent")]: !_ctx.loading && !_ctx.hasArrow,
                [_ctx.nh.bem("arrow", "expanded")]: _ctx.expanded
              }),
              "aria-hidden": !_ctx.loading && !_ctx.hasArrow,
              onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.handleToggleExpand(), ["stop"]))
            }, [
              _ctx.loading ? (openBlock(), createBlock(_component_Icon, {
                key: 0,
                pulse: ""
              }, {
                default: withCtx(() => [
                  createVNode(_component_Spinner)
                ]),
                _: 1
              })) : (openBlock(), createBlock(_component_Icon, { key: 1 }, {
                default: withCtx(() => [
                  createVNode(_component_ChevronRight)
                ]),
                _: 1
              }))
            ], 10, _hoisted_222),
            _ctx.hasCheckbox && !_ctx.suffixCheckbox ? (openBlock(), createBlock(_component_Checkbox, {
              key: 0,
              inherit: "",
              class: normalizeClass(_ctx.nh.be("checkbox")),
              "tab-index": -1,
              control: _ctx.hasArrow,
              checked: _ctx.checked,
              disabled: _ctx.isDisabled,
              partial: _ctx.partial,
              onClick: _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.handleToggleCheck(), ["prevent", "stop"]))
            }, null, 8, ["class", "control", "checked", "disabled", "partial"])) : createCommentVNode("", true),
            createBaseVNode("div", {
              class: normalizeClass({
                [_ctx.nh.be("label")]: true,
                [_ctx.nh.bem("label", "focused")]: _ctx.focused,
                [_ctx.nh.bem("label", "selected")]: _ctx.selected,
                [_ctx.nh.bem("label", "disabled")]: _ctx.isDisabled,
                [_ctx.nh.bem("label", "readonly")]: _ctx.isReadonly,
                [_ctx.nh.bem("label", "is-floor")]: _ctx.floorSelect && ((_a = _ctx.node.children) == null ? void 0 : _a.length),
                [_ctx.nh.bem("label", "secondary")]: _ctx.secondary
              }),
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.handleLabelClick())
            }, [
              _ctx.renderer ? (openBlock(), createBlock(_component_Renderer, {
                key: 0,
                renderer: _ctx.renderer,
                data: { node: _ctx.node, depth: _ctx.depth, data: _ctx.node.data }
              }, null, 8, ["renderer", "data"])) : renderSlot(_ctx.$slots, "label", {
                key: 1,
                data: _ctx.node.data,
                node: _ctx.node,
                depth: _ctx.depth,
                focused: _ctx.focused
              }, () => [
                createTextVNode(toDisplayString(_ctx.data[_ctx.labelKey]), 1)
              ])
            ], 2),
            _ctx.hasCheckbox && _ctx.suffixCheckbox ? (openBlock(), createBlock(_component_Checkbox, {
              key: 1,
              inherit: "",
              class: normalizeClass([_ctx.nh.be("checkbox"), _ctx.nh.bem("checkbox", "suffix")]),
              "tab-index": -1,
              control: _ctx.hasArrow,
              checked: _ctx.checked,
              disabled: _ctx.isDisabled,
              partial: _ctx.partial,
              onClick: _cache[3] || (_cache[3] = withModifiers(($event) => _ctx.handleToggleCheck(), ["prevent", "stop"]))
            }, null, 8, ["class", "control", "checked", "disabled", "partial"])) : createCommentVNode("", true)
          ], 6)
        ];
      })
    ], 16, _hoisted_149)) : createCommentVNode("", true),
    createVNode(_component_CollapseTransition, {
      appear: _ctx.appear,
      onAfterEnter: _ctx.updateVisible,
      onAfterLeave: _ctx.updateVisible
    }, {
      default: withCtx(() => [
        _ctx.showChildren ? (openBlock(), createElementBlock("ul", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("list"))
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.node.children, (item, index) => {
            return openBlock(), createBlock(_component_TreeNode, mergeProps({ key: index }, _ctx.nodeProps(item.data, item), {
              node: item,
              data: item.data,
              arrow: item.arrow,
              checkbox: item.checkbox,
              appear: _ctx.appear,
              visible: item.visible,
              selected: item.selected,
              expanded: item.expanded,
              disabled: item.disabled,
              "label-key": _ctx.labelKey,
              checked: item.checked,
              loading: item.loading,
              loaded: item.loaded,
              partial: item.partial,
              readonly: item.readonly,
              indent: _ctx.indent,
              draggable: _ctx.draggable,
              "floor-select": _ctx.floorSelect,
              matched: item.matched,
              "child-matched": item.childMatched,
              "upper-matched": item.upperMatched,
              "node-props": _ctx.nodeProps
            }), {
              default: withCtx((payload) => [
                renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(payload)))
              ]),
              label: withCtx((payload) => [
                renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(payload)))
              ]),
              _: 2
            }, 1040, ["node", "data", "arrow", "checkbox", "appear", "visible", "selected", "expanded", "disabled", "label-key", "checked", "loading", "loaded", "partial", "readonly", "indent", "draggable", "floor-select", "matched", "child-matched", "upper-matched", "node-props"]);
          }), 128))
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 3
    }, 8, ["appear", "onAfterEnter", "onAfterLeave"])
  ], 64);
}
var TreeNode = _export_sfc(_sfc_main89, [["render", _sfc_render89]]);

// node_modules/vexip-ui/es/components/tree/props.mjs
var treeProps = buildProps({
  arrow: {
    type: [Boolean, String],
    default: null
  },
  data: Array,
  noBuildTree: booleanProp,
  emptyTip: String,
  disabled: booleanProp,
  readonly: booleanProp,
  checkbox: booleanProp,
  suffixCheckbox: booleanProp,
  renderer: Function,
  multiple: booleanProp,
  indent: [String, Number],
  accordion: booleanProp,
  draggable: booleanProp,
  appear: booleanProp,
  floorSelect: booleanProp,
  onAsyncLoad: Function,
  cacheNode: booleanProp,
  rootId: [String, Number],
  keyConfig: Object,
  noCascaded: booleanProp,
  filter: [String, Function],
  ignoreCase: booleanProp,
  nodeProps: [Object, Function],
  onNodeChange: eventProp(),
  onNodeClick: eventProp(),
  onNodeSelect: eventProp(),
  onNodeCancel: eventProp(),
  onNodeExpand: eventProp(),
  onNodeReduce: eventProp(),
  onDragStart: eventProp(),
  onDragOver: eventProp(),
  onDrop: eventProp(),
  onDragEnd: eventProp(),
  onLabelClick: eventProp()
});

// node_modules/vexip-ui/es/components/tree/tree.mjs
var defaultKeyConfig4 = {
  id: "id",
  parent: "parent",
  label: "label",
  children: "children",
  visible: "visible",
  selected: "selected",
  expanded: "expanded",
  disabled: "disabled",
  checked: "checked",
  loading: "loading",
  loaded: "loaded",
  readonly: "readonly",
  arrow: "arrow",
  checkbox: "checkbox"
};
var _sfc_main90 = defineComponent({
  name: "Tree",
  components: {
    TreeNode
  },
  props: treeProps,
  emits: [],
  setup(_props) {
    const props = useProps("tree", _props, {
      arrow: {
        default: "auto",
        validator: (value) => typeof value === "boolean" || value === "auto"
      },
      data: {
        default: () => [],
        static: true
      },
      noBuildTree: false,
      emptyTip: null,
      disabled: false,
      readonly: false,
      checkbox: false,
      suffixCheckbox: false,
      renderer: {
        default: null,
        isFunc: true
      },
      multiple: false,
      indent: "16px",
      accordion: false,
      draggable: false,
      appear: false,
      floorSelect: false,
      onAsyncLoad: {
        default: null,
        isFunc: true
      },
      cacheNode: false,
      rootId: null,
      keyConfig: () => ({}),
      noCascaded: false,
      filter: "",
      ignoreCase: false,
      nodeProps: null
    });
    const nh = useNameHelper("tree");
    const nodeMaps = /* @__PURE__ */ new Map();
    const treeData = ref([]);
    const dragging = ref(false);
    const indicatorShow = ref(false);
    const anyMatched = ref(false);
    const { isMounted } = Io();
    const wrapper = ref();
    const trap = ref();
    const indicator = ref();
    let visibleNodeEls = [];
    const defaultNodeProperties = {
      visible: true,
      selected: false,
      expanded: false,
      disabled: false,
      checked: false,
      loading: false,
      loaded: false,
      readonly: false,
      arrow: "auto",
      checkbox: null
    };
    const keyConfig = computed(() => {
      return { ...defaultKeyConfig4, ...props.keyConfig };
    });
    const parsedOptions = computed(() => {
      return {
        keyField: keyConfig.value.id,
        childField: keyConfig.value.children,
        parentField: keyConfig.value.parent,
        rootId: props.rootId
      };
    });
    const boundAsyncLoad = computed(() => {
      return typeof props.onAsyncLoad === "function";
    });
    const flattedData = computed(() => {
      return Rr(treeData.value, {
        keyField: "id",
        parentField: "parent",
        childField: "children",
        rootId: props.rootId
      });
    });
    const labelKey = computed(() => keyConfig.value.label);
    function createDefaultFilter(value) {
      const pattern = props.ignoreCase ? String(value).toLocaleLowerCase() : value;
      const defaultFilter = (data) => {
        const label = data[labelKey.value];
        return props.ignoreCase ? String(label).toLocaleLowerCase().includes(pattern) : String(label).includes(pattern);
      };
      return defaultFilter;
    }
    watchEffect(() => {
      const nodes = flattedData.value;
      if (!props.filter) {
        for (let i = 0, len = nodes.length; i < len; ++i) {
          const node = nodes[i];
          node.matched = true;
          node.childMatched = false;
          node.upperMatched = false;
        }
        anyMatched.value = true;
      } else {
        const filter = typeof props.filter === "function" ? props.filter : createDefaultFilter(props.filter);
        anyMatched.value = false;
        for (let i = 0, len = nodes.length; i < len; ++i) {
          const node = nodes[i];
          const parent = nodeMaps.get(node.parent);
          node.matched = filter(node.data, node);
          node.childMatched = false;
          node.upperMatched = !!parent && (parent.matched || parent.upperMatched);
          anyMatched.value = anyMatched.value || node.matched;
          if (node.matched) {
            let upper = parent;
            while (upper && !upper.childMatched) {
              upper.childMatched = true;
              upper = nodeMaps.get(upper.parent);
            }
          }
        }
      }
    });
    provide(
      TREE_STATE,
      reactive({
        arrow: toRef(props, "arrow"),
        checkbox: toRef(props, "checkbox"),
        suffixCheckbox: toRef(props, "suffixCheckbox"),
        renderer: toRef(props, "renderer"),
        dragging,
        boundAsyncLoad,
        updateVisibleNodeEls,
        computeCheckedState,
        handleNodeClick,
        handleNodeSelect,
        handleNodeCancel,
        handleNodeExpand,
        handleNodeReduce,
        handleAsyncLoad,
        handleNodeDragStart,
        handleNodeDragOver,
        handleNodeDrop,
        handleNodeDragEnd,
        handleHittingChange,
        handleNodeHitting,
        handleLabelClick
      })
    );
    provide(
      TREE_NODE_STATE,
      reactive({
        depth: -1,
        disabled: toRef(props, "disabled"),
        readonly: toRef(props, "readonly")
      })
    );
    watch([() => props.data, () => props.data.length], parseAndTransformData);
    watch(parsedOptions, parseAndTransformData);
    parseAndTransformData();
    onMounted(updateVisibleNodeEls);
    const checkedNodes = flattedData.value.filter((item) => item.checked);
    for (let i = 0, len = checkedNodes.length; i < len; ++i) {
      const item = checkedNodes[i];
      const parentKey = item.parent;
      updateCheckedDown(item);
      if (parentKey && nodeMaps.has(parentKey)) {
        const parent = nodeMaps.get(parentKey);
        if (!parent.checked) {
          updateCheckedUpward(item);
        }
      }
    }
    function updateVisibleNodeEls() {
      requestAnimationFrame(() => {
        if (wrapper.value) {
          visibleNodeEls = _e(`.${nh.be("node")}`, wrapper.value);
        }
      });
    }
    function parseAndTransformData() {
      var _a;
      const idKey = keyConfig.value.id;
      const parentKey = keyConfig.value.parent;
      const oldDataMap = /* @__PURE__ */ new Map();
      const oldIpMap = /* @__PURE__ */ new Map();
      for (const node of nodeMaps.values()) {
        oldDataMap.set(node.data, node);
        oldIpMap.set(node.data[idKey], node);
      }
      nodeMaps.clear();
      const nodes = [];
      const data = props.noBuildTree ? Rr(props.data, parsedOptions.value) : props.data;
      for (let i = 0, len = data.length; i < len; ++i) {
        const item = data[i];
        const oldNode = (_a = oldDataMap.get(item)) != null ? _a : oldIpMap.get(item[idKey]);
        const node = props.cacheNode ? oldNode != null ? oldNode : createNodeItem(item) : createNodeItem(item, oldNode);
        node.parent = item[parentKey];
        node.data = item;
        nodeMaps.set(node.id, node);
        nodes.push(node);
      }
      treeData.value = _r(nodes, {
        keyField: "id",
        parentField: "parent",
        childField: "children",
        rootId: props.rootId
      });
      isMounted.value && updateVisibleNodeEls();
    }
    function forceUpdateData() {
      const nodes = [];
      const data = props.noBuildTree ? Rr(props.data, parsedOptions.value) : props.data;
      const {
        id: idKey,
        visible: visibleKey,
        selected: selectedKey,
        expanded: expandedKey,
        disabled: disabledKey,
        checked: checkedKey,
        loading: loadingKey,
        loaded: loadedKey,
        readonly: readonlyKey,
        arrow: arrowKey,
        checkbox: checkboxKey
      } = keyConfig.value;
      for (let i = 0, len = data.length; i < len; ++i) {
        const item = data[i];
        const id2 = item[idKey];
        let node;
        if (nodeMaps.has(id2)) {
          node = nodeMaps.get(id2);
          const {
            [visibleKey]: visible = node.visible,
            [selectedKey]: selected = node.selected,
            [expandedKey]: expanded = node.expanded,
            [disabledKey]: disabled = node.disabled,
            [checkedKey]: checked = node.checked,
            [loadingKey]: loading = node.loading,
            [loadedKey]: loaded = node.loaded,
            [readonlyKey]: readonly = node.readonly,
            [arrowKey]: arrow = node.arrow,
            [checkboxKey]: checkbox = node.checkbox
          } = item;
          node.visible = visible;
          node.selected = selected;
          node.expanded = expanded;
          node.disabled = disabled;
          node.checked = checked;
          node.loading = loading;
          node.loaded = loaded;
          node.readonly = readonly;
          node.arrow = arrow;
          node.checkbox = checkbox;
        } else {
          node = createNodeItem(item);
          nodeMaps.set(id2, node);
        }
        nodes.push(node);
      }
      treeData.value = _r(nodes, {
        keyField: "id",
        parentField: "parent",
        childField: "children",
        rootId: props.rootId
      });
      isMounted.value && updateVisibleNodeEls();
    }
    function syncNodeStateIntoData() {
      flattedData.value.forEach((node) => {
        if (!node.data)
          return;
        const { data, visible, selected, expanded, disabled, checked, loading, readonly } = node;
        data.visible = visible;
        data.selected = selected;
        data.expanded = expanded;
        data.disabled = disabled;
        data.checked = checked;
        data.loading = loading;
        data.readonly = readonly;
      });
      isMounted.value && updateVisibleNodeEls();
    }
    function createNodeItem(data, defaults = defaultNodeProperties) {
      const {
        id: idKey,
        parent: parentKey,
        visible: visibleKey,
        selected: selectedKey,
        expanded: expandedKey,
        disabled: disabledKey,
        checked: checkedKey,
        loading: loadingKey,
        loaded: loadedKey,
        readonly: readonlyKey,
        arrow: arrowKey,
        checkbox: checkboxKey
      } = keyConfig.value;
      const {
        [visibleKey]: visible = defaults.visible,
        [selectedKey]: selected = defaults.selected,
        [expandedKey]: expanded = defaults.expanded,
        [disabledKey]: disabled = defaults.disabled,
        [checkedKey]: checked = defaults.checked,
        [loadingKey]: loading = defaults.loading,
        [loadedKey]: loaded = defaults.loaded,
        [readonlyKey]: readonly = defaults.readonly,
        [arrowKey]: arrow = defaults.arrow,
        [checkboxKey]: checkbox = defaults.checkbox
      } = data;
      const id2 = data[idKey];
      const parent = data[parentKey];
      return reactive({
        id: id2,
        parent,
        children: [],
        data,
        visible,
        selected,
        expanded,
        disabled,
        checked,
        loading,
        loaded,
        readonly,
        arrow,
        checkbox,
        partial: false,
        matched: false,
        childMatched: false,
        upperMatched: false
      });
    }
    function getNodeChildren(node) {
      return node.children;
    }
    function updateCheckedUpward(originNode) {
      let node = originNode;
      while (!qe(node.parent)) {
        const parentId = node.parent;
        if (!nodeMaps.has(parentId))
          break;
        const parent = nodeMaps.get(parentId);
        if (node.checked === parent.checked && node.partial === parent.partial) {
          break;
        }
        if (node.checked) {
          parent.checked = parent.children.every((item) => item.checked);
          parent.partial = !parent.checked;
        } else {
          parent.checked = false;
          parent.partial = parent.children.some((item) => item.checked || item.partial);
        }
        node = parent;
      }
    }
    function updateCheckedDown(originNode) {
      const checked = originNode.checked;
      const partial = originNode.partial;
      const loop = [...originNode.children];
      let node;
      while (loop.length) {
        node = loop.shift();
        if (node.disabled)
          continue;
        node.checked = checked;
        node.partial = partial;
        if (node.children.length) {
          loop.push(...node.children);
        }
      }
    }
    function computeCheckedState(originNode, able) {
      if (!props.noCascaded) {
        const nodeList = [originNode].concat(
          flattedData.value.filter((item) => item.disabled && item.checked)
        );
        for (let i = 0, len = nodeList.length; i < len; ++i) {
          const item = nodeList[i];
          updateCheckedUpward(item);
          updateCheckedDown(item);
        }
      }
      emitEvent(props.onNodeChange, originNode.data, originNode, able);
    }
    function handleNodeClick(node) {
      emitEvent(props.onNodeClick, node.data, node);
    }
    function handleLabelClick(node) {
      emitEvent(props.onLabelClick, node.data, node);
    }
    function handleNodeSelect(node) {
      const selectedNodes = flattedData.value.filter((item) => item.selected);
      if (props.multiple) {
        emitEvent(
          props.onNodeSelect,
          selectedNodes.map((item) => item.data),
          selectedNodes
        );
      } else {
        const currentId = node.id;
        for (let i = 0, len = selectedNodes.length; i < len; ++i) {
          const item = selectedNodes[i];
          item.selected = item.id === currentId;
        }
        emitEvent(props.onNodeSelect, node.data, node);
      }
    }
    function handleNodeCancel(node) {
      emitEvent(props.onNodeCancel, node.data, node);
    }
    function handleNodeExpand(node) {
      if (props.accordion) {
        const siblingNodes = getSiblingNodes(node);
        for (let i = 0, len = siblingNodes.length; i < len; ++i) {
          siblingNodes[i].expanded = false;
        }
      }
      emitEvent(props.onNodeExpand, node.data, node);
    }
    function handleNodeReduce(node) {
      emitEvent(props.onNodeReduce, node.data, node);
    }
    async function handleAsyncLoad(node) {
      if (!boundAsyncLoad.value)
        return false;
      let result = props.onAsyncLoad(node.data, node);
      if (Je(result)) {
        result = await result;
      }
      return result !== false;
    }
    let dragState = null;
    function handleNodeDragStart(nodeInstance) {
      if (!wrapper.value)
        return;
      dragState = {
        draggingNode: nodeInstance.node,
        treeRect: wrapper.value.getBoundingClientRect(),
        willDropNode: null,
        dropType: DropType.BEFORE
      };
      dragging.value = true;
      emitEvent(props.onDragStart, nodeInstance.node.data, nodeInstance.node);
    }
    function handleNodeDragOver(nodeInstance, event) {
      if (!dragState || !nodeInstance.el || !nodeInstance.arrow)
        return;
      const dropNodeRect = nodeInstance.el.getBoundingClientRect();
      const treeRect = dragState.treeRect;
      const dropArrowRect = nodeInstance.arrow.getBoundingClientRect();
      const prevPercent = 0.25;
      const nextPercent = 0.75;
      const distance = event.clientY - dropNodeRect.top;
      const dropNodeHeight = dropArrowRect.height;
      let dropType;
      let indicatorTop = -9999;
      let isIndicatorShow = true;
      if (distance < dropNodeHeight * prevPercent) {
        dropType = DropType.BEFORE;
        indicatorTop = dropArrowRect.top - treeRect.top;
      } else if (distance > dropNodeHeight * nextPercent) {
        dropType = DropType.AFTER;
        indicatorTop = dropArrowRect.bottom - treeRect.top;
      } else {
        dropType = DropType.INNER;
        isIndicatorShow = false;
      }
      if (indicator.value) {
        indicator.value.style.top = `${indicatorTop}px`;
        indicator.value.style.left = `${dropArrowRect.right - treeRect.left}px`;
      }
      dragState.willDropNode = nodeInstance.node;
      dragState.dropType = dropType;
      indicatorShow.value = isIndicatorShow;
      emitEvent(props.onDragOver, nodeInstance.node.data, nodeInstance.node);
    }
    function isLeftInsideRight(left, right) {
      if (!left || !right)
        return true;
      while (left) {
        if (left === right || left.id === right.id) {
          return true;
        }
        left = getParentNode(left);
      }
      return false;
    }
    function handleNodeDrop(nodeInstance) {
      if (!dragState)
        return;
      const { draggingNode, willDropNode, dropType } = dragState;
      if (!willDropNode || isLeftInsideRight(willDropNode, draggingNode))
        return;
      let currentId;
      let parent;
      if (draggingNode) {
        parent = getParentNode(draggingNode);
        if (!parent) {
          parent = {
            children: treeData.value
          };
        }
        currentId = draggingNode.id;
        kr(parent.children, (item) => item.id === currentId);
      }
      if (dropType === DropType.INNER) {
        if (!Array.isArray(willDropNode.children)) {
          willDropNode.children = [];
        }
        const children = Array.from(willDropNode.children);
        children.push(draggingNode);
        willDropNode.children = children;
        draggingNode.parent = willDropNode.id;
      } else {
        parent = getParentNode(willDropNode);
        if (!parent) {
          parent = {
            parent: void 0,
            children: treeData.value
          };
        }
        currentId = willDropNode.id;
        const index = parent.children.findIndex((item) => item.id === currentId);
        if (~index) {
          parent.children.splice(+(dropType === DropType.AFTER) + index, 0, draggingNode);
          draggingNode.parent = parent.id;
        }
      }
      emitEvent(props.onDrop, nodeInstance.node.data, nodeInstance.node, dropType);
    }
    function handleNodeDragEnd(nodeInstance) {
      dragging.value = true;
      indicatorShow.value = false;
      dragState = null;
      emitEvent(props.onDragEnd, nodeInstance.node.data, nodeInstance.node);
    }
    function handleHittingChange(type) {
      var _a;
      const activeEl = document.activeElement;
      if (!visibleNodeEls.length || !activeEl)
        return;
      const index = visibleNodeEls.findIndex((nodeEl) => nodeEl === activeEl);
      if (~index) {
        (_a = visibleNodeEls.at((index + (type === "up" ? -1 : 1)) % visibleNodeEls.length)) == null ? void 0 : _a.focus();
      }
    }
    function handleNodeHitting(nodeEl) {
      if (!nodeEl || !visibleNodeEls.length)
        return;
      if (visibleNodeEls.includes(nodeEl)) {
        nodeEl.focus();
      }
    }
    function handleTreeFocus(event) {
      const target = event.target;
      if (!visibleNodeEls.length || !target || !trap.value) {
        return;
      }
      if (target === trap.value) {
        visibleNodeEls[0].focus();
      }
    }
    function getCheckedNodes() {
      return flattedData.value.filter((item) => item.checked);
    }
    function getCheckedNodeData() {
      return getCheckedNodes().map((node) => node.data);
    }
    function getSelectedNodes() {
      return flattedData.value.filter((item) => item.selected);
    }
    function getSelectedNodeData() {
      return getSelectedNodes().map((node) => node.data);
    }
    function getExpandedNodes() {
      return flattedData.value.filter((item) => item.expanded);
    }
    function getDisabledNodes() {
      return flattedData.value.filter((item) => item.disabled);
    }
    function getParentNode(node) {
      var _a;
      if (node.parent) {
        return (_a = nodeMaps.get(node.parent)) != null ? _a : null;
      }
      return null;
    }
    function getSiblingNodes(node, includeSelf = false) {
      const parent = getParentNode(node);
      const currentId = node.id;
      const parentId = parent ? parent.id : null;
      return flattedData.value.filter((item) => {
        const isChild = parentId === null ? !item.parent : item.parent === parentId;
        if (isChild && !includeSelf) {
          return item.id !== currentId;
        }
        return isChild;
      });
    }
    function getPrevSiblingNode(node) {
      const parent = getParentNode(node);
      if (!parent)
        return null;
      const currentId = node.id;
      const parentId = parent.id;
      const children = flattedData.value.filter((item) => item.parent === parentId);
      if (children && children.length) {
        const index = children.findIndex((item) => item.id === currentId);
        if (index > 0) {
          return children[index - 1];
        }
      }
      return null;
    }
    function getNextSiblingNode(node) {
      const parent = getParentNode(node);
      if (!parent)
        return null;
      const currentId = node.id;
      const parentId = parent.id;
      const children = flattedData.value.filter((item) => item.parent === parentId);
      if (children && children.length) {
        const index = children.findIndex((item) => item.id === currentId);
        if (!~index && index < children.length - 1) {
          return children[index + 1];
        }
      }
      return null;
    }
    function getNodeByData(data) {
      var _a;
      const idKey = keyConfig.value.id;
      return (_a = flattedData.value.find((item) => item.data[idKey] === data[idKey])) != null ? _a : null;
    }
    function expandNodeByData(data, expanded, upstream = false) {
      const node = getNodeByData(data);
      if (node) {
        node.expanded = qe(expanded) ? !node.expanded : !!expanded;
        if (upstream) {
          let parentNode = getParentNode(node);
          while (parentNode) {
            parentNode.expanded = node.expanded;
            parentNode = getParentNode(parentNode);
          }
        }
      }
    }
    function selectNodeByData(data, selected) {
      const node = getNodeByData(data);
      if (node) {
        node.selected = qe(selected) ? !node.selected : !!selected;
      }
    }
    function checkNodeByData(data, checked) {
      const node = getNodeByData(data);
      if (node) {
        node.checked = qe(checked) ? !node.checked : !!checked;
        if (!props.noCascaded) {
          const nodeList = [node].concat(
            flattedData.value.filter((item) => item.disabled && item.checked)
          );
          for (let i = 0, len = nodeList.length; i < len; ++i) {
            const item = nodeList[i];
            updateCheckedUpward(item);
            updateCheckedDown(item);
          }
        }
      }
    }
    function toggleNodeLoadingByData(data, loading) {
      const node = getNodeByData(data);
      if (node) {
        node.checked = qe(loading) ? !node.loading : !!loading;
      }
    }
    return {
      props,
      nh,
      locale: useLocale("tree"),
      treeData,
      indicatorShow,
      anyMatched,
      labelKey,
      childrenKey: computed(() => keyConfig.value.children),
      getNodeProps: computed(() => {
        return typeof props.nodeProps === "function" ? props.nodeProps : () => props.nodeProps;
      }),
      wrapper,
      trap,
      indicator,
      handleTreeFocus,
      parseAndTransformData,
      forceUpdateData,
      syncNodeStateIntoData,
      getCheckedNodes,
      getCheckedNodeData,
      getSelectedNodes,
      getSelectedNodeData,
      getExpandedNodes,
      getDisabledNodes,
      getNodeChildren,
      getParentNode,
      getSiblingNodes,
      getPrevSiblingNode,
      getNextSiblingNode,
      getNodeByData,
      expandNodeByData,
      selectNodeByData,
      checkNodeByData,
      toggleNodeLoadingByData
    };
  }
});
var _hoisted_150 = ["aria-disabled", "aria-readonly"];
function _sfc_render90(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TreeNode = resolveComponent("TreeNode");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars"), _ctx.props.inherit && _ctx.nh.bm("inherit")]),
    role: "tree",
    tabindex: "-1",
    "aria-disabled": _ctx.props.disabled,
    "aria-readonly": _ctx.props.readonly
  }, [
    createBaseVNode("span", {
      ref: "trap",
      tabindex: "0",
      "aria-hidden": "true",
      style: { "width": "0", "height": "0", "overflow": "hidden", "outline": "none" },
      onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.handleTreeFocus && _ctx.handleTreeFocus(...args))
    }, null, 544),
    createBaseVNode("ul", {
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.treeData, (item, index) => {
        return openBlock(), createBlock(_component_TreeNode, mergeProps({ key: index }, _ctx.getNodeProps(item.data, item), {
          node: item,
          data: item.data,
          arrow: item.arrow,
          checkbox: item.checkbox,
          appear: _ctx.props.appear,
          visible: item.visible,
          selected: item.selected,
          expanded: item.expanded,
          disabled: item.disabled,
          "label-key": _ctx.labelKey,
          checked: item.checked,
          loading: item.loading,
          loaded: item.loaded,
          partial: item.partial,
          readonly: item.readonly,
          indent: _ctx.props.indent,
          draggable: _ctx.props.draggable,
          "floor-select": _ctx.props.floorSelect,
          matched: item.matched,
          "child-matched": item.childMatched,
          "upper-matched": item.upperMatched,
          "node-props": _ctx.getNodeProps
        }), {
          default: withCtx((payload) => [
            renderSlot(_ctx.$slots, "node", normalizeProps(guardReactiveProps(payload)))
          ]),
          label: withCtx((payload) => [
            renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(payload)))
          ]),
          _: 2
        }, 1040, ["node", "data", "arrow", "checkbox", "appear", "visible", "selected", "expanded", "disabled", "label-key", "checked", "loading", "loaded", "partial", "readonly", "indent", "draggable", "floor-select", "matched", "child-matched", "upper-matched", "node-props"]);
      }), 128))
    ], 2),
    !_ctx.props.data || !_ctx.props.data.length || !_ctx.anyMatched ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("empty-tip"))
    }, [
      renderSlot(_ctx.$slots, "empty", {}, () => {
        var _a;
        return [
          createTextVNode(toDisplayString((_a = _ctx.props.emptyTip) != null ? _a : _ctx.locale.empty), 1)
        ];
      })
    ], 2)) : createCommentVNode("", true),
    _ctx.props.draggable ? withDirectives((openBlock(), createElementBlock("div", {
      key: 1,
      ref: "indicator",
      class: normalizeClass(_ctx.nh.be("indicator"))
    }, null, 2)), [
      [vShow, _ctx.indicatorShow]
    ]) : createCommentVNode("", true)
  ], 10, _hoisted_150);
}
var Tree = _export_sfc(_sfc_main90, [["render", _sfc_render90]]);

// node_modules/vexip-ui/es/components/upload/props.mjs
var uploadProps = buildProps({
  state: stateProp,
  url: String,
  fileList: Array,
  multiple: booleanProp,
  tip: String,
  accept: [String, Array],
  filter: [String, Array],
  maxSize: Number,
  field: String,
  data: Object,
  headers: Object,
  withCredentials: booleanProp,
  manual: booleanProp,
  hiddenFiles: booleanProp,
  countLimit: Number,
  allowDrag: booleanProp,
  onBeforeUpload: Function,
  onBeforeSelect: Function,
  iconRenderer: Function,
  selectToAdd: booleanProp,
  listType: String,
  block: booleanProp,
  loadingText: String,
  directory: booleanProp,
  pathField: String,
  disabledClick: booleanProp,
  buttonLabel: String,
  disabled: booleanProp,
  loading: booleanProp,
  loadingIcon: Object,
  loadingLock: booleanProp,
  loadingSpin: booleanProp,
  image: booleanProp,
  defaultFiles: Array,
  canPreview: Function,
  listStyle: styleProp,
  onExceed: eventProp(),
  onChange: eventProp(),
  onFilterError: eventProp(),
  onSizeError: eventProp(),
  onDelete: eventProp(),
  onPreview: eventProp(),
  onProgress: eventProp(),
  onSuccess: eventProp(),
  onError: eventProp()
});
var uploadListProps = buildProps({
  files: Array,
  selectToAdd: booleanProp,
  iconRenderer: Function,
  type: String,
  loadingText: String,
  style: styleProp,
  precision: Number,
  canPreview: Function,
  onDelete: eventProp(),
  onPreview: eventProp()
});
var uploadFileProps = buildProps({
  file: Object,
  iconRenderer: Function,
  listType: String,
  loadingText: String,
  selectToAdd: booleanProp,
  precision: Number,
  canPreview: Function,
  onDelete: eventProp(),
  onPreview: eventProp()
});

// node_modules/vexip-ui/es/components/upload/file-icon.mjs
var iconConfig = /* @__PURE__ */ new Map();
iconConfig.set(u6, ["doc", "docx"]);
iconConfig.set(v4, [
  "mp4",
  "flv",
  "mkv",
  "rm",
  "rmvb",
  "mov",
  "mtv",
  "wnv",
  "avi",
  "3gp",
  "amv",
  "dmv"
]);
iconConfig.set(H, ["ppt", "pptx", "pptm"]);
iconConfig.set(z, ["pdf"]);
iconConfig.set(x23, [
  "bmp",
  "jpg",
  "jpeg",
  "png",
  "tif",
  "gif",
  "pcx",
  "tga",
  "exif",
  "fpx",
  "svg",
  "psd",
  "cdr",
  "pcd",
  "dxf",
  "ufo",
  "eps",
  "ai",
  "raw",
  "wmf",
  "webp"
]);
iconConfig.set(u5, ["xls", "xlsx", "xlsm", "xlsb", "xlam"]);
iconConfig.set(x21, [
  "json",
  "xml",
  "property",
  "class",
  "c",
  "cpp",
  "cc",
  "cxx",
  "h",
  "hpp",
  "hxx",
  "cs",
  "yml",
  "yaml",
  "ts",
  "tsx"
]);
iconConfig.set(x17, ["js", "jsx", "mjs"]);
iconConfig.set(x15, ["css", "styl", "pcss"]);
iconConfig.set(v3, ["sass", "scss"]);
iconConfig.set(u3, ["less"]);
iconConfig.set(x16, ["java", "class", "jsp"]);
iconConfig.set($24, ["vue"]);
iconConfig.set(L3, ["html", "htm"]);
iconConfig.set(x18, ["py", "pyc", "pyw", "pyo", "pyd"]);
iconConfig.set(v2, [
  "cd",
  "wave",
  "aiff",
  "mpeg",
  "mp3",
  "mpeg-4",
  "midi",
  "wma",
  "ra",
  "rm",
  "rmx",
  "vqf",
  "amr",
  "ape",
  "flac",
  "aac"
]);
iconConfig.set(M, [
  "rar",
  "zip",
  "7z",
  "cab",
  "arj",
  "lzh",
  "tar",
  "gz",
  "ace",
  "uue",
  "bz2",
  "jar",
  "iso"
]);
iconConfig.set(x22, ["txt"]);
iconConfig.set(h2, ["csv"]);
iconConfig.set(C4, ["rvt", "rfa", "rte", "rtf", "dgn", "dwf", "dwg", "ifc", "sat", "skp"]);
iconConfig.set(u7, ["default"]);
var iconMaps = {};
for (const [Icon2, types] of iconConfig.entries()) {
  if (types == null ? void 0 : types.length) {
    for (const type of types) {
      iconMaps[type] = Icon2;
    }
  }
}

// node_modules/vexip-ui/es/components/upload/symbol.mjs
var StatusType = ((StatusType2) => {
  StatusType2["PENDING"] = "pending";
  StatusType2["UPLOADING"] = "uploading";
  StatusType2["FAIL"] = "fail";
  StatusType2["SUCCESS"] = "success";
  StatusType2["DELETE"] = "delete";
  return StatusType2;
})(StatusType || {});
var uploadListTypes = Object.freeze([
  "name",
  "detail",
  "thumbnail",
  "card"
]);

// node_modules/vexip-ui/es/components/upload/upload-file.mjs
var imageExtRE = /\.(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i;
var imageBase64RE = /^data:image\//;
function isImage(file) {
  if (file.type) {
    return file.type.startsWith("image/");
  }
  const { name, url, base64 } = file;
  return !!(imageExtRE.test(name) || url && (imageExtRE.test(url) || imageBase64RE.test(url)) || base64 && imageBase64RE.test(base64));
}
var _sfc_main91 = defineComponent({
  name: "UploadFile",
  components: {
    CollapseTransition,
    Icon,
    Progress,
    Renderer,
    CircleCheck: x2,
    CircleExclamation: $19,
    Spinner: h4,
    EyeR: x20,
    TrashCanR: h6
  },
  props: uploadFileProps,
  emits: [],
  setup(_props) {
    const props = useProps("uploadFile", _props, {
      file: {
        default: () => ({}),
        static: true
      },
      iconRenderer: {
        default: null,
        isFunc: true
      },
      listType: {
        default: "name",
        validator: (value) => uploadListTypes.includes(value)
      },
      loadingText: null,
      selectToAdd: false,
      precision: 2,
      canPreview: {
        default: isImage,
        isFunc: true
      }
    });
    const nh = useNameHelper("upload");
    const useIconRenderer = computed(() => typeof props.iconRenderer === "function");
    const fileName = computed(() => props.file.path || props.file.name);
    const percentage = computed(() => zt(props.file.percentage, props.precision));
    const showThumb = computed(() => isImage(props.file) && (props.file.url || props.file.base64));
    function getFileExtension(file) {
      return file.name.split(".").pop().toLocaleLowerCase();
    }
    function getFileIcon(file) {
      const extension = getFileExtension(file);
      if (extension) {
        return iconMaps[extension] || iconMaps.default;
      }
      return iconMaps.default;
    }
    function handleDelete(file) {
      emitEvent(props.onDelete, file);
    }
    function handlePreview(file) {
      emitEvent(props.onPreview, file);
    }
    function transformfileToBase64(file) {
      if (!file.source)
        return;
      const reader = new FileReader();
      reader.readAsDataURL(file.source);
      reader.onload = () => {
        var _a, _b;
        if (file.status !== StatusType.DELETE) {
          file.base64 = (_b = (_a = reader.result) == null ? void 0 : _a.toString()) != null ? _b : null;
        }
      };
    }
    return {
      props,
      nh,
      locale: useLocale("upload"),
      useIconRenderer,
      fileName,
      percentage,
      showThumb,
      getFileIcon,
      handleDelete,
      handlePreview,
      transformfileToBase64
    };
  }
});
var _hoisted_151 = ["title"];
var _hoisted_223 = { style: { "margin-bottom": "0.3em" } };
var _hoisted_39 = ["src", "alt"];
var _hoisted_45 = ["disabled"];
function _sfc_render91(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Icon = resolveComponent("Icon");
  const _component_CircleCheck = resolveComponent("CircleCheck");
  const _component_CircleExclamation = resolveComponent("CircleExclamation");
  const _component_Spinner = resolveComponent("Spinner");
  const _component_TrashCanR = resolveComponent("TrashCanR");
  const _component_Progress = resolveComponent("Progress");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  const _component_EyeR = resolveComponent("EyeR");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass([
      _ctx.nh.be("file"),
      _ctx.nh.bem("file", _ctx.props.listType),
      _ctx.nh.bem("file", _ctx.props.file.status),
      _ctx.props.inherit && _ctx.nh.bem("file", "inherit")
    ]),
    title: _ctx.fileName,
    tabindex: "-1"
  }, [
    renderSlot(_ctx.$slots, "default", {
      file: _ctx.props.file,
      status: _ctx.props.file.status,
      percentage: _ctx.percentage
    }, () => {
      var _a;
      return [
        _ctx.props.listType === "name" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("label"))
          }, [
            createBaseVNode("div", {
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("file-icon")])
            }, [
              renderSlot(_ctx.$slots, "icon", {
                file: _ctx.props.file
              }, () => [
                _ctx.useIconRenderer ? (openBlock(), createBlock(_component_Renderer, {
                  key: 0,
                  renderer: _ctx.props.iconRenderer,
                  data: { file: _ctx.props.file }
                }, null, 8, ["renderer", "data"])) : (openBlock(), createBlock(_component_Icon, {
                  key: 1,
                  icon: _ctx.getFileIcon(_ctx.props.file)
                }, null, 8, ["icon"]))
              ])
            ], 2),
            createBaseVNode("span", {
              class: normalizeClass(_ctx.nh.be("filename"))
            }, toDisplayString(_ctx.fileName), 3)
          ], 2),
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("actions"))
          }, [
            _ctx.props.file.status === "uploading" ? (openBlock(), createElementBlock("span", {
              key: 0,
              style: { "margin-right": "0.5em" },
              class: normalizeClass(_ctx.nh.be("percentage"))
            }, toDisplayString(`${_ctx.percentage}%`), 3)) : createCommentVNode("", true),
            _ctx.props.file.status === "success" ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("success")])
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_CircleCheck)
                ]),
                _: 1
              })
            ], 2)) : _ctx.props.file.status === "fail" ? (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("fail")])
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_CircleExclamation)
                ]),
                _: 1
              })
            ], 2)) : _ctx.props.file.status === "uploading" ? (openBlock(), createElementBlock("div", {
              key: 3,
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
            }, [
              createVNode(_component_Icon, { pulse: "" }, {
                default: withCtx(() => [
                  createVNode(_component_Spinner)
                ]),
                _: 1
              })
            ], 2)) : createCommentVNode("", true),
            createBaseVNode("button", {
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("close")]),
              onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleDelete(_ctx.props.file))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_TrashCanR)
                ]),
                _: 1
              })
            ], 2)
          ], 2),
          _ctx.props.file.status === "uploading" ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("progress"))
          }, [
            createVNode(_component_Progress, {
              inherit: "",
              "info-type": "none",
              "stroke-width": 2,
              percentage: _ctx.props.file.percentage,
              precision: _ctx.props.precision
            }, null, 8, ["percentage", "precision"])
          ], 2)) : createCommentVNode("", true)
        ], 64)) : _ctx.props.listType === "thumbnail" || _ctx.props.listType === "card" ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("card"))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(_ctx.nh.be("thumbnail"))
          }, [
            _ctx.props.file.status === "uploading" ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              _ctx.props.listType === "thumbnail" ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(_ctx.nh.be("progress"))
              }, [
                createBaseVNode("span", _hoisted_223, toDisplayString((_a = _ctx.props.loadingText) != null ? _a : _ctx.locale.uploading), 1),
                createVNode(_component_Progress, {
                  inherit: "",
                  "info-type": "none",
                  "stroke-width": 2,
                  percentage: _ctx.props.file.percentage,
                  precision: _ctx.props.precision
                }, null, 8, ["percentage", "precision"]),
                createBaseVNode("span", {
                  style: { "margin-top": "3px" },
                  class: normalizeClass(_ctx.nh.be("percentage"))
                }, toDisplayString(`${_ctx.percentage}%`), 3)
              ], 2)) : (openBlock(), createBlock(_component_Icon, {
                key: 1,
                pulse: "",
                scale: 1.8
              }, {
                default: withCtx(() => [
                  createVNode(_component_Spinner)
                ]),
                _: 1
              }, 8, ["scale"]))
            ], 64)) : _ctx.showThumb ? (openBlock(), createElementBlock("img", {
              key: 1,
              class: normalizeClass(_ctx.nh.be("image")),
              src: _ctx.props.file.url || _ctx.props.file.base64 || "",
              alt: _ctx.fileName
            }, null, 10, _hoisted_39)) : (openBlock(), createElementBlock(Fragment, { key: 2 }, [
              createTextVNode(toDisplayString(_ctx.transformfileToBase64(_ctx.props.file)) + " ", 1),
              renderSlot(_ctx.$slots, "icon", {
                file: _ctx.props.file
              }, () => [
                _ctx.useIconRenderer ? (openBlock(), createBlock(_component_Renderer, {
                  key: 0,
                  renderer: _ctx.props.iconRenderer,
                  data: { file: _ctx.props.file }
                }, null, 8, ["renderer", "data"])) : (openBlock(), createBlock(_component_Icon, {
                  key: 1,
                  icon: _ctx.getFileIcon(_ctx.props.file),
                  scale: 2.8
                }, null, 8, ["icon", "scale"]))
              ])
            ], 64))
          ], 2),
          _ctx.props.listType === "card" ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("info"))
          }, [
            createBaseVNode("span", {
              class: normalizeClass(_ctx.nh.be("filename"))
            }, toDisplayString(_ctx.fileName), 3),
            createVNode(_component_CollapseTransition, null, {
              default: withCtx(() => [
                _ctx.props.file.status === "uploading" ? (openBlock(), createElementBlock("div", {
                  key: 0,
                  class: normalizeClass(_ctx.nh.be("progress"))
                }, [
                  createVNode(_component_Progress, {
                    inherit: "",
                    "info-type": "none",
                    "stroke-width": 4,
                    percentage: _ctx.props.file.percentage,
                    precision: _ctx.props.precision
                  }, null, 8, ["percentage", "precision"])
                ], 2)) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ], 2)) : createCommentVNode("", true),
          _ctx.props.listType === "card" || _ctx.props.file.status !== "uploading" ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass(_ctx.nh.be("actions"))
          }, [
            _ctx.props.listType === "thumbnail" ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("mask"))
            }, null, 2)) : createCommentVNode("", true),
            createBaseVNode("button", {
              class: normalizeClass([
                _ctx.nh.be("icon"),
                _ctx.nh.be("action"),
                {
                  [_ctx.nh.bem("action", "disabled")]: !_ctx.props.canPreview(_ctx.props.file)
                }
              ]),
              disabled: !_ctx.props.canPreview(_ctx.props.file),
              onClick: _cache[1] || (_cache[1] = ($event) => _ctx.handlePreview(_ctx.props.file))
            }, [
              createVNode(_component_Icon, { scale: 1.4 }, {
                default: withCtx(() => [
                  createVNode(_component_EyeR)
                ]),
                _: 1
              }, 8, ["scale"])
            ], 10, _hoisted_45),
            createBaseVNode("button", {
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("action")]),
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.handleDelete(_ctx.props.file))
            }, [
              createVNode(_component_Icon, { scale: 1.4 }, {
                default: withCtx(() => [
                  createVNode(_component_TrashCanR)
                ]),
                _: 1
              }, 8, ["scale"])
            ], 2)
          ], 2)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true)
      ];
    })
  ], 10, _hoisted_151);
}
var UploadFile = _export_sfc(_sfc_main91, [["render", _sfc_render91]]);

// node_modules/vexip-ui/es/components/upload/upload-list.mjs
var _sfc_main92 = defineComponent({
  name: "UploadList",
  components: {
    UploadFile
  },
  props: uploadListProps,
  emits: [],
  setup(_props) {
    const props = useProps("uploadList", _props, {
      files: {
        default: () => [],
        static: true
      },
      selectToAdd: false,
      iconRenderer: {
        default: null,
        isFunc: true
      },
      type: {
        default: "name",
        validator: (value) => uploadListTypes.includes(value)
      },
      loadingText: null,
      style: null,
      precision: 2
    });
    const nh = useNameHelper("upload");
    const transitionName = computed(() => nh.ns("fade"));
    function handleDelete(file) {
      emitEvent(props.onDelete, file);
    }
    function handlePreview(file) {
      emitEvent(props.onPreview, file);
    }
    return {
      props,
      nh,
      transitionName,
      handleDelete,
      handlePreview
    };
  }
});
function _sfc_render92(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_UploadFile = resolveComponent("UploadFile");
  return openBlock(), createElementBlock("ul", {
    class: normalizeClass([_ctx.nh.be("files"), _ctx.nh.bs("vars"), _ctx.props.inherit && _ctx.nh.bem("files", "inherit")]),
    style: normalizeStyle(_ctx.props.style)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.props.files, (item) => {
      return openBlock(), createBlock(Transition, {
        key: item.id,
        appear: "",
        name: _ctx.props.selectToAdd ? _ctx.transitionName : void 0
      }, {
        default: withCtx(() => [
          createVNode(_component_UploadFile, {
            inherit: "",
            file: item,
            "icon-renderer": _ctx.props.iconRenderer,
            "list-type": _ctx.props.type,
            "loading-text": _ctx.props.loadingText,
            "select-to-add": _ctx.props.selectToAdd,
            precision: _ctx.props.precision,
            "can-preview": _ctx.props.canPreview,
            onDelete: _ctx.handleDelete,
            onPreview: _ctx.handlePreview
          }, {
            default: withCtx(({ file, status, percentage }) => [
              renderSlot(_ctx.$slots, "item", {
                file,
                status,
                percentage
              })
            ]),
            icon: withCtx(({ file }) => [
              renderSlot(_ctx.$slots, "icon", { file })
            ]),
            _: 2
          }, 1032, ["file", "icon-renderer", "list-type", "loading-text", "select-to-add", "precision", "can-preview", "onDelete", "onPreview"])
        ]),
        _: 2
      }, 1032, ["name"]);
    }), 128)),
    renderSlot(_ctx.$slots, "suffix")
  ], 6);
}
var UploadList = _export_sfc(_sfc_main92, [["render", _sfc_render92]]);

// node_modules/vexip-ui/es/components/upload/request.mjs
function getError(url, xhr) {
  const message = `fail to post ${url} ${xhr.status}'`;
  const error = new Error(message);
  error.response = getBody(xhr);
  error.url = url;
  error.status = xhr.status;
  error.method = "POST";
  return error;
}
function getBody(xhr) {
  const text = xhr.responseText || xhr.response;
  if (!text) {
    return text;
  }
  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}
function upload(options) {
  var _a;
  if (typeof XMLHttpRequest === "undefined") {
    return null;
  }
  const xhr = new XMLHttpRequest();
  const url = options.url;
  if (xhr.upload && options.onProgress) {
    xhr.upload.onprogress = (event) => {
      let percent = 0;
      if (event.total > 0) {
        percent = event.loaded / event.total * 100;
      }
      options.onProgress(percent);
    };
  }
  const formData = new FormData();
  if (options.data) {
    const data = options.data;
    Object.keys(data).forEach((key) => {
      formData.append(key, data[key]);
    });
  }
  formData.append(options.field || "file", options.file);
  options.file.path && formData.append(options.pathField || "path", options.file.path);
  if (options.onError) {
    xhr.onerror = () => {
      options.onError(getError(url, xhr));
    };
  }
  xhr.onload = () => {
    var _a2;
    if (xhr.status < 200 || xhr.status >= 300) {
      if (options.onError) {
        options.onError(getError(url, xhr));
      }
      return;
    }
    const body = getBody(xhr);
    (_a2 = options.onSuccess) == null ? void 0 : _a2.call(options, body);
  };
  if (options.onAbort) {
    xhr.onabort = () => {
      options.onAbort();
    };
  }
  xhr.open("POST", url, true);
  if (options.withCredentials && "withCredentials" in xhr) {
    xhr.withCredentials = true;
  }
  const headers = (_a = options.headers) != null ? _a : {};
  Object.keys(headers).forEach((header) => {
    if (Ge(headers, header) && y(headers[header])) {
      xhr.setRequestHeader(header, headers[header]);
    }
  });
  xhr.send(formData);
  return xhr;
}

// node_modules/vexip-ui/es/components/upload/upload.mjs
function getDefaultFileState() {
  return {
    id: dn(),
    name: "",
    size: 0,
    type: "",
    base64: null,
    status: StatusType.PENDING,
    percentage: 0,
    source: null,
    url: null,
    path: "",
    xhr: null,
    response: null,
    error: null
  };
}
var Upload = defineComponent({
  name: "Upload",
  components: {
    Button,
    Icon,
    UploadList,
    CloudArrowUp: x5
  },
  props: uploadProps,
  emits: ["update:file-list"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a, _b;
      if ((_a = button.value) == null ? void 0 : _a.$el) {
        button.value.$el.focus();
      } else {
        (_b = panel.value) == null ? void 0 : _b.focus();
      }
    });
    const props = useProps("upload", _props, {
      state: createStateProp(state),
      url: {
        default: "",
        static: true
      },
      fileList: {
        default: () => getFieldValue([]),
        static: true
      },
      multiple: false,
      tip: "",
      accept: null,
      filter: "",
      maxSize: {
        default: null,
        validator: (value) => value >= 0
      },
      field: "file",
      data: () => ({}),
      headers: () => ({}),
      withCredentials: false,
      manual: false,
      hiddenFiles: false,
      countLimit: {
        default: 0,
        validator: (value) => value >= 0
      },
      allowDrag: false,
      onBeforeUpload: {
        default: null,
        isFunc: true
      },
      onBeforeSelect: {
        default: null,
        isFunc: true
      },
      iconRenderer: {
        default: null,
        isFunc: true
      },
      selectToAdd: false,
      listType: {
        default: "name",
        validator: (value) => uploadListTypes.includes(value)
      },
      block: false,
      loadingText: null,
      directory: false,
      pathField: "path",
      disabledClick: false,
      buttonLabel: null,
      disabled: () => disabled.value,
      loading: () => loading.value,
      loadingIcon: h4,
      loadingLock: false,
      loadingSpin: false,
      defaultFiles: () => [],
      listStyle: null
    });
    const nh = useNameHelper("upload");
    const locale = useLocale("upload");
    const fileStates = ref([]);
    const isDragOver = ref(false);
    const input = ref();
    const button = ref();
    const panel = ref();
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), nh.bm(`type-${props.listType}`), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.state)]: props.state !== "default",
        [nh.bm("multiple")]: props.multiple,
        [nh.bm("drag")]: props.allowDrag,
        [nh.bm("to-add")]: props.selectToAdd,
        [nh.bm("block")]: props.block,
        [nh.bm("drag-only")]: props.disabledClick,
        [nh.bm("image")]: props.image,
        [nh.bm("has-file")]: !props.hiddenFiles && renderFiles.value.length
      }];
    });
    const controlClass = computed(() => {
      if (props.image) {
        return {
          [nh.be("image-control")]: true,
          [nh.bem("image-control", "drag-over")]: isDragOver.value,
          [nh.bem("image-control", "disabled")]: props.disabled
        };
      }
      return {
        [nh.be("control")]: true,
        [nh.bem("control", "drag-over")]: isDragOver.value
      };
    });
    const acceptString = computed(() => {
      if (props.image)
        return "image/*";
      const accept = props.accept;
      return accept && (typeof accept === "string" ? accept : accept.join());
    });
    const defaultList = computed(() => props.defaultFiles.map((file) => createFileState(file)));
    const renderFiles = computed(() => {
      return defaultList.value.concat(fileStates.value).filter((item) => item.status !== StatusType.DELETE);
    });
    watch(() => props.fileList, (value) => {
      const idMap = /* @__PURE__ */ new Map();
      const fileMap = /* @__PURE__ */ new Map();
      for (const state2 of fileStates.value) {
        if (y(state2.id)) {
          idMap.set(state2.id, state2);
        }
        if (state2.source) {
          fileMap.set(state2.source, state2);
        }
      }
      fileStates.value = (value || []).map((file) => createFileState(file, file.id ? idMap.get(file.id) : file.source ? fileMap.get(file.source) : void 0));
      syncInputFiles();
    }, {
      immediate: true,
      deep: true
    });
    expose({
      execute,
      handleDelete
    });
    function handleClick() {
      var _a;
      !props.disabledClick && ((_a = input.value) == null ? void 0 : _a.click());
    }
    function handleKeyDown(event) {
      const key = event.code || event.key;
      if (key === "Enter" || key === "Space") {
        handleClick();
      }
    }
    function handleInputChange(event) {
      const target = event.target;
      if (target == null ? void 0 : target.files) {
        handleFilesChange(target.files);
      }
    }
    async function handleFilesChange(inputFiles) {
      const originFiles = Array.from(inputFiles || []);
      const shouldAdd = props.selectToAdd;
      const files = shouldAdd ? Array.from(fileStates.value) : [];
      for (const file of originFiles) {
        if (!file.path) {
          file.path = file.webkitRelativePath;
        }
        let fileState = getFileStateBySource(file);
        if (fileState) {
          if (fileState.status !== StatusType.SUCCESS && fileState.status !== StatusType.UPLOADING) {
            fileState.status = StatusType.PENDING;
          }
        } else {
          fileState = createFileState({
            name: file.name,
            size: file.size,
            type: file.type,
            source: file
          });
        }
        if (typeof props.onBeforeSelect === "function") {
          let result = props.onBeforeSelect(fileState, files);
          if (Je(result)) {
            result = await result;
          }
          if (Qe(result))
            continue;
        }
        if (!files.includes(fileState)) {
          files.push(fileState);
        }
      }
      const countLimit = props.countLimit;
      if (countLimit > 0 && files.length > countLimit) {
        const exceedFiles = files.slice(countLimit);
        emitEvent(props.onExceed, exceedFiles);
        fileStates.value = files.slice(0, countLimit);
      } else {
        fileStates.value = files;
      }
      syncInputFiles();
      emitChangeEvent();
      if (!props.manual) {
        execute();
      }
    }
    function emitChangeEvent() {
      setFieldValue(fileStates.value);
      emitEvent(props.onChange, fileStates.value);
      emit("update:file-list", fileStates.value);
      validateField();
    }
    function getFileStateBySource(file) {
      const {
        name,
        size: size2,
        type
      } = file;
      const path = file.path || file.webkitRelativePath;
      return fileStates.value.find(({
        source
      }) => {
        return source && (source.path || source.webkitRelativePath) === path && source.name === name && source.size === size2 && source.type === type;
      });
    }
    function createFileState(file, defaults = getDefaultFileState()) {
      var _a;
      const {
        id: id2,
        name,
        size: size2,
        type,
        base64,
        status,
        percentage,
        source,
        url,
        path
      } = file;
      Object.assign(defaults, {
        id: (_a = id2 != null ? id2 : defaults.id) != null ? _a : dn(),
        name: name || "",
        size: size2 || 0,
        type: type || "",
        base64: base64 || null,
        status: status != null ? status : StatusType.PENDING,
        percentage: percentage || 0,
        source: source || null,
        url: url || null,
        path: path || "",
        xhr: null,
        response: null,
        error: null
      });
      return defaults;
    }
    function getFileExtension(file) {
      return file.name.split(".").pop().toLocaleLowerCase();
    }
    async function execute() {
      if (!props.url || !verifyFiles()) {
        return false;
      }
      const uploadFiles = fileStates.value.filter((item) => item.status !== StatusType.SUCCESS && item.status !== StatusType.DELETE);
      const requests = [];
      for (const file of uploadFiles) {
        requests.push(uploadFile(file).catch(cn));
      }
      return await Promise.all(requests).then((responses) => responses.filter((response) => response));
    }
    async function uploadFile(file) {
      if (typeof props.onBeforeUpload === "function") {
        let result = props.onBeforeUpload(file, fileStates.value.filter((item) => item.status !== StatusType.SUCCESS && item.status !== StatusType.DELETE));
        if (Je(result)) {
          try {
            result = await result;
          } catch (e) {
            return;
          }
        }
        if (Qe(result))
          return;
        if (result instanceof Blob) {
          if (result instanceof File) {
            file.source = result;
          } else {
            file.source = new File([result], file.name, {
              type: file.type
            });
          }
        }
      }
      if (!file.source)
        return;
      file.status = StatusType.UPLOADING;
      const {
        url,
        headers,
        withCredentials,
        data,
        field,
        pathField
      } = props;
      return await new Promise((resolve, reject) => {
        file.xhr = upload({
          url,
          headers,
          withCredentials,
          data,
          field,
          pathField,
          file: file.source,
          onProgress: (percent) => {
            handleProgress(percent, file);
          },
          onSuccess: (response) => {
            handleSuccess(response, file);
            resolve(response);
          },
          onError: (error) => {
            handleError(error, file);
            reject(error);
          },
          onAbort: () => {
            resolve(null);
          }
        });
      });
    }
    function verifyFiles() {
      const limitSize = props.maxSize ? props.maxSize * 1024 : Infinity;
      const filter = typeof props.filter === "string" ? props.filter ? [props.filter] : [] : props.filter.filter((item) => item);
      for (let i = 0, len = fileStates.value.length; i < len; ++i) {
        const file = fileStates.value[i];
        const extension = getFileExtension(file);
        if (filter.length && !filter.includes(extension)) {
          emitEvent(props.onFilterError, file);
          return false;
        }
        if (file.size > limitSize) {
          emitEvent(props.onSizeError, file);
          return false;
        }
      }
      return true;
    }
    function handleDelete(file) {
      file.status = StatusType.DELETE;
      if (file.xhr) {
        file.xhr.abort();
      }
      syncInputFiles();
      emitEvent(props.onDelete, file);
      emitChangeEvent();
    }
    function handlePreview(file) {
      emitEvent(props.onPreview, file);
    }
    function syncInputFiles() {
      if (!V)
        return;
      const dataTransfer = new DataTransfer();
      fileStates.value = fileStates.value.filter((item) => item.status !== StatusType.DELETE);
      fileStates.value.forEach((item) => {
        item.source && dataTransfer.items.add(item.source);
      });
      if (input.value) {
        input.value.files = dataTransfer.files;
      }
    }
    function handleProgress(percent, file) {
      if (file.status === StatusType.DELETE)
        return;
      file.percentage = percent;
      emitEvent(props.onProgress, file, percent);
      emitChangeEvent();
    }
    function handleSuccess(response, file) {
      if (file.status === StatusType.DELETE)
        return;
      file.status = StatusType.SUCCESS;
      file.response = response;
      file.error = null;
      emitEvent(props.onSuccess, file, response);
      emitChangeEvent();
    }
    function handleError(error, file) {
      if (file.status === StatusType.DELETE)
        return;
      file.status = StatusType.FAIL;
      file.error = error;
      emitEvent(props.onError, file, error);
      emitChangeEvent();
    }
    let dragTimer;
    onBeforeUnmount(() => {
      clearTimeout(dragTimer);
    });
    async function handleDrop(event) {
      if (!props.allowDrag)
        return;
      clearTimeout(dragTimer);
      event.preventDefault();
      isDragOver.value = false;
      if (event.dataTransfer) {
        const files = await collectDropFiles(event.dataTransfer);
        files.length && handleFilesChange(files);
      }
    }
    function handleDragEnter(event) {
      if (!props.allowDrag)
        return;
      clearTimeout(dragTimer);
      event.preventDefault();
      isDragOver.value = true;
    }
    function handleDragLeave(event) {
      if (!props.allowDrag)
        return;
      event.preventDefault();
      dragTimer = setTimeout(() => {
        isDragOver.value = false;
      }, 100);
    }
    async function collectDropFiles(dataTransfer) {
      var _a, _b;
      const {
        items,
        files
      } = dataTransfer;
      if (!items.length)
        return [];
      const collectedFiles = [];
      const dirLoop = [];
      const processes = [];
      for (let i = 0, len = items.length; i < len; ++i) {
        const entity = (_b = (_a = items[i]).webkitGetAsEntry) == null ? void 0 : _b.call(_a);
        if (!entity)
          return files;
        if (entity.isFile) {
          collectedFiles.push(files[i]);
        } else {
          dirLoop.push({
            dir: entity,
            prefix: ""
          });
        }
      }
      if (!props.directory || !dirLoop.length)
        return collectedFiles;
      const fileEntries = [];
      let countLimit = props.countLimit - (props.selectToAdd ? fileStates.value.length : 0);
      countLimit = Math.round(countLimit) > 0 ? countLimit : 100;
      const doProcess = () => {
        while (dirLoop.length) {
          const loop = dirLoop.shift();
          const dir = loop.dir;
          const prefix = loop.prefix ? `${loop.prefix}/${dir.name}` : dir.name;
          const reader = dir.createReader();
          processes.push(new Promise((resolve) => {
            reader.readEntries((entries) => {
              entries.forEach((entry) => {
                if (entry.isFile) {
                  fileEntries.push({
                    entry,
                    prefix
                  });
                } else {
                  dirLoop.push({
                    dir: entry,
                    prefix
                  });
                }
              });
              resolve();
            });
          }));
        }
      };
      while (true) {
        doProcess();
        await Promise.all(processes);
        if (!dirLoop.length || fileEntries.length >= countLimit) {
          break;
        }
      }
      if (fileEntries.length > 0) {
        return collectedFiles.concat(await Promise.all(fileEntries.map(({
          entry,
          prefix
        }) => new Promise((resolve) => entry.file((file) => {
          file.path = `${prefix}/${file.name}`;
          resolve(file);
        })))));
      }
      return collectedFiles;
    }
    function renderNormalAction() {
      return !props.allowDrag && !props.disabledClick ? createVNode(Fragment, null, [createVNode(Button, {
        "ref": button,
        "inherit": true,
        "size": size.value,
        "icon": x14,
        "type": props.state,
        "disabled": props.disabled,
        "loading": props.loading,
        "loading-icon": props.loadingIcon,
        "loading-spin": props.loadingSpin
      }, {
        default: () => {
          var _a;
          return [(_a = props.buttonLabel) != null ? _a : locale.value.upload];
        }
      }), slots.tip ? slots.tip() : props.tip && createVNode("p", {
        "class": nh.be("tip")
      }, [props.tip])]) : createVNode("div", {
        "ref": panel,
        "class": [nh.be("drag-panel"), props.disabled && nh.bem("drag-panel", "disabled")],
        "tabindex": 0
      }, [createVNode(Icon, {
        "class": [nh.be("cloud"), props.disabled && nh.bem("cloud", "disabled")],
        "scale": 4
      }, {
        default: () => [createVNode(x5, null, null)]
      }), slots.tip ? slots.tip() : createVNode("p", {
        "class": nh.be("tip")
      }, [props.tip || locale.value.dragOrClick]), createVNode(Icon, {
        "class": nh.be("loading-icon"),
        "spin": props.loadingSpin,
        "pulse": !props.loadingSpin,
        "icon": props.loadingIcon,
        "style": {
          opacity: props.loading ? "100%" : "0%"
        }
      }, null)]);
    }
    function renderImageAction() {
      var _a;
      return createVNode("div", {
        "class": [nh.be("image-action"), props.disabled && nh.bem("image-action", "disabled")]
      }, [slots.default ? slots.default({
        isDragOver: (props.allowDrag || props.disabledClick) && isDragOver.value
      }) : createVNode(Fragment, null, [props.loading ? createVNode(Icon, {
        "class": nh.be("loading-icon"),
        "spin": props.loadingSpin,
        "pulse": !props.loadingSpin,
        "icon": props.loadingIcon,
        "style": {
          marginBottom: "6px"
        }
      }, null) : createVNode(Icon, {
        "class": [nh.be("cloud"), props.disabled && nh.bem("cloud", "disabled")],
        "scale": 1.2,
        "style": {
          marginBottom: "6px"
        }
      }, {
        default: () => [createVNode(x10, null, null)]
      }), createVNode("span", null, [(_a = props.buttonLabel) != null ? _a : locale.value.upload])])]);
    }
    function renderControl() {
      const HtmlTag = props.image ? "li" : "div";
      return createVNode(HtmlTag, {
        "class": controlClass.value,
        "tabindex": -1,
        "onClick": handleClick,
        "onDrop": handleDrop,
        "onDragover": handleDragEnter,
        "onDragleave": handleDragLeave,
        "onKeydown": handleKeyDown
      }, {
        default: () => [!props.disabledClick && createVNode("input", {
          "ref": input,
          "type": "file",
          "class": nh.be("input"),
          "disabled": props.disabled,
          "multiple": props.multiple,
          "accept": acceptString.value,
          "webkitdirectory": props.directory,
          "onChange": handleInputChange
        }, null), props.image ? renderImageAction() : slots.default ? slots.default({
          isDragOver: (props.allowDrag || props.disabledClick) && isDragOver.value
        }) : renderNormalAction()]
      });
    }
    function renderFileList() {
      return createVNode(UploadList, {
        "inherit": true,
        "files": renderFiles.value,
        "select-to-add": props.selectToAdd,
        "type": props.image ? "thumbnail" : props.listType,
        "icon-renderer": props.iconRenderer,
        "loading-text": props.loadingText,
        "can-preview": props.canPreview,
        "style": props.listStyle,
        "onDelete": handleDelete,
        "onPreview": handlePreview
      }, {
        item: slots.item,
        icon: slots.icon,
        suffix: () => props.image && (!props.maxSize || renderFiles.value.length < props.maxSize) ? renderControl() : null
      });
    }
    return () => createVNode("div", {
      "id": idFor.value,
      "class": className.value
    }, [!props.image && renderControl(), !props.hiddenFiles && renderFileList()]);
  },
  methods: {
    execute: cn,
    handleDelete: cn
  }
});

// node_modules/vexip-ui/es/components/viewer/props.mjs
var viewerProps = buildProps({
  width: [String, Number],
  height: [String, Number],
  moveDisabled: booleanProp,
  zoomDisabled: booleanProp,
  zoomDelta: Number,
  zoomMin: Number,
  zoomMax: Number,
  flipDisabled: booleanProp,
  rotateDisabled: booleanProp,
  rotateDelta: Number,
  fullDisabled: booleanProp,
  toolbarPlacement: String,
  actions: Array,
  toolbarFade: booleanNumberProp,
  noTransition: booleanProp,
  onMoveStart: eventProp(),
  onMove: eventProp(),
  onMoveEnd: eventProp(),
  onWheel: eventProp(),
  onRotate: eventProp(),
  onFlipX: eventProp(),
  onFlipY: eventProp(),
  onZoom: eventProp(),
  onFull: eventProp(),
  onReset: eventProp()
});

// node_modules/vexip-ui/es/components/viewer/symbol.mjs
var InternalActionName = ((InternalActionName2) => {
  InternalActionName2["RotateRight"] = "rotateRight";
  InternalActionName2["RotateLeft"] = "rotateLeft";
  InternalActionName2["FlipHorizontal"] = "flipHorizontal";
  InternalActionName2["FlipVertical"] = "flipVertical";
  InternalActionName2["ZoomIn"] = "zoomIn";
  InternalActionName2["ZoomOut"] = "zoomOut";
  InternalActionName2["FullScreen"] = "fullScreen";
  InternalActionName2["FullScreenExit"] = "fullScreenExit";
  InternalActionName2["Reset"] = "reset";
  return InternalActionName2;
})(InternalActionName || {});

// node_modules/vexip-ui/es/components/viewer/viewer.mjs
var _sfc_main93 = defineComponent({
  name: "Viewer",
  components: {
    Divider,
    Icon,
    Renderer
  },
  props: viewerProps,
  emits: [],
  setup(_props) {
    const props = useProps("viewer", _props, {
      width: "100%",
      height: "100%",
      moveDisabled: false,
      zoomDisabled: false,
      zoomDelta: 0.15,
      zoomMin: 0.1,
      zoomMax: Infinity,
      rotateDisabled: false,
      rotateDelta: 90,
      flipDisabled: false,
      fullDisabled: false,
      toolbarPlacement: "bottom",
      actions: () => [],
      toolbarFade: false,
      noTransition: false
    });
    const nh = useNameHelper("viewer");
    const locale = useLocale("viewer");
    const { timer: timer2 } = $o();
    const toolbarActive = ref(false);
    const zoom = ref(1);
    const rotate = ref(0);
    const flipX = ref(false);
    const flipY = ref(false);
    const transition = ref();
    const {
      supported: fullSupported,
      target: viewer,
      full,
      enter: enterFull,
      exit: exitFull
    } = Mo();
    const {
      target: container,
      x: currentLeft,
      y: currentTop,
      moving
    } = jo({
      onStart: (_, event) => {
        if (props.moveDisabled || event.button > 0) {
          return false;
        }
        emitEvent(props.onMoveStart, getState());
      },
      onMove: () => {
        emitEvent(props.onMoveStart, getState());
      },
      onEnd: () => {
        emitEvent(props.onMoveStart, getState());
      }
    });
    const state = reactive({
      zoom,
      rotate,
      flipX,
      flipY,
      full,
      moving,
      x: currentLeft,
      y: currentTop
    });
    const zoomOrigin = {
      x: 0,
      y: 0
    };
    No({
      target: viewer,
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.up || modifier.down || modifier.left || modifier.right) {
          event.preventDefault();
          const current = modifier.up || modifier.down ? currentTop : currentLeft;
          const step = modifier.up || modifier.left ? -10 : 10;
          current.value += event.ctrlKey ? 5 * step : step;
          modifier.resetAll();
        }
      }
    });
    function getState() {
      return state;
    }
    function getActionProp(action, prop) {
      const value = action[prop];
      return typeof value === "function" ? value(state) : value;
    }
    const internalActions = [
      {
        name: InternalActionName.RotateRight,
        icon: $9,
        process: () => handleRotate(props.rotateDelta),
        title: () => locale.value.rotateRight,
        hidden: () => props.rotateDisabled
      },
      {
        name: InternalActionName.RotateLeft,
        icon: C2,
        process: () => handleRotate(-1 * props.rotateDelta),
        title: () => locale.value.rotateLeft,
        hidden: () => props.rotateDisabled,
        divided: true
      },
      {
        name: InternalActionName.FlipHorizontal,
        icon: x11,
        process: () => toggleFlipHorizontal(),
        title: () => locale.value.flipHorizontal,
        hidden: () => props.flipDisabled
      },
      {
        name: InternalActionName.FlipVertical,
        icon: x11,
        process: () => toggleFlipVertical(),
        title: () => locale.value.flipVertical,
        hidden: () => props.flipDisabled,
        iconStyle: "transform: rotate(90deg)",
        divided: true
      },
      {
        name: InternalActionName.ZoomIn,
        icon: x10,
        process: () => handleZoom(props.zoomDelta),
        title: () => locale.value.zoomIn,
        hidden: () => props.zoomDisabled
      },
      {
        name: InternalActionName.ZoomOut,
        icon: $22,
        process: () => handleZoom(-1 * props.zoomDelta),
        title: () => locale.value.zoomOut,
        hidden: () => props.zoomDisabled,
        divided: true
      },
      {
        name: InternalActionName.FullScreen,
        icon: x7,
        process: () => toggleFull(true),
        title: () => locale.value.fullScreen,
        hidden: () => props.fullDisabled || full.value,
        divided: true
      },
      {
        name: InternalActionName.FullScreenExit,
        icon: C3,
        process: () => toggleFull(false),
        title: () => locale.value.fullScreenExit,
        hidden: () => props.fullDisabled || !full.value,
        divided: true
      },
      {
        name: InternalActionName.Reset,
        icon: v,
        process: handleReset,
        title: () => locale.value.reset,
        divided: true
      }
    ];
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("draggable")]: !props.moveDisabled,
        [nh.bm("resizable")]: !props.zoomDisabled,
        [nh.bm("full")]: full.value,
        [nh.bm("moving")]: moving.value,
        [nh.bm("static")]: props.noTransition
      };
    });
    const style = computed(() => {
      return {
        width: /\d$/.test(`${props.width}`) ? `${props.width}px` : props.width,
        height: /\d$/.test(`${props.height}`) ? `${props.height}px` : props.height
      };
    });
    const toolbarVertical = computed(() => {
      const [layout] = props.toolbarPlacement.split("-");
      return layout === "left" || layout === "right";
    });
    const toolbarClass = computed(() => {
      return {
        [nh.be("toolbar")]: true,
        [nh.bem("toolbar", "active")]: props.toolbarFade < 300 || toolbarActive.value,
        [nh.bem("toolbar", props.toolbarPlacement)]: true,
        [nh.bem("toolbar", "vertical")]: toolbarVertical.value
      };
    });
    const contentStyle = computed(() => {
      return {
        transform: `translate3d(${currentLeft.value}px, ${currentTop.value}px, 0) scale(${zoom.value})`
      };
    });
    const transitionStyle = computed(() => {
      return {
        transform: `scaleX(${flipX.value ? -1 : 1}) scaleY(${flipY.value ? -1 : 1}) rotate(${rotate.value}deg)`
      };
    });
    const allActions = computed(() => {
      const map = /* @__PURE__ */ new Map();
      internalActions.concat(props.actions).forEach((action) => {
        if (action.name) {
          map.set(action.name, action);
        }
      });
      return Array.from(map.values());
    });
    onMounted(() => {
      if (container.value) {
        const rect = container.value.getBoundingClientRect();
        zoomOrigin.x = rect.left + rect.width * 0.5;
        zoomOrigin.y = rect.top + rect.height * 0.5;
      }
    });
    function handleWheel(event) {
      event.stopPropagation();
      event.preventDefault();
      const sign = event.deltaY > 0 ? -1 : 1;
      zoomOrigin.x = event.clientX;
      zoomOrigin.y = event.clientY;
      emitEvent(props.onWheel, sign, state);
      handleZoom(sign * props.zoomDelta);
    }
    function handleRotate(deg) {
      if (props.rotateDisabled) {
        return;
      }
      rotate.value += deg;
      if (props.noTransition && rotate.value % 360 === 0) {
        rotate.value = 0;
      }
      emitEvent(props.onRotate, deg, state);
    }
    function toggleFlipHorizontal(target = !flipX.value) {
      if (props.flipDisabled) {
        return;
      }
      flipX.value = target;
      emitEvent(props.onFlipX, target, state);
    }
    function toggleFlipVertical(target = !flipY.value) {
      if (props.flipDisabled) {
        return;
      }
      flipY.value = target;
      emitEvent(props.onFlipY, target, state);
    }
    function handleZoom(ratio) {
      if (props.zoomDisabled || !container.value) {
        return;
      }
      const containerRect = container.value.getBoundingClientRect();
      const { x: x24, y: y2 } = zoomOrigin;
      const { offsetWidth, offsetHeight } = container.value;
      const prveZoom = zoom.value;
      zoom.value = zt(Fn(zoom.value + ratio, props.zoomMin, props.zoomMax), 5);
      const delta = zoom.value / prveZoom - 1;
      const originX = delta * offsetWidth * 0.5;
      const originY = delta * offsetHeight * 0.5;
      currentLeft.value -= delta * (x24 - containerRect.left - currentLeft.value) - originX;
      currentTop.value -= delta * (y2 - containerRect.top - currentTop.value) - originY;
      emitEvent(props.onZoom, zoom.value, state);
    }
    async function toggleFull(target = !full.value) {
      target ? await enterFull() : await exitFull();
      emitEvent(props.onFull, target, state);
    }
    function handleReset() {
      currentTop.value = 0;
      currentLeft.value = 0;
      rotate.value = 0;
      flipX.value = false;
      flipY.value = false;
      zoom.value = 1;
      emitEvent(props.onReset, state);
    }
    function normalizeProps2() {
      const queue = [];
      if (rotate.value % 360 === 0) {
        queue.push(
          () => {
            if (transition.value) {
              transition.value.style.transitionDuration = "0ms";
            }
          },
          () => {
            rotate.value = 0;
          },
          () => {
            if (transition.value) {
              transition.value.style.transitionDuration = "";
            }
          }
        );
      }
      const run = () => {
        var _a;
        (_a = queue.shift()) == null ? void 0 : _a();
        queue.length && requestAnimationFrame(run);
      };
      run();
    }
    function handleEnterToolbar() {
      clearTimeout(timer2.toolbarFade);
      toolbarActive.value = true;
    }
    function handleLeaveToolbar() {
      clearTimeout(timer2.toolbarFade);
      const fade = typeof props.toolbarFade === "number" ? props.toolbarFade : props.toolbarFade ? 1500 : 0;
      if (fade > 0) {
        timer2.toolbarFade = setTimeout(() => {
          toolbarActive.value = false;
        }, fade);
      }
    }
    return {
      props,
      nh,
      moving,
      fullSupported,
      state,
      viewer,
      container,
      transition,
      className,
      style,
      toolbarVertical,
      toolbarClass,
      contentStyle,
      transitionStyle,
      allActions,
      getActionProp,
      handleWheel,
      handleRotate,
      toggleFlipHorizontal,
      toggleFlipVertical,
      handleZoom,
      toggleFull,
      handleReset,
      normalizeProps: normalizeProps2,
      handleEnterToolbar,
      handleLeaveToolbar
    };
  }
});
var _hoisted_152 = ["title", "onClick"];
function _sfc_render93(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Icon = resolveComponent("Icon");
  const _component_Divider = resolveComponent("Divider");
  return openBlock(), createElementBlock("div", {
    ref: "viewer",
    class: normalizeClass(_ctx.className),
    tabindex: "0",
    style: normalizeStyle(_ctx.style)
  }, [
    createBaseVNode("div", {
      ref: "container",
      class: normalizeClass(_ctx.nh.be("container")),
      onWheel: _cache[1] || (_cache[1] = (...args) => _ctx.handleWheel && _ctx.handleWheel(...args))
    }, [
      createBaseVNode("div", {
        class: normalizeClass(_ctx.nh.be("content")),
        style: normalizeStyle(_ctx.contentStyle)
      }, [
        createBaseVNode("div", {
          ref: "transition",
          class: normalizeClass(_ctx.nh.be("transition")),
          style: normalizeStyle(_ctx.transitionStyle),
          onTransitionend: _cache[0] || (_cache[0] = (...args) => _ctx.normalizeProps && _ctx.normalizeProps(...args))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 38)
      ], 6)
    ], 34),
    createBaseVNode("div", {
      class: normalizeClass(_ctx.toolbarClass),
      role: "toolbar",
      onMouseenter: _cache[2] || (_cache[2] = (...args) => _ctx.handleEnterToolbar && _ctx.handleEnterToolbar(...args)),
      onMouseleave: _cache[3] || (_cache[3] = (...args) => _ctx.handleLeaveToolbar && _ctx.handleLeaveToolbar(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.allActions, (action) => {
        return openBlock(), createElementBlock(Fragment, {
          key: action.name
        }, [
          !_ctx.getActionProp(action, "hidden") ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            createBaseVNode("button", {
              class: normalizeClass({
                [_ctx.nh.be("action")]: true,
                [_ctx.nh.bem("action", "disabled")]: _ctx.getActionProp(action, "disabled")
              }),
              title: _ctx.getActionProp(action, "title"),
              onClick: withModifiers(($event) => action.process(_ctx.state), ["stop"])
            }, [
              typeof action.icon === "function" ? (openBlock(), createBlock(_component_Renderer, {
                key: 0,
                renderer: action.icon,
                data: { state: _ctx.state }
              }, null, 8, ["renderer", "data"])) : (openBlock(), createBlock(_component_Icon, {
                key: 1,
                icon: action.icon,
                style: normalizeStyle(_ctx.getActionProp(action, "iconStyle")),
                scale: _ctx.getActionProp(action, "iconScale") || 1
              }, null, 8, ["icon", "style", "scale"]))
            ], 10, _hoisted_152),
            _ctx.getActionProp(action, "divided") ? (openBlock(), createBlock(_component_Divider, {
              key: 0,
              inherit: "",
              vertical: !_ctx.toolbarVertical
            }, null, 8, ["vertical"])) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true)
        ], 64);
      }), 128))
    ], 34)
  ], 6);
}
var Viewer = _export_sfc(_sfc_main93, [["render", _sfc_render93]]);

// node_modules/vexip-ui/es/components/typography/props.mjs
var textProps = buildProps({
  type: String,
  tag: String,
  delete: booleanProp,
  strong: booleanProp,
  italic: booleanProp,
  underline: booleanProp,
  code: booleanProp,
  mark: booleanProp,
  disabled: booleanProp,
  keyboard: booleanProp,
  thin: booleanProp,
  reversed: booleanProp
});
var pProps = omitProps(textProps, ["tag", "code"]);
var strongProps = omitProps(textProps, ["tag", "strong", "code"]);
var titleProps = buildProps({
  type: String,
  level: Number,
  top: booleanProp,
  marker: booleanProp,
  aligned: booleanProp,
  thin: booleanProp,
  markerType: String
});
var hProps = omitProps(titleProps, ["level"]);
var blockquoteProps = buildProps({
  type: String
});
var olProps = buildProps({
  type: String
});
var ulProps = buildProps({
  listStyle: String
});

// node_modules/vexip-ui/es/components/typography/title.mjs
var Title = defineComponent({
  name: "Title",
  props: titleProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const props = useProps("title", _props, {
      type: "default",
      level: 5,
      top: false,
      marker: false,
      aligned: false,
      thin: false,
      markerType: null
    });
    const nh = useNameHelper("title");
    const coloredMarker = computed(() => gn(props.markerType));
    const markerType = computed(() => props.markerType || props.type);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.type)]: props.type !== "default",
        [nh.bm("top")]: props.top,
        [nh.bm("marker")]: props.marker,
        [nh.bm("aligned")]: props.aligned,
        [nh.bm("thin")]: props.thin,
        [nh.bm(`marker-${markerType.value}`)]: !coloredMarker.value && markerType.value !== "default"
      };
    });
    const level = computed(() => Fn(Math.round(props.level), 1, 6) || 5);
    const style = computed(() => {
      return coloredMarker.value ? {
        [nh.cv("marker-color")]: props.markerType
      } : null;
    });
    return () => {
      const CustomTag = `h${level.value}`;
      return createVNode(CustomTag, {
        "class": className.value,
        "style": style.value
      }, {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      });
    };
  }
});

// node_modules/vexip-ui/es/components/typography/text.mjs
function _isSlot4(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var Text = defineComponent({
  name: "Text",
  props: textProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const props = useProps("text", _props, {
      type: "default",
      tag: "span",
      delete: false,
      strong: false,
      italic: false,
      underline: false,
      code: false,
      reversed: false
    });
    const nh = useNameHelper("text");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.type)]: props.type !== "default",
        [nh.bm("delete")]: props.delete,
        [nh.bm("strong")]: props.strong,
        [nh.bm("italic")]: props.italic,
        [nh.bm("underline")]: props.underline,
        [nh.bm("code")]: props.code,
        [nh.bm("mark")]: props.mark,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("keyboard")]: props.keyboard,
        [nh.bm("thin")]: props.thin,
        [nh.bm("reversed")]: props.reversed
      };
    });
    return () => {
      var _a;
      const CustomTag = props.tag || "span";
      const children = (_a = slots.default) == null ? void 0 : _a.call(slots);
      return props.code ? createVNode("code", {
        "class": className.value
      }, [props.delete ? createVNode("del", null, [children]) : children]) : props.delete ? createVNode("del", {
        "class": className.value
      }, [children]) : createVNode(CustomTag, {
        "class": className.value
      }, _isSlot4(children) ? children : {
        default: () => [children]
      });
    };
  }
});

// node_modules/vexip-ui/es/components/typography/blockquote.mjs
var Blockquote = defineComponent({
  name: "Blockquote",
  props: blockquoteProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const props = useProps("blockquote", _props, {
      type: "default"
    });
    const nh = useNameHelper("blockquote");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.type)]: props.type !== "default"
      };
    });
    return () => {
      var _a;
      return createVNode("blockquote", {
        "class": className.value
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});

// node_modules/vexip-ui/es/components/typography/ol.mjs
var OL = defineComponent({
  name: "OL",
  props: olProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const props = useProps("ol", _props, {
      type: "1"
    });
    const nh = useNameHelper("ol");
    return () => {
      var _a;
      return createVNode("ol", {
        "class": [nh.b(), props.inherit && nh.bm("inherit")],
        "type": props.type
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});

// node_modules/vexip-ui/es/components/typography/ul.mjs
var UL = defineComponent({
  name: "UL",
  props: ulProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const props = useProps("ul", _props, {
      listStyle: "circle"
    });
    const nh = useNameHelper("ul");
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("no-marker")]: props.listStyle === "none"
      };
    });
    return () => {
      var _a;
      return createVNode("ul", {
        "class": className.value,
        "style": {
          listStyleType: props.listStyle
        }
      }, [(_a = slots.default) == null ? void 0 : _a.call(slots)]);
    };
  }
});

// node_modules/vexip-ui/es/components/typography/h.mjs
function createHComponent(level) {
  return defineComponent({
    name: `H${level}`,
    props: hProps,
    emits: [],
    setup(_props, {
      slots
    }) {
      const props = useProps(`h${level}`, _props, {
        type: "default",
        top: false,
        marker: false,
        aligned: false,
        thin: false
      });
      return () => createVNode(Title, mergeProps(props, {
        "level": level
      }), {
        default: () => {
          var _a;
          return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
        }
      });
    }
  });
}
var H1 = createHComponent(1);
var H2 = createHComponent(2);
var H3 = createHComponent(3);
var H4 = createHComponent(4);
var H5 = createHComponent(5);
var H6 = createHComponent(6);

// node_modules/vexip-ui/es/components/typography/p.mjs
var P = defineComponent({
  name: "P",
  props: pProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const props = useProps("p", _props, {
      type: "default",
      delete: false,
      strong: false,
      italic: false,
      underline: false,
      mark: false,
      disabled: false,
      keyboard: false,
      thin: false,
      reversed: false
    });
    return () => createVNode(Text, mergeProps(props, {
      "tag": "p"
    }), {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
      }
    });
  }
});

// node_modules/vexip-ui/es/components/typography/strong.mjs
var Strong = defineComponent({
  name: "Strong",
  props: strongProps,
  emits: [],
  setup(_props, {
    slots
  }) {
    const props = useProps("strong", _props, {
      type: "default",
      delete: false,
      italic: false,
      underline: false,
      mark: false,
      disabled: false,
      keyboard: false,
      thin: false,
      reversed: false
    });
    return () => createVNode(Text, mergeProps(props, {
      "tag": "strong",
      "strong": true
    }), {
      default: () => {
        var _a;
        return [(_a = slots.default) == null ? void 0 : _a.call(slots)];
      }
    });
  }
});

// node_modules/vexip-ui/es/components/create.mjs
function buildInstall(components2 = [], defaultLocale) {
  return function install3(app, options = {}) {
    const {
      prefix = "",
      namespace = "",
      props = {},
      locale = { locale: defaultLocale },
      zIndex
    } = options;
    const withDefaultLocale = computed(() => {
      return { locale: defaultLocale, ...unref(locale) };
    });
    configNamespace(namespace, app);
    configProps(props, app);
    configLocale(withDefaultLocale, app);
    if (typeof zIndex === "number") {
      configZIndex(zIndex, app);
    }
    const normalizedPrefix = Ye(prefix || "");
    components2.forEach((component) => {
      if (typeof component === "function" || typeof component.install === "function") {
        app.use(component);
      } else {
        app.component(`${normalizedPrefix}${component.name}`, component);
      }
    });
  };
}

// node_modules/vexip-ui/es/directives/loading/index.mjs
var vLoading = {
  mounted(el, binding) {
    nextTick(() => {
      const props = L(binding.value) ? { ...binding.value } : { active: binding.value };
      props.inner = true;
      const spin = createVNode(Spin, props, null, 0, Object.keys(props));
      const position = getComputedStyle(el).position;
      el.__loading = {
        spin,
        props,
        originPosition: position
      };
      if (position === "static") {
        el.style.position = "relative";
      }
      render(spin, el);
    });
  },
  updated(el, binding) {
    nextTick(() => {
      if (!el.__loading)
        return;
      const props = L(binding.value) ? binding.value : { active: binding.value };
      const component = el.__loading.spin.component;
      if (component) {
        Object.keys(props).forEach((key) => {
          component.props[key] = props[key];
        });
        component.props.inner = true;
      }
    });
  },
  beforeUnmount(el) {
    if (!el.__loading)
      return;
    render(null, el);
    delete el.__loading;
  }
};

// node_modules/vexip-ui/es/directives/index.mjs
function install(app) {
  app.directive("loading", vLoading);
}

// node_modules/vexip-ui/es/components/version.mjs
var version = "2.0.19";

// node_modules/vexip-ui/es/components/index.mjs
var components = [
  Alert,
  Anchor,
  AnchorLink,
  AutoComplete,
  Avatar,
  AvatarGroup,
  Badge,
  Breadcrumb,
  BreadcrumbItem,
  Bubble,
  Button,
  ButtonGroup,
  Calendar,
  CalendarPanel,
  Card,
  Carousel,
  CarouselItem,
  Cascader,
  Cell,
  Checkbox,
  CheckboxGroup,
  Collapse,
  CollapsePanel,
  CollapseTransition,
  ColorPicker,
  Column,
  ConfigProvider,
  DatePicker,
  Divider,
  Drawer,
  Dropdown,
  DropdownItem,
  DropdownList,
  Ellipsis,
  Form,
  FormItem,
  FormReset,
  FormSubmit,
  Grid,
  Highlight,
  Icon,
  Input,
  Layout,
  LayoutAside,
  LayoutFooter,
  LayoutHeader,
  Linker,
  Masker,
  Menu,
  MenuGroup,
  MenuItem,
  Modal,
  NativeScroll,
  NumberInput,
  Option,
  OptionGroup,
  Overflow,
  Pagination,
  Popup,
  Portal,
  Progress,
  Radio,
  RadioGroup,
  Renderer,
  ResizeObserver,
  Row,
  Scroll,
  Scrollbar,
  Select,
  Skeleton,
  SkeletonGroup,
  Slider,
  Space,
  Spin,
  Split,
  Switch,
  TabNav,
  TabNavItem,
  TabPanel,
  Table,
  TableColumn,
  Tabs,
  Tag,
  Textarea,
  TimeAgo,
  TimePicker,
  Timeline,
  TimelineItem,
  Tooltip,
  Transfer,
  Tree,
  Upload,
  UploadFile,
  UploadList,
  Viewer,
  VirtualList,
  Wheel,
  Confirm,
  Contextmenu,
  Loading,
  Message,
  Notice,
  Toast,
  Title,
  Text,
  Blockquote,
  OL,
  UL,
  H1,
  H2,
  H3,
  H4,
  H5,
  H6,
  P,
  Strong,
  install
];
var install2 = buildInstall(components);
export {
  Alert,
  Anchor,
  AnchorLink,
  AutoComplete,
  Avatar,
  AvatarGroup,
  Badge,
  Blockquote,
  Breadcrumb,
  BreadcrumbItem,
  Bubble,
  Button,
  ButtonGroup,
  Calendar,
  CalendarPanel,
  Card,
  Carousel,
  CarouselItem,
  Cascader,
  Cell,
  Checkbox,
  CheckboxGroup,
  Collapse,
  CollapsePanel,
  CollapseTransition,
  ColorPicker,
  Column,
  ConfigProvider,
  Confirm,
  ConfirmManager,
  Contextmenu,
  ContextmenuManager,
  DatePicker,
  Divider,
  Drawer,
  Dropdown,
  DropdownItem,
  DropdownList,
  Ellipsis,
  Form,
  FormItem,
  FormReset,
  FormSubmit,
  Grid,
  H1,
  H2,
  H3,
  H4,
  H5,
  H6,
  Highlight,
  Icon,
  Input,
  Layout,
  LayoutAside,
  LayoutFooter,
  LayoutHeader,
  Linker,
  Loading,
  LoadingManager,
  Masker,
  Menu,
  MenuGroup,
  MenuItem,
  Message,
  MessageManager,
  Modal,
  NativeScroll,
  Notice,
  NoticeManager,
  NumberInput,
  OL,
  Option,
  OptionGroup,
  Overflow,
  P,
  Pagination,
  Popup,
  Portal,
  Progress,
  Radio,
  RadioGroup,
  Renderer,
  ResizeObserver,
  Row,
  Scroll,
  Scrollbar,
  Select,
  Skeleton,
  SkeletonGroup,
  Slider,
  Space,
  Spin,
  Split,
  Strong,
  Switch,
  TabNav,
  TabNavItem,
  TabPanel,
  Table,
  TableColumn,
  Tabs,
  Tag,
  Text,
  Textarea,
  TimeAgo,
  TimePicker,
  Timeline,
  TimelineItem,
  Title,
  Toast,
  ToastManager,
  Tooltip,
  Transfer,
  Tree,
  UL,
  Upload,
  UploadFile,
  UploadList,
  Viewer,
  VirtualList,
  Wheel,
  animateScrollTo2 as animateScrollTo,
  buildInstall,
  currentBreakPoint,
  defineColumn,
  defineColumns,
  defineFilter,
  defineSorter,
  getValueByPath,
  install2 as install,
  setValueByPath,
  iconMaps as uploadFileIconMap,
  useFieldStore,
  vLoading,
  validate,
  validateBoolean,
  validateDate,
  validateEmail,
  validateEnumeration,
  validateFloat,
  validateInt,
  validateNumber,
  validateRequirement,
  validateString,
  validateType,
  validateUrl,
  version
};
//# sourceMappingURL=vexip-ui.js.map
