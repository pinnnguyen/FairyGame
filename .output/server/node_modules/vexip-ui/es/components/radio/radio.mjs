import { defineComponent, inject, ref, computed, watch, onMounted, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, createBlock, withCtx, createVNode, createCommentVNode, renderSlot, createTextVNode, toDisplayString } from "vue";
import "../collapse-transition/index.mjs";
import "../icon/index.mjs";
import "../../common/config/src/index.mjs";
import { isDefined } from "@vexip-ui/utils";
import { radioProps } from "./props.mjs";
import { GROUP_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import CollapseTransition from "../collapse/collapse-transition.mjs";
import Icon from "../icon/icon.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "Radio",
  components: {
    CollapseTransition,
    Icon
  },
  props: radioProps,
  emits: ["update:value"],
  setup(_props, { emit }) {
    const props = useProps("radio", _props, {
      size: createSizeProp(),
      state: createStateProp(),
      value: {
        default: null,
        static: true
      },
      label: {
        default: null,
        validator: isDefined,
        static: true
      },
      labelClass: null,
      disabled: false,
      border: false,
      tabIndex: 0,
      loading: false,
      loadingLock: false
    });
    const groupState = inject(GROUP_STATE, null);
    const nh = useNameHelper("radio");
    const currentValue = ref(props.value);
    const input = ref();
    const size = computed(() => (groupState == null ? void 0 : groupState.size) || props.size);
    const state = computed(() => (groupState == null ? void 0 : groupState.state) || props.state);
    const isDisabled = computed(() => (groupState == null ? void 0 : groupState.disabled) || props.disabled);
    const isButton = computed(() => groupState == null ? void 0 : groupState.button);
    const isBorder = computed(() => (groupState == null ? void 0 : groupState.border) || props.border);
    const isLoading = computed(() => (groupState == null ? void 0 : groupState.loading) || props.loading);
    const LoadingIcon = computed(() => (groupState == null ? void 0 : groupState.loadingIcon) || null);
    const isLoadingLock = computed(() => (groupState == null ? void 0 : groupState.loadingLock) || false);
    const isLoadingSpin = computed(() => (groupState == null ? void 0 : groupState.loadingSpin) || false);
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: props.inherit,
          [nh.bm("checked")]: currentValue.value === props.label,
          [nh.bm("disabled")]: isDisabled.value,
          [nh.bm("loading")]: isLoading.value && isLoadingLock.value,
          [nh.bm(size.value)]: size.value !== "default",
          [nh.bm("border")]: isBorder.value,
          [nh.bm(state.value)]: state.value !== "default"
        }
      ];
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
      }
    );
    watch(currentValue, (value) => {
      emitEvent(props.onChange, value);
      emit("update:value", value);
      if (groupState && value === props.label) {
        groupState.updateValue(value);
      }
    });
    if (groupState) {
      watch(
        () => groupState.currentValue,
        (value) => {
          currentValue.value = value;
        },
        { immediate: true }
      );
      onMounted(() => {
        groupState.registerInput(input);
      });
      onBeforeUnmount(() => {
        groupState.unregisterInput(input);
      });
    }
    function handleChange() {
      if (isDisabled.value || isLoading.value && isLoadingLock.value) {
        return;
      }
      currentValue.value = props.label;
    }
    return {
      props,
      nh,
      currentValue,
      className,
      isDisabled,
      isButton,
      isLoading,
      computedLoadingIcon: LoadingIcon,
      isLoadingSpin,
      input,
      handleChange
    };
  }
});
const _hoisted_1 = ["checked", "disabled", "tabindex"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return openBlock(), createElementBlock("label", {
    class: normalizeClass(_ctx.className)
  }, [
    createElementVNode("span", {
      class: normalizeClass([_ctx.nh.be("signal"), _ctx.isLoading && _ctx.nh.bem("signal", "active")])
    }, null, 2),
    createElementVNode("span", {
      class: normalizeClass([_ctx.nh.be("label"), _ctx.props.labelClass])
    }, [
      _ctx.isButton ? (openBlock(), createBlock(_component_CollapseTransition, {
        key: 0,
        appear: "",
        horizontal: "",
        "fade-effect": ""
      }, {
        default: withCtx(() => [
          _ctx.isLoading ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("loading"))
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.isLoadingSpin,
              pulse: !_ctx.isLoadingSpin,
              icon: _ctx.computedLoadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      })) : createCommentVNode("", true),
      renderSlot(_ctx.$slots, "default", {}, () => [
        createTextVNode(toDisplayString(_ctx.props.label), 1)
      ])
    ], 2),
    createElementVNode("input", {
      ref: "input",
      type: "radio",
      class: normalizeClass(_ctx.nh.be("input")),
      checked: _ctx.currentValue === _ctx.props.label,
      disabled: _ctx.isDisabled,
      tabindex: _ctx.props.tabIndex,
      onChange: _cache[0] || (_cache[0] = (...args) => _ctx.handleChange && _ctx.handleChange(...args))
    }, null, 42, _hoisted_1)
  ], 2);
}
var Radio = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Radio as default };
