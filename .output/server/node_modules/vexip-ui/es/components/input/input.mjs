import { isVNode, defineComponent, ref, computed, watch, nextTick, createVNode, Transition } from "vue";
import "../icon/index.mjs";
import "../form/index.mjs";
import { useHover } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { isNull, debounce, throttle, noop } from "@vexip-ui/utils";
import { Spinner, EyeR, EyeSlashR, CircleXmark } from "@vexip-ui/icons";
import { inputProps } from "./props.mjs";
import Icon from "../icon/icon.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const inputTypes = Object.freeze(["text", "password", "date", "datetime", "time"]);
function toNotNullString(value) {
  return isNull(value) ? "" : String(value);
}
var Input = defineComponent({
  name: "Input",
  components: {
    Icon
  },
  props: inputProps,
  emits: ["update:value"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = inputControl.value) == null ? void 0 : _a.focus();
    });
    const props = useProps("input", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      type: {
        default: "text",
        validator: (value) => inputTypes.includes(value)
      },
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      formatter: {
        default: null,
        isFunc: true
      },
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      placeholder: null,
      autofocus: false,
      spellcheck: false,
      autocomplete: false,
      readonly: false,
      disabled: () => disabled.value,
      inputClass: "",
      debounce: false,
      maxLength: 0,
      before: "",
      after: "",
      plainPassword: false,
      clearable: false,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      transparent: false,
      sync: false
    });
    const initValue = toNotNullString(props.value);
    const nh = useNameHelper("input");
    const focused = ref(false);
    const currentValue = ref(initValue);
    const showPassword = ref(false);
    const currentLength = ref(initValue.length);
    const beforeHover = ref(false);
    const afterHover = ref(false);
    const inputControl = ref();
    const {
      wrapper: control,
      isHover
    } = useHover();
    const locale = useLocale("input");
    let lastValue = props.value;
    const hasBefore = computed(() => {
      return !!(slots.before || slots.beforeAction || slots["before-action"] || props.before);
    });
    const hasAfter = computed(() => {
      return !!(slots.after || slots.afterAction || slots["after-action"] || props.after);
    });
    const basisClass = computed(() => {
      return {
        [nh.bs("wrapper")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.size)]: props.size !== "default"
      };
    });
    const className = computed(() => {
      return [nh.b(), nh.bm(props.type), !hasBefore.value && !hasAfter.value && basisClass.value, {
        [nh.bm("focused")]: focused.value,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("loading")]: props.loading && props.loadingLock,
        [nh.bm(props.state)]: props.state !== "default",
        [nh.bm("before")]: slots.beforeAction || slots["before-action"],
        [nh.bm("after")]: slots.afterAction || slots["after-action"],
        [nh.bm("loading")]: props.loading,
        [nh.bm("transparent")]: props.transparent
      }];
    });
    const wrapperClass = computed(() => {
      return {
        ...basisClass.value,
        [nh.bm(`wrapper--${props.size}`)]: props.size !== "default",
        [nh.bs("wrapper--before-only")]: hasBefore.value && !hasAfter.value,
        [nh.bs("wrapper--after-only")]: !hasBefore.value && hasAfter.value,
        [nh.bm("transparent")]: props.transparent
      };
    });
    const hasPrefix = computed(() => !!(slots.prefix || props.prefix));
    const hasSuffix = computed(() => !!(slots.suffix || props.suffix));
    const inputType = computed(() => {
      const type = props.type;
      if (type === "password") {
        return showPassword.value ? "text" : "password";
      }
      if (type === "datetime") {
        return "datetime-local";
      }
      return type;
    });
    const formattedValue = computed(() => {
      return typeof props.formatter === "function" ? toNotNullString(props.formatter(currentValue.value)) : currentValue.value;
    });
    const passwordIcon = computed(() => showPassword.value ? EyeR : EyeSlashR);
    const hasValue = computed(() => {
      return !(isNull(currentValue.value) || currentValue.value === "");
    });
    const readonly = computed(() => props.loading && props.loadingLock || props.readonly);
    const showClear = computed(() => {
      return !props.disabled && props.clearable && hasValue.value && isHover.value;
    });
    watch(() => props.value, (value) => {
      currentValue.value = toNotNullString(value);
      limitValueLength();
      lastValue = currentValue.value;
    });
    expose({
      input: inputControl,
      focus: () => {
        var _a;
        (_a = inputControl.value) == null ? void 0 : _a.focus();
      },
      blur: () => {
        var _a;
        (_a = inputControl.value) == null ? void 0 : _a.blur();
      }
    });
    function handleFocus(event) {
      if (!focused.value) {
        focused.value = true;
        emitEvent(props.onFocus, event);
      }
    }
    function handleBlur(event) {
      if (focused.value) {
        focused.value = false;
        setTimeout(() => {
          if (!focused.value) {
            emitEvent(props.onBlur, event);
            emitChangeEvent("change");
          }
        }, 120);
      }
    }
    function handleChange(event) {
      const type = event.type;
      currentValue.value = event.target.value;
      limitValueLength();
      const value = currentValue.value;
      setValue(value, type);
    }
    function setValue(value, type) {
      currentValue.value = value;
      emitChangeEvent(type);
    }
    function emitChangeEvent(type) {
      type = type === "input" ? "input" : "change";
      const value = typeof props.value === "number" ? parseFloat(currentValue.value) : currentValue.value;
      if (type === "change") {
        if (lastValue === value)
          return;
        lastValue = value;
        setFieldValue(value);
        emitEvent(props.onChange, value);
        if (!props.sync) {
          emit("update:value", value);
          validateField();
        }
      } else {
        emitEvent(props.onInput, value);
        if (props.sync) {
          emit("update:value", value);
          validateField();
        }
      }
    }
    function limitValueLength() {
      let value = currentValue.value;
      if (isNull(value)) {
        currentLength.value = 0;
        return;
      }
      const maxLength = props.maxLength;
      if (maxLength && value.length > maxLength) {
        value = value.slice(0, maxLength);
      }
      currentLength.value = value.length;
      currentValue.value = value;
    }
    function toggleShowPassword() {
      var _a;
      if (props.disabled) {
        return;
      }
      showPassword.value = !showPassword.value;
      (_a = inputControl.value) == null ? void 0 : _a.focus();
    }
    function handleClear(event) {
      event.stopPropagation();
      setValue("", "change");
      if (props.sync) {
        emit("update:value", currentValue.value);
        validateField();
      }
      emitEvent(props.onClear);
      nextTick(clearField);
    }
    function handleEnter() {
      emitEvent(props.onEnter);
    }
    function handlePrefixClick(event) {
      emitEvent(props.onPrefixClick, event);
    }
    function handleSuffixClick(event) {
      emitEvent(props.onSuffixClick, event);
    }
    function handleKeyDown(event) {
      emitEvent(props.onKeyDown, event);
    }
    function handleKeyPress(event) {
      emitEvent(props.onKeyPress, event);
    }
    function handleKeyUp(event) {
      if (event.key === "Enter") {
        handleEnter();
      }
      emitEvent(props.onKeyUp, event);
    }
    const handleInput = props.debounce ? debounce(handleChange) : throttle(handleChange);
    function renderPrefix() {
      return createVNode("div", {
        "class": [nh.be("icon"), nh.be("prefix")],
        "style": {
          color: props.prefixColor
        },
        "onClick": handlePrefixClick
      }, [slots.prefix ? slots.prefix() : createVNode(Icon, {
        "icon": props.prefix
      }, null)]);
    }
    function renderCustomSuffix() {
      if (hasSuffix.value) {
        return createVNode("div", {
          "key": "suffix",
          "class": [nh.be("icon"), nh.be("suffix")],
          "style": {
            color: props.suffixColor,
            opacity: showClear.value || props.loading ? "0%" : ""
          },
          "onClick": handleSuffixClick
        }, [slots.suffix ? slots.suffix() : createVNode(Icon, {
          "icon": props.suffix
        }, null)]);
      }
      if (props.type === "password" && props.plainPassword) {
        return createVNode("div", {
          "key": "password",
          "class": [nh.be("icon"), nh.be("password")],
          "style": {
            color: props.suffixColor,
            opacity: showClear.value || props.loading ? "0%" : ""
          },
          "onClick": toggleShowPassword
        }, [createVNode(Icon, {
          "icon": passwordIcon.value
        }, null)]);
      }
      if (props.clearable || props.loading) {
        return createVNode("div", {
          "key": "placeholder",
          "class": [nh.be("icon"), nh.bem("icon", "placeholder")]
        }, null);
      }
      return null;
    }
    function renderSuffixAction() {
      if (showClear.value) {
        return createVNode("div", {
          "key": "clear",
          "class": [nh.be("icon"), nh.be("clear")],
          "onClick": handleClear
        }, [createVNode(Icon, {
          "icon": CircleXmark
        }, null)]);
      }
      if (props.loading) {
        return createVNode("div", {
          "key": "loading",
          "class": [nh.be("icon"), nh.be("loading")]
        }, [createVNode(Icon, {
          "spin": props.loadingSpin,
          "pulse": !props.loadingSpin,
          "icon": props.loadingIcon
        }, null)]);
      }
      return null;
    }
    function renderSuffix() {
      let _slot;
      return createVNode("div", {
        "class": nh.be("suffix-wrapper")
      }, [renderCustomSuffix(), createVNode(Transition, {
        "name": nh.ns("fade"),
        "appear": true
      }, _isSlot(_slot = renderSuffixAction()) ? _slot : {
        default: () => [_slot]
      })]);
    }
    function renderCount() {
      return createVNode("div", {
        "class": nh.be("count")
      }, [slots.count ? slots.count({
        value: currentValue.value
      }) : `${currentLength.value}/${props.maxLength}`]);
    }
    function renderControl() {
      var _a;
      return createVNode("div", {
        "id": idFor.value,
        "ref": control,
        "class": className.value,
        "onClick": () => {
          var _a2;
          return (_a2 = inputControl.value) == null ? void 0 : _a2.focus();
        }
      }, [hasPrefix.value && renderPrefix(), createVNode("input", {
        "ref": inputControl,
        "class": [nh.be("control"), props.inputClass],
        "type": inputType.value,
        "value": formattedValue.value,
        "autofocus": props.autofocus,
        "autocomplete": props.autocomplete ? "on" : "off",
        "spellcheck": props.spellcheck,
        "disabled": props.disabled,
        "readonly": readonly.value,
        "placeholder": (_a = props.placeholder) != null ? _a : locale.value.placeholder,
        "maxlength": props.maxLength > 0 ? props.maxLength : void 0,
        "onBlur": handleBlur,
        "onFocus": handleFocus,
        "onInput": handleInput,
        "onChange": handleChange,
        "onKeypress": handleKeyPress,
        "onKeydown": handleKeyDown,
        "onKeyup": handleKeyUp
      }, null), renderSuffix(), props.maxLength > 0 ? renderCount() : null]);
    }
    function renderAside(type) {
      const buttonSlot = slots[`${type}Action`] || slots[`${type}-action`];
      if (buttonSlot) {
        return createVNode("div", {
          "class": [nh.be(type), nh.bem(type, "action")],
          "onMouseenter": () => (type === "before" ? beforeHover : afterHover).value = true,
          "onMouseleave": () => (type === "before" ? beforeHover : afterHover).value = false
        }, [buttonSlot()]);
      }
      return createVNode("div", {
        "class": nh.be(type)
      }, [slots[type] ? slots[type]() : props[type]]);
    }
    return () => {
      if (hasBefore.value || hasAfter.value) {
        return createVNode("div", {
          "class": wrapperClass.value
        }, [hasBefore.value && renderAside("before"), renderControl(), hasAfter.value && renderAside("after")]);
      }
      return renderControl();
    };
  },
  methods: {
    focus: noop,
    blur: noop
  }
});
export { Input as default };
