import { defineComponent, inject, provide, reactive, computed, watch, h } from "vue";
import "../../common/config/src/index.mjs";
import { isDefined, has } from "@vexip-ui/utils";
import { cellProps } from "./props.mjs";
import { currentBreakPoint, breakPoints } from "./helpler.mjs";
import { GRID_STATE } from "./symbol.mjs";
import { useProps } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
var Cell = defineComponent({
  name: "Cell",
  props: cellProps,
  setup(_props, { slots }) {
    const props = useProps("cell", _props, {
      tag: "div",
      top: "auto",
      left: "auto",
      width: null,
      height: 1,
      right: "",
      bottom: "",
      xs: null,
      sm: null,
      md: null,
      lg: null,
      xl: null,
      xxl: null,
      useFlex: null
    });
    const gridState = inject(GRID_STATE, null);
    const nh = useNameHelper("cell");
    provide(GRID_STATE, null);
    const layoutState = reactive({
      top: props.top,
      right: props.right,
      bottom: props.bottom,
      left: props.left,
      width: props.width,
      height: props.height
    });
    const leyoutKeys = Object.keys(layoutState);
    const defaultWidth = computed(() => {
      if (isDefined(props.width)) {
        return props.width;
      }
      return (gridState == null ? void 0 : gridState.columns) && typeof gridState.columns === "number" ? gridState.columns : 1;
    });
    watch(
      currentBreakPoint,
      (value) => {
        var _a;
        const matchSize = queryBreakPointOptions(value);
        if (matchSize) {
          if (typeof matchSize === "number") {
            leyoutKeys.forEach((key) => {
              layoutState[key] = props[key];
            });
            layoutState.width = matchSize;
          } else {
            leyoutKeys.forEach((key) => {
              layoutState[key] = has(matchSize, key) ? matchSize[key] : props[key];
            });
            layoutState.width = (_a = layoutState.width) != null ? _a : defaultWidth.value;
          }
        } else {
          leyoutKeys.forEach((key) => {
            layoutState[key] = props[key];
          });
          layoutState.width = defaultWidth.value;
        }
      },
      { immediate: true }
    );
    const className = computed(() => {
      const cellFelx = props.useFlex !== false && (props.useFlex || (gridState == null ? void 0 : gridState.cellFlex)) && {
        ...(gridState == null ? void 0 : gridState.cellFlex) || {},
        ...props.useFlex ? props.useFlex === true ? { justify: "start", align: "top" } : props.useFlex : {}
      };
      const className2 = {
        [nh.b()]: true,
        [nh.bm("inherit")]: gridState || props.inherit,
        [nh.bm("flex")]: cellFelx
      };
      if (cellFelx) {
        if (cellFelx.justify)
          className2[nh.bm(cellFelx.justify)] = true;
        if (cellFelx.align)
          className2[nh.bm(cellFelx.align)] = true;
      }
      return className2;
    });
    const style = computed(() => {
      const style2 = {};
      const topSet = isPositionSet(layoutState.top);
      const rightSet = isPositionSet(layoutState.right);
      const bottomSet = isPositionSet(layoutState.bottom);
      const leftSet = isPositionSet(layoutState.left);
      if (topSet && bottomSet) {
        style2.gridRowStart = parsePosition(layoutState.top);
        style2.gridRowEnd = parsePosition(layoutState.bottom);
      } else if (topSet) {
        style2.gridRowStart = parsePosition(layoutState.top);
        style2.gridRowEnd = `span ${layoutState.height}`;
      } else if (bottomSet) {
        style2.gridRowStart = `span ${layoutState.height}`;
        style2.gridRowEnd = parsePosition(layoutState.bottom);
      } else {
        style2.gridRowEnd = `span ${layoutState.height}`;
      }
      if (leftSet && rightSet) {
        style2.gridColumnStart = parsePosition(layoutState.left);
        style2.gridColumnEnd = parsePosition(layoutState.right);
      } else if (leftSet) {
        style2.gridColumnStart = parsePosition(layoutState.left);
        style2.gridColumnEnd = `span ${layoutState.width}`;
      } else if (rightSet) {
        style2.gridColumnStart = `span ${layoutState.width}`;
        style2.gridColumnEnd = parsePosition(layoutState.right);
      } else {
        style2.gridColumnStart = `span ${layoutState.width}`;
      }
      return style2;
    });
    function isPositionSet(value) {
      return value === 0 || value && value !== "auto";
    }
    function parsePosition(value) {
      return typeof value === "number" ? value + 1 : value;
    }
    function queryBreakPointOptions(breakPoint) {
      const index = breakPoints.findIndex((v) => v === breakPoint);
      if (~index) {
        for (let i = index; i >= 0; --i) {
          if (isDefined(props[breakPoints[i]])) {
            return props[breakPoints[i]];
          }
        }
      }
      return null;
    }
    return () => h(
      props.tag || "div",
      {
        class: className.value,
        style: style.value
      },
      {
        default: () => {
          var _a;
          return (_a = slots.default) == null ? void 0 : _a.call(slots);
        }
      }
    );
  }
});
export { Cell as default };
