import { defineComponent, inject, ref, computed, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, createBlock, withCtx, createElementVNode, renderSlot } from "vue";
import "../icon/index.mjs";
import "../resize-observer/index.mjs";
import "../../common/config/src/index.mjs";
import { avatarProps } from "./props.mjs";
import { GROUP_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import ResizeObserver from "../resize-observer/resize-observer.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const objectFitValues = Object.freeze(["fill", "contain", "cover", "none", "scale-down"]);
const _sfc_main = defineComponent({
  name: "Avatar",
  components: {
    Icon,
    ResizeObserver
  },
  props: avatarProps,
  emits: [],
  setup(_props) {
    const props = useProps("avatar", _props, {
      size: "default",
      src: {
        default: "",
        static: true
      },
      icon: null,
      circle: false,
      alt: "",
      fit: {
        default: "cover",
        validator: (value) => objectFitValues.includes(value)
      },
      srcSet: "",
      gap: 4,
      iconScale: 1.4,
      fallbackSrc: "",
      color: null,
      background: null
    });
    const groupState = inject(GROUP_STATE, null);
    const nh = useNameHelper("avatar");
    const loadFail = ref(false);
    const fallbackFail = ref(false);
    const wrapper = ref();
    const text = ref();
    const size = computed(() => {
      var _a;
      return (_a = groupState == null ? void 0 : groupState.size) != null ? _a : props.size;
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(size.value)]: typeof size.value !== "number" && size.value !== "default",
        [nh.bm("circle")]: props.circle
      };
    });
    const style = computed(() => {
      const style2 = {
        [nh.cv("color")]: props.color,
        [nh.cv("bg-color")]: props.background,
        [nh.cv("image-fit")]: props.fit
      };
      if (typeof size.value === "number") {
        style2[nh.cv("size")] = `${size.value}px`;
      }
      return style2;
    });
    watch(
      () => props.src,
      () => {
        loadFail.value = false;
        fallbackFail.value = false;
        scaleText();
      }
    );
    watch(
      () => props.fallbackSrc,
      () => {
        fallbackFail.value = false;
        scaleText();
      }
    );
    watch(() => props.gap, scaleText);
    function handleError(event) {
      loadFail.value = true;
      emitEvent(props.onError, event);
    }
    let lastText = null;
    function scaleText() {
      const avatarEl = wrapper.value;
      const textEl = text.value;
      if (avatarEl && textEl && (lastText === null || lastText !== textEl.textContent)) {
        lastText = textEl.textContent;
        const { offsetWidth: avatarWidth, offsetHeight: avatarHeight } = avatarEl;
        const { offsetWidth: textWidth, offsetHeight: textHeight } = textEl;
        const padding = props.gap * 2;
        const ratio = Math.min(
          (avatarWidth - padding) / (textWidth || 1),
          (avatarHeight - padding) / (textHeight || 1),
          1
        );
        textEl.style.transform = `scale(${ratio})`;
      }
    }
    function handleClick(event) {
      emitEvent(props.onClick, event);
    }
    return {
      props,
      nh,
      loadFail,
      fallbackFail,
      wrapper,
      text,
      className,
      style,
      handleError,
      scaleText,
      handleClick
    };
  }
});
const _hoisted_1 = ["src", "alt", "srcset"];
const _hoisted_2 = ["src", "alt"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.style),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    (_ctx.props.src || _ctx.props.srcSet) && !_ctx.loadFail ? (openBlock(), createElementBlock("img", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("image")),
      src: _ctx.props.src,
      alt: _ctx.props.alt,
      srcset: _ctx.props.srcSet,
      onError: _cache[0] || (_cache[0] = (...args) => _ctx.handleError && _ctx.handleError(...args))
    }, null, 42, _hoisted_1)) : _ctx.loadFail && _ctx.props.fallbackSrc && !_ctx.fallbackFail ? (openBlock(), createElementBlock("img", {
      key: 1,
      class: normalizeClass(_ctx.nh.be("image")),
      src: _ctx.props.fallbackSrc,
      alt: _ctx.props.alt,
      onError: _cache[1] || (_cache[1] = ($event) => _ctx.fallbackFail = true)
    }, null, 42, _hoisted_2)) : _ctx.icon ? (openBlock(), createBlock(_component_Icon, {
      key: 2,
      class: normalizeClass(_ctx.nh.be("icon")),
      icon: _ctx.icon,
      scale: _ctx.props.iconScale
    }, null, 8, ["class", "icon", "scale"])) : (openBlock(), createBlock(_component_ResizeObserver, {
      key: 3,
      "on-resize": _ctx.scaleText
    }, {
      default: withCtx(() => [
        createElementVNode("span", {
          ref: "text",
          class: normalizeClass(_ctx.nh.be("text"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 8, ["on-resize"]))
  ], 6);
}
var Avatar = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Avatar as default };
