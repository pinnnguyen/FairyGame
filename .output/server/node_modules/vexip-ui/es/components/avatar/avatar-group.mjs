import { defineComponent, ref, watchEffect, provide, computed, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, Fragment, renderList, renderSlot, createVNode, withCtx, createTextVNode, toDisplayString, createBlock, createCommentVNode } from "vue";
import "./index.mjs";
import "../tooltip/index.mjs";
import "../../common/config/src/index.mjs";
import { avatarGroupProps } from "./props.mjs";
import { GROUP_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Avatar from "./avatar.mjs";
import Tooltip from "../tooltip/tooltip.mjs";
import { useProps } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "AvatarGroup",
  components: {
    Avatar,
    Tooltip
  },
  props: avatarGroupProps,
  setup(_props) {
    const props = useProps("avatarGroup", _props, {
      size: "default",
      options: {
        default: () => [],
        static: true
      },
      circle: false,
      max: null,
      showTip: false,
      tipTrigger: "hover",
      vertical: false,
      offset: null,
      restColor: null,
      restBackground: null
    });
    const nh = useNameHelper("avatar-group");
    const renderAvatars = ref([]);
    const restAvatars = ref([]);
    watchEffect(() => {
      const size = props.options.length;
      if (props.max > 0 && size > props.max) {
        renderAvatars.value = props.options.slice(0, props.max - 1);
        restAvatars.value = props.options.slice(props.max - 1);
      } else {
        renderAvatars.value = Array.from(props.options);
        restAvatars.value = [];
      }
    });
    provide(GROUP_STATE, props);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("avatar-vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.size)]: typeof props.size !== "number" && props.size !== "default",
        [nh.bm("circle")]: props.circle,
        [nh.bm("vertical")]: props.vertical
      };
    });
    const style = computed(() => {
      const style2 = {};
      if (typeof props.offset === "number") {
        style2[nh.cv("offset")] = `${props.offset}px`;
      }
      return style2;
    });
    return {
      props,
      nh,
      renderAvatars,
      restAvatars,
      className,
      style
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Avatar = resolveComponent("Avatar");
  const _component_Tooltip = resolveComponent("Tooltip");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.className),
    role: "group",
    style: normalizeStyle(_ctx.style)
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.renderAvatars, (option, index) => {
      return openBlock(), createElementBlock("div", {
        key: index,
        class: normalizeClass(_ctx.nh.be("item"))
      }, [
        renderSlot(_ctx.$slots, "default", {
          option,
          index
        }, () => [
          createVNode(_component_Avatar, {
            inherit: "",
            src: option.src,
            icon: option.icon,
            alt: option.alt,
            fit: option.fit,
            "src-set": option.srcSet,
            gap: option.gap,
            "icon-scale": option.iconScale,
            "fallback-src": option.fallbackSrc
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString(option.text), 1)
            ]),
            _: 2
          }, 1032, ["src", "icon", "alt", "fit", "src-set", "gap", "icon-scale", "fallback-src"])
        ])
      ], 2);
    }), 128)),
    _ctx.restAvatars.length ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass([_ctx.nh.be("item"), _ctx.nh.bem("item", "rest")])
    }, [
      _ctx.props.showTip ? (openBlock(), createBlock(_component_Tooltip, {
        key: 0,
        inherit: "",
        trigger: _ctx.props.tipTrigger,
        "tip-class": _ctx.nh.be("rest")
      }, {
        trigger: withCtx(() => [
          renderSlot(_ctx.$slots, "rest", {
            options: _ctx.restAvatars,
            count: _ctx.restAvatars.length
          }, () => [
            createVNode(_component_Avatar, {
              inherit: "",
              color: _ctx.props.restColor,
              background: _ctx.props.restBackground
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(`+${_ctx.restAvatars.length}`), 1)
              ]),
              _: 1
            }, 8, ["color", "background"])
          ])
        ]),
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "tip", {
            options: _ctx.restAvatars,
            count: _ctx.restAvatars.length
          }, () => [
            (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.restAvatars, (option, index) => {
              return openBlock(), createBlock(_component_Avatar, {
                key: index,
                inherit: "",
                src: option.src,
                icon: option.icon,
                alt: option.alt,
                fit: option.fit,
                "src-set": option.srcSet,
                gap: option.gap,
                "icon-scale": option.iconScale,
                "fallback-src": option.fallbackSrc
              }, {
                default: withCtx(() => [
                  createTextVNode(toDisplayString(option.text), 1)
                ]),
                _: 2
              }, 1032, ["src", "icon", "alt", "fit", "src-set", "gap", "icon-scale", "fallback-src"]);
            }), 128))
          ])
        ]),
        _: 3
      }, 8, ["trigger", "tip-class"])) : renderSlot(_ctx.$slots, "rest", {
        key: 1,
        options: _ctx.restAvatars,
        count: _ctx.restAvatars.length
      }, () => [
        createVNode(_component_Avatar, {
          inherit: "",
          color: _ctx.props.restColor,
          background: _ctx.props.restBackground
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(`+${_ctx.restAvatars.length}`), 1)
          ]),
          _: 1
        }, 8, ["color", "background"])
      ])
    ], 2)) : createCommentVNode("", true)
  ], 6);
}
var AvatarGroup = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { AvatarGroup as default };
