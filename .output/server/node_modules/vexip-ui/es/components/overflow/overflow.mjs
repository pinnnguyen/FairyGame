import { isVNode, createTextVNode, defineComponent, ref, computed, watch, nextTick, onMounted, createVNode, mergeProps, Fragment } from "vue";
import "../resize-observer/index.mjs";
import "../../common/config/src/index.mjs";
import { isDefined } from "@vexip-ui/utils";
import { overflowProps } from "./props.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import ResizeObserver from "../resize-observer/resize-observer.mjs";
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const TEXT_VNODE = createTextVNode("").type;
var Overflow = defineComponent({
  name: "Overflow",
  inheritAttrs: false,
  props: overflowProps,
  emits: [],
  setup(_props, {
    attrs,
    slots,
    expose
  }) {
    const props = useProps("overflow", _props, {
      items: {
        default: null,
        static: true
      },
      tag: "div",
      attrFlag: false,
      static: false,
      maxCount: 0
    });
    const nh = useNameHelper("overflow");
    const restCount = ref(0);
    const wrapper = ref();
    const counter = ref();
    const suffix = ref();
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("manual")]: props.maxCount > 0
      }];
    });
    const hiddenFlag = computed(() => {
      return props.attrFlag ? props.attrFlag === true ? "hidden" : props.attrFlag : false;
    });
    watch([() => {
      var _a;
      return (_a = props.items) == null ? void 0 : _a.length;
    }, () => props.maxCount], () => {
      nextTick(refresh);
    });
    expose({
      refresh
    });
    onMounted(refresh);
    function toggleDisplay(el, show) {
      if (hiddenFlag.value) {
        show ? el.removeAttribute(hiddenFlag.value) : el.setAttribute(hiddenFlag.value, "");
      } else {
        if (show) {
          el.style.display = "";
        } else {
          el.style.display = "none";
        }
      }
    }
    function computeHorizontalMargin(el) {
      const style = getComputedStyle(el);
      const marginLeft = parseFloat(style.marginLeft) || 0;
      const marginRight = parseFloat(style.marginRight) || 0;
      return marginLeft + marginRight;
    }
    function computeHorizontalPadding(el) {
      const style = getComputedStyle(el);
      const paddingLeft = parseFloat(style.paddingLeft) || 0;
      const paddingRight = parseFloat(style.paddingRight) || 0;
      return paddingLeft + paddingRight;
    }
    function computeOuterWidth(el) {
      return el.offsetWidth + computeHorizontalMargin(el);
    }
    let lastOverflow = false;
    let lastRestCount = restCount.value;
    function refresh() {
      const counterEl = counter.value;
      if (!wrapper.value || !counterEl)
        return;
      toggleDisplay(counterEl, true);
      const children = wrapper.value.children;
      const childCount = children.length;
      let overflow = false;
      if (props.maxCount > 0) {
        for (let i = 0, len = childCount - 1; i < len; ++i) {
          const child = children[i];
          child.style.display = i < props.maxCount ? "" : "none";
        }
        if (props.maxCount > childCount - 1) {
          toggleDisplay(counterEl, false);
          restCount.value = 0;
        } else {
          restCount.value = childCount - 1 - props.maxCount;
          overflow = restCount.value > 0;
        }
        postRefresh(overflow);
        return;
      }
      const suffixEl = suffix.value;
      const wrapperWidth = wrapper.value.offsetWidth - computeHorizontalPadding(wrapper.value);
      const childWidths = [];
      let totalWidth = suffixEl ? suffixEl.offsetWidth : 0;
      const counterMargin = computeHorizontalMargin(counterEl);
      const length = childCount - (suffixEl ? 2 : 1);
      for (let i = 0; i < length; ++i) {
        if (i < 0)
          continue;
        const child = children[i];
        if (overflow) {
          toggleDisplay(child, false);
          continue;
        } else {
          toggleDisplay(child, true);
        }
        const childWidth = computeOuterWidth(child);
        totalWidth += childWidth;
        childWidths[i] = childWidth;
        if (totalWidth > wrapperWidth) {
          for (let j = i; j >= 0; --j) {
            restCount.value = length - j;
            totalWidth -= childWidths[j];
            if (totalWidth + counterEl.offsetWidth + counterMargin <= wrapperWidth || !j) {
              overflow = true;
              i = j - 1;
              if (suffixEl) {
                suffixEl.style.maxWidth = i === -1 ? `${wrapperWidth - counterEl.offsetWidth}px` : "";
              }
              break;
            }
          }
        }
      }
      postRefresh(overflow);
    }
    function postRefresh(overflow) {
      if (lastRestCount !== restCount.value) {
        lastRestCount = restCount.value;
        emitEvent(props.onRestChange, restCount.value);
      }
      counter.value && toggleDisplay(counter.value, overflow);
      if (overflow !== lastOverflow) {
        lastOverflow = overflow;
        emitEvent(props.onToggle, overflow);
      }
    }
    function syncCounterRef(el) {
      if (el) {
        counter.value = el.nextElementSibling;
      } else {
        counter.value = void 0;
      }
    }
    return () => {
      var _a;
      let _slot;
      const CustomTag = props.tag || "div";
      const itemSlot = slots.default;
      const staticItem = props.static;
      const counterVNode = ((_a = slots.counter) == null ? void 0 : _a.call(slots, {
        count: restCount.value
      })[0]) || null;
      const renderCounter = () => (counterVNode == null ? void 0 : counterVNode.type) === TEXT_VNODE ? createVNode("span", null, [counterVNode]) : counterVNode;
      const render = () => createVNode(CustomTag, mergeProps({
        "ref": wrapper
      }, attrs, {
        "class": className.value
      }), {
        default: () => [itemSlot && isDefined(props.items) ? props.items.map((item, index) => {
          const vnode = itemSlot({
            item,
            index
          })[0];
          if (staticItem) {
            vnode.key = index;
            return vnode;
          }
          return createVNode(ResizeObserver, {
            "key": index,
            "onResize": refresh
          }, {
            default: () => vnode
          });
        }) : itemSlot == null ? void 0 : itemSlot(), counterVNode ? createVNode(Fragment, {
          "ref": syncCounterRef
        }, [renderCounter()]) : createVNode("span", {
          "ref": counter,
          "style": {
            display: "inline-block"
          }
        }, null), slots.suffix ? createVNode(ResizeObserver, {
          "onResize": refresh
        }, {
          default: () => [createVNode("div", {
            "ref": suffix,
            "class": nh.be("suffix")
          }, [slots.suffix()])]
        }) : null]
      });
      if (false) {
        return render();
      }
      return createVNode(ResizeObserver, {
        "onResize": refresh
      }, _isSlot(_slot = render()) ? _slot : {
        default: () => [_slot]
      });
    };
  }
});
export { Overflow as default };
