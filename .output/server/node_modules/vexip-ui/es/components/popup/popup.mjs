import { defineComponent, ref, computed, provide, watch, reactive, resolveComponent, openBlock, createElementBlock, normalizeClass, Fragment, renderList, createBlock, normalizeStyle, withCtx, renderSlot } from "vue";
import PopupItem from "./popup-item.mjs";
import "../../common/config/src/index.mjs";
import { isFunction, noop } from "@vexip-ui/utils";
import { DELETE_HANDLER } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { classProp } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const popupPlacements = Object.freeze([
  "top-right",
  "top-center",
  "top-left",
  "bottom-right",
  "bottom-center",
  "bottom-left"
]);
let globalIndex = 0;
function getIndex() {
  return globalIndex++;
}
const _sfc_main = defineComponent({
  name: "Popup",
  components: {
    PopupItem
  },
  props: {
    transitionName: {
      type: String,
      default: null
    },
    innerClass: {
      type: classProp,
      default: null
    },
    startOffset: {
      type: Number,
      default: 30
    },
    placement: {
      default: "top-right",
      validator: (value) => popupPlacements.includes(value)
    },
    itemOffset: {
      type: Number,
      default: 16
    }
  },
  setup(props) {
    const nh = useNameHelper("popup");
    const items = ref([]);
    const queue = [];
    const wrapper = ref();
    let pending = false;
    const placementArray = computed(() => {
      return props.placement.split("-");
    });
    const transition = computed(() => props.transitionName || nh.ns("popup-top"));
    provide(DELETE_HANDLER, deleteItem);
    watch(
      () => props.startOffset,
      (value, prevValue) => {
        items.value.forEach((item) => {
          item.verticalPosition += value - prevValue;
        });
      }
    );
    function getItemStyle(item) {
      const [verticalStyle, horizontalStyle] = placementArray.value;
      const style = { [verticalStyle]: `${item.verticalPosition}px` };
      if (horizontalStyle === "center") {
        style.left = "50%";
        style.transform = "translateX(-50%)";
      } else {
        style[horizontalStyle] = "24px";
      }
      return style;
    }
    function add(options) {
      return new Promise((resolve) => {
        const onOpen = isFunction(options.onOpen) ? options.onOpen : noop;
        options.onOpen = (key) => {
          resolve(key);
          onOpen();
        };
        queue.push({
          type: "add",
          param: options
        });
        if (!pending) {
          pending = true;
          queueOut();
        }
      });
    }
    function remove(key) {
      return new Promise((resolve) => {
        const item = find(key);
        if (!item)
          return resolve(false);
        const onClose = isFunction(item.onClose) ? item.onClose : noop;
        item.onClose = (reslut) => {
          resolve(reslut);
          onClose(reslut);
        };
        queue.push({
          type: "clear",
          param: key
        });
        if (!pending) {
          pending = true;
          queueOut();
        }
      });
    }
    function queueOut() {
      if (queue.length) {
        const state = queue.shift();
        if (state.type === "add") {
          renderItem(state.param);
        } else {
          removeItem(state.param);
        }
        requestAnimationFrame(queueOut);
      } else {
        pending = false;
      }
    }
    function renderItem(options) {
      var _a;
      let item = options.key ? find(options.key) : null;
      if (!(item == null ? void 0 : item.visible)) {
        const index = getIndex();
        const key = (_a = options.key) != null ? _a : nh.bs(`${index}`);
        let currentVertical = props.startOffset;
        items.value.forEach((existingItem) => {
          if (existingItem.visible) {
            currentVertical += existingItem.height + props.itemOffset;
          }
        });
        item = reactive(
          Object.assign(
            {
              key,
              content: "",
              closable: false,
              onOpen: noop,
              onClose: noop
            },
            options,
            {
              height: 0,
              visible: true,
              verticalPosition: currentVertical
            }
          )
        );
        items.value.push(item);
      }
      isFunction(options.onOpen) && options.onOpen(item.key);
    }
    function removeItem(key) {
      const index = items.value.findIndex((item) => item.key === key);
      if (~index) {
        const item = items.value[index];
        const removeHeight = item.height;
        item.visible = false;
        for (let i = index + 1, len = items.value.length; i < len; ++i) {
          items.value[i].verticalPosition -= removeHeight + props.itemOffset;
        }
        isFunction(item.onClose) && item.onClose(true);
      }
    }
    function deleteItem(key) {
      const index = items.value.findIndex((item) => item.key === key);
      if (~index) {
        items.value.splice(index, 1);
      }
    }
    function has(key) {
      return !~items.value.findIndex((item) => item.key === key);
    }
    function find(key) {
      return items.value.find((item) => item.key === key);
    }
    function clear() {
      queue.length = 0;
      items.value = [];
    }
    return {
      nh,
      items,
      transition,
      wrapper,
      getItemStyle,
      add,
      remove,
      has,
      find,
      clear
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_PopupItem = resolveComponent("PopupItem");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bm(_ctx.placement)])
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.items, (item) => {
      return openBlock(), createBlock(_component_PopupItem, {
        key: item.key,
        ref_for: true,
        ref: "instances",
        state: item,
        "transition-name": _ctx.transition,
        "inner-class": _ctx.innerClass,
        style: normalizeStyle(_ctx.getItemStyle(item))
      }, {
        default: withCtx(({ item: itemData }) => [
          renderSlot(_ctx.$slots, "item", { item: itemData })
        ]),
        _: 2
      }, 1032, ["state", "transition-name", "inner-class", "style"]);
    }), 128))
  ], 2);
}
var Popup = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Popup as default };
