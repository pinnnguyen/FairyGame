import { defineComponent, ref, toRef, reactive, computed, watchEffect, watch, onMounted, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle, renderSlot, createVNode, createCommentVNode, Fragment, renderList, createBlock, withModifiers, withCtx, createTextVNode, toDisplayString, Transition } from "vue";
import "../icon/index.mjs";
import "../option/index.mjs";
import "../portal/index.mjs";
import "../tag/index.mjs";
import "../virtual-list/index.mjs";
import "../form/index.mjs";
import { placementWhileList, useMounted, useClickOutside, usePopper, useHover, useModifier } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { isNull, removeArrayItem, getRangeWidth } from "@vexip-ui/utils";
import { Check, CircleXmark, ChevronDown, Spinner } from "@vexip-ui/icons";
import { selectProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import Option from "../option/option.mjs";
import Portal from "../portal/portal.mjs";
import Tag from "../tag/tag.mjs";
import VirtualList from "../virtual-list/virtual-list.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const defaultKeyConfig = {
  value: "value",
  label: "label",
  disabled: "disabled",
  divided: "divided",
  noTitle: "noTitle",
  group: "group",
  children: "children"
};
function isSameValue(newValue, oldValue) {
  const isNewArray = Array.isArray(newValue);
  const isOldArray = Array.isArray(oldValue);
  if (isNewArray !== isOldArray)
    return false;
  if (isNewArray && isOldArray) {
    if (newValue.length !== oldValue.length)
      return false;
    for (let i = 0, len = newValue.length; i < len; ++i) {
      if (newValue[i] !== oldValue[i])
        return false;
    }
    return true;
  }
  if (isNull(newValue))
    return isNull(oldValue);
  return newValue === oldValue;
}
const _sfc_main = defineComponent({
  name: "Select",
  components: {
    Icon,
    Option,
    Portal,
    Tag,
    VirtualList,
    Check,
    CircleXmark,
    ChevronDown
  },
  props: selectProps,
  emits: ["update:value", "update:visible", "update:label"],
  setup(_props, { emit, slots }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("select");
    const props = useProps("select", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      visible: {
        default: false,
        static: true
      },
      options: {
        default: () => [],
        static: true
      },
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      outsideClose: true,
      placeholder: null,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      value: {
        default: () => getFieldValue(null),
        static: true
      },
      multiple: false,
      clearable: false,
      maxListHeight: 300,
      listClass: null,
      placement: {
        default: "bottom",
        validator: (value) => placementWhileList.includes(value)
      },
      transfer: false,
      optionCheck: false,
      emptyText: null,
      staticSuffix: false,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      keyConfig: () => ({}),
      filter: false,
      ignoreCase: false,
      creatable: false,
      transparent: false
    });
    const locale = useLocale("select");
    const currentVisible = ref(props.visible);
    const currentLabels = ref([]);
    const currentValues = ref([]);
    const currentIndex = ref(-1);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const listHeight = ref();
    const baseOptions = ref([]);
    const currentFilter = ref("");
    const anchorWidth = ref(0);
    const userOptions = ref([]);
    const { isMounted } = useMounted();
    const dynamicOption = reactive({
      disabled: false,
      divided: false,
      noTitle: false,
      value: "",
      label: "",
      group: false,
      depth: 0,
      parent: null,
      hidden: false,
      hitting: true,
      data: ""
    });
    const optionValues = reactive(/* @__PURE__ */ new Set());
    const optionStates = computed(() => userOptions.value.concat(baseOptions.value));
    const visibleOptions = computed(() => optionStates.value.filter((state2) => !state2.hidden));
    const keyConfig = computed(() => ({ ...defaultKeyConfig, ...props.keyConfig }));
    let optionValueMap = /* @__PURE__ */ new Map();
    let emittedValue = props.value;
    const updateTrigger = ref(0);
    watchEffect(() => {
      props.keyConfig.value;
      props.keyConfig.label;
      props.keyConfig.disabled;
      props.keyConfig.divided;
      props.keyConfig.noTitle;
      props.options;
      updateTrigger.value++;
    });
    watch(updateTrigger, initOptionState, { immediate: true });
    function initOptionState() {
      var _a, _b;
      const {
        value: valueKey,
        label: labelKey,
        disabled: disabledKey,
        divided: dividedKey,
        noTitle: noTitleKey,
        group: groupKey,
        children: childrenKey
      } = keyConfig.value;
      const oldMap = optionValueMap;
      const map = /* @__PURE__ */ new Map();
      const states = [];
      const loop = props.options.map((option) => ({ option, depth: 0, parent: null })).reverse();
      optionValues.clear();
      for (const option of userOptions.value) {
        map.set(option.value, option);
        optionValues.add(option.value);
      }
      while (loop.length) {
        const { option, depth, parent } = loop.pop();
        const rawOption = typeof option === "string" ? { [valueKey]: option } : option;
        const group = !!rawOption[groupKey];
        const value = rawOption[valueKey];
        if (!group && isNull(value))
          return;
        const label = rawOption[labelKey] || String(value);
        const {
          [disabledKey]: disabled2 = false,
          [dividedKey]: divided = false,
          [noTitleKey]: noTitle = false,
          [childrenKey]: children = null
        } = rawOption;
        const oldState = oldMap.get(rawOption.value);
        const optionState = reactive({
          disabled: disabled2,
          divided,
          noTitle,
          value,
          label,
          group,
          depth,
          parent,
          hidden: (_a = oldState == null ? void 0 : oldState.hidden) != null ? _a : false,
          hitting: (_b = oldState == null ? void 0 : oldState.hitting) != null ? _b : false,
          data: option
        });
        states.push(optionState);
        if (!group) {
          map.set(value, optionState);
          optionValues.add(String(value));
        }
        if (Array.isArray(children) && children.length) {
          loop.push(
            ...children.map((child) => {
              return { option: child, depth: depth + 1, parent: optionState };
            }).reverse()
          );
        }
      }
      optionValueMap = map;
      baseOptions.value = states;
      initValueAndLabel(emittedValue);
    }
    const wrapper = useClickOutside(handleClickOutside);
    const input = ref();
    const device = ref();
    const virtualList = ref();
    const { reference, popper, transferTo, updatePopper } = usePopper({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = useHover(reference);
    useModifier({
      target: wrapper,
      passive: false,
      onKeyDown: (event, modifier) => {
        if (!currentVisible.value) {
          if (modifier.space) {
            event.preventDefault();
            event.stopPropagation();
            toggleVisible();
          }
          return;
        }
        if (modifier.up || modifier.down) {
          event.preventDefault();
          event.stopPropagation();
          const options = visibleOptions.value;
          const length = options.length;
          if (!length)
            return;
          const step = modifier.down ? 1 : -1;
          let index = (Math.max(-1, currentIndex.value + step) + length) % length;
          let option = options[index];
          for (let i = 0; (option.disabled || option.group) && i < length; ++i) {
            index += step;
            index = (index + length) % length;
            option = options[index];
          }
          updateHitting(index);
          modifier.resetAll();
        } else if (modifier.enter) {
          event.preventDefault();
          event.stopPropagation();
          if (currentIndex.value >= 0) {
            handleSelect(totalOptions.value[currentIndex.value]);
          } else if (showDynamic.value) {
            handleSelect(dynamicOption);
          } else {
            currentVisible.value = false;
          }
          modifier.resetAll();
        } else if (modifier.tab || modifier.escape) {
          currentVisible.value = false;
          modifier.resetAll();
        }
      }
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("multiple")]: props.multiple,
        [nh.bm("filter")]: props.filter
      };
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--focused`]: !props.disabled && currentVisible.value,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--${props.state}`]: props.state !== "default",
        [`${baseCls}--has-prefix`]: hasPrefix.value,
        [`${baseCls}--has-suffix`]: !props.noSuffix,
        [`${baseCls}--transparent`]: props.transparent
      };
    });
    const hasValue = computed(() => !isNull(currentValues.value[0]));
    const hasPrefix = computed(() => !!(slots.prefix || props.prefix));
    const showDynamic = computed(() => {
      return !!(props.filter && props.creatable && dynamicOption.value && !optionValues.has(dynamicOption.value));
    });
    const totalOptions = computed(() => {
      return showDynamic.value ? [dynamicOption].concat(visibleOptions.value) : visibleOptions.value;
    });
    const normalOptions = computed(() => optionStates.value.filter((option) => !option.group));
    const optionParentMap = computed(() => {
      const options = normalOptions.value;
      const map = /* @__PURE__ */ new Map();
      for (let i = 0, len = options.length; i < len; ++i) {
        const option = options[i];
        if (option.parent) {
          map.set(option.value, option.parent);
        }
      }
      return map;
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && hasValue.value;
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        initHittingIndex();
        requestAnimationFrame(() => {
          updatePopper();
          if (wrapper.value && popper.value) {
            popper.value.style.minWidth = `${wrapper.value.offsetWidth}px`;
          }
        });
        setTimeout(() => {
          if (virtualList.value && !isNull(currentValues.value[0])) {
            virtualList.value.ensureKeyInView(currentValues.value[0]);
          }
        }, 32);
      }
      syncInputValue();
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(
      () => props.value,
      (value) => {
        if (!emittedValue || isSameValue(value, emittedValue)) {
          emittedValue = value;
          initValueAndLabel(value);
        }
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    watch(currentFilter, (value) => {
      dynamicOption.value = value;
      dynamicOption.label = value;
      dynamicOption.data = value;
      filterOptions(value);
    });
    onMounted(syncInputValue);
    function initValueAndLabel(value) {
      if (isNull(value)) {
        currentValues.value = [];
        currentLabels.value = [];
        return;
      }
      const normalizedValue = !Array.isArray(value) ? [value] : value;
      const valueSet = new Set(normalizedValue);
      const selectedValues = [];
      const selectedLabels = [];
      valueSet.forEach((value2) => {
        const option = optionValueMap.get(value2);
        if (option) {
          selectedValues.push(option.value);
          selectedLabels.push(option.label);
        }
      });
      currentValues.value = selectedValues;
      currentLabels.value = selectedLabels;
      initHittingIndex();
      filterOptions(currentFilter.value);
    }
    function initHittingIndex() {
      const value = currentValues.value[0];
      if (isNull(value)) {
        updateHitting(-1);
      } else {
        if (!isMounted.value)
          return;
        updateHitting(visibleOptions.value.findIndex((option) => option.value === value));
      }
    }
    function updateHitting(hitting, ensureInView = true) {
      currentIndex.value = hitting;
      let index = -1;
      visibleOptions.value.forEach((option) => {
        if (!option.hidden) {
          index += 1;
          option.hitting = hitting === index;
        } else {
          option.hitting = false;
        }
      });
      if (ensureInView && currentVisible.value && virtualList.value) {
        virtualList.value.ensureIndexInView(hitting);
      }
    }
    function isSelected(option) {
      if (props.multiple) {
        return currentValues.value.includes(option.value);
      }
      return currentValues.value[0] === option.value;
    }
    function filterOptions(value) {
      const filter = props.filter;
      if (!filter)
        return;
      if (!value) {
        optionStates.value.forEach((state2) => {
          state2.hidden = false;
        });
      } else {
        optionStates.value.forEach((state2) => {
          state2.hidden = true;
        });
        if (typeof filter === "function") {
          normalOptions.value.forEach((state2) => {
            state2.hidden = !filter(value, state2);
          });
        } else {
          if (props.ignoreCase) {
            const ignoreCaseValue = value.toString().toLocaleLowerCase();
            normalOptions.value.forEach((state2) => {
              var _a;
              state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().toLocaleLowerCase().includes(ignoreCaseValue));
            });
          } else {
            normalOptions.value.forEach((state2) => {
              var _a;
              state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().includes(value == null ? void 0 : value.toString()));
            });
          }
        }
        const parentMap = optionParentMap.value;
        normalOptions.value.forEach((option) => {
          if (!option.hidden && option.parent) {
            let parent = parentMap.get(option.value) || null;
            while (parent && parent.hidden) {
              parent.hidden = false;
              parent = parent.parent;
            }
          }
        });
      }
      updateHitting(currentIndex.value);
    }
    function handleTagClose(value) {
      handleSelect(optionValueMap.get(value));
    }
    function handleSelect(option) {
      if (!option)
        return;
      const selected = isSelected(option);
      const value = option.value;
      if (selected) {
        if (userOptions.value.find((item) => item.value === value)) {
          removeArrayItem(userOptions.value, (item) => item.value === value);
          optionValueMap.delete(value);
        }
      } else {
        if (!props.multiple) {
          userOptions.value.length = 0;
        }
        if (dynamicOption.value && value === dynamicOption.value) {
          const newOption = { ...dynamicOption };
          userOptions.value.push(newOption);
          optionValueMap.set(value, newOption);
        }
      }
      emitEvent(props[props.multiple && selected ? "onCancel" : "onSelect"], value, option.data);
      handleChange(option);
      if (props.multiple) {
        currentFilter.value = "";
        syncInputValue();
        updatePopper();
      } else {
        currentVisible.value = false;
      }
    }
    function handleChange(option) {
      if (props.multiple) {
        if (isSelected(option)) {
          const index = currentValues.value.findIndex((v) => v === option.value);
          if (~index) {
            currentValues.value.splice(index, 1);
            currentLabels.value.splice(index, 1);
          }
        } else {
          currentValues.value.push(option.value);
          currentLabels.value.push(option.label);
        }
        emittedValue = Array.from(currentValues.value);
        setFieldValue(emittedValue);
        emitEvent(
          props.onChange,
          emittedValue,
          emittedValue.map((value) => {
            var _a, _b;
            return (_b = (_a = optionValueMap.get(value)) == null ? void 0 : _a.data) != null ? _b : "";
          })
        );
        emit("update:value", emittedValue);
        emit("update:label", currentLabels.value);
        validateField();
      } else {
        const prevValue = currentValues.value[0];
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
        currentValues.value.push(option.value);
        currentLabels.value.push(option.label);
        if (prevValue !== option.value) {
          emittedValue = option.value;
          setFieldValue(emittedValue);
          emitEvent(props.onChange, emittedValue, option.data);
          emit("update:value", emittedValue);
          emit("update:label", currentLabels.value[0]);
          validateField();
        }
      }
    }
    function toggleVisible() {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      currentVisible.value = !currentVisible.value;
    }
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      if (props.outsideClose && currentVisible.value) {
        currentVisible.value = false;
        emitEvent(props.onOutsideClose);
      }
    }
    function handleClear() {
      if (props.clearable) {
        for (const option of userOptions.value) {
          optionValueMap.delete(option.value);
        }
        userOptions.value.length = 0;
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
        emittedValue = props.multiple ? [] : "";
        emitEvent(props.onChange, emittedValue, props.multiple ? [] : "");
        emit("update:value", emittedValue);
        emitEvent(props.onClear);
        clearField(emittedValue);
        updatePopper();
      }
    }
    function handleFocus(event) {
      emitEvent(props.onFocus, event);
    }
    function handleBlur(event) {
      emitEvent(props.onFocus, event);
    }
    function syncInputValue() {
      if (!input.value)
        return;
      const visible = currentVisible.value;
      if (props.multiple) {
        input.value.value = "";
      } else {
        input.value.value = visible ? "" : currentLabels.value[0] || "";
      }
      visible ? input.value.focus() : input.value.blur();
    }
    function handleFilterInput() {
      if (!input.value)
        return;
      currentFilter.value = input.value.value;
      if (showDynamic.value || currentIndex.value !== -1) {
        currentIndex.value = 0;
      } else {
        currentIndex.value = visibleOptions.value.findIndex(
          (option) => String(option.value) === currentFilter.value
        );
      }
      requestAnimationFrame(() => {
        if (props.multiple && device.value) {
          anchorWidth.value = getRangeWidth(device.value);
        }
        updatePopper();
      });
    }
    function handleBackspace(event) {
      if (!input.value)
        return;
      if (event.key === "Backspace" && !input.value.value && !isNull(currentValues.value.at(-1))) {
        event.stopPropagation();
        handleTagClose(currentValues.value.at(-1));
      }
    }
    return {
      props,
      nh,
      locale,
      idFor,
      currentVisible,
      currentValues,
      currentLabels,
      transferTo,
      listHeight,
      optionStates,
      isHover,
      currentFilter,
      anchorWidth,
      className,
      selectorClass,
      hasValue,
      hasPrefix,
      visibleOptions,
      totalOptions,
      showClear,
      normalOptions,
      optionParentMap,
      wrapper,
      reference,
      popper,
      input,
      device,
      virtualList,
      isSelected,
      filterOptions,
      updateHitting,
      handleTagClose,
      handleSelect,
      toggleVisible,
      handleClear,
      handleFocus,
      handleBlur,
      handleFilterInput,
      handleBackspace
    };
  }
});
const _hoisted_1 = ["id", "aria-disabled"];
const _hoisted_2 = ["disabled"];
const _hoisted_3 = ["disabled", "placeholder"];
const _hoisted_4 = ["title"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Tag = resolveComponent("Tag");
  const _component_ChevronDown = resolveComponent("ChevronDown");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_Check = resolveComponent("Check");
  const _component_Option = resolveComponent("Option");
  const _component_VirtualList = resolveComponent("VirtualList");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    "aria-disabled": _ctx.props.disabled ? "true" : void 0,
    onClick: _cache[8] || (_cache[8] = (...args) => _ctx.toggleVisible && _ctx.toggleVisible(...args))
  }, [
    createElementVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onFocus: _cache[4] || (_cache[4] = (...args) => _ctx.handleFocus && _ctx.handleFocus(...args)),
      onBlur: _cache[5] || (_cache[5] = (...args) => _ctx.handleBlur && _ctx.handleBlur(...args))
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        renderSlot(_ctx.$slots, "control", {}, () => {
          var _a, _b, _c;
          return [
            _ctx.props.multiple ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentValues, (item, index) => {
                return openBlock(), createBlock(_component_Tag, {
                  key: index,
                  inherit: "",
                  class: normalizeClass(_ctx.nh.be("tag")),
                  closable: "",
                  onClick: withModifiers(_ctx.toggleVisible, ["stop"]),
                  onClose: ($event) => _ctx.handleTagClose(item)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.currentLabels[index]), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "onClick", "onClose"]);
              }), 128)),
              _ctx.props.filter ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(_ctx.nh.be("anchor")),
                style: normalizeStyle({
                  width: `${_ctx.anchorWidth}px`
                })
              }, [
                createElementVNode("input", {
                  ref: "input",
                  class: normalizeClass([_ctx.nh.be("input"), _ctx.nh.bem("input", "multiple")]),
                  disabled: _ctx.props.disabled,
                  autocomplete: "off",
                  tabindex: "-1",
                  role: "combobox",
                  "aria-autocomplete": "list",
                  onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleFilterInput && _ctx.handleFilterInput(...args)),
                  onKeydown: _cache[1] || (_cache[1] = (...args) => _ctx.handleBackspace && _ctx.handleBackspace(...args))
                }, null, 42, _hoisted_2),
                createElementVNode("span", {
                  ref: "device",
                  class: normalizeClass(_ctx.nh.be("device")),
                  "aria-hidden": "true"
                }, toDisplayString(_ctx.currentFilter), 3)
              ], 6)) : createCommentVNode("", true)
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              _ctx.props.filter ? (openBlock(), createElementBlock("input", {
                key: 0,
                ref: "input",
                class: normalizeClass(_ctx.nh.be("input")),
                disabled: _ctx.props.disabled,
                placeholder: _ctx.currentLabels[0] || ((_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder),
                autocomplete: "off",
                tabindex: "-1",
                role: "combobox",
                "aria-autocomplete": "list",
                onInput: _cache[2] || (_cache[2] = (...args) => _ctx.handleFilterInput && _ctx.handleFilterInput(...args))
              }, null, 42, _hoisted_3)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                createTextVNode(toDisplayString(_ctx.currentLabels[0]), 1)
              ], 64))
            ], 64)),
            (_ctx.props.multiple || !_ctx.props.filter) && (!_ctx.currentVisible || !_ctx.currentFilter) && ((_b = _ctx.props.placeholder) != null ? _b : _ctx.locale.placeholder) && !_ctx.hasValue ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass(_ctx.nh.be("placeholder"))
            }, toDisplayString((_c = _ctx.props.placeholder) != null ? _c : _ctx.locale.placeholder), 3)) : createCommentVNode("", true)
          ];
        })
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          _ctx.props.suffix ? (openBlock(), createBlock(_component_Icon, {
            key: 0,
            icon: _ctx.props.suffix,
            class: normalizeClass({
              [_ctx.nh.be("arrow")]: !_ctx.props.staticSuffix
            })
          }, null, 8, ["icon", "class"])) : (openBlock(), createBlock(_component_Icon, {
            key: 1,
            class: normalizeClass(_ctx.nh.be("arrow"))
          }, {
            default: withCtx(() => [
              createVNode(_component_ChevronDown)
            ]),
            _: 1
          }, 8, ["class"]))
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.showClear ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[3] || (_cache[3] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onAfterLeave: _cache[7] || (_cache[7] = ($event) => _ctx.currentFilter = "")
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[6] || (_cache[6] = withModifiers(() => {
              }, ["stop"]))
            }, [
              createVNode(_component_VirtualList, {
                ref: "virtualList",
                inherit: "",
                class: normalizeClass([_ctx.nh.be("list"), _ctx.props.listClass]),
                style: normalizeStyle({
                  height: _ctx.listHeight,
                  maxHeight: `${_ctx.props.maxListHeight}px`
                }),
                items: _ctx.totalOptions,
                "item-size": 32,
                "use-y-bar": "",
                height: "100%",
                "id-key": "value",
                "items-attrs": {
                  class: [_ctx.nh.be("options"), _ctx.props.optionCheck ? _ctx.nh.bem("options", "has-check") : ""],
                  role: "listbox",
                  ariaLabel: "options"
                }
              }, {
                default: withCtx(({ item: option, index }) => [
                  option.group ? (openBlock(), createElementBlock("li", {
                    key: 0,
                    class: normalizeClass([_ctx.nh.ns("option-vars"), _ctx.nh.be("group")]),
                    title: option.label
                  }, [
                    renderSlot(_ctx.$slots, "group", {
                      option,
                      index
                    }, () => [
                      createElementVNode("div", {
                        class: normalizeClass([_ctx.nh.be("label"), _ctx.nh.bem("label", "group")]),
                        style: normalizeStyle({ paddingLeft: `${option.depth * 6}px` })
                      }, toDisplayString(option.label), 7)
                    ])
                  ], 10, _hoisted_4)) : (openBlock(), createBlock(_component_Option, {
                    key: 1,
                    label: option.label,
                    value: option.value,
                    disabled: option.disabled,
                    divided: option.divided,
                    "no-title": option.noTitle,
                    hitting: option.hitting,
                    selected: _ctx.isSelected(option),
                    "no-hover": "",
                    onSelect: ($event) => _ctx.handleSelect(option),
                    onMousemove: ($event) => _ctx.updateHitting(index, false)
                  }, {
                    default: withCtx(() => [
                      renderSlot(_ctx.$slots, "default", {
                        option,
                        index,
                        selected: _ctx.isSelected(option)
                      }, () => [
                        createElementVNode("span", {
                          class: normalizeClass(_ctx.nh.be("label")),
                          style: normalizeStyle({ paddingLeft: `${option.depth * 6}px` })
                        }, toDisplayString(option.label), 7),
                        _ctx.props.optionCheck ? (openBlock(), createBlock(Transition, {
                          key: 0,
                          name: _ctx.nh.ns("fade"),
                          appear: ""
                        }, {
                          default: withCtx(() => [
                            _ctx.isSelected(option) ? (openBlock(), createBlock(_component_Icon, {
                              key: 0,
                              class: normalizeClass(_ctx.nh.be("check"))
                            }, {
                              default: withCtx(() => [
                                createVNode(_component_Check)
                              ]),
                              _: 1
                            }, 8, ["class"])) : createCommentVNode("", true)
                          ]),
                          _: 2
                        }, 1032, ["name"])) : createCommentVNode("", true)
                      ])
                    ]),
                    _: 2
                  }, 1032, ["label", "value", "disabled", "divided", "no-title", "hitting", "selected", "onSelect", "onMousemove"]))
                ]),
                empty: withCtx(() => [
                  createElementVNode("div", {
                    class: normalizeClass(_ctx.nh.be("empty"))
                  }, [
                    renderSlot(_ctx.$slots, "empty", {}, () => {
                      var _a;
                      return [
                        createTextVNode(toDisplayString((_a = _ctx.props.emptyText) != null ? _a : _ctx.locale.empty), 1)
                      ];
                    })
                  ], 2)
                ]),
                _: 3
              }, 8, ["class", "style", "items", "items-attrs"])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name"])
      ]),
      _: 3
    }, 8, ["to"])
  ], 10, _hoisted_1);
}
var Select = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Select as default };
