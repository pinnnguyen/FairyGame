import { defineComponent, ref, computed, watch, nextTick, resolveComponent, openBlock, createBlock, withCtx, createElementVNode, mergeProps, withKeys, withModifiers, Transition, withDirectives, normalizeClass, vShow, createCommentVNode, createVNode, renderSlot } from "vue";
import "../portal/index.mjs";
import "../../common/config/src/index.mjs";
import { isPromise, queryTabables } from "@vexip-ui/utils";
import { maskerProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Portal from "../portal/portal.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
const _sfc_main = defineComponent({
  name: "Masker",
  components: {
    Portal
  },
  props: maskerProps,
  emits: ["update:active"],
  setup(_props, { emit }) {
    const nh = useNameHelper("masker");
    const props = useProps("masker", _props, {
      active: {
        default: false,
        static: true
      },
      closable: false,
      inner: false,
      maskTransition: () => nh.ns("fade"),
      transitionName: () => nh.ns("fade"),
      disabled: false,
      onBeforeClose: {
        default: null,
        isFunc: true
      },
      transfer: false,
      autoRemove: false
    });
    const currentActive = ref(props.active);
    const wrapShow = ref(props.active);
    const wrapper = ref();
    const topTrap = ref();
    const bottomTrap = ref();
    let showing = false;
    let prevFocusdEl = null;
    const transferTo = computed(() => {
      return props.inner ? "" : typeof props.transfer === "boolean" ? props.transfer ? "body" : "" : props.transfer;
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inherit")]: transferTo.value !== "body" && props.inherit,
          [nh.bm("inner")]: props.inner,
          [nh.bm("disabled")]: props.disabled
        }
      ];
    });
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
        if (value) {
          wrapShow.value = value;
        }
      }
    );
    watch(currentActive, (value) => {
      if (!value) {
        showing = false;
        if (prevFocusdEl) {
          prevFocusdEl.focus();
          prevFocusdEl = null;
        }
      } else {
        prevFocusdEl = document.activeElement;
      }
      emitEvent(props.onToggle, value);
      emit("update:active", value);
    });
    function toggleActive(value) {
      currentActive.value = value;
    }
    async function handleClose() {
      if (!props.closable)
        return;
      let result = true;
      if (typeof props.onBeforeClose === "function") {
        result = props.onBeforeClose();
        if (isPromise(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        nextTick(() => {
          toggleActive(false);
          emitEvent(props.onClose);
        });
      }
    }
    function afterClose() {
      nextTick(() => {
        wrapShow.value = false;
        emitEvent(props.onHide);
      });
    }
    function afterOpen() {
      var _a;
      const activeEl = document && document.activeElement;
      if (!activeEl || !wrapper.value || !wrapper.value.contains(activeEl)) {
        (_a = topTrap.value) == null ? void 0 : _a.focus();
      }
      nextTick(() => {
        showing = true;
        emitEvent(props.onShow);
      });
    }
    function handleFocusIn(event) {
      const target = event.target;
      if (!showing || !wrapper.value || !target || !topTrap.value || !bottomTrap.value) {
        return;
      }
      const tabables = queryTabables(wrapper.value);
      if (!tabables.length) {
        return;
      }
      if (topTrap.value === target) {
        tabables.at(-1).focus();
      } else if (bottomTrap.value === target) {
        tabables[0].focus();
      }
    }
    return {
      props,
      nh,
      currentActive,
      wrapShow,
      className,
      transferTo,
      wrapper,
      topTrap,
      bottomTrap,
      handleClose,
      afterClose,
      afterOpen,
      handleFocusIn
    };
  }
});
const _hoisted_1 = {
  ref: "topTrap",
  tabindex: "0",
  "aria-hidden": "true",
  style: { "width": "0", "height": "0", "overflow": "hidden", "outline": "none" }
};
const _hoisted_2 = {
  ref: "bottomTrap",
  tabindex: "0",
  "aria-hidden": "true",
  style: { "width": "0", "height": "0", "overflow": "hidden", "outline": "none" }
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");
  return !_ctx.props.autoRemove || _ctx.wrapShow ? (openBlock(), createBlock(_component_Portal, {
    key: 0,
    to: _ctx.transferTo
  }, {
    default: withCtx(() => [
      createElementVNode("div", mergeProps({
        ref: "wrapper",
        class: _ctx.className,
        tabindex: "-1",
        style: {
          pointerEvents: _ctx.wrapShow ? void 0 : "none",
          visibility: _ctx.wrapShow ? void 0 : "hidden"
        }
      }, _ctx.$attrs, {
        onFocusin: _cache[1] || (_cache[1] = (...args) => _ctx.handleFocusIn && _ctx.handleFocusIn(...args)),
        onKeydown: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.handleClose && _ctx.handleClose(...args), ["prevent"]), ["escape"]))
      }), [
        !_ctx.props.disabled ? (openBlock(), createBlock(Transition, {
          key: 0,
          appear: _ctx.props.autoRemove,
          name: _ctx.props.maskTransition,
          onAfterEnter: _ctx.afterOpen,
          onAfterLeave: _ctx.afterClose
        }, {
          default: withCtx(() => [
            withDirectives(createElementVNode("div", {
              class: normalizeClass(_ctx.nh.be("mask")),
              onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
            }, [
              createElementVNode("div", {
                class: normalizeClass(_ctx.nh.be("mask-inner"))
              }, null, 2)
            ], 2), [
              [vShow, _ctx.currentActive]
            ])
          ]),
          _: 1
        }, 8, ["appear", "name", "onAfterEnter", "onAfterLeave"])) : createCommentVNode("", true),
        createElementVNode("span", _hoisted_1, null, 512),
        createVNode(Transition, {
          appear: _ctx.props.autoRemove,
          name: _ctx.props.transitionName
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default", { show: _ctx.currentActive })
          ]),
          _: 3
        }, 8, ["appear", "name"]),
        createElementVNode("span", _hoisted_2, null, 512)
      ], 16)
    ]),
    _: 3
  }, 8, ["to"])) : createCommentVNode("", true);
}
var Masker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Masker as default };
