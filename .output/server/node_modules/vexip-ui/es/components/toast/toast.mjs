import { defineComponent, reactive, onMounted, nextTick, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, createVNode, Transition, withCtx, createCommentVNode, createBlock, Fragment, mergeProps, toDisplayString } from "vue";
import "../icon/index.mjs";
import "../renderer/index.mjs";
import "../../common/config/src/index.mjs";
import { isFunction } from "@vexip-ui/utils";
import { toastProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import Renderer from "../renderer/renderer.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps } from "../../common/config/src/props.mjs";
import { useZIndex } from "../../common/config/src/z-index.mjs";
const _sfc_main = defineComponent({
  name: "Toast",
  components: {
    Icon,
    Renderer
  },
  props: toastProps,
  emits: [],
  setup(_props) {
    const nh = useNameHelper("toast");
    const props = useProps("toast", _props, {
      bodyWidth: 100,
      icon: null,
      iconProps: () => ({}),
      position: "center",
      transitionName: () => nh.ns("ease"),
      closable: false,
      maskClose: false,
      showMask: false,
      maskClass: null,
      maskStyle: null,
      renderer: {
        default: null,
        isFunc: true,
        static: true
      },
      parseHtml: false
    });
    const state = reactive({
      visible: false,
      zIndex: 0,
      content: "",
      icon: props.icon,
      iconProps: props.iconProps,
      position: props.position,
      transition: props.transitionName,
      closable: props.closable,
      maskClose: props.maskClose,
      showMask: props.showMask,
      maskClass: props.maskClass,
      maskStyle: props.maskStyle,
      parseHtml: props.parseHtml,
      textOnly: false,
      renderer: props.renderer,
      onClose: null
    });
    const mounted = new Promise((resolve) => {
      onMounted(() => {
        nextTick(resolve);
      });
    });
    async function openToast(options) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
      state.zIndex = useZIndex().value;
      await mounted;
      state.content = (_a = options.content) != null ? _a : "";
      state.icon = (_b = options.icon) != null ? _b : props.icon;
      state.iconProps = (_c = options.iconProps) != null ? _c : props.iconProps;
      state.position = (_d = options.position) != null ? _d : props.position;
      state.transition = (_e = options.transitionName) != null ? _e : props.transitionName;
      state.closable = (_f = options.closable) != null ? _f : props.closable;
      state.maskClose = (_g = options.maskClose) != null ? _g : props.maskClose;
      state.showMask = (_h = options.showMask) != null ? _h : props.showMask;
      state.maskClass = (_i = options.maskClass) != null ? _i : props.maskClass;
      state.maskStyle = (_j = options.maskStyle) != null ? _j : props.maskStyle;
      state.parseHtml = (_k = options.parseHtml) != null ? _k : props.parseHtml;
      state.renderer = isFunction(options.renderer) ? options.renderer : props.renderer;
      state.onClose = options.onClose || null;
      state.textOnly = !state.icon;
      if (isFunction(state.renderer)) {
        const render = state.renderer;
        state.renderer = () => render(options);
        state.textOnly = false;
      }
      state.visible = true;
    }
    function cloasToast() {
      state.visible = false;
      if (isFunction(state.onClose)) {
        state.onClose();
      }
    }
    function handleReset() {
      if (state.visible)
        return;
      state.content = "";
      state.icon = props.icon;
      state.iconProps = props.iconProps;
      state.position = props.position;
      state.transition = props.transitionName;
      state.closable = props.closable;
      state.maskClose = props.maskClose;
      state.showMask = props.showMask;
      state.maskClass = props.maskClass;
      state.maskStyle = props.maskStyle;
      state.parseHtml = props.parseHtml;
      state.textOnly = false;
      state.renderer = props.renderer;
      state.onClose = null;
    }
    function handleWrapperClick() {
      if (state.visible && state.closable) {
        cloasToast();
      }
    }
    function handleMaskClick() {
      if (state.visible && state.maskClose) {
        cloasToast();
      }
    }
    return {
      props,
      nh,
      state,
      isFunction,
      openToast,
      cloasToast,
      handleReset,
      handleWrapperClick,
      handleMaskClick
    };
  }
});
const _hoisted_1 = ["innerHTML"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_Icon = resolveComponent("Icon");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass({
      [_ctx.nh.b()]: true,
      [_ctx.nh.bs("vars")]: true,
      [_ctx.nh.bm("text-only")]: _ctx.state.textOnly
    }),
    style: normalizeStyle({
      zIndex: _ctx.state.zIndex
    })
  }, [
    createVNode(Transition, {
      name: _ctx.nh.ns("fade")
    }, {
      default: withCtx(() => [
        _ctx.state.showMask && _ctx.state.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([_ctx.nh.be("mask"), _ctx.state.maskClass]),
          style: normalizeStyle(_ctx.state.maskStyle),
          onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleMaskClick && _ctx.handleMaskClick(...args))
        }, null, 6)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["name"]),
    createVNode(Transition, {
      name: _ctx.state.transition
    }, {
      default: withCtx(() => [
        _ctx.state.visible ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass({
            [_ctx.nh.be("wrapper")]: true,
            [_ctx.nh.bem("wrapper", _ctx.state.position)]: _ctx.state.position !== "center",
            [_ctx.nh.bem("wrapper", "closable")]: _ctx.state.closable
          }),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleWrapperClick && _ctx.handleWrapperClick(...args))
        }, [
          _ctx.isFunction(_ctx.state.renderer) ? (openBlock(), createBlock(_component_Renderer, {
            key: 0,
            renderer: _ctx.state.renderer
          }, null, 8, ["renderer"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            _ctx.state.icon ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass(_ctx.nh.be("icon"))
            }, [
              _ctx.isFunction(_ctx.icon) ? (openBlock(), createBlock(_component_Renderer, {
                key: 0,
                renderer: _ctx.icon
              }, null, 8, ["renderer"])) : (openBlock(), createBlock(_component_Icon, mergeProps({
                key: 1,
                icon: _ctx.state.icon,
                scale: 1.8
              }, _ctx.state.iconProps), null, 16, ["icon", "scale"]))
            ], 2)) : createCommentVNode("", true),
            _ctx.state.parseHtml ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass(_ctx.nh.be("content")),
              innerHTML: _ctx.state.content
            }, null, 10, _hoisted_1)) : (openBlock(), createElementBlock("div", {
              key: 2,
              class: normalizeClass(_ctx.nh.be("content"))
            }, toDisplayString(_ctx.state.content), 3))
          ], 64))
        ], 2)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["name"])
  ], 6);
}
var Component = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Component as default };
