import { defineComponent, computed, reactive, toRef, provide, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, renderSlot, Fragment, renderList, createBlock, withCtx, createTextVNode, toDisplayString } from "vue";
import "../breadcrumb-item/index.mjs";
import "../../common/config/src/index.mjs";
import { debounceMinor, isNull, callIfFunc } from "@vexip-ui/utils";
import { breadcrumbProps } from "./props.mjs";
import { BREADCRUMB_STATE } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import BreadcrumbItem from "./breadcrumb-item.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "Breadcrumb",
  components: {
    BreadcrumbItem
  },
  props: breadcrumbProps,
  emits: [],
  setup(_props, { slots }) {
    const props = useProps("breadcrumb", _props, {
      separator: "/",
      border: false,
      options: {
        default: () => [],
        static: true
      }
    });
    const nh = useNameHelper("breadcrumb");
    const itemStates = /* @__PURE__ */ new Set();
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("border")]: props.border
      };
    });
    const normalizedOptions = computed(() => {
      return props.options.map((option) => {
        if (typeof option === "string") {
          return { label: option };
        }
        return option;
      });
    });
    const refreshLabels = debounceMinor(() => {
      Array.from(itemStates).forEach((item, index) => {
        if (isNull(item.label)) {
          item.label = index + 1;
        }
      });
    });
    const state = reactive({
      separator: toRef(props, "separator"),
      separatorRenderer: null,
      increaseItem,
      decreaseItem,
      handleSelect,
      refreshLabels,
      handleSeparatorClick
    });
    provide(BREADCRUMB_STATE, state);
    watch(
      () => slots.separator,
      (value) => {
        state.separatorRenderer = value ? (data) => value(data) : null;
      },
      { immediate: true }
    );
    function increaseItem(item) {
      itemStates.add(item);
      refreshLabels();
    }
    function decreaseItem(item) {
      itemStates.delete(item);
      refreshLabels();
    }
    function handleSelect(label) {
      emitEvent(props.onSelect, label);
    }
    function handleSeparatorClick(label) {
      emitEvent(props.onSeparatorClick, label);
    }
    return {
      props,
      className,
      normalizedOptions,
      callIfFunc
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_BreadcrumbItem = resolveComponent("BreadcrumbItem");
  return openBlock(), createElementBlock("ol", {
    class: normalizeClass(_ctx.className)
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.normalizedOptions, (option) => {
        return openBlock(), createBlock(_component_BreadcrumbItem, {
          key: option.label,
          label: option.label
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(option.name ? _ctx.callIfFunc(option.name) : option.label), 1)
          ]),
          _: 2
        }, 1032, ["label"]);
      }), 128))
    ])
  ], 2);
}
var Breadcrumb = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Breadcrumb as default };
