import { defineComponent, ref, toRef, computed, watch, nextTick, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, withModifiers, createVNode, withCtx, createBlock, resolveDynamicComponent, renderSlot, createCommentVNode } from "vue";
import "../scrollbar/index.mjs";
import "../resize-observer/index.mjs";
import "../../common/config/src/index.mjs";
import { createEventEmitter, isTrue, USE_TOUCH } from "@vexip-ui/utils";
import { nativeScrollProps } from "./props.mjs";
import { useScrollWrapper } from "./hooks.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Scrollbar from "../scrollbar/scrollbar.mjs";
import ResizeObserver from "../resize-observer/resize-observer.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const scrollModes = Object.freeze(["horizontal", "vertical", "both"]);
const MOVE_EVENT = "mousemove";
const UP_EVENT = "mouseup";
const _sfc_main = defineComponent({
  name: "NativeScroll",
  components: {
    Scrollbar,
    ResizeObserver
  },
  props: nativeScrollProps,
  emits: [],
  setup(_props) {
    const props = useProps("nativeScroll", _props, {
      scrollClass: null,
      scrollStyle: () => ({}),
      mode: {
        default: "vertical",
        validator: (value) => scrollModes.includes(value)
      },
      width: "",
      height: "",
      disabled: false,
      pointer: false,
      scrollX: {
        default: 0,
        static: true
      },
      scrollY: {
        default: 0,
        static: true
      },
      useXBar: false,
      useYBar: false,
      barFade: 1500,
      barClass: null,
      autoplay: false,
      playWaiting: 500,
      onBeforeScroll: {
        default: null,
        isFunc: true
      },
      appear: false,
      barDuration: null,
      useBarTrack: false,
      wrapperTag: "div"
    });
    const emitter = createEventEmitter();
    const nh = useNameHelper("native-scroll");
    const usingBar = ref(false);
    const scrolling = ref(false);
    const {
      contentElement,
      currentScroll,
      percentX,
      percentY,
      xScrollLimit,
      yScrollLimit,
      enableXScroll,
      enableYScroll,
      xBarLength,
      yBarLength,
      handleResize,
      setScrollX,
      setScrollY,
      computePercent,
      refresh,
      scrollTo,
      scrollBy,
      scrollToElement
    } = useScrollWrapper({
      mode: toRef(props, "mode"),
      disabled: toRef(props, "disabled"),
      appear: toRef(props, "appear"),
      width: toRef(props, "width"),
      height: toRef(props, "height"),
      scrollX: toRef(props, "scrollX"),
      scrollY: toRef(props, "scrollY"),
      onResize: (entry) => {
        emitEvent(props.onResize, entry);
      },
      onBeforeRefresh: stopAutoplay,
      onAfterRefresh: startAutoplay
    });
    const canPlay = ref(false);
    const canAutoplay = computed(() => {
      return props.mode !== "both" && (isTrue(props.autoplay) || props.autoplay > 1e3) && (props.mode === "horizontal" && enableXScroll.value || props.mode === "vertical" && enableYScroll.value);
    });
    watch(
      () => props.autoplay,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    watch(
      () => props.playWaiting,
      () => {
        stopAutoplay();
        nextTick(startAutoplay);
      }
    );
    let playTimer;
    let startTimer;
    let endTimer;
    onBeforeUnmount(stopAutoplay);
    function startAutoplay() {
      if (!canAutoplay.value || !contentElement.value)
        return;
      stopAutoplay();
      const mode = props.mode;
      const distance = mode === "horizontal" ? "offsetWidth" : "offsetHeight";
      const limit = mode === "horizontal" ? xScrollLimit : yScrollLimit;
      const prop = mode === "horizontal" ? "x" : "y";
      const waiting = props.playWaiting < 20 ? 20 : props.playWaiting;
      const setScroll = mode === "horizontal" ? setScrollX : setScrollY;
      let playSpeed = 0.5;
      if (typeof props.autoplay === "number") {
        playSpeed = contentElement.value[distance] / props.autoplay * 16;
      }
      const scroll = () => {
        setScroll(currentScroll[prop] + playSpeed);
        if (currentScroll[prop] >= limit.value) {
          setScroll(limit.value);
          canPlay.value = false;
          computePercent();
          syncBarScroll();
          endTimer = setTimeout(() => {
            scrollTo(0, 0, 500);
            startTimer = setTimeout(() => {
              canPlay.value = true;
              scroll();
            }, 500 + waiting);
          }, waiting);
        } else {
          computePercent();
          syncBarScroll();
          if (canPlay.value) {
            requestAnimationFrame(scroll);
          }
        }
      };
      playTimer = setTimeout(() => {
        canPlay.value = true;
        scroll();
      }, waiting);
    }
    function stopAutoplay() {
      canPlay.value = false;
      clearTimeout(playTimer);
      clearTimeout(startTimer);
      clearTimeout(endTimer);
    }
    const className = computed(() => {
      return [
        nh.b(),
        nh.bm(props.mode),
        {
          [nh.bm("inherit")]: props.inherit
        }
      ];
    });
    const style = computed(() => {
      const { width, height } = props;
      return {
        width: width ? typeof width === "string" ? Number.isNaN(Number(width)) ? width : `${Number(width)}px` : `${width}px` : void 0,
        height: height ? typeof height === "string" ? Number.isNaN(Number(height)) ? height : `${Number(height)}px` : `${height}px` : void 0
      };
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        props.scrollClass,
        {
          [nh.bem("wrapper", "scrolling")]: scrolling.value,
          [nh.bem("wrapper", "using-bar")]: usingBar.value
        }
      ];
    });
    watch(enableXScroll, (value) => {
      emitEvent(props.onXEnabledChange, value);
    });
    watch(enableYScroll, (value) => {
      emitEvent(props.onYEnabledChange, value);
    });
    const xBar = ref();
    const yBar = ref();
    function syncBarScroll() {
      var _a, _b;
      (_a = xBar.value) == null ? void 0 : _a.handleScroll(percentX.value);
      (_b = yBar.value) == null ? void 0 : _b.handleScroll(percentY.value);
    }
    function handleMouseDown(event) {
      if (!props.pointer || event.button !== 0 || USE_TOUCH) {
        return false;
      }
      handlePointerDown(event);
    }
    let xScrollStartAt = 0;
    let yScrollStartAt = 0;
    let cursorXPosition = 0;
    let cursorYPosition = 0;
    function handlePointerDown(event) {
      if (!enableXScroll.value && !enableYScroll.value) {
        return false;
      }
      event.preventDefault();
      prepareScroll();
      xScrollStartAt = currentScroll.x;
      yScrollStartAt = currentScroll.y;
      cursorXPosition = event.clientX;
      cursorYPosition = event.clientY;
      document.addEventListener(MOVE_EVENT, handlePointerMove);
      document.addEventListener(UP_EVENT, handlePointerUp);
      emitEvent(props.onScrollStart, {
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handlePointerMove(event) {
      var _a;
      event.stopPropagation();
      event.preventDefault();
      const signX = event.clientX - cursorXPosition > 0 ? 1 : -1;
      const signY = event.clientY - cursorYPosition > 0 ? 1 : -1;
      if (((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX, signY })) === false) {
        return false;
      }
      scrolling.value = true;
      if (enableXScroll.value) {
        setScrollX(xScrollStartAt - (event.clientX - cursorXPosition));
      }
      if (enableYScroll.value) {
        setScrollY(yScrollStartAt - (event.clientY - cursorYPosition));
      }
      computePercent();
      syncBarScroll();
      emitScrollEvent(props.mode);
    }
    function handlePointerUp() {
      document.removeEventListener(MOVE_EVENT, handlePointerMove);
      document.removeEventListener(UP_EVENT, handlePointerUp);
      emitEvent(props.onScrollEnd, {
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      startAutoplay();
    }
    function handleWheel(event, type) {
      var _a;
      const isVerticalScroll = enableYScroll.value && type === "vertical";
      const isHorizontalScroll = enableXScroll.value && type === "horizontal";
      const sign = event.deltaY > 0 ? 1 : -1;
      emitEvent(props.onWheel, event, type);
      if ((isVerticalScroll || isHorizontalScroll) && ((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX: sign, signY: sign })) !== false) {
        const maxLimit = isVerticalScroll ? yScrollLimit.value : xScrollLimit.value;
        const scroll = isVerticalScroll ? currentScroll.y : currentScroll.x;
        if (sign > 0 ? scroll < maxLimit : scroll > 0) {
          event.stopPropagation();
          return false;
        }
      }
    }
    function handleScroll(event, type) {
      var _a;
      event.stopPropagation();
      event.preventDefault();
      if (contentElement.value) {
        const signX = contentElement.value.scrollLeft - currentScroll.x > 0 ? 1 : -1;
        const signY = contentElement.value.scrollTop - currentScroll.y > 0 ? 1 : -1;
        if (((_a = props.onBeforeScroll) == null ? void 0 : _a.call(props, { signX, signY })) === false) {
          contentElement.value.scrollTop = currentScroll.y;
          contentElement.value.scrollLeft = currentScroll.x;
          return;
        }
        currentScroll.y = contentElement.value.scrollTop;
        currentScroll.x = contentElement.value.scrollLeft;
      }
      computePercent();
      syncBarScroll();
      emitScrollEvent(type);
    }
    function prepareScroll() {
      stopAutoplay();
    }
    function handleBarScrollStart(type) {
      usingBar.value = true;
      emitEvent(props.onBarScrollStart, {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleBarScrollEnd(type) {
      usingBar.value = false;
      emitEvent(props.onBarScrollEnd, {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function handleXBarScroll(percent) {
      percentX.value = percent;
      setScrollX(percent * xScrollLimit.value / 100);
      emitEvent(props.onBarScroll, {
        type: "horizontal",
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("horizontal");
    }
    function handleYBarScroll(percent) {
      percentY.value = percent;
      setScrollY(percent * yScrollLimit.value / 100);
      emitEvent(props.onBarScroll, {
        type: "vertical",
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitScrollEvent("vertical");
    }
    function emitScrollEvent(type) {
      emitEvent(props.onScroll, {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
      emitter.emit("scroll", {
        type,
        clientX: currentScroll.x,
        clientY: currentScroll.y,
        percentX: percentX.value,
        percentY: percentY.value
      });
    }
    function getXScrollLimit() {
      return [0, xScrollLimit.value];
    }
    function getYScrollLimit() {
      return [0, yScrollLimit.value];
    }
    function addScrollListener(listener) {
      emitter.on("scroll", listener);
    }
    function removeScrollListener(listener) {
      emitter.off("scroll", listener);
    }
    return {
      props,
      nh,
      percentX,
      percentY,
      currentScroll,
      xScrollLimit,
      yScrollLimit,
      className,
      style,
      wrapperClass,
      xBarLength,
      yBarLength,
      enableXScroll,
      enableYScroll,
      wrapper: ref(),
      content: contentElement,
      xBar,
      yBar,
      handleResize,
      handleMouseDown,
      handleScroll,
      handleWheel,
      handleBarScrollStart,
      handleBarScrollEnd,
      handleXBarScroll,
      handleYBarScroll,
      refresh,
      scrollTo,
      scrollBy,
      scrollToElement,
      getXScrollLimit,
      getYScrollLimit,
      addScrollListener,
      removeScrollListener
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_Scrollbar = resolveComponent("Scrollbar");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    style: normalizeStyle(_ctx.style),
    onMousedown: _cache[6] || (_cache[6] = (...args) => _ctx.handleMouseDown && _ctx.handleMouseDown(...args)),
    onWheel: [
      _cache[7] || (_cache[7] = withModifiers(($event) => _ctx.handleWheel($event, "vertical"), ["exact"])),
      _cache[8] || (_cache[8] = withModifiers(($event) => _ctx.handleWheel($event, "horizontal"), ["shift"]))
    ]
  }, [
    createVNode(_component_ResizeObserver, {
      throttle: "",
      "on-resize": _ctx.handleResize
    }, {
      default: withCtx(() => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.props.wrapperTag || "div"), {
          ref: "content",
          class: normalizeClass(_ctx.wrapperClass),
          style: normalizeStyle(_ctx.props.scrollStyle),
          onScroll: [
            _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.handleScroll($event, "vertical"), ["exact"])),
            _cache[1] || (_cache[1] = withModifiers(($event) => _ctx.handleScroll($event, "horizontal"), ["shift"]))
          ]
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 40, ["class", "style"]))
      ]),
      _: 3
    }, 8, ["on-resize"]),
    _ctx.props.useXBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 0,
      ref: "xBar",
      inherit: "",
      placement: "bottom",
      class: normalizeClass([_ctx.nh.bem("bar", "horizontal"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.xBarLength,
      disabled: !_ctx.enableXScroll,
      appear: _ctx.props.appear,
      duration: _ctx.props.barDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[2] || (_cache[2] = ($event) => _ctx.handleBarScrollStart("horizontal")),
      onScroll: _ctx.handleXBarScroll,
      onScrollEnd: _cache[3] || (_cache[3] = ($event) => _ctx.handleBarScrollEnd("horizontal"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "appear", "duration", "use-track", "onScroll"])) : createCommentVNode("", true),
    _ctx.props.useYBar ? (openBlock(), createBlock(_component_Scrollbar, {
      key: 1,
      ref: "yBar",
      inherit: "",
      placement: "right",
      class: normalizeClass([_ctx.nh.bem("bar", "vertical"), _ctx.props.barClass]),
      fade: _ctx.props.barFade,
      "bar-length": _ctx.yBarLength,
      disabled: !_ctx.enableYScroll,
      appear: _ctx.props.appear,
      duration: _ctx.props.barDuration,
      "use-track": _ctx.props.useBarTrack,
      onScrollStart: _cache[4] || (_cache[4] = ($event) => _ctx.handleBarScrollStart("vertical")),
      onScroll: _ctx.handleYBarScroll,
      onScrollEnd: _cache[5] || (_cache[5] = ($event) => _ctx.handleBarScrollEnd("vertical"))
    }, null, 8, ["class", "fade", "bar-length", "disabled", "appear", "duration", "use-track", "onScroll"])) : createCommentVNode("", true)
  ], 38);
}
var NativeScroll = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { NativeScroll as default };
