import { defineComponent, inject, toRef, ref, computed, provide, watch, onMounted, nextTick, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, withKeys, withModifiers, renderSlot, createVNode, withCtx, Transition, withDirectives, vShow } from "vue";
import "../portal/index.mjs";
import { placementWhileList, useClickOutside, usePopper, useSetTimeout } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import DropdownDrop from "./dropdown-drop.mjs";
import { dropdownProps } from "./props.mjs";
import { useLabel } from "./hooks.mjs";
import { DROPDOWN_STATE, SELECT_HANDLER } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Portal from "../portal/portal.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
const _sfc_main = defineComponent({
  name: "Dropdown",
  components: {
    DropdownDrop,
    Portal
  },
  props: dropdownProps,
  emits: ["update:visible"],
  setup(_props, { emit }) {
    const nh = useNameHelper("dropdown");
    const props = useProps("dropdown", _props, {
      visible: {
        default: false,
        static: true
      },
      placement: {
        default: "bottom",
        validator: (value) => placementWhileList.includes(value)
      },
      outsideClose: true,
      trigger: {
        default: "hover",
        validator: (value) => ["hover", "click", "custom"].includes(value)
      },
      label: {
        default: null,
        static: true
      },
      transitionName: () => nh.ns("drop"),
      transfer: false,
      dropClass: null,
      appear: false,
      meta: null
    });
    const parentState = inject(DROPDOWN_STATE, null);
    const isNested = !!parentState;
    const label = toRef(props, "label");
    const placement = ref(props.placement);
    const currentVisible = ref(props.visible);
    const transfer = toRef(props, "transfer");
    const wrapper = useClickOutside(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = usePopper({
      placement,
      transfer,
      wrapper,
      isDrop: true,
      offset: isNested ? [-5, 0] : void 0
    });
    const currentLabel = useLabel(label, reference);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("visible")]: currentVisible.value
      };
    });
    provide(SELECT_HANDLER, null);
    provide(DROPDOWN_STATE, {
      handleSelect,
      handleTriggerEnter,
      handleTriggerLeave
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(
      () => props.placement,
      (value) => {
        setPlacement(value);
      }
    );
    watch(currentVisible, (value) => {
      if (value) {
        updatePopper();
      }
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    onMounted(() => {
      nextTick(() => {
        setPlacement(props.placement);
      });
    });
    function handleClickOutside() {
      emitEvent(props.onClickOutside);
      if (props.outsideClose && props.trigger !== "custom" && currentVisible.value) {
        currentVisible.value = false;
        emitEvent(props.onOutsideClose);
      }
    }
    function handleSelect(labels, metas) {
      if (props.trigger !== "custom") {
        currentVisible.value = false;
        emitEvent(props.onSelect, labels, metas);
      }
      if (typeof (parentState == null ? void 0 : parentState.handleSelect) === "function") {
        parentState.handleSelect([currentLabel.value, ...labels], [props.meta || {}, ...metas]);
      }
    }
    function setPlacement(value) {
      const [xPlacement] = value.split("-");
      if (isNested && xPlacement !== "right" && xPlacement !== "left") {
        placement.value = "right-start";
      } else {
        placement.value = value;
      }
    }
    const { timer } = useSetTimeout();
    function handleTriggerEnter() {
      if (props.trigger === "hover") {
        clearTimeout(timer.hover);
        if (typeof (parentState == null ? void 0 : parentState.handleTriggerEnter) === "function") {
          parentState.handleTriggerEnter();
        }
        timer.hover = setTimeout(() => {
          currentVisible.value = true;
        }, 250);
      }
    }
    function handleTriggerLeave() {
      if (props.trigger === "hover") {
        clearTimeout(timer.hover);
        if (typeof (parentState == null ? void 0 : parentState.handleTriggerLeave) === "function") {
          parentState.handleTriggerLeave();
        }
        timer.hover = setTimeout(() => {
          currentVisible.value = false;
        }, 250);
      }
    }
    function handleTriggerClick() {
      if (props.trigger === "click") {
        currentVisible.value = !currentVisible.value;
      }
    }
    return {
      props,
      nh,
      isNested,
      currentVisible,
      transferTo,
      wrapper,
      reference,
      popper,
      className,
      handleTriggerEnter,
      handleTriggerLeave,
      handleTriggerClick
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Portal = resolveComponent("Portal");
  const _component_DropdownDrop = resolveComponent("DropdownDrop");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onMouseenter: _cache[5] || (_cache[5] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
    onMouseleave: _cache[6] || (_cache[6] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
  }, [
    createElementVNode("div", {
      ref: "reference",
      class: normalizeClass([_ctx.nh.be("trigger"), _ctx.currentVisible ? _ctx.nh.bem("trigger", "active") : ""]),
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleTriggerClick && _ctx.handleTriggerClick(...args)),
      onKeydown: [
        _cache[1] || (_cache[1] = withKeys(withModifiers((...args) => _ctx.handleTriggerClick && _ctx.handleTriggerClick(...args), ["prevent"]), ["enter"])),
        _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => _ctx.handleTriggerClick && _ctx.handleTriggerClick(...args), ["prevent"]), ["space"]))
      ]
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 34),
    createVNode(_component_DropdownDrop, null, {
      default: withCtx(() => [
        createVNode(_component_Portal, { to: _ctx.transferTo }, {
          default: withCtx(() => [
            createVNode(Transition, {
              name: _ctx.props.transitionName,
              appear: _ctx.props.appear
            }, {
              default: withCtx(() => [
                withDirectives(createElementVNode("div", {
                  ref: "popper",
                  class: normalizeClass([
                    _ctx.nh.be("popper"),
                    _ctx.nh.bs("vars"),
                    _ctx.isNested ? _ctx.nh.bem("popper", "nested") : null,
                    _ctx.props.dropClass
                  ]),
                  onMouseenter: _cache[3] || (_cache[3] = (...args) => _ctx.handleTriggerEnter && _ctx.handleTriggerEnter(...args)),
                  onMouseleave: _cache[4] || (_cache[4] = (...args) => _ctx.handleTriggerLeave && _ctx.handleTriggerLeave(...args))
                }, [
                  renderSlot(_ctx.$slots, "drop")
                ], 34), [
                  [vShow, _ctx.currentVisible]
                ])
              ]),
              _: 3
            }, 8, ["name", "appear"])
          ]),
          _: 3
        }, 8, ["to"])
      ]),
      _: 3
    })
  ], 34);
}
var Dropdown = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Dropdown as default };
