import { defineComponent, ref, toRef, computed, watchEffect, watch, nextTick, onBeforeUpdate, reactive, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, withKeys, withModifiers, normalizeStyle, renderSlot, createVNode, createCommentVNode, createBlock, withCtx, createTextVNode, toDisplayString, Fragment, renderList, Transition, normalizeProps, guardReactiveProps } from "vue";
import CascaderPanel from "./cascader-panel.mjs";
import "../icon/index.mjs";
import "../native-scroll/index.mjs";
import "../overflow/index.mjs";
import "../portal/index.mjs";
import "../tag/index.mjs";
import "../tooltip/index.mjs";
import "../form/index.mjs";
import "../../common/config/src/index.mjs";
import { placementWhileList, useClickOutside, usePopper, useHover } from "@vexip-ui/hooks";
import { flatTree, transformTree, isPromise, isNull } from "@vexip-ui/utils";
import { ChevronDown, CircleXmark, Spinner } from "@vexip-ui/icons";
import { cascaderProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import NativeScroll from "../native-scroll/native-scroll.mjs";
import Overflow from "../overflow/overflow.mjs";
import Portal from "../portal/portal.mjs";
import Tag from "../tag/tag.mjs";
import Tooltip from "../tooltip/tooltip.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const ID_KEY = Symbol("ID_KEY");
const PARENT_KEY = Symbol("PARENT_KEY");
const defaultKeyConfig = {
  value: "value",
  label: "label",
  children: "children",
  disabled: "disabled",
  hasChild: "hasChild"
};
const _sfc_main = defineComponent({
  name: "Cascader",
  components: {
    CascaderPanel,
    Icon,
    NativeScroll,
    Overflow,
    Portal,
    Tag,
    Tooltip,
    ChevronDown,
    CircleXmark
  },
  props: cascaderProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { emit, slots }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("cascader");
    const props = useProps("cascader", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue([]),
        static: true
      },
      visible: {
        default: false,
        static: true
      },
      options: {
        default: () => [],
        static: true
      },
      placeholder: null,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noCascaded: false,
      multiple: false,
      disabled: () => disabled.value,
      clearable: false,
      placement: {
        default: "bottom-start",
        validator: (value) => placementWhileList.includes(value)
      },
      transfer: false,
      staticSuffix: false,
      noSuffix: false,
      transitionName: () => nh.ns("drop"),
      outsideClose: true,
      keyConfig: () => ({}),
      separator: {
        default: "/",
        validator: (value) => value.length === 1
      },
      hoverTrigger: false,
      maxTagCount: 0,
      briefLabel: false,
      noRestTip: false,
      onAsyncLoad: {
        default: null,
        isFunc: true
      },
      mergeTags: false,
      tagType: null,
      emptyText: null,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false,
      transparent: false
    });
    const currentVisible = ref(props.visible);
    const currentValues = ref([]);
    const currentLabels = ref([]);
    const mergedValues = ref([]);
    const mergedLabels = ref([]);
    const isPopperShow = ref(false);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const emittedValue = ref(null);
    const optionTree = ref(null);
    const isAsyncLoad = computed(() => typeof props.onAsyncLoad === "function");
    let optionList = null;
    let optionIdMap = null;
    let optionValueMap = null;
    let outsideClosed = false;
    let prevClosedId = -1;
    const updateTrigger = ref(0);
    watchEffect(() => {
      props.keyConfig.value;
      props.keyConfig.label;
      props.keyConfig.children;
      props.keyConfig.disabled;
      props.keyConfig.hasChild;
      props.separator;
      props.options;
      isAsyncLoad.value;
      updateTrigger.value++;
    });
    watch(updateTrigger, initOptionStates, { immediate: true });
    function initOptionStates() {
      var _a;
      const childrenKey = (_a = props.keyConfig.children) != null ? _a : defaultKeyConfig.children;
      const rawOptions = flatTree(props.options, {
        keyField: ID_KEY,
        parentField: PARENT_KEY,
        childField: childrenKey
      });
      const separator = props.separator;
      const isAsync = isAsyncLoad.value;
      optionList = createOptionStates(rawOptions);
      optionIdMap = /* @__PURE__ */ new Map();
      optionValueMap = /* @__PURE__ */ new Map();
      for (let i = 0, len = optionList.length; i < len; ++i) {
        const option = optionList[i];
        initOptionFull(option, separator);
        optionIdMap.set(option.id, option);
        optionValueMap.set(option.fullValue, option);
        if (isAsync) {
          option.childrenLoaded = queryChildrenLoaded(option);
        }
      }
      optionTree.value = transformTree(optionList);
      initValueAndLabel(emittedValue.value);
    }
    const openedIds = ref([]);
    const optionsList = computed(() => {
      return [
        optionTree.value,
        ...openedIds.value.map((id) => {
          var _a;
          return (_a = optionIdMap.get(id)) == null ? void 0 : _a.children;
        }).filter(Boolean)
      ];
    });
    const wrapper = useClickOutside(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = usePopper({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = useHover(reference);
    const locale = useLocale("select");
    const panelElList = ref([]);
    const restTagCount = ref(0);
    const restTipShow = ref(false);
    const selectorWidth = ref(0);
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("multiple")]: props.multiple,
        [nh.bm("responsive")]: props.multiple && props.maxTagCount <= 0
      };
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--focused`]: !props.disabled && currentVisible.value,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--${props.state}`]: props.state !== "default",
        [`${baseCls}--has-prefix`]: hasPrefix.value,
        [`${baseCls}--has-suffix`]: !props.noSuffix,
        [`${baseCls}--transparent`]: props.transparent
      };
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const usingMerged = computed(() => props.mergeTags && !props.noCascaded);
    const templateValues = computed(
      () => usingMerged.value ? mergedValues.value : currentValues.value
    );
    const templateLabels = computed(
      () => usingMerged.value ? mergedLabels.value : currentLabels.value
    );
    const hasValue = computed(() => !!templateValues.value[0]);
    const usingHover = computed(() => props.hoverTrigger && !isAsyncLoad.value);
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && hasValue.value;
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      var _a;
      if (value) {
        restTipShow.value = false;
        selectorWidth.value = ((_a = wrapper.value) == null ? void 0 : _a.offsetWidth) || 0;
        updatePopper();
        nextTick(() => {
          var _a2, _b;
          (_b = (_a2 = panelElList.value.at(-1)) == null ? void 0 : _a2.$el) == null ? void 0 : _b.focus();
        });
      } else {
        isPopperShow.value = false;
        if (reference.value && !outsideClosed) {
          reference.value.focus();
        }
      }
      outsideClosed = false;
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    let outsideChanged = false;
    watch(emittedValue, () => {
      outsideChanged = true;
    });
    watch(
      () => props.value,
      (value) => {
        if (value !== emittedValue.value || outsideChanged) {
          emittedValue.value = value;
          initValueAndLabel(value);
          nextTick(() => {
            outsideChanged = false;
          });
        }
      },
      { immediate: true }
    );
    watch(
      () => props.briefLabel,
      (brief) => {
        currentLabels.value = currentValues.value.map((value) => {
          var _a;
          return (_a = optionValueMap.get(value)) == null ? void 0 : _a[brief ? "label" : "fullLabel"];
        }).filter(Boolean);
      }
    );
    watch(isAsyncLoad, (value) => {
      if (value) {
        for (const option of optionIdMap.values()) {
          option.childrenLoaded = queryChildrenLoaded(option);
        }
      }
    });
    watch(usingMerged, (value) => {
      if (value) {
        mergedValues.value.length = 0;
        mergedLabels.value.length = 0;
        updateMergedProps();
      }
      if (isAsyncLoad.value) {
        const originalOptions = [];
        for (const option of optionIdMap.values()) {
          if (option.checked) {
            originalOptions.push(option);
          }
          if (option.hasChild && !option.children.length && !option.loaded) {
            option.checked = false;
          }
        }
        for (let i = 0, len = originalOptions.length; i < len; ++i) {
          const option = originalOptions[i];
          updateCheckedUpward(option);
          updateCheckedDown(option);
        }
      }
      emitMultipleChange();
    });
    watch(
      () => optionsList.value.length,
      () => {
        nextTick(() => {
          const panel = panelElList.value.at(-1);
          if (panel == null ? void 0 : panel.$el) {
            panel.$el.focus();
          }
          prevClosedId = -1;
        });
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loading,
      (value) => {
        if (value && props.loadingLock) {
          currentVisible.value = false;
        }
      }
    );
    watch(
      () => props.loadingLock,
      (value) => {
        if (props.loading && value) {
          currentVisible.value = false;
        }
      }
    );
    onBeforeUpdate(() => {
      panelElList.value.length = 0;
    });
    function createOptionStates(rawOptions) {
      const {
        value: valueKey,
        label: labelKey,
        disabled: disabledKey,
        hasChild: hasChildKey
      } = { ...defaultKeyConfig, ...props.keyConfig };
      return rawOptions.map((rawOption) => {
        const {
          [ID_KEY]: id,
          [PARENT_KEY]: parent,
          [valueKey]: value,
          [labelKey]: label,
          [disabledKey]: disabled2,
          [hasChildKey]: hasChild
        } = rawOption;
        return reactive({
          id,
          parent,
          value,
          disabled: disabled2,
          hasChild,
          label: label || String(value),
          fullValue: "",
          fullLabel: "",
          children: [],
          checked: false,
          partial: false,
          loading: false,
          loaded: false,
          error: false,
          childrenLoaded: false,
          data: rawOption
        });
      });
    }
    function initOptionFull(option, separator) {
      let value = option.value;
      let label = option.label;
      let parent = optionIdMap.get(option.parent);
      while (parent) {
        value = `${parent.value}${separator}${value}`;
        label = `${parent.label}${separator}${label}`;
        parent = optionIdMap.get(parent.parent);
      }
      option.fullValue = value;
      option.fullLabel = label;
    }
    function queryChildrenLoaded(option) {
      var _a, _b;
      if (option.hasChild && !((_a = option.children) == null ? void 0 : _a.length)) {
        return option.loaded;
      }
      const loop = [...option.children];
      while (loop.length) {
        const child = loop.shift();
        if (child.childrenLoaded)
          continue;
        if (child.hasChild && !((_b = child.children) == null ? void 0 : _b.length)) {
          child.childrenLoaded = child.loaded;
          if (!child.loaded)
            return false;
        }
        loop.push(...child.children);
      }
      return true;
    }
    function updateMergedProps() {
      const baseValues = isAsyncLoad.value ? currentValues.value.concat(mergedValues.value) : currentValues.value;
      const values = new Set(baseValues);
      const loop = [...baseValues];
      while (loop.length) {
        const value = loop.shift();
        const option = optionValueMap.get(value);
        if (option) {
          const parent = optionIdMap.get(option.parent);
          if (parent == null ? void 0 : parent.checked) {
            values.delete(value);
            values.add(parent.fullValue);
            loop.push(parent.fullValue);
          }
        }
      }
      const briefLabel = props.briefLabel;
      mergedValues.value = Array.from(values).filter((value) => optionValueMap.has(value));
      mergedLabels.value = mergedValues.value.map((value) => {
        const option = optionValueMap.get(value);
        return briefLabel ? option.label : option.fullLabel;
      }).filter(Boolean);
    }
    function isFlatArray(value) {
      return !!value.length && !Array.isArray(value[0]);
    }
    function isComplexArray(value) {
      return !!value.length && Array.isArray(value[0]);
    }
    function initValueAndLabel(value) {
      for (const option of optionList) {
        option.checked = false;
        option.partial = false;
      }
      if (!(value == null ? void 0 : value.length)) {
        currentValues.value = [];
        currentLabels.value = [];
        return;
      }
      const briefLabel = props.briefLabel;
      if (props.multiple) {
        const normalizedValue = isFlatArray(value) ? [value] : value;
        const valueSet = new Set(normalizedValue.map((v) => v.join(props.separator)));
        const selectedValues = [];
        const selectedLabels = [];
        const selectedOptions = [];
        valueSet.forEach((value2) => {
          const option = optionValueMap.get(value2);
          if (option) {
            option.checked = true;
            option.partial = false;
            selectedValues.push(value2);
            selectedLabels.push(briefLabel ? option.label : option.fullLabel);
            selectedOptions.push(option);
          }
        });
        if (!props.noCascaded) {
          const originalOptions = selectedOptions.concat(
            Array.from(optionIdMap.values()).filter((option) => option.disabled && option.checked)
          );
          for (let i = 0, len = originalOptions.length; i < len; ++i) {
            const option = originalOptions[i];
            updateCheckedUpward(option);
            updateCheckedDown(option);
          }
        }
        currentValues.value = selectedValues;
        currentLabels.value = selectedLabels;
      } else {
        const normalizedValue = isComplexArray(value) ? value[0] : value;
        const stringValue = normalizedValue.join(props.separator);
        const option = optionValueMap.get(stringValue);
        if (option) {
          currentValues.value = [stringValue];
          currentLabels.value = [briefLabel ? option.label : option.fullLabel];
          if (props.noCascaded) {
            option.checked = true;
            option.partial = false;
          }
        } else {
          currentValues.value = [];
          currentLabels.value = [];
        }
      }
      if (openedIds.value.length)
        return;
      const firstValue = currentValues.value[0];
      if (firstValue) {
        const option = optionValueMap.get(firstValue);
        const ids = [option.id];
        let parent = optionIdMap.get(option.parent);
        while (parent) {
          ids.push(parent.id);
          parent = optionIdMap.get(parent.parent);
        }
        openedIds.value = ids.reverse().slice(0, -1);
      }
    }
    async function handlePanelOpen(option, depth) {
      var _a, _b;
      if (!option.hasChild && !((_a = option.children) == null ? void 0 : _a.length))
        return;
      if (isAsyncLoad.value && !((_b = option.children) == null ? void 0 : _b.length) && !option.loaded) {
        option.loading = true;
        let result;
        try {
          result = props.onAsyncLoad(option.data);
          result = isPromise(result) ? await result : result;
        } catch (e) {
          option.error = true;
          option.loading = false;
          return;
        }
        const rawOptions = result;
        if (!Array.isArray(rawOptions) || !rawOptions.length) {
          option.hasChild = false;
        } else {
          const options = createOptionStates(rawOptions);
          const parentId = option.id;
          const separator = props.separator;
          option.children.push(...options);
          let idCount = Math.max(...Array.from(optionIdMap.keys()).map(Number)) + 1;
          options.forEach((option2) => {
            option2.id = idCount++;
            option2.parent = parentId;
            initOptionFull(option2, separator);
            optionIdMap.set(option2.id, option2);
            optionValueMap.set(option2.fullValue, option2);
          });
          optionList.push(...options);
        }
        option.loaded = true;
        option.loading = false;
        const upstream = queryUpstreamOptions(option);
        upstream.forEach((option2) => {
          option2.childrenLoaded = queryChildrenLoaded(option2);
        });
      }
      if (depth < openedIds.value.length) {
        openedIds.value = openedIds.value.slice(0, depth);
      }
      openedIds.value.push(option.id);
      requestAnimationFrame(() => {
        var _a2, _b2;
        (_b2 = (_a2 = panelElList.value.at(-1)) == null ? void 0 : _a2.$el) == null ? void 0 : _b2.focus();
      });
    }
    function handleOptionSelect(option, depth) {
      var _a;
      if (!option)
        return;
      if (option.hasChild || ((_a = option.children) == null ? void 0 : _a.length)) {
        handlePanelOpen(option, depth);
      } else {
        handleSingleSelect(option.fullValue);
      }
    }
    function queryUpstreamOptions(option) {
      const options = [option];
      let parent = optionIdMap.get(option.parent);
      while (parent) {
        options.push(parent);
        parent = optionIdMap.get(parent.parent);
      }
      return options;
    }
    function updateCheckedUpward(originalOption) {
      let option = originalOption;
      while (!isNull(option.parent)) {
        const parent = optionIdMap.get(option.parent);
        if (!parent)
          break;
        if (option.checked === parent.checked && option.partial === parent.partial) {
          break;
        }
        if (option.checked) {
          parent.checked = parent.children.every((item) => item.disabled || item.checked);
          parent.partial = !parent.checked;
        } else {
          parent.checked = false;
          parent.partial = parent.children.some((item) => item.checked || item.partial);
        }
        option = parent;
      }
    }
    function updateCheckedDown(originalOption) {
      var _a;
      const checked = originalOption.checked;
      const partial = originalOption.partial;
      const loop = [...originalOption.children];
      let option;
      while (loop.length) {
        option = loop.shift();
        if (option.disabled)
          continue;
        option.checked = checked;
        option.partial = partial;
        if ((_a = option.children) == null ? void 0 : _a.length) {
          loop.push(...option.children);
        }
      }
    }
    function handleOptionCheck(option) {
      if (!option)
        return;
      const options = Array.from(optionIdMap.values());
      const checked = !option.checked;
      if (!props.multiple) {
        for (let i = 0, len = options.length; i < len; ++i) {
          options[i].checked = false;
        }
        option.checked = checked;
        option.partial = false;
        return handleSingleSelect(option.fullValue);
      }
      option.checked = checked;
      option.partial = false;
      if (!props.noCascaded) {
        const originalOptions = [option].concat(
          options.filter((option2) => option2.disabled && option2.checked)
        );
        for (let i = 0, len = originalOptions.length; i < len; ++i) {
          const option2 = originalOptions[i];
          updateCheckedUpward(option2);
          updateCheckedDown(option2);
        }
      }
      emitEvent(props[checked ? "onSelect" : "onCancel"], option.fullValue, option.data);
      emitMultipleChange();
    }
    function emitMultipleChange() {
      const options = Array.from(optionIdMap.values());
      const selectedOptions = props.noCascaded ? options.filter((option) => option.checked) : options.filter((option) => {
        var _a;
        return option.checked && !(option.hasChild || ((_a = option.children) == null ? void 0 : _a.length));
      });
      const selectedValues = [];
      const selectedLabels = [];
      const values = [];
      const dataList = [];
      const briefLabel = props.briefLabel;
      selectedOptions.forEach((option) => {
        selectedValues.push(option.fullValue);
        selectedLabels.push(briefLabel ? option.label : option.fullLabel);
        const { value, data } = queryArrayMeta(option.fullValue);
        values.push(value);
        dataList.push(data);
      });
      currentValues.value = selectedValues;
      currentLabels.value = selectedLabels;
      if (usingMerged.value) {
        if (isAsyncLoad.value) {
          mergedValues.value = options.filter((option) => option.checked).map((option) => option.fullValue);
        }
        updateMergedProps();
      }
      if (usingMerged.value && isAsyncLoad.value) {
        values.length = 0;
        dataList.length = 0;
        mergedValues.value.forEach((fullValue) => {
          const option = optionValueMap.get(fullValue);
          if (option) {
            const { value, data } = queryArrayMeta(option.fullValue);
            values.push(value);
            dataList.push(data);
          }
        });
      }
      emitChangeEvent(values, dataList);
      nextTick(updatePopper);
    }
    function handleSingleSelect(fullValue) {
      const option = optionValueMap.get(fullValue);
      if (!option)
        return;
      emitEvent(props.onSelect, fullValue, option.data);
      if (fullValue) {
        currentValues.value[0] = fullValue;
        currentLabels.value[0] = props.briefLabel ? option.label : option.fullLabel;
      } else {
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
      }
      const { value, data } = queryArrayMeta(fullValue);
      emitChangeEvent(value, data);
      currentVisible.value = false;
    }
    function emitChangeEvent(value, data) {
      emittedValue.value = value;
      nextTick(() => {
        outsideChanged = false;
        setFieldValue(value);
        emitEvent(props.onChange, value, data);
        emit("update:value", value);
        validateField();
      });
    }
    function queryArrayMeta(fullValue) {
      let option = optionValueMap.get(fullValue);
      if (!option)
        return { value: [], data: [] };
      const value = [option.value];
      const data = [option.data];
      while (option.parent) {
        const parent = optionIdMap.get(option.parent);
        if (!parent)
          break;
        value.push(parent.value);
        data.push(parent.data);
        option = parent;
      }
      return {
        value: value.reverse(),
        data: data.reverse()
      };
    }
    function toggleVisible(visible = !currentVisible.value) {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      currentVisible.value = visible;
    }
    function handleClickOutside() {
      restTipShow.value = false;
      emitEvent(props.onClickOutside);
      if (props.outsideClose && currentVisible.value) {
        currentVisible.value = false;
        outsideClosed = true;
        emitEvent(props.onOutsideClose);
      }
    }
    function handleClear() {
      if (props.clearable) {
        currentValues.value.length = 0;
        currentLabels.value.length = 0;
        mergedValues.value.length = 0;
        mergedLabels.value.length = 0;
        openedIds.value.length = 0;
        emittedValue.value = [];
        restTipShow.value = false;
        for (const option of optionIdMap.values()) {
          option.checked = false;
          option.partial = false;
        }
        emitEvent(props.onChange, emittedValue.value, []);
        emit("update:value", emittedValue.value);
        emitEvent(props.onClear);
        clearField(emittedValue.value);
      }
    }
    function toggleShowRestTip() {
      if (!currentVisible.value) {
        restTipShow.value = !restTipShow.value;
      } else {
        restTipShow.value = false;
      }
    }
    function handleTipClose(fullValue) {
      if (props.multiple) {
        handleOptionCheck(optionValueMap.get(fullValue));
      } else {
        handleSingleSelect(fullValue);
      }
    }
    function handlePanelKeyOpen(option, depth) {
      handlePanelOpen(option, depth);
      requestAnimationFrame(() => {
        const panel = panelElList.value.at(-1);
        if (panel && panel.currentHitting < 0) {
          panel.currentHitting = panel.options.findIndex((option2) => option2.id === prevClosedId);
          if (panel.currentHitting < 0) {
            panel.currentHitting = 0;
          }
        }
      });
    }
    function handlePanelBack() {
      prevClosedId = openedIds.value.pop();
    }
    function handlePanelsEnter() {
      requestAnimationFrame(() => {
        isPopperShow.value = true;
      });
    }
    return {
      props,
      nh,
      locale,
      idFor,
      currentVisible,
      isPopperShow,
      currentValues,
      currentLabels,
      transferTo,
      isHover,
      openedIds,
      restTagCount,
      restTipShow,
      selectorWidth,
      optionsList,
      className,
      selectorClass,
      hasValue,
      hasPrefix,
      isAsyncLoad,
      usingMerged,
      templateValues,
      templateLabels,
      usingHover,
      showClear,
      wrapper,
      reference,
      popper,
      panelElList,
      handlePanelOpen,
      handleOptionSelect,
      handleOptionCheck,
      toggleVisible,
      handleClear,
      toggleShowRestTip,
      handleTipClose,
      handlePanelKeyOpen,
      handlePanelBack,
      handlePanelsEnter
    };
  }
});
const _hoisted_1 = ["id"];
const _hoisted_2 = { key: 1 };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Tag = resolveComponent("Tag");
  const _component_NativeScroll = resolveComponent("NativeScroll");
  const _component_Tooltip = resolveComponent("Tooltip");
  const _component_Overflow = resolveComponent("Overflow");
  const _component_ChevronDown = resolveComponent("ChevronDown");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_CascaderPanel = resolveComponent("CascaderPanel");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onClick: _cache[8] || (_cache[8] = ($event) => _ctx.toggleVisible())
  }, [
    createElementVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onKeydown: [
        _cache[3] || (_cache[3] = withKeys(withModifiers(($event) => _ctx.toggleVisible(), ["prevent"]), ["space"])),
        _cache[4] || (_cache[4] = withKeys(($event) => _ctx.toggleVisible(false), ["tab"]))
      ]
    }, [
      _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
        style: normalizeStyle({ color: _ctx.props.prefixColor })
      }, [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ], 6)) : createCommentVNode("", true),
      createElementVNode("div", {
        class: normalizeClass(_ctx.nh.be("control"))
      }, [
        renderSlot(_ctx.$slots, "control", {}, () => {
          var _a, _b;
          return [
            _ctx.props.multiple ? (openBlock(), createBlock(_component_Overflow, {
              key: 0,
              inherit: "",
              class: normalizeClass([_ctx.nh.be("tags")]),
              items: _ctx.templateValues,
              "max-count": _ctx.props.maxTagCount,
              onRestChange: _cache[1] || (_cache[1] = ($event) => _ctx.restTagCount = $event)
            }, {
              default: withCtx(({ item, index }) => [
                createVNode(_component_Tag, {
                  inherit: "",
                  class: normalizeClass(_ctx.nh.be("tag")),
                  type: _ctx.props.tagType,
                  closable: "",
                  onClick: _cache[0] || (_cache[0] = withModifiers(($event) => _ctx.toggleVisible(), ["stop"])),
                  onClose: ($event) => _ctx.handleTipClose(item)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(_ctx.templateLabels[index]), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "type", "onClose"])
              ]),
              counter: withCtx(({ count }) => [
                _ctx.props.noRestTip ? (openBlock(), createBlock(_component_Tag, {
                  key: 0,
                  inherit: "",
                  class: normalizeClass([_ctx.nh.be("tag"), _ctx.nh.be("counter")]),
                  type: _ctx.props.tagType
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(`+${count}`), 1)
                  ]),
                  _: 2
                }, 1032, ["class", "type"])) : (openBlock(), createElementBlock("span", _hoisted_2, [
                  createVNode(_component_Tooltip, {
                    inherit: "",
                    transfer: false,
                    visible: _ctx.restTipShow,
                    trigger: "custom",
                    placement: "top-end",
                    "tip-class": _ctx.nh.be("rest-tip"),
                    onClick: withModifiers(_ctx.toggleShowRestTip, ["stop"])
                  }, {
                    trigger: withCtx(() => [
                      createVNode(_component_Tag, {
                        inherit: "",
                        class: normalizeClass([_ctx.nh.be("tag"), _ctx.nh.be("counter")]),
                        type: _ctx.props.tagType
                      }, {
                        default: withCtx(() => [
                          createTextVNode(toDisplayString(`+${count}`), 1)
                        ]),
                        _: 2
                      }, 1032, ["class", "type"])
                    ]),
                    default: withCtx(() => [
                      createVNode(_component_NativeScroll, {
                        inherit: "",
                        "use-y-bar": ""
                      }, {
                        default: withCtx(() => [
                          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.templateValues, (item, index) => {
                            return openBlock(), createElementBlock(Fragment, { key: index }, [
                              index >= _ctx.templateValues.length - _ctx.restTagCount ? (openBlock(), createBlock(_component_Tag, {
                                key: 0,
                                inherit: "",
                                class: normalizeClass(_ctx.nh.be("tag")),
                                closable: "",
                                type: _ctx.props.tagType,
                                onClose: ($event) => _ctx.handleTipClose(item)
                              }, {
                                default: withCtx(() => [
                                  createTextVNode(toDisplayString(_ctx.templateLabels[index]), 1)
                                ]),
                                _: 2
                              }, 1032, ["class", "type", "onClose"])) : createCommentVNode("", true)
                            ], 64);
                          }), 128))
                        ]),
                        _: 1
                      })
                    ]),
                    _: 2
                  }, 1032, ["visible", "tip-class", "onClick"])
                ]))
              ]),
              _: 1
            }, 8, ["class", "items", "max-count"])) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createTextVNode(toDisplayString(_ctx.currentLabels[0]), 1)
            ], 64)),
            ((_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder) && !_ctx.hasValue ? (openBlock(), createElementBlock("span", {
              key: 2,
              class: normalizeClass(_ctx.nh.be("placeholder"))
            }, toDisplayString((_b = _ctx.props.placeholder) != null ? _b : _ctx.locale.placeholder), 3)) : createCommentVNode("", true)
          ];
        })
      ], 2),
      !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
        key: 1,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
        style: normalizeStyle({
          color: _ctx.props.suffixColor,
          opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
        })
      }, [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          _ctx.props.suffix ? (openBlock(), createBlock(_component_Icon, {
            key: 0,
            icon: _ctx.props.suffix,
            class: normalizeClass({
              [_ctx.nh.be("arrow")]: !_ctx.props.staticSuffix
            })
          }, null, 8, ["icon", "class"])) : (openBlock(), createBlock(_component_Icon, {
            key: 1,
            class: normalizeClass(_ctx.nh.be("arrow"))
          }, {
            default: withCtx(() => [
              createVNode(_component_ChevronDown)
            ]),
            _: 1
          }, 8, ["class"]))
        ])
      ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
        key: 2,
        class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
      }, null, 2)) : createCommentVNode("", true),
      createVNode(Transition, {
        name: _ctx.nh.ns("fade"),
        appear: ""
      }, {
        default: withCtx(() => [
          _ctx.showClear ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
            onClick: _cache[2] || (_cache[2] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
          }, [
            createVNode(_component_Icon, null, {
              default: withCtx(() => [
                createVNode(_component_CircleXmark)
              ]),
              _: 1
            })
          ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
            key: 1,
            class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
          }, [
            createVNode(_component_Icon, {
              spin: _ctx.props.loadingSpin,
              pulse: !_ctx.props.loadingSpin,
              icon: _ctx.props.loadingIcon
            }, null, 8, ["spin", "pulse", "icon"])
          ], 2)) : createCommentVNode("", true)
        ]),
        _: 1
      }, 8, ["name"])
    ], 34),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName,
          onEnter: _ctx.handlePanelsEnter
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onClick: _cache[7] || (_cache[7] = withModifiers(() => {
              }, ["stop"]))
            }, [
              createElementVNode("div", {
                class: normalizeClass({
                  [_ctx.nh.be("panels")]: true,
                  [_ctx.nh.bem("panels", "empty")]: !_ctx.optionsList[0] || !_ctx.optionsList[0].length
                })
              }, [
                _ctx.optionsList[0] && _ctx.optionsList[0].length ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.optionsList, (items, index) => {
                  return openBlock(), createBlock(_component_CascaderPanel, {
                    key: index,
                    ref_for: true,
                    ref: (panel) => panel && _ctx.panelElList.push(panel),
                    options: items,
                    "opened-id": _ctx.openedIds[index],
                    values: _ctx.currentValues,
                    ready: _ctx.isPopperShow,
                    multiple: _ctx.props.multiple,
                    "is-async": _ctx.isAsyncLoad,
                    merged: _ctx.usingMerged,
                    "no-cascaded": _ctx.props.noCascaded,
                    onSelect: ($event) => _ctx.handleOptionSelect($event, index),
                    onHover: ($event) => _ctx.usingHover && _ctx.handlePanelOpen($event, index),
                    onCheck: _cache[5] || (_cache[5] = ($event) => _ctx.handleOptionCheck($event)),
                    onOpen: ($event) => _ctx.handlePanelKeyOpen($event, index),
                    onBack: _ctx.handlePanelBack,
                    onClose: _cache[6] || (_cache[6] = ($event) => _ctx.currentVisible = false)
                  }, {
                    default: withCtx((payload) => [
                      renderSlot(_ctx.$slots, "default", normalizeProps(guardReactiveProps(payload)))
                    ]),
                    label: withCtx((payload) => [
                      renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(payload)))
                    ]),
                    _: 2
                  }, 1032, ["options", "opened-id", "values", "ready", "multiple", "is-async", "merged", "no-cascaded", "onSelect", "onHover", "onOpen", "onBack"]);
                }), 128)) : (openBlock(), createElementBlock("div", {
                  key: 1,
                  class: normalizeClass(_ctx.nh.be("empty")),
                  style: normalizeStyle({ width: `${_ctx.selectorWidth}px` })
                }, [
                  renderSlot(_ctx.$slots, "empty", {}, () => {
                    var _a;
                    return [
                      createTextVNode(toDisplayString((_a = _ctx.props.emptyText) != null ? _a : _ctx.locale.empty), 1)
                    ];
                  })
                ], 6))
              ], 2)
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 3
        }, 8, ["name", "onEnter"])
      ]),
      _: 3
    }, 8, ["to"])
  ], 10, _hoisted_1);
}
var Cascader = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Cascader as default };
