import { defineComponent, ref, computed, watch, nextTick, resolveComponent, openBlock, createBlock, normalizeClass, withCtx, withDirectives, createElementVNode, normalizeStyle, createElementBlock, renderSlot, createTextVNode, toDisplayString, createVNode, createCommentVNode, vShow } from "vue";
import "../button/index.mjs";
import "../icon/index.mjs";
import "../masker/index.mjs";
import "../../common/config/src/index.mjs";
import { useMoving } from "@vexip-ui/hooks";
import { toNumber, isPromise } from "@vexip-ui/utils";
import { Xmark } from "@vexip-ui/icons";
import { drawerProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Button from "../button/button.mjs";
import Icon from "../icon/icon.mjs";
import Masker from "../masker/masker.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const drawerPlacements = Object.freeze(["top", "right", "bottom", "left"]);
let idCount = 0;
const _sfc_main = defineComponent({
  name: "Drawer",
  components: {
    Button,
    Icon,
    Masker,
    Xmark
  },
  props: drawerProps,
  emits: ["update:active"],
  setup(_props, { slots, emit }) {
    const props = useProps("drawer", _props, {
      transfer: false,
      active: {
        default: false,
        static: true
      },
      width: {
        default: 280,
        validator: (value) => value > 0
      },
      height: {
        default: 280,
        validator: (value) => value > 0
      },
      placement: {
        default: "right",
        validator: (value) => drawerPlacements.includes(value)
      },
      title: "",
      closable: true,
      inner: false,
      maskClose: true,
      drawerClass: null,
      hideMask: false,
      onBeforeClose: {
        default: null,
        isFunc: true
      },
      resizable: false,
      autoRemove: false,
      footer: false,
      confirmText: null,
      cancelText: null,
      loading: false
    });
    const nh = useNameHelper("drawer");
    const currentActive = ref(props.active);
    const currentWidth = ref(props.width);
    const currentHeight = ref(props.height);
    const wrapper = ref();
    const idIndex = `${idCount++}`;
    const { target: resizer, moving: resizing } = useMoving({
      onStart: (state, event) => {
        if (!props.resizable || event.button > 0 || !wrapper.value) {
          return false;
        }
        const width = `${currentWidth.value}`.endsWith("%") ? wrapper.value.offsetWidth : toNumber(currentWidth.value);
        const height = `${currentHeight.value}`.endsWith("%") ? wrapper.value.offsetHeight : toNumber(currentHeight.value);
        state.xStart = width;
        state.yStart = height;
        emitEvent(props.onResizeStart, { width, height });
      },
      onMove: (state, event) => {
        const deltaX = event.clientX - state.clientX;
        const deltaY = event.clientY - state.clientY;
        let width = toNumber(currentWidth.value);
        let height = toNumber(currentHeight.value);
        switch (props.placement) {
          case "top": {
            height = state.yStart + deltaY;
            break;
          }
          case "right": {
            width = state.xStart - deltaX;
            break;
          }
          case "bottom": {
            height = state.yStart - deltaY;
            break;
          }
          default: {
            width = state.xStart + deltaX;
          }
        }
        currentWidth.value = Math.max(width, 100);
        currentHeight.value = Math.max(height, 100);
        emitEvent(props.onResizeMove, {
          width: toNumber(currentWidth.value),
          height: toNumber(currentHeight.value)
        });
      },
      onEnd: () => {
        emitEvent(props.onResizeEnd, {
          width: toNumber(currentWidth.value),
          height: toNumber(currentHeight.value)
        });
      }
    });
    const className = computed(() => {
      return [
        nh.b(),
        nh.bs("vars"),
        {
          [nh.bm("inner")]: props.inner,
          [nh.bm("closable")]: props.closable,
          [nh.bm("resizable")]: props.resizable
        }
      ];
    });
    const moveTransition = computed(() => {
      return nh.ns(`move-${props.placement}`);
    });
    const wrapperClass = computed(() => {
      return [
        nh.be("wrapper"),
        nh.bem("wrapper", props.placement),
        {
          [nh.bem("wrapper", "resizing")]: resizing.value
        },
        props.drawerClass
      ];
    });
    const wrapperStyle = computed(() => {
      const placement = props.placement;
      if (placement === "top" || placement === "bottom") {
        const height = currentHeight.value;
        return {
          height: `${height}`.endsWith("%") ? height : `${height}px`
        };
      }
      const width = currentWidth.value;
      return {
        width: `${width}`.endsWith("%") ? width : `${width}px`
      };
    });
    const hasTitle = computed(() => {
      var _a;
      return !!((_a = slots.title) != null ? _a : props.title);
    });
    const titleId = computed(() => `${nh.bs(idIndex)}__title`);
    const bodyId = computed(() => `${nh.bs(idIndex)}__body`);
    watch(
      () => props.active,
      (value) => {
        currentActive.value = value;
      }
    );
    watch(currentActive, (value) => {
      emitEvent(props.onToggle, value);
      emit("update:active", value);
    });
    watch(
      () => props.width,
      (value) => {
        currentWidth.value = value;
      }
    );
    watch(
      () => props.height,
      (value) => {
        currentHeight.value = value;
      }
    );
    async function handleClose(isConfirm = false) {
      let result = true;
      if (typeof props.onBeforeClose === "function") {
        result = props.onBeforeClose(isConfirm);
        if (isPromise(result)) {
          result = await result;
        }
      }
      if (result !== false) {
        nextTick(() => {
          currentActive.value = false;
          emitEvent(props.onClose);
        });
      }
      return result;
    }
    function handleMaskClose() {
      if (props.maskClose) {
        return handleClose();
      }
    }
    function handleShow() {
      emitEvent(props.onShow);
    }
    function handleHide() {
      emitEvent(props.onHide);
    }
    function handleConfirm() {
      handleClose(true);
      emitEvent(props.onConfirm);
    }
    function handleCancle() {
      handleClose(false);
      emitEvent(props.onCancel);
    }
    return {
      props,
      nh,
      locale: useLocale("modal"),
      currentActive,
      resizing,
      className,
      moveTransition,
      wrapperClass,
      wrapperStyle,
      hasTitle,
      titleId,
      bodyId,
      wrapper,
      resizer,
      handleClose,
      handleMaskClose,
      handleShow,
      handleHide,
      handleConfirm,
      handleCancle
    };
  }
});
const _hoisted_1 = ["aria-modal", "aria-labelledby", "aria-describedby"];
const _hoisted_2 = ["id"];
const _hoisted_3 = ["id"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_Button = resolveComponent("Button");
  const _component_Masker = resolveComponent("Masker");
  return openBlock(), createBlock(_component_Masker, {
    active: _ctx.currentActive,
    "onUpdate:active": _cache[1] || (_cache[1] = ($event) => _ctx.currentActive = $event),
    inherit: _ctx.props.inherit,
    class: normalizeClass(_ctx.className),
    inner: _ctx.props.inner,
    "transition-name": _ctx.moveTransition,
    closable: _ctx.props.maskClose,
    disabled: _ctx.props.hideMask,
    "on-before-close": _ctx.handleMaskClose,
    transfer: _ctx.props.transfer,
    "auto-remove": _ctx.props.autoRemove,
    onShow: _ctx.handleShow,
    onHide: _ctx.handleHide
  }, {
    default: withCtx(({ show }) => [
      withDirectives(createElementVNode("section", {
        ref: "wrapper",
        class: normalizeClass(_ctx.wrapperClass),
        style: normalizeStyle(_ctx.wrapperStyle),
        role: "dialog",
        "aria-modal": show ? "true" : void 0,
        "aria-labelledby": _ctx.titleId,
        "aria-describedby": _ctx.bodyId
      }, [
        _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("header"))
        }, [
          createElementVNode("div", {
            id: _ctx.titleId,
            class: normalizeClass(_ctx.nh.be("title"))
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.props.title), 1)
            ])
          ], 10, _hoisted_2),
          _ctx.props.closable ? (openBlock(), createElementBlock("button", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("close")),
            onClick: _cache[0] || (_cache[0] = ($event) => _ctx.handleClose())
          }, [
            renderSlot(_ctx.$slots, "close", {}, () => [
              createVNode(_component_Icon, {
                scale: 1.2,
                label: "close"
              }, {
                default: withCtx(() => [
                  createVNode(_component_Xmark)
                ]),
                _: 1
              }, 8, ["scale"])
            ])
          ], 2)) : createCommentVNode("", true)
        ], 2)) : createCommentVNode("", true),
        createElementVNode("div", {
          id: _ctx.bodyId,
          class: normalizeClass(_ctx.nh.be("content"))
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 10, _hoisted_3),
        _ctx.props.footer || _ctx.$slots.footer ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("footer"))
        }, [
          renderSlot(_ctx.$slots, "footer", {}, () => [
            createVNode(_component_Button, {
              inherit: "",
              text: "",
              size: "small",
              onClick: _ctx.handleCancle
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
              ]),
              _: 1
            }, 8, ["onClick"]),
            createVNode(_component_Button, {
              inherit: "",
              type: "primary",
              size: "small",
              loading: _ctx.props.loading,
              onClick: _ctx.handleConfirm
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
              ]),
              _: 1
            }, 8, ["loading", "onClick"])
          ])
        ], 2)) : createCommentVNode("", true),
        _ctx.props.resizable ? (openBlock(), createElementBlock("div", {
          key: 2,
          ref: "resizer",
          class: normalizeClass([
            _ctx.nh.be("handler"),
            _ctx.nh.bem("handler", _ctx.props.placement),
            {
              [_ctx.nh.bem("handler", "resizing")]: _ctx.resizing
            }
          ])
        }, [
          renderSlot(_ctx.$slots, "handler", { resizing: _ctx.resizing })
        ], 2)) : createCommentVNode("", true)
      ], 14, _hoisted_1), [
        [vShow, show]
      ])
    ]),
    _: 3
  }, 8, ["active", "inherit", "class", "inner", "transition-name", "closable", "disabled", "on-before-close", "transfer", "auto-remove", "onShow", "onHide"]);
}
var Drawer = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Drawer as default };
