import { defineComponent, ref, computed, watchEffect, provide, reactive, toRef, watch, onMounted, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, Fragment, renderList, createBlock, mergeProps, withCtx, renderSlot, normalizeProps, guardReactiveProps, createTextVNode, toDisplayString, createCommentVNode, withDirectives, vShow } from "vue";
import TreeNode from "./tree-node.mjs";
import "../../common/config/src/index.mjs";
import { useMounted } from "@vexip-ui/hooks";
import { flatTree, queryAll, transformTree, isNull, isPromise, removeArrayItem } from "@vexip-ui/utils";
import { treeProps } from "./props.mjs";
import { TREE_STATE, TREE_NODE_STATE, DropType } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const defaultKeyConfig = {
  id: "id",
  parent: "parent",
  label: "label",
  children: "children",
  visible: "visible",
  selected: "selected",
  expanded: "expanded",
  disabled: "disabled",
  checked: "checked",
  loading: "loading",
  loaded: "loaded",
  readonly: "readonly",
  arrow: "arrow",
  checkbox: "checkbox"
};
const _sfc_main = defineComponent({
  name: "Tree",
  components: {
    TreeNode
  },
  props: treeProps,
  emits: [],
  setup(_props) {
    const props = useProps("tree", _props, {
      arrow: {
        default: "auto",
        validator: (value) => typeof value === "boolean" || value === "auto"
      },
      data: {
        default: () => [],
        static: true
      },
      noBuildTree: false,
      emptyTip: null,
      disabled: false,
      readonly: false,
      checkbox: false,
      suffixCheckbox: false,
      renderer: {
        default: null,
        isFunc: true
      },
      multiple: false,
      indent: "16px",
      accordion: false,
      draggable: false,
      appear: false,
      floorSelect: false,
      onAsyncLoad: {
        default: null,
        isFunc: true
      },
      cacheNode: false,
      rootId: null,
      keyConfig: () => ({}),
      noCascaded: false,
      filter: "",
      ignoreCase: false,
      nodeProps: null
    });
    const nh = useNameHelper("tree");
    const nodeMaps = /* @__PURE__ */ new Map();
    const treeData = ref([]);
    const dragging = ref(false);
    const indicatorShow = ref(false);
    const anyMatched = ref(false);
    const { isMounted } = useMounted();
    const wrapper = ref();
    const trap = ref();
    const indicator = ref();
    let visibleNodeEls = [];
    const defaultNodeProperties = {
      visible: true,
      selected: false,
      expanded: false,
      disabled: false,
      checked: false,
      loading: false,
      loaded: false,
      readonly: false,
      arrow: "auto",
      checkbox: null
    };
    const keyConfig = computed(() => {
      return { ...defaultKeyConfig, ...props.keyConfig };
    });
    const parsedOptions = computed(() => {
      return {
        keyField: keyConfig.value.id,
        childField: keyConfig.value.children,
        parentField: keyConfig.value.parent,
        rootId: props.rootId
      };
    });
    const boundAsyncLoad = computed(() => {
      return typeof props.onAsyncLoad === "function";
    });
    const flattedData = computed(() => {
      return flatTree(treeData.value, {
        keyField: "id",
        parentField: "parent",
        childField: "children",
        rootId: props.rootId
      });
    });
    const labelKey = computed(() => keyConfig.value.label);
    function createDefaultFilter(value) {
      const pattern = props.ignoreCase ? String(value).toLocaleLowerCase() : value;
      const defaultFilter = (data) => {
        const label = data[labelKey.value];
        return props.ignoreCase ? String(label).toLocaleLowerCase().includes(pattern) : String(label).includes(pattern);
      };
      return defaultFilter;
    }
    watchEffect(() => {
      const nodes = flattedData.value;
      if (!props.filter) {
        for (let i = 0, len = nodes.length; i < len; ++i) {
          const node = nodes[i];
          node.matched = true;
          node.childMatched = false;
          node.upperMatched = false;
        }
        anyMatched.value = true;
      } else {
        const filter = typeof props.filter === "function" ? props.filter : createDefaultFilter(props.filter);
        anyMatched.value = false;
        for (let i = 0, len = nodes.length; i < len; ++i) {
          const node = nodes[i];
          const parent = nodeMaps.get(node.parent);
          node.matched = filter(node.data, node);
          node.childMatched = false;
          node.upperMatched = !!parent && (parent.matched || parent.upperMatched);
          anyMatched.value = anyMatched.value || node.matched;
          if (node.matched) {
            let upper = parent;
            while (upper && !upper.childMatched) {
              upper.childMatched = true;
              upper = nodeMaps.get(upper.parent);
            }
          }
        }
      }
    });
    provide(
      TREE_STATE,
      reactive({
        arrow: toRef(props, "arrow"),
        checkbox: toRef(props, "checkbox"),
        suffixCheckbox: toRef(props, "suffixCheckbox"),
        renderer: toRef(props, "renderer"),
        dragging,
        boundAsyncLoad,
        updateVisibleNodeEls,
        computeCheckedState,
        handleNodeClick,
        handleNodeSelect,
        handleNodeCancel,
        handleNodeExpand,
        handleNodeReduce,
        handleAsyncLoad,
        handleNodeDragStart,
        handleNodeDragOver,
        handleNodeDrop,
        handleNodeDragEnd,
        handleHittingChange,
        handleNodeHitting,
        handleLabelClick
      })
    );
    provide(
      TREE_NODE_STATE,
      reactive({
        depth: -1,
        disabled: toRef(props, "disabled"),
        readonly: toRef(props, "readonly")
      })
    );
    watch([() => props.data, () => props.data.length], parseAndTransformData);
    watch(parsedOptions, parseAndTransformData);
    parseAndTransformData();
    onMounted(updateVisibleNodeEls);
    const checkedNodes = flattedData.value.filter((item) => item.checked);
    for (let i = 0, len = checkedNodes.length; i < len; ++i) {
      const item = checkedNodes[i];
      const parentKey = item.parent;
      updateCheckedDown(item);
      if (parentKey && nodeMaps.has(parentKey)) {
        const parent = nodeMaps.get(parentKey);
        if (!parent.checked) {
          updateCheckedUpward(item);
        }
      }
    }
    function updateVisibleNodeEls() {
      requestAnimationFrame(() => {
        if (wrapper.value) {
          visibleNodeEls = queryAll(`.${nh.be("node")}`, wrapper.value);
        }
      });
    }
    function parseAndTransformData() {
      var _a;
      const idKey = keyConfig.value.id;
      const parentKey = keyConfig.value.parent;
      const oldDataMap = /* @__PURE__ */ new Map();
      const oldIpMap = /* @__PURE__ */ new Map();
      for (const node of nodeMaps.values()) {
        oldDataMap.set(node.data, node);
        oldIpMap.set(node.data[idKey], node);
      }
      nodeMaps.clear();
      const nodes = [];
      const data = props.noBuildTree ? flatTree(props.data, parsedOptions.value) : props.data;
      for (let i = 0, len = data.length; i < len; ++i) {
        const item = data[i];
        const oldNode = (_a = oldDataMap.get(item)) != null ? _a : oldIpMap.get(item[idKey]);
        const node = props.cacheNode ? oldNode != null ? oldNode : createNodeItem(item) : createNodeItem(item, oldNode);
        node.parent = item[parentKey];
        node.data = item;
        nodeMaps.set(node.id, node);
        nodes.push(node);
      }
      treeData.value = transformTree(nodes, {
        keyField: "id",
        parentField: "parent",
        childField: "children",
        rootId: props.rootId
      });
      isMounted.value && updateVisibleNodeEls();
    }
    function forceUpdateData() {
      const nodes = [];
      const data = props.noBuildTree ? flatTree(props.data, parsedOptions.value) : props.data;
      const {
        id: idKey,
        visible: visibleKey,
        selected: selectedKey,
        expanded: expandedKey,
        disabled: disabledKey,
        checked: checkedKey,
        loading: loadingKey,
        loaded: loadedKey,
        readonly: readonlyKey,
        arrow: arrowKey,
        checkbox: checkboxKey
      } = keyConfig.value;
      for (let i = 0, len = data.length; i < len; ++i) {
        const item = data[i];
        const id = item[idKey];
        let node;
        if (nodeMaps.has(id)) {
          node = nodeMaps.get(id);
          const {
            [visibleKey]: visible = node.visible,
            [selectedKey]: selected = node.selected,
            [expandedKey]: expanded = node.expanded,
            [disabledKey]: disabled = node.disabled,
            [checkedKey]: checked = node.checked,
            [loadingKey]: loading = node.loading,
            [loadedKey]: loaded = node.loaded,
            [readonlyKey]: readonly = node.readonly,
            [arrowKey]: arrow = node.arrow,
            [checkboxKey]: checkbox = node.checkbox
          } = item;
          node.visible = visible;
          node.selected = selected;
          node.expanded = expanded;
          node.disabled = disabled;
          node.checked = checked;
          node.loading = loading;
          node.loaded = loaded;
          node.readonly = readonly;
          node.arrow = arrow;
          node.checkbox = checkbox;
        } else {
          node = createNodeItem(item);
          nodeMaps.set(id, node);
        }
        nodes.push(node);
      }
      treeData.value = transformTree(nodes, {
        keyField: "id",
        parentField: "parent",
        childField: "children",
        rootId: props.rootId
      });
      isMounted.value && updateVisibleNodeEls();
    }
    function syncNodeStateIntoData() {
      flattedData.value.forEach((node) => {
        if (!node.data)
          return;
        const { data, visible, selected, expanded, disabled, checked, loading, readonly } = node;
        data.visible = visible;
        data.selected = selected;
        data.expanded = expanded;
        data.disabled = disabled;
        data.checked = checked;
        data.loading = loading;
        data.readonly = readonly;
      });
      isMounted.value && updateVisibleNodeEls();
    }
    function createNodeItem(data, defaults = defaultNodeProperties) {
      const {
        id: idKey,
        parent: parentKey,
        visible: visibleKey,
        selected: selectedKey,
        expanded: expandedKey,
        disabled: disabledKey,
        checked: checkedKey,
        loading: loadingKey,
        loaded: loadedKey,
        readonly: readonlyKey,
        arrow: arrowKey,
        checkbox: checkboxKey
      } = keyConfig.value;
      const {
        [visibleKey]: visible = defaults.visible,
        [selectedKey]: selected = defaults.selected,
        [expandedKey]: expanded = defaults.expanded,
        [disabledKey]: disabled = defaults.disabled,
        [checkedKey]: checked = defaults.checked,
        [loadingKey]: loading = defaults.loading,
        [loadedKey]: loaded = defaults.loaded,
        [readonlyKey]: readonly = defaults.readonly,
        [arrowKey]: arrow = defaults.arrow,
        [checkboxKey]: checkbox = defaults.checkbox
      } = data;
      const id = data[idKey];
      const parent = data[parentKey];
      return reactive({
        id,
        parent,
        children: [],
        data,
        visible,
        selected,
        expanded,
        disabled,
        checked,
        loading,
        loaded,
        readonly,
        arrow,
        checkbox,
        partial: false,
        matched: false,
        childMatched: false,
        upperMatched: false
      });
    }
    function getNodeChildren(node) {
      return node.children;
    }
    function updateCheckedUpward(originNode) {
      let node = originNode;
      while (!isNull(node.parent)) {
        const parentId = node.parent;
        if (!nodeMaps.has(parentId))
          break;
        const parent = nodeMaps.get(parentId);
        if (node.checked === parent.checked && node.partial === parent.partial) {
          break;
        }
        if (node.checked) {
          parent.checked = parent.children.every((item) => item.checked);
          parent.partial = !parent.checked;
        } else {
          parent.checked = false;
          parent.partial = parent.children.some((item) => item.checked || item.partial);
        }
        node = parent;
      }
    }
    function updateCheckedDown(originNode) {
      const checked = originNode.checked;
      const partial = originNode.partial;
      const loop = [...originNode.children];
      let node;
      while (loop.length) {
        node = loop.shift();
        if (node.disabled)
          continue;
        node.checked = checked;
        node.partial = partial;
        if (node.children.length) {
          loop.push(...node.children);
        }
      }
    }
    function computeCheckedState(originNode, able) {
      if (!props.noCascaded) {
        const nodeList = [originNode].concat(
          flattedData.value.filter((item) => item.disabled && item.checked)
        );
        for (let i = 0, len = nodeList.length; i < len; ++i) {
          const item = nodeList[i];
          updateCheckedUpward(item);
          updateCheckedDown(item);
        }
      }
      emitEvent(props.onNodeChange, originNode.data, originNode, able);
    }
    function handleNodeClick(node) {
      emitEvent(props.onNodeClick, node.data, node);
    }
    function handleLabelClick(node) {
      emitEvent(props.onLabelClick, node.data, node);
    }
    function handleNodeSelect(node) {
      const selectedNodes = flattedData.value.filter((item) => item.selected);
      if (props.multiple) {
        emitEvent(
          props.onNodeSelect,
          selectedNodes.map((item) => item.data),
          selectedNodes
        );
      } else {
        const currentId = node.id;
        for (let i = 0, len = selectedNodes.length; i < len; ++i) {
          const item = selectedNodes[i];
          item.selected = item.id === currentId;
        }
        emitEvent(props.onNodeSelect, node.data, node);
      }
    }
    function handleNodeCancel(node) {
      emitEvent(props.onNodeCancel, node.data, node);
    }
    function handleNodeExpand(node) {
      if (props.accordion) {
        const siblingNodes = getSiblingNodes(node);
        for (let i = 0, len = siblingNodes.length; i < len; ++i) {
          siblingNodes[i].expanded = false;
        }
      }
      emitEvent(props.onNodeExpand, node.data, node);
    }
    function handleNodeReduce(node) {
      emitEvent(props.onNodeReduce, node.data, node);
    }
    async function handleAsyncLoad(node) {
      if (!boundAsyncLoad.value)
        return false;
      let result = props.onAsyncLoad(node.data, node);
      if (isPromise(result)) {
        result = await result;
      }
      return result !== false;
    }
    let dragState = null;
    function handleNodeDragStart(nodeInstance) {
      if (!wrapper.value)
        return;
      dragState = {
        draggingNode: nodeInstance.node,
        treeRect: wrapper.value.getBoundingClientRect(),
        willDropNode: null,
        dropType: DropType.BEFORE
      };
      dragging.value = true;
      emitEvent(props.onDragStart, nodeInstance.node.data, nodeInstance.node);
    }
    function handleNodeDragOver(nodeInstance, event) {
      if (!dragState || !nodeInstance.el || !nodeInstance.arrow)
        return;
      const dropNodeRect = nodeInstance.el.getBoundingClientRect();
      const treeRect = dragState.treeRect;
      const dropArrowRect = nodeInstance.arrow.getBoundingClientRect();
      const prevPercent = 0.25;
      const nextPercent = 0.75;
      const distance = event.clientY - dropNodeRect.top;
      const dropNodeHeight = dropArrowRect.height;
      let dropType;
      let indicatorTop = -9999;
      let isIndicatorShow = true;
      if (distance < dropNodeHeight * prevPercent) {
        dropType = DropType.BEFORE;
        indicatorTop = dropArrowRect.top - treeRect.top;
      } else if (distance > dropNodeHeight * nextPercent) {
        dropType = DropType.AFTER;
        indicatorTop = dropArrowRect.bottom - treeRect.top;
      } else {
        dropType = DropType.INNER;
        isIndicatorShow = false;
      }
      if (indicator.value) {
        indicator.value.style.top = `${indicatorTop}px`;
        indicator.value.style.left = `${dropArrowRect.right - treeRect.left}px`;
      }
      dragState.willDropNode = nodeInstance.node;
      dragState.dropType = dropType;
      indicatorShow.value = isIndicatorShow;
      emitEvent(props.onDragOver, nodeInstance.node.data, nodeInstance.node);
    }
    function isLeftInsideRight(left, right) {
      if (!left || !right)
        return true;
      while (left) {
        if (left === right || left.id === right.id) {
          return true;
        }
        left = getParentNode(left);
      }
      return false;
    }
    function handleNodeDrop(nodeInstance) {
      if (!dragState)
        return;
      const { draggingNode, willDropNode, dropType } = dragState;
      if (!willDropNode || isLeftInsideRight(willDropNode, draggingNode))
        return;
      let currentId;
      let parent;
      if (draggingNode) {
        parent = getParentNode(draggingNode);
        if (!parent) {
          parent = {
            children: treeData.value
          };
        }
        currentId = draggingNode.id;
        removeArrayItem(parent.children, (item) => item.id === currentId);
      }
      if (dropType === DropType.INNER) {
        if (!Array.isArray(willDropNode.children)) {
          willDropNode.children = [];
        }
        const children = Array.from(willDropNode.children);
        children.push(draggingNode);
        willDropNode.children = children;
        draggingNode.parent = willDropNode.id;
      } else {
        parent = getParentNode(willDropNode);
        if (!parent) {
          parent = {
            parent: void 0,
            children: treeData.value
          };
        }
        currentId = willDropNode.id;
        const index = parent.children.findIndex((item) => item.id === currentId);
        if (~index) {
          parent.children.splice(+(dropType === DropType.AFTER) + index, 0, draggingNode);
          draggingNode.parent = parent.id;
        }
      }
      emitEvent(props.onDrop, nodeInstance.node.data, nodeInstance.node, dropType);
    }
    function handleNodeDragEnd(nodeInstance) {
      dragging.value = true;
      indicatorShow.value = false;
      dragState = null;
      emitEvent(props.onDragEnd, nodeInstance.node.data, nodeInstance.node);
    }
    function handleHittingChange(type) {
      var _a;
      const activeEl = document.activeElement;
      if (!visibleNodeEls.length || !activeEl)
        return;
      const index = visibleNodeEls.findIndex((nodeEl) => nodeEl === activeEl);
      if (~index) {
        (_a = visibleNodeEls.at((index + (type === "up" ? -1 : 1)) % visibleNodeEls.length)) == null ? void 0 : _a.focus();
      }
    }
    function handleNodeHitting(nodeEl) {
      if (!nodeEl || !visibleNodeEls.length)
        return;
      if (visibleNodeEls.includes(nodeEl)) {
        nodeEl.focus();
      }
    }
    function handleTreeFocus(event) {
      const target = event.target;
      if (!visibleNodeEls.length || !target || !trap.value) {
        return;
      }
      if (target === trap.value) {
        visibleNodeEls[0].focus();
      }
    }
    function getCheckedNodes() {
      return flattedData.value.filter((item) => item.checked);
    }
    function getCheckedNodeData() {
      return getCheckedNodes().map((node) => node.data);
    }
    function getSelectedNodes() {
      return flattedData.value.filter((item) => item.selected);
    }
    function getSelectedNodeData() {
      return getSelectedNodes().map((node) => node.data);
    }
    function getExpandedNodes() {
      return flattedData.value.filter((item) => item.expanded);
    }
    function getDisabledNodes() {
      return flattedData.value.filter((item) => item.disabled);
    }
    function getParentNode(node) {
      var _a;
      if (node.parent) {
        return (_a = nodeMaps.get(node.parent)) != null ? _a : null;
      }
      return null;
    }
    function getSiblingNodes(node, includeSelf = false) {
      const parent = getParentNode(node);
      const currentId = node.id;
      const parentId = parent ? parent.id : null;
      return flattedData.value.filter((item) => {
        const isChild = parentId === null ? !item.parent : item.parent === parentId;
        if (isChild && !includeSelf) {
          return item.id !== currentId;
        }
        return isChild;
      });
    }
    function getPrevSiblingNode(node) {
      const parent = getParentNode(node);
      if (!parent)
        return null;
      const currentId = node.id;
      const parentId = parent.id;
      const children = flattedData.value.filter((item) => item.parent === parentId);
      if (children && children.length) {
        const index = children.findIndex((item) => item.id === currentId);
        if (index > 0) {
          return children[index - 1];
        }
      }
      return null;
    }
    function getNextSiblingNode(node) {
      const parent = getParentNode(node);
      if (!parent)
        return null;
      const currentId = node.id;
      const parentId = parent.id;
      const children = flattedData.value.filter((item) => item.parent === parentId);
      if (children && children.length) {
        const index = children.findIndex((item) => item.id === currentId);
        if (!~index && index < children.length - 1) {
          return children[index + 1];
        }
      }
      return null;
    }
    function getNodeByData(data) {
      var _a;
      const idKey = keyConfig.value.id;
      return (_a = flattedData.value.find((item) => item.data[idKey] === data[idKey])) != null ? _a : null;
    }
    function expandNodeByData(data, expanded, upstream = false) {
      const node = getNodeByData(data);
      if (node) {
        node.expanded = isNull(expanded) ? !node.expanded : !!expanded;
        if (upstream) {
          let parentNode = getParentNode(node);
          while (parentNode) {
            parentNode.expanded = node.expanded;
            parentNode = getParentNode(parentNode);
          }
        }
      }
    }
    function selectNodeByData(data, selected) {
      const node = getNodeByData(data);
      if (node) {
        node.selected = isNull(selected) ? !node.selected : !!selected;
      }
    }
    function checkNodeByData(data, checked) {
      const node = getNodeByData(data);
      if (node) {
        node.checked = isNull(checked) ? !node.checked : !!checked;
        if (!props.noCascaded) {
          const nodeList = [node].concat(
            flattedData.value.filter((item) => item.disabled && item.checked)
          );
          for (let i = 0, len = nodeList.length; i < len; ++i) {
            const item = nodeList[i];
            updateCheckedUpward(item);
            updateCheckedDown(item);
          }
        }
      }
    }
    function toggleNodeLoadingByData(data, loading) {
      const node = getNodeByData(data);
      if (node) {
        node.checked = isNull(loading) ? !node.loading : !!loading;
      }
    }
    return {
      props,
      nh,
      locale: useLocale("tree"),
      treeData,
      indicatorShow,
      anyMatched,
      labelKey,
      childrenKey: computed(() => keyConfig.value.children),
      getNodeProps: computed(() => {
        return typeof props.nodeProps === "function" ? props.nodeProps : () => props.nodeProps;
      }),
      wrapper,
      trap,
      indicator,
      handleTreeFocus,
      parseAndTransformData,
      forceUpdateData,
      syncNodeStateIntoData,
      getCheckedNodes,
      getCheckedNodeData,
      getSelectedNodes,
      getSelectedNodeData,
      getExpandedNodes,
      getDisabledNodes,
      getNodeChildren,
      getParentNode,
      getSiblingNodes,
      getPrevSiblingNode,
      getNextSiblingNode,
      getNodeByData,
      expandNodeByData,
      selectNodeByData,
      checkNodeByData,
      toggleNodeLoadingByData
    };
  }
});
const _hoisted_1 = ["aria-disabled", "aria-readonly"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TreeNode = resolveComponent("TreeNode");
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass([_ctx.nh.b(), _ctx.nh.bs("vars"), _ctx.props.inherit && _ctx.nh.bm("inherit")]),
    role: "tree",
    tabindex: "-1",
    "aria-disabled": _ctx.props.disabled,
    "aria-readonly": _ctx.props.readonly
  }, [
    createElementVNode("span", {
      ref: "trap",
      tabindex: "0",
      "aria-hidden": "true",
      style: { "width": "0", "height": "0", "overflow": "hidden", "outline": "none" },
      onFocus: _cache[0] || (_cache[0] = (...args) => _ctx.handleTreeFocus && _ctx.handleTreeFocus(...args))
    }, null, 544),
    createElementVNode("ul", {
      class: normalizeClass(_ctx.nh.be("list"))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.treeData, (item, index) => {
        return openBlock(), createBlock(_component_TreeNode, mergeProps({ key: index }, _ctx.getNodeProps(item.data, item), {
          node: item,
          data: item.data,
          arrow: item.arrow,
          checkbox: item.checkbox,
          appear: _ctx.props.appear,
          visible: item.visible,
          selected: item.selected,
          expanded: item.expanded,
          disabled: item.disabled,
          "label-key": _ctx.labelKey,
          checked: item.checked,
          loading: item.loading,
          loaded: item.loaded,
          partial: item.partial,
          readonly: item.readonly,
          indent: _ctx.props.indent,
          draggable: _ctx.props.draggable,
          "floor-select": _ctx.props.floorSelect,
          matched: item.matched,
          "child-matched": item.childMatched,
          "upper-matched": item.upperMatched,
          "node-props": _ctx.getNodeProps
        }), {
          default: withCtx((payload) => [
            renderSlot(_ctx.$slots, "node", normalizeProps(guardReactiveProps(payload)))
          ]),
          label: withCtx((payload) => [
            renderSlot(_ctx.$slots, "label", normalizeProps(guardReactiveProps(payload)))
          ]),
          _: 2
        }, 1040, ["node", "data", "arrow", "checkbox", "appear", "visible", "selected", "expanded", "disabled", "label-key", "checked", "loading", "loaded", "partial", "readonly", "indent", "draggable", "floor-select", "matched", "child-matched", "upper-matched", "node-props"]);
      }), 128))
    ], 2),
    !_ctx.props.data || !_ctx.props.data.length || !_ctx.anyMatched ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(_ctx.nh.be("empty-tip"))
    }, [
      renderSlot(_ctx.$slots, "empty", {}, () => {
        var _a;
        return [
          createTextVNode(toDisplayString((_a = _ctx.props.emptyTip) != null ? _a : _ctx.locale.empty), 1)
        ];
      })
    ], 2)) : createCommentVNode("", true),
    _ctx.props.draggable ? withDirectives((openBlock(), createElementBlock("div", {
      key: 1,
      ref: "indicator",
      class: normalizeClass(_ctx.nh.be("indicator"))
    }, null, 2)), [
      [vShow, _ctx.indicatorShow]
    ]) : createCommentVNode("", true)
  ], 10, _hoisted_1);
}
var Tree = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Tree as default };
