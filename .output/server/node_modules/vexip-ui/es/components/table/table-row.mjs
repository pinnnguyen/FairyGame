import { defineComponent, inject, ref, reactive, toRef, computed, nextTick, watch, onMounted, onUpdated, resolveComponent, openBlock, createElementBlock, normalizeClass, withModifiers, createElementVNode, mergeProps, renderSlot, createBlock, withCtx, normalizeStyle, createCommentVNode } from "vue";
import "../collapse-transition/index.mjs";
import "../renderer/index.mjs";
import "../../common/config/src/index.mjs";
import { isFunction } from "@vexip-ui/utils";
import { TABLE_STORE, TABLE_ACTION, TABLE_HEAD_KEY } from "./symbol.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import CollapseTransition from "../collapse/collapse-transition.mjs";
import Renderer from "../renderer/renderer.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "TableRow",
  components: {
    CollapseTransition,
    Renderer
  },
  props: {
    row: {
      type: Object,
      default: () => ({})
    },
    index: {
      type: Number,
      default: null
    },
    isHead: {
      type: Boolean,
      default: false
    },
    isFixed: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const { state, mutations } = inject(TABLE_STORE);
    const tableAction = inject(TABLE_ACTION);
    const nh = useNameHelper("table");
    const wrapper = ref();
    const rowElement = ref();
    const expandElement = ref();
    const instance = reactive({
      el: wrapper,
      row: toRef(props, "row")
    });
    const rowKey = computed(() => props.isHead ? TABLE_HEAD_KEY : props.row.key);
    const className = computed(() => {
      let customClass = null;
      if (!props.isHead) {
        if (typeof state.rowClass === "function") {
          customClass = state.rowClass(props.row.data, props.index);
        } else {
          customClass = state.rowClass;
        }
      }
      return [
        nh.be("row"),
        {
          [nh.bem("row", "hover")]: !props.isHead && state.highlight && props.row.hover,
          [nh.bem("row", "stripe")]: props.index % 2 === 1,
          [nh.bem("row", "checked")]: props.row.checked
        },
        customClass
      ];
    });
    const style = computed(() => {
      let customStyle = "";
      if (!props.isHead) {
        if (typeof state.rowStyle === "function") {
          customStyle = state.rowStyle(props.row.data, props.index);
        } else {
          customStyle = state.rowStyle;
        }
      }
      return [
        {
          minHeight: !state.rowHeight ? `${state.rowMinHeight}px` : void 0
        },
        customStyle
      ];
    });
    const attrs = computed(() => {
      if (!props.isHead) {
        if (typeof state.rowAttrs === "function") {
          return state.rowAttrs(props.row.data, props.index);
        } else {
          return state.rowAttrs;
        }
      }
      return null;
    });
    const draggable = computed(() => !props.isHead && state.rowDraggable);
    const dragging = computed(() => state.dragging);
    const expandColumn = computed(() => {
      return state.columns.find((column) => column.type === "expand");
    });
    const expandRenderer = computed(() => state.expandRenderer);
    const expandStyle = computed(() => {
      return props.isFixed ? {
        width: "1px",
        overflow: "hidden",
        whiteSpace: "nowrap",
        visibility: "hidden"
      } : {};
    });
    const leftFixed = computed(() => computeFixedWidth(state.leftFixedColumns));
    const rightFixed = computed(() => computeFixedWidth(state.rightFixedColumns));
    function getRowHeight(row) {
      if (!row)
        return 0;
      return (row.borderHeight || 0) + (row.height || 0) + (row.expandHeight || 0);
    }
    function computeFixedWidth(columns) {
      if (!(columns == null ? void 0 : columns.length)) {
        return 0;
      }
      const widths = state.widths;
      let width = 0;
      for (let i = 0, len = columns.length; i < len; ++i) {
        const column = columns[i];
        const key = column.key;
        const columnWidth = widths[key];
        width += columnWidth;
      }
      return width;
    }
    function computeRectHeight() {
      if (!Object.keys(props.row).length || props.row.hidden)
        return;
      computeBorderHeight();
      computeRowHeight();
      if (state.heightBITree && !props.isFixed) {
        nextTick(() => {
          const height = getRowHeight(props.row);
          const tree = state.heightBITree;
          const prev = tree.get(props.index);
          if (height !== prev) {
            tree.add(props.index, height - prev);
            mutations.updateTotalHeight();
          }
        });
      }
    }
    watch(
      () => props.row.hidden,
      (value) => {
        !value && computeRectHeight();
      }
    );
    watch(
      () => props.row,
      () => {
        computeRectHeight();
      }
    );
    onMounted(() => {
      computeRectHeight();
      mutations.updateTotalHeight();
    });
    onUpdated(() => {
      if (!state.rowHeight) {
        computeRectHeight();
      } else if (!props.row.hidden) {
        computeBorderHeight();
      }
    });
    function computeRowHeight() {
      if (state.rowHeight) {
        mutations.setRowHeight(rowKey.value, state.rowHeight);
        nextTick(() => {
          if (rowElement.value) {
            rowElement.value.style.height = `${state.rowHeight}px`;
            rowElement.value.style.maxHeight = `${state.rowHeight}px`;
          }
        });
      } else {
        nextTick(() => {
          if (!props.isFixed) {
            if (rowElement.value) {
              mutations.setRowHeight(rowKey.value, rowElement.value.offsetHeight);
            }
          } else {
            setTimeout(() => {
              if (rowElement.value) {
                rowElement.value.style.height = `${props.row.height}px`;
              }
            }, 0);
          }
        });
      }
    }
    function computeBorderHeight() {
      var _a;
      if (wrapper.value) {
        const style2 = getComputedStyle(wrapper.value);
        const borderHeight = parseFloat(style2.borderTopWidth) + parseFloat(style2.borderBottomWidth);
        mutations.setBorderHeight(rowKey.value, borderHeight);
        mutations.setRowExpandHeight(rowKey.value, ((_a = expandElement.value) == null ? void 0 : _a.offsetHeight) || 0);
      }
    }
    function buildEventPayload(event) {
      return {
        row: props.row.data,
        key: props.row.key,
        index: props.index,
        event
      };
    }
    function handleMouseEnter(event) {
      mutations.setRowHover(rowKey.value, true);
      if (!props.isHead && tableAction) {
        const { data, key, index } = props.row;
        tableAction.emitRowEnter({ row: data, key, index, event });
      }
    }
    function handleMouseLeave(event) {
      mutations.setRowHover(rowKey.value, false);
      if (!props.isHead && tableAction) {
        tableAction.emitRowLeave(buildEventPayload(event));
      }
    }
    function handleClick(event) {
      if (!props.isHead && tableAction) {
        tableAction.emitRowClick(buildEventPayload(event));
      }
    }
    function handleDblclick(event) {
      if (!props.isHead && tableAction) {
        tableAction.emitRowDblclick(buildEventPayload(event));
      }
    }
    function handleContextmenu(event) {
      if (!props.isHead && tableAction) {
        tableAction.emitRowContextmenu(buildEventPayload(event));
      }
    }
    function handleDragStart(event) {
      if (!draggable.value)
        return;
      tableAction.handleRowDragStart(instance, event);
    }
    function handleDragOver(event) {
      if (!draggable.value || !dragging.value)
        return;
      event.stopPropagation();
      event.preventDefault();
      tableAction.handleRowDragOver(instance, event);
    }
    function handleDrop(event) {
      if (!draggable.value || !dragging.value)
        return;
      event.stopPropagation();
      event.preventDefault();
      tableAction.handleRowDrop(instance, event);
    }
    function handleDragEnd(event) {
      if (!draggable.value || !dragging.value)
        return;
      event.stopPropagation();
      tableAction.handleRowDragEnd(event);
    }
    return {
      nh,
      className,
      style,
      attrs,
      draggable,
      expandColumn,
      expandRenderer,
      expandStyle,
      leftFixed,
      rightFixed,
      wrapper,
      rowEl: rowElement,
      expand: expandElement,
      isFunction,
      handleMouseEnter,
      handleMouseLeave,
      handleClick,
      handleDblclick,
      handleContextmenu,
      handleDragStart,
      handleDragOver,
      handleDrop,
      handleDragEnd,
      computeRectHeight
    };
  }
});
const _hoisted_1 = ["draggable"];
const _hoisted_2 = ["aria-rowindex"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Renderer = resolveComponent("Renderer");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return !_ctx.row.hidden ? (openBlock(), createElementBlock("div", {
    key: 0,
    ref: "wrapper",
    class: normalizeClass([_ctx.nh.be("group"), _ctx.row.checked && _ctx.nh.bem("group", "checked")]),
    draggable: _ctx.draggable,
    onMouseenter: _cache[0] || (_cache[0] = (...args) => _ctx.handleMouseEnter && _ctx.handleMouseEnter(...args)),
    onMouseleave: _cache[1] || (_cache[1] = (...args) => _ctx.handleMouseLeave && _ctx.handleMouseLeave(...args)),
    onClick: _cache[2] || (_cache[2] = (...args) => _ctx.handleClick && _ctx.handleClick(...args)),
    onDblclick: _cache[3] || (_cache[3] = (...args) => _ctx.handleDblclick && _ctx.handleDblclick(...args)),
    onContextmenu: _cache[4] || (_cache[4] = (...args) => _ctx.handleContextmenu && _ctx.handleContextmenu(...args)),
    onDragstart: _cache[5] || (_cache[5] = withModifiers((...args) => _ctx.handleDragStart && _ctx.handleDragStart(...args), ["stop"])),
    onDragover: _cache[6] || (_cache[6] = (...args) => _ctx.handleDragOver && _ctx.handleDragOver(...args)),
    onDragend: _cache[7] || (_cache[7] = (...args) => _ctx.handleDragEnd && _ctx.handleDragEnd(...args)),
    onDrop: _cache[8] || (_cache[8] = (...args) => _ctx.handleDrop && _ctx.handleDrop(...args))
  }, [
    createElementVNode("div", mergeProps({
      ref: "rowEl",
      class: _ctx.className,
      role: "row",
      style: _ctx.style,
      "aria-rowindex": _ctx.index
    }, _ctx.attrs), [
      renderSlot(_ctx.$slots, "default")
    ], 16, _hoisted_2),
    !!_ctx.expandColumn ? (openBlock(), createBlock(_component_CollapseTransition, {
      key: 0,
      appear: "",
      onAfterEnter: _ctx.computeRectHeight,
      onAfterLeave: _ctx.computeRectHeight
    }, {
      default: withCtx(() => [
        _ctx.row.expanded ? (openBlock(), createElementBlock("div", {
          key: 0,
          ref: "expand",
          class: normalizeClass(_ctx.nh.be("collapse")),
          style: normalizeStyle(_ctx.expandStyle)
        }, [
          _ctx.isFunction(_ctx.expandColumn.renderer) ? (openBlock(), createBlock(_component_Renderer, {
            key: 0,
            renderer: _ctx.expandColumn.renderer,
            data: { leftFixed: _ctx.leftFixed, rightFixed: _ctx.rightFixed, row: _ctx.row.data, rowIndex: _ctx.index }
          }, null, 8, ["renderer", "data"])) : _ctx.isFunction(_ctx.expandRenderer) ? (openBlock(), createBlock(_component_Renderer, {
            key: 1,
            renderer: _ctx.expandRenderer,
            data: { leftFixed: _ctx.leftFixed, rightFixed: _ctx.rightFixed, row: _ctx.row.data, rowIndex: _ctx.index }
          }, null, 8, ["renderer", "data"])) : createCommentVNode("", true)
        ], 6)) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["onAfterEnter", "onAfterLeave"])) : createCommentVNode("", true)
  ], 42, _hoisted_1)) : createCommentVNode("", true);
}
var TableRow = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { TableRow as default };
