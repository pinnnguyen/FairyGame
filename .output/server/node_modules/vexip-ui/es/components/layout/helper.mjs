import { inject, reactive, ref, computed, watch, onBeforeMount, onBeforeUnmount, onMounted, onUpdated } from "vue";
import { isClient, parseColorToRgba, mixColor, adjustAlpha, toFixed } from "@vexip-ui/utils";
import { LAYOUT_STATE } from "./symbol.mjs";
const rootEl = isClient ? document.documentElement : void 0;
const rootStyle = rootEl && getComputedStyle(rootEl);
function computeSeriesColors(value, storageName = "") {
  if (!rootEl || !rootStyle)
    return;
  const colors = {
    light: [],
    opacity: [],
    dark: []
  };
  const black = parseColorToRgba(
    rootStyle.getPropertyValue("--vxp-color-black") || { r: 0, g: 0, b: 0, a: 1 }
  );
  const white = parseColorToRgba(
    rootStyle.getPropertyValue("--vxp-color-white") || { r: 255, g: 255, b: 255, a: 1 }
  );
  const style = rootEl.style;
  for (let i = 1; i < 10; ++i) {
    const light = mixColor(white, value, i * 0.1).toString();
    const opacity = adjustAlpha(value, toFixed(1 - i * 0.1, 1)).toString();
    style.setProperty(`--vxp-color-primary-light-${i}`, light);
    style.setProperty(`--vxp-color-primary-opacity-${i}`, opacity);
    colors.light.push(light);
    colors.opacity.push(opacity);
  }
  for (let i = 1; i < 3; ++i) {
    const dark = mixColor(black, value, i * 0.1).toString();
    style.setProperty(`--vxp-color-primary-dark-${i}`, dark);
    colors.dark.push(dark);
  }
  style.setProperty("--vxp-color-primary-base", `${value}`);
  storageName && localStorage.setItem(storageName, `${value}`);
  return colors;
}
function useLayoutState() {
  return inject(
    LAYOUT_STATE,
    reactive({
      isLayout: false,
      locked: false,
      affixed: false,
      scrollY: 0,
      affixMatched: false,
      expanded: false,
      reduced: false,
      navConfig: false
    })
  );
}
const breakPoints = Object.freeze(["xs", "sm", "md", "lg", "xl", "xxl"]);
function useMediaQuery(query) {
  const matched = ref(false);
  if (!isClient)
    return matched;
  const computedStyle = getComputedStyle(document.documentElement);
  const computedQuery = computed(() => {
    if (breakPoints.includes(query.value)) {
      const media = computedStyle.getPropertyValue(`--vxp-break-point-${query.value}`).trim();
      return `only screen and ${media}`;
    }
    return query.value;
  });
  let mediaQuery;
  const update = () => {
    if (typeof computedQuery.value === "boolean") {
      matched.value = computedQuery.value;
      return;
    }
    if (!computedQuery.value || computedQuery.value === "min") {
      matched.value = false;
      return;
    }
    if (computedQuery.value === "max") {
      matched.value = true;
      return;
    }
    if (!mediaQuery) {
      mediaQuery = matchMedia(computedQuery.value);
    }
    matched.value = mediaQuery.matches;
  };
  watch(computedQuery, () => {
    mediaQuery = void 0;
    update();
  });
  onBeforeMount(() => {
    update();
    mediaQuery == null ? void 0 : mediaQuery.addEventListener("change", update);
  });
  onBeforeUnmount(() => {
    mediaQuery == null ? void 0 : mediaQuery.removeEventListener("change", update);
  });
  return matched;
}
function useUpdateCounter() {
  const counter = ref(0);
  onMounted(() => {
    counter.value++;
  });
  onUpdated(() => {
    counter.value++;
  });
  return counter;
}
export { computeSeriesColors, useLayoutState, useMediaQuery, useUpdateCounter };
