import { defineComponent, toRefs, ref, computed, watch, nextTick, createVNode, mergeProps } from "vue";
import "../native-scroll/index.mjs";
import "../resize-observer/index.mjs";
import "../../common/config/src/index.mjs";
import { useVirtual } from "@vexip-ui/hooks";
import { virtualListProps } from "./props.mjs";
import NativeScroll from "../native-scroll/native-scroll.mjs";
import ResizeObserver from "../resize-observer/resize-observer.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
var VirtualList = defineComponent({
  name: "VirtualList",
  components: {
    NativeScroll,
    ResizeObserver
  },
  inheritAttrs: false,
  props: virtualListProps,
  emits: [],
  setup(_props, {
    slots,
    attrs,
    expose
  }) {
    const props = useProps("virtualList", _props, {
      items: {
        default: () => [],
        static: true
      },
      itemSize: 36,
      itemFixed: false,
      idKey: "id",
      defaultKeyAt: null,
      bufferSize: 5,
      listTag: "div",
      itemsTag: "ul",
      itemsAttrs: null
    });
    const nh = useNameHelper("virtual-list");
    const {
      items,
      itemSize,
      itemFixed,
      idKey,
      bufferSize
    } = toRefs(props);
    const scroll = ref();
    const list = ref();
    const wrapper = computed(() => {
      var _a, _b;
      return (_b = (_a = scroll.value) == null ? void 0 : _a.content) != null ? _b : null;
    });
    const {
      indexMap,
      scrollOffset,
      visibleItems,
      listStyle,
      itemsStyle,
      handleScroll,
      handleResize,
      handleItemResize,
      scrollTo,
      scrollBy,
      scrollToKey,
      scrollToIndex,
      ensureIndexInView,
      ensureKeyInView
    } = useVirtual({
      items,
      itemSize,
      itemFixed,
      idKey,
      bufferSize,
      wrapper,
      defaultKeyAt: props.defaultKeyAt,
      autoResize: false
    });
    expose({
      scroll,
      wrapper,
      list,
      scrollOffset,
      scrollTo,
      scrollBy,
      scrollToKey,
      scrollToIndex,
      ensureIndexInView,
      ensureKeyInView,
      refresh
    });
    watch(() => props.items.length, () => {
      nextTick(refresh);
    });
    function onScroll(payload) {
      handleScroll();
      emitEvent(props.onScroll, payload);
    }
    function onResize(entry) {
      handleResize(entry);
      emitEvent(props.onResize, entry);
    }
    function refresh() {
      var _a;
      (_a = scroll.value) == null ? void 0 : _a.refresh();
    }
    return () => {
      const keyField = props.idKey;
      const itemFixed2 = props.itemFixed;
      const keyIndexMap = indexMap.value;
      const itemSlot = slots.default;
      const {
        class: itemsClass,
        style: itemsOtherStyle,
        ...itemsAttrs
      } = props.itemsAttrs || {};
      const ListTag = props.listTag || "div";
      const ItemsTag = props.itemsTag || "ul";
      let renderingItems = visibleItems.value;
      if (false) {
        renderingItems = props.items;
      }
      return createVNode(NativeScroll, mergeProps({
        "ref": scroll,
        "inherit": props.inherit,
        "class": nh.b(),
        "use-y-bar": true,
        "scroll-y": scrollOffset.value
      }, attrs, {
        "onScroll": onScroll,
        "onResize": onResize
      }), {
        default: () => [createVNode(ResizeObserver, {
          "throttle": true,
          "onResize": refresh
        }, {
          default: () => [createVNode(ListTag, {
            "ref": list,
            "class": nh.be("list"),
            "style": listStyle.value
          }, {
            default: () => [createVNode(ItemsTag, mergeProps(itemsAttrs, {
              "class": [nh.be("items"), itemsClass],
              "style": [itemsStyle.value, itemsOtherStyle]
            }), {
              default: () => {
                var _a;
                return [itemSlot && props.items.length ? renderingItems.map((item) => {
                  const key = item[keyField];
                  const index = keyIndexMap.get(key);
                  const vnode = itemSlot({
                    item,
                    index
                  })[0];
                  if (itemFixed2) {
                    vnode.key = key;
                    return vnode;
                  }
                  const onResize2 = handleItemResize.bind(null, key);
                  return createVNode(ResizeObserver, {
                    "key": key,
                    "throttle": true,
                    "onResize": onResize2
                  }, {
                    default: () => vnode
                  });
                }) : (_a = slots.empty) == null ? void 0 : _a.call(slots)];
              }
            })]
          })]
        })]
      });
    };
  }
});
export { VirtualList as default };
