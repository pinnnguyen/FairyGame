import { defineComponent, ref, toRef, computed, watch, nextTick, resolveComponent, openBlock, createElementBlock, normalizeClass, withKeys, withModifiers, createElementVNode, renderSlot, normalizeStyle, createVNode, createCommentVNode, createBlock, withCtx, Transition, Fragment, renderList, createTextVNode, toDisplayString } from "vue";
import ColorAlpha from "./color-alpha.mjs";
import ColorHue from "./color-hue.mjs";
import ColorPalette from "./color-palette.mjs";
import "../button/index.mjs";
import "../icon/index.mjs";
import "../input/index.mjs";
import "../portal/index.mjs";
import "../form/index.mjs";
import { placementWhileList, useClickOutside, usePopper, useHover } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { rgbToHsv, hsvToRgb, rgbaToHex, rgbToHex, parseColorToRgba, toFixed, hsvToHsl, isClient, isElement } from "@vexip-ui/utils";
import { Xmark, ChevronDown, CircleXmark, Spinner } from "@vexip-ui/icons";
import { colorPickerProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Button from "../button/button.mjs";
import Icon from "../icon/icon.mjs";
import Input from "../input/input.mjs";
import Portal from "../portal/portal.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const getDefaultHsv = () => rgbToHsv(0, 0, 0);
const defaultShotcuts = Object.freeze([
  "#2d8cf0",
  "#19be6b",
  "#ff9900",
  "#ed4014",
  "#00b5ff",
  "#19c919",
  "#f9e31c",
  "#ea1a1a",
  "#9b1dea",
  "#00c2b1",
  "#ac7a33",
  "#1d35ea",
  "#8bc34a",
  "#f16b62",
  "#ea4ca3",
  "#0d94aa",
  "#febd79",
  "#5d4037",
  "#00bcd4",
  "#f06292",
  "#cddc39",
  "#607d8b",
  "#000000",
  "#ffffff"
]);
const _sfc_main = defineComponent({
  name: "ColorPicker",
  components: {
    Button,
    ColorAlpha,
    ColorHue,
    ColorPalette,
    Icon,
    Input,
    Portal,
    Xmark,
    ChevronDown,
    CircleXmark
  },
  props: colorPickerProps,
  emits: ["update:value", "update:visible"],
  setup(_props, { slots, emit }) {
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = reference.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("color-picker");
    const props = useProps("colorPicker", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      visible: false,
      format: {
        default: "rgb",
        validator: (value) => ["rgb", "hsl", "hsv", "hex"].includes(value)
      },
      alpha: false,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      noInput: false,
      shortcut: false,
      placement: {
        default: "bottom",
        validator: (value) => placementWhileList.includes(value)
      },
      transfer: false,
      outsideClose: true,
      clearable: false,
      cancelText: null,
      confirmText: null,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      noSuffix: false,
      staticSuffix: false,
      loading: () => loading.value,
      loadingIcon: Spinner,
      loadingLock: false,
      loadingSpin: false
    });
    const isEmpty = ref(true);
    const currentVisible = ref(props.visible);
    const currentValue = ref(null);
    const currentAlpha = ref(1);
    const editing = ref(false);
    const placement = toRef(props, "placement");
    const transfer = toRef(props, "transfer");
    const shortcutHitting = ref(0);
    const shortcutsFocused = ref(false);
    parseValue(props.value);
    const palette = ref(null);
    const hue = ref(null);
    const alpha = ref(null);
    const shortcut = ref(null);
    const input = ref(null);
    const cancel = ref(null);
    const confirm = ref(null);
    const wrapper = useClickOutside(handleClickOutside);
    const { reference, popper, transferTo, updatePopper } = usePopper({
      placement,
      transfer,
      wrapper,
      isDrop: true
    });
    const { isHover } = useHover(reference);
    const unitList = computed(() => {
      return [
        palette.value,
        hue.value,
        alpha.value,
        shortcut.value,
        input.value,
        cancel.value,
        confirm.value
      ].filter(Boolean);
    });
    const lastValue = ref({
      ...currentValue.value,
      a: currentAlpha.value,
      format: "hsva"
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.ns("input-vars")]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("empty")]: isEmpty.value && !currentVisible.value,
        [nh.bm("focused")]: currentVisible.value,
        [nh.bm("disabled")]: props.disabled,
        [nh.bm("alpha")]: props.alpha,
        [nh.bm(props.size)]: props.size !== "default",
        [nh.bm(props.state)]: props.state !== "default"
      };
    });
    const selectorClass = computed(() => {
      const baseCls = nh.be("selector");
      return {
        [baseCls]: true,
        [`${baseCls}--disabled`]: props.disabled,
        [`${baseCls}--loading`]: props.loading && props.loadingLock,
        [`${baseCls}--${props.size}`]: props.size !== "default",
        [`${baseCls}--focused`]: currentVisible.value,
        [`${baseCls}--${props.state}`]: props.state !== "default"
      };
    });
    const rgb = computed(() => {
      var _a;
      const { h, s, v } = currentValue.value && currentVisible.value ? currentValue.value : (_a = lastValue.value) != null ? _a : { h: 0, s: 0, v: 0 };
      return hsvToRgb(h, s, v);
    });
    const hex = computed(() => {
      const { r, g, b } = rgb.value;
      if (props.alpha) {
        return rgbaToHex(r, g, b, currentAlpha.value);
      }
      return rgbToHex(r, g, b);
    });
    const shortcutList = computed(() => {
      if (!props.shortcut)
        return [];
      if (Array.isArray(props.shortcut)) {
        return props.shortcut;
      }
      return defaultShotcuts;
    });
    const hasPrefix = computed(() => {
      return !!(slots.prefix || props.prefix);
    });
    const showClear = computed(() => {
      return !props.disabled && props.clearable && isHover.value && !isEmpty.value;
    });
    watch(
      () => props.visible,
      (value) => {
        currentVisible.value = value;
      }
    );
    watch(currentVisible, (value) => {
      value && updatePopper();
      emitEvent(props.onToggle, value);
      emit("update:visible", value);
    });
    watch(
      () => props.value,
      (value) => {
        parseValue(value);
        lastValue.value = { ...currentValue.value, a: currentAlpha.value, format: "hsva" };
      }
    );
    watch(
      () => props.disabled,
      (value) => {
        if (value) {
          currentVisible.value = false;
        }
      }
    );
    function parseValue(value) {
      if (value) {
        const { r, g, b, a } = parseColorToRgba(value);
        isEmpty.value = false;
        currentValue.value = rgbToHsv(r, g, b);
        currentAlpha.value = a;
      } else {
        isEmpty.value = true;
        currentValue.value = getDefaultHsv();
        currentAlpha.value = 1;
      }
    }
    function handleClickOutside() {
      if (!editing.value) {
        emitEvent(props.onClickOutside);
        if (props.outsideClose && currentVisible.value) {
          currentVisible.value = false;
          emitEvent(props.onOutsideClose);
        }
      }
    }
    function toggleVisible() {
      if (props.disabled || props.loading && props.loadingLock)
        return;
      currentVisible.value = !currentVisible.value;
    }
    function handleClear() {
      if (props.clearable) {
        currentVisible.value = false;
        nextTick(() => {
          parseValue(null);
          clearField();
          emitEvent(props.onClear);
        });
      }
    }
    function handleOk() {
      lastValue.value = { ...currentValue.value, a: currentAlpha.value, format: "hsva" };
      isEmpty.value = false;
      currentVisible.value = false;
      handleChange();
    }
    function getForamttedColor() {
      let color;
      if (props.format === "hex") {
        const { r, g, b } = rgb.value;
        if (props.alpha) {
          color = rgbaToHex(r, g, b, currentAlpha.value);
        } else {
          color = rgbToHex(r, g, b);
        }
      } else {
        switch (props.format) {
          case "rgb": {
            color = { ...rgb.value };
            color.r = Math.round(color.r);
            color.g = Math.round(color.g);
            color.b = Math.round(color.b);
            break;
          }
          case "hsl": {
            const { h, s, v } = currentValue.value;
            color = hsvToHsl(h, s, v);
            color.h = Math.round(color.h);
            color.s = toFixed(color.s, 3);
            color.l = toFixed(color.l, 3);
            break;
          }
          default: {
            color = { ...currentValue.value };
            color.h = Math.round(color.h);
            color.s = toFixed(color.s, 3);
            color.v = toFixed(color.v, 3);
          }
        }
        color.a = toFixed(currentAlpha.value, 3);
      }
      return color;
    }
    function handleChange() {
      const formattedColor = getForamttedColor();
      setFieldValue(formattedColor);
      emitEvent(props.onChange, formattedColor);
      emit("update:value", formattedColor);
      validateField();
    }
    function handlePaletteChange({ s, v }) {
      currentValue.value.s = s;
      currentValue.value.v = v;
    }
    function handleHueChange(hue2) {
      currentValue.value.h = hue2;
    }
    function handleAlphaChange(alpha2) {
      currentAlpha.value = alpha2;
    }
    function handleInputColor(value) {
      const { r, g, b, a } = parseColorToRgba(value);
      currentValue.value = rgbToHsv(r, g, b);
      currentAlpha.value = a;
    }
    function handleShortcutClick(color) {
      const { r, g, b, a } = parseColorToRgba(color);
      currentValue.value = rgbToHsv(r, g, b);
      currentAlpha.value = a;
      emitEvent(props.onShortcut, getForamttedColor());
    }
    function toggleEditing(able) {
      if (!able) {
        setTimeout(() => {
          editing.value = false;
        }, 0);
      } else {
        editing.value = true;
      }
    }
    function handleTabDown(event) {
      var _a;
      if (isClient && currentVisible.value) {
        const activeEl = document && document.activeElement;
        if (!activeEl)
          return;
        event.preventDefault();
        const shift = event.shiftKey;
        const elList = Array.from(unitList.value);
        const index = elList.findIndex((unit) => {
          const el = isElement(unit) ? unit : unit.$el;
          return el === activeEl || el.contains(activeEl);
        });
        let maybeEl;
        if (!~index) {
          maybeEl = elList.at(shift ? -1 : 0);
        } else if (shift ? !index : index === elList.length - 1) {
          maybeEl = reference.value;
        } else {
          maybeEl = elList.at(index + (shift ? -1 : 1));
        }
        if (maybeEl) {
          if (typeof maybeEl.focus === "function") {
            maybeEl.focus();
          } else {
            (_a = maybeEl.$el) == null ? void 0 : _a.focus();
          }
        }
      }
    }
    function handleShrtcutsFocus() {
      shortcutHitting.value = 0;
      shortcutsFocused.value = true;
    }
    function handleShortcutsKeydown(event) {
      const key = event.code || event.key;
      const shortcutCount = shortcutList.value.length;
      switch (key) {
        case "ArrowUp":
        case "ArrowLeft": {
          shortcutHitting.value--;
          break;
        }
        case "ArrowDown":
        case "ArrowRight": {
          shortcutHitting.value++;
          break;
        }
        case "Enter":
        case "Space":
        case " ": {
          const color = shortcutList.value.at(shortcutHitting.value);
          color && handleShortcutClick(color);
          break;
        }
      }
      shortcutHitting.value = (shortcutHitting.value + shortcutCount) % shortcutCount;
    }
    function handleSpaceDown(event) {
      var _a;
      if (props.disabled) {
        currentVisible.value = false;
      } else {
        event.preventDefault();
        if (currentVisible.value) {
          handleOk();
          (_a = reference.value) == null ? void 0 : _a.focus();
        } else {
          currentVisible.value = true;
        }
      }
    }
    function handleEscDown() {
      var _a;
      currentVisible.value = false;
      (_a = reference.value) == null ? void 0 : _a.focus();
    }
    return {
      props,
      nh,
      locale: useLocale("colorPicker"),
      idFor,
      isEmpty,
      currentVisible,
      currentValue,
      currentAlpha,
      transferTo,
      lastValue,
      shortcutHitting,
      shortcutsFocused,
      className,
      selectorClass,
      rgb,
      hex,
      shortcutList,
      hasPrefix,
      showClear,
      wrapper,
      reference,
      popper,
      palette,
      hue,
      alphaUnit: alpha,
      shortcutUnit: shortcut,
      input,
      cancel,
      confirm,
      toggleVisible,
      handleClear,
      handleOk,
      handlePaletteChange,
      handleHueChange,
      handleAlphaChange,
      handleInputColor,
      handleShortcutClick,
      toggleEditing,
      handleTabDown,
      handleShrtcutsFocus,
      handleShortcutsKeydown,
      handleSpaceDown,
      handleEscDown
    };
  }
});
const _hoisted_1 = ["id"];
const _hoisted_2 = ["onClick"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Xmark = resolveComponent("Xmark");
  const _component_ChevronDown = resolveComponent("ChevronDown");
  const _component_CircleXmark = resolveComponent("CircleXmark");
  const _component_ColorPalette = resolveComponent("ColorPalette");
  const _component_ColorHue = resolveComponent("ColorHue");
  const _component_ColorAlpha = resolveComponent("ColorAlpha");
  const _component_Input = resolveComponent("Input");
  const _component_Button = resolveComponent("Button");
  const _component_Portal = resolveComponent("Portal");
  return openBlock(), createElementBlock("div", {
    id: _ctx.idFor,
    ref: "wrapper",
    class: normalizeClass(_ctx.className),
    onKeydown: [
      _cache[14] || (_cache[14] = withKeys(withModifiers((...args) => _ctx.handleTabDown && _ctx.handleTabDown(...args), ["stop"]), ["tab"])),
      _cache[15] || (_cache[15] = withKeys((...args) => _ctx.handleSpaceDown && _ctx.handleSpaceDown(...args), ["space"])),
      _cache[16] || (_cache[16] = withKeys((...args) => _ctx.handleEscDown && _ctx.handleEscDown(...args), ["escape"]))
    ]
  }, [
    createElementVNode("div", {
      ref: "reference",
      class: normalizeClass(_ctx.selectorClass),
      tabindex: "0",
      onClick: _cache[1] || (_cache[1] = (...args) => _ctx.toggleVisible && _ctx.toggleVisible(...args))
    }, [
      renderSlot(_ctx.$slots, "control", {
        color: _ctx.rgb,
        alpha: _ctx.currentAlpha,
        empty: _ctx.isEmpty
      }, () => [
        _ctx.hasPrefix ? (openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("prefix")]),
          style: normalizeStyle({ color: _ctx.props.prefixColor })
        }, [
          renderSlot(_ctx.$slots, "prefix", {}, () => [
            createVNode(_component_Icon, {
              icon: _ctx.props.prefix
            }, null, 8, ["icon"])
          ])
        ], 6)) : createCommentVNode("", true),
        createElementVNode("div", {
          class: normalizeClass(_ctx.nh.be("control"))
        }, [
          createElementVNode("div", {
            class: normalizeClass(_ctx.nh.be("marker"))
          }, [
            !_ctx.currentVisible && _ctx.isEmpty ? (openBlock(), createBlock(_component_Icon, { key: 0 }, {
              default: withCtx(() => [
                createVNode(_component_Xmark)
              ]),
              _: 1
            })) : (openBlock(), createElementBlock("div", {
              key: 1,
              style: normalizeStyle({
                width: "100%",
                height: "100%",
                backgroundColor: `rgba(${_ctx.rgb.r}, ${_ctx.rgb.g}, ${_ctx.rgb.b}, ${_ctx.currentVisible ? _ctx.currentAlpha : _ctx.lastValue.a})`
              })
            }, null, 4))
          ], 2)
        ], 2),
        !_ctx.props.noSuffix ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("suffix")]),
          style: normalizeStyle({
            color: _ctx.props.suffixColor,
            opacity: _ctx.showClear || _ctx.props.loading ? "0%" : ""
          })
        }, [
          renderSlot(_ctx.$slots, "suffix", {}, () => [
            _ctx.props.suffix ? (openBlock(), createBlock(_component_Icon, {
              key: 0,
              icon: _ctx.props.suffix,
              class: normalizeClass({
                [_ctx.nh.be("arrow")]: !_ctx.props.staticSuffix
              })
            }, null, 8, ["icon", "class"])) : (openBlock(), createBlock(_component_Icon, {
              key: 1,
              class: normalizeClass(_ctx.nh.be("arrow"))
            }, {
              default: withCtx(() => [
                createVNode(_component_ChevronDown)
              ]),
              _: 1
            }, 8, ["class"]))
          ])
        ], 6)) : _ctx.props.clearable || _ctx.props.loading ? (openBlock(), createElementBlock("div", {
          key: 2,
          class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.bem("icon", "placeholder"), _ctx.nh.be("suffix")])
        }, null, 2)) : createCommentVNode("", true),
        createVNode(Transition, {
          name: _ctx.nh.ns("fade"),
          appear: ""
        }, {
          default: withCtx(() => [
            _ctx.showClear ? (openBlock(), createElementBlock("div", {
              key: 0,
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("clear")]),
              onClick: _cache[0] || (_cache[0] = withModifiers((...args) => _ctx.handleClear && _ctx.handleClear(...args), ["stop"]))
            }, [
              createVNode(_component_Icon, null, {
                default: withCtx(() => [
                  createVNode(_component_CircleXmark)
                ]),
                _: 1
              })
            ], 2)) : _ctx.props.loading ? (openBlock(), createElementBlock("div", {
              key: 1,
              class: normalizeClass([_ctx.nh.be("icon"), _ctx.nh.be("loading")])
            }, [
              createVNode(_component_Icon, {
                spin: _ctx.props.loadingSpin,
                pulse: !_ctx.props.loadingSpin,
                icon: _ctx.props.loadingIcon
              }, null, 8, ["spin", "pulse", "icon"])
            ], 2)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name"])
      ])
    ], 2),
    createVNode(_component_Portal, { to: _ctx.transferTo }, {
      default: withCtx(() => [
        createVNode(Transition, {
          name: _ctx.props.transitionName
        }, {
          default: withCtx(() => [
            _ctx.currentVisible ? (openBlock(), createElementBlock("div", {
              key: 0,
              ref: "popper",
              class: normalizeClass([
                _ctx.nh.be("popper"),
                _ctx.nh.bs("vars"),
                _ctx.transferTo !== "body" && [_ctx.nh.bem("popper", "inherit")]
              ]),
              onKeydown: [
                _cache[11] || (_cache[11] = withKeys(withModifiers((...args) => _ctx.handleTabDown && _ctx.handleTabDown(...args), ["stop"]), ["tab"])),
                _cache[12] || (_cache[12] = withKeys((...args) => _ctx.handleSpaceDown && _ctx.handleSpaceDown(...args), ["space"])),
                _cache[13] || (_cache[13] = withKeys((...args) => _ctx.handleEscDown && _ctx.handleEscDown(...args), ["escape"]))
              ]
            }, [
              createElementVNode("div", {
                class: normalizeClass(_ctx.nh.be("panel"))
              }, [
                createElementVNode("div", {
                  class: normalizeClass(_ctx.nh.be("section"))
                }, [
                  createVNode(_component_ColorPalette, {
                    ref: "palette",
                    hue: _ctx.currentValue.h,
                    saturation: _ctx.currentValue.s,
                    value: _ctx.currentValue.v,
                    onEditStart: _cache[2] || (_cache[2] = ($event) => _ctx.toggleEditing(true)),
                    onEditEnd: _cache[3] || (_cache[3] = ($event) => _ctx.toggleEditing(false)),
                    onChange: _ctx.handlePaletteChange
                  }, null, 8, ["hue", "saturation", "value", "onChange"]),
                  createVNode(_component_ColorHue, {
                    ref: "hue",
                    hue: _ctx.currentValue.h,
                    onEditStart: _cache[4] || (_cache[4] = ($event) => _ctx.toggleEditing(true)),
                    onEditEnd: _cache[5] || (_cache[5] = ($event) => _ctx.toggleEditing(false)),
                    onChange: _ctx.handleHueChange
                  }, null, 8, ["hue", "onChange"]),
                  _ctx.props.alpha ? (openBlock(), createBlock(_component_ColorAlpha, {
                    key: 0,
                    ref: "alphaUnit",
                    rgb: _ctx.rgb,
                    alpha: _ctx.currentAlpha,
                    onEditStart: _cache[6] || (_cache[6] = ($event) => _ctx.toggleEditing(true)),
                    onEditEnd: _cache[7] || (_cache[7] = ($event) => _ctx.toggleEditing(false)),
                    onChange: _ctx.handleAlphaChange
                  }, null, 8, ["rgb", "alpha", "onChange"])) : createCommentVNode("", true),
                  _ctx.props.shortcut ? (openBlock(), createElementBlock("div", {
                    key: 1,
                    ref: "shortcutUnit",
                    class: normalizeClass(_ctx.nh.be("shortcuts")),
                    tabindex: "-1",
                    onFocus: _cache[8] || (_cache[8] = (...args) => _ctx.handleShrtcutsFocus && _ctx.handleShrtcutsFocus(...args)),
                    onBlur: _cache[9] || (_cache[9] = ($event) => _ctx.shortcutsFocused = false),
                    onKeydown: _cache[10] || (_cache[10] = (...args) => _ctx.handleShortcutsKeydown && _ctx.handleShortcutsKeydown(...args))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.shortcutList, (item, index) => {
                      return openBlock(), createElementBlock("div", {
                        key: index,
                        class: normalizeClass({
                          [_ctx.nh.be("shortcut-item")]: true,
                          [_ctx.nh.bem("shortcut-item", "hitting")]: _ctx.shortcutsFocused && _ctx.shortcutHitting === index
                        }),
                        style: normalizeStyle({ backgroundColor: item }),
                        onClick: ($event) => _ctx.handleShortcutClick(item)
                      }, null, 14, _hoisted_2);
                    }), 128))
                  ], 34)) : createCommentVNode("", true)
                ], 2),
                createElementVNode("div", {
                  class: normalizeClass(_ctx.nh.be("action"))
                }, [
                  !_ctx.props.noInput ? (openBlock(), createBlock(_component_Input, {
                    key: 0,
                    ref: "input",
                    inherit: "",
                    class: normalizeClass(_ctx.nh.be("input")),
                    size: "small",
                    value: _ctx.hex.toUpperCase(),
                    respond: false,
                    onChange: _ctx.handleInputColor
                  }, null, 8, ["class", "value", "onChange"])) : createCommentVNode("", true),
                  _ctx.props.clearable ? (openBlock(), createBlock(_component_Button, {
                    key: 1,
                    ref: "cancel",
                    inherit: "",
                    text: "",
                    size: "small",
                    onClick: _ctx.handleClear
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.props.cancelText || _ctx.locale.cancel), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])) : createCommentVNode("", true),
                  createVNode(_component_Button, {
                    ref: "confirm",
                    inherit: "",
                    type: "primary",
                    size: "small",
                    onClick: _ctx.handleOk
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString(_ctx.props.confirmText || _ctx.locale.confirm), 1)
                    ]),
                    _: 1
                  }, 8, ["onClick"])
                ], 2)
              ], 2)
            ], 34)) : createCommentVNode("", true)
          ]),
          _: 1
        }, 8, ["name"])
      ]),
      _: 1
    }, 8, ["to"])
  ], 42, _hoisted_1);
}
var ColorPicker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { ColorPicker as default };
