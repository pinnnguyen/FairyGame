import { defineComponent, ref, computed, watch, openBlock, createElementBlock, normalizeClass, createElementVNode, normalizeStyle } from "vue";
import "../../common/config/src/index.mjs";
import { useModifier, useMoving } from "@vexip-ui/hooks";
import { toFixed, boundRange } from "@vexip-ui/utils";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const _sfc_main = defineComponent({
  name: "ColorAlpha",
  props: {
    rgb: {
      type: Object,
      default: () => {
        return { r: 0, g: 0, b: 0 };
      },
      validator: (value) => {
        return "r" in value && "g" in value && "b" in value;
      }
    },
    alpha: {
      type: Number,
      default: 1,
      validator: (value) => {
        return value >= 0 && value <= 1;
      }
    }
  },
  emits: ["edit-start", "edit-end", "change"],
  setup(props, { emit }) {
    const currentLeft = ref(props.alpha * 100);
    let prevLeft = currentLeft.value;
    let widthLimit;
    let leftStartAt;
    const { target: wrapper } = useModifier({
      passive: false,
      onKeyDown: (event, modifier) => {
        if (modifier.left || modifier.right) {
          event.preventDefault();
          const step = event.ctrlKey ? 10 : event.altKey ? 0.5 : 2;
          const delta = step * (modifier.left ? -1 : 1);
          currentLeft.value += delta;
          verifyPosition();
          prevLeft = currentLeft.value;
          handleChange();
        }
      }
    });
    const { moving: editing } = useMoving({
      target: wrapper,
      onStart: (state, event) => {
        if (!wrapper.value || event.button > 0) {
          return false;
        }
        const rect = wrapper.value.getBoundingClientRect();
        const { left, width } = rect;
        widthLimit = width;
        currentLeft.value = (leftStartAt = state.clientX - left) / width * 100;
        verifyPosition();
        emit("edit-start");
        if (Math.abs(currentLeft.value - prevLeft) >= 0.01) {
          prevLeft = currentLeft.value;
          handleChange();
        }
      },
      onMove: (state) => {
        currentLeft.value = (leftStartAt + state.deltaX) / widthLimit * 100;
        verifyPosition();
        handleChange();
      },
      onEnd: () => {
        emit("edit-end");
      }
    });
    const rgbString = computed(() => {
      const { r, g, b } = props.rgb;
      return `${r}, ${g}, ${b}`;
    });
    verifyPosition();
    watch(
      () => props.alpha,
      (value) => {
        currentLeft.value = value * 100;
        verifyPosition();
      },
      { immediate: true }
    );
    function verifyPosition() {
      currentLeft.value = toFixed(boundRange(currentLeft.value, 0, 100), 3);
    }
    function handleChange() {
      emit("change", currentLeft.value / 100);
    }
    return {
      nh: useNameHelper("color-picker"),
      currentLeft,
      editing,
      rgbString,
      wrapper
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "wrapper",
    class: normalizeClass(_ctx.nh.be("alpha")),
    tabindex: "-1"
  }, [
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("opacity")),
      style: normalizeStyle({
        backgroundImage: `linear-gradient(to right, rgba(${_ctx.rgbString}, 0) 0%, rgb(${_ctx.rgbString}) 100%)`
      })
    }, null, 6),
    createElementVNode("div", {
      class: normalizeClass(_ctx.nh.be("alpha-handler")),
      style: normalizeStyle({ left: `${_ctx.currentLeft}%` })
    }, null, 6)
  ], 2);
}
var ColorAlpha = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { ColorAlpha as default };
