import { defineComponent, ref, computed, watch, watchEffect, onMounted, nextTick, resolveComponent, openBlock, createBlock, normalizeClass, createSlots, withCtx, renderSlot, createElementVNode, withKeys, createVNode } from "vue";
import "../icon/index.mjs";
import "../select/index.mjs";
import "../form/index.mjs";
import { placementWhileList } from "@vexip-ui/hooks";
import "../../common/config/src/index.mjs";
import { isNull } from "@vexip-ui/utils";
import { autoCompleteProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import Icon from "../icon/icon.mjs";
import Select from "../select/select.mjs";
import { useFieldStore } from "../form/helper.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
import { useProps, createSizeProp, createStateProp, emitEvent } from "../../common/config/src/props.mjs";
import { useLocale } from "../../common/config/src/locale/index.mjs";
const _sfc_main = defineComponent({
  name: "AutoComplete",
  components: {
    Icon,
    Select
  },
  props: autoCompleteProps,
  emits: ["update:value"],
  setup(_props, { slots, emit }) {
    const select = ref();
    const control = ref();
    const {
      idFor,
      state,
      disabled,
      loading,
      size,
      validateField,
      clearField,
      getFieldValue,
      setFieldValue
    } = useFieldStore(() => {
      var _a;
      return (_a = control.value) == null ? void 0 : _a.focus();
    });
    const nh = useNameHelper("auto-complete");
    const props = useProps("autoComplete", _props, {
      size: createSizeProp(size),
      state: createStateProp(state),
      transfer: false,
      value: {
        default: () => getFieldValue(""),
        static: true
      },
      options: {
        default: () => [],
        static: true
      },
      filter: false,
      prefix: null,
      prefixColor: "",
      suffix: null,
      suffixColor: "",
      placeholder: null,
      disabled: () => disabled.value,
      transitionName: () => nh.ns("drop"),
      dropDisabled: false,
      placement: {
        default: "bottom",
        validator: (value) => placementWhileList.includes(value)
      },
      clearable: false,
      ignoreCase: false,
      autofocus: false,
      spellcheck: false,
      keyConfig: () => ({}),
      loading: () => loading.value,
      loadingIcon: null,
      loadingLock: false,
      loadingSpin: false,
      transparent: false
    });
    const currentValue = ref(props.value);
    const currentIndex = ref(-1);
    const visible = ref(false);
    let changed = false;
    let lastValue = props.value;
    let lastInput = String(lastValue);
    const optionStates = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.optionStates) || [];
    });
    const normalOptions = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.normalOptions) || [];
    });
    const filteredOptions = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.visibleOptions) || [];
    });
    const hasPrefix = computed(() => !!(slots.prefix || props.prefix));
    const hasSuffix = computed(() => !!(slots.suffix || props.suffix));
    const optionParentMap = computed(() => {
      var _a;
      return ((_a = select.value) == null ? void 0 : _a.optionParentMap) || /* @__PURE__ */ new Map();
    });
    watch(
      () => props.value,
      (value) => {
        currentValue.value = value;
        lastValue = value;
        lastInput = String(value);
        if (control.value) {
          control.value.value = String(value);
        }
      }
    );
    watch(currentIndex, computeHitting);
    watch(visible, (value) => {
      var _a, _b;
      if (!value) {
        currentIndex.value = -1;
        (_a = control.value) == null ? void 0 : _a.blur();
      } else {
        (_b = control.value) == null ? void 0 : _b.focus();
      }
    });
    watchEffect(() => {
      if (props.filter) {
        const value = currentValue.value;
        if (isNull(value)) {
          optionStates.value.forEach((state2) => {
            state2.hidden = false;
          });
        } else {
          optionStates.value.forEach((state2) => {
            state2.hidden = true;
          });
          if (typeof props.filter === "function") {
            const filter = props.filter;
            normalOptions.value.forEach((state2) => {
              state2.hidden = !filter(value, state2);
            });
          } else {
            if (props.ignoreCase) {
              const ignoreCaseValue = value == null ? void 0 : value.toString().toLocaleLowerCase();
              normalOptions.value.forEach((state2) => {
                var _a;
                state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().toLocaleLowerCase().includes(ignoreCaseValue));
              });
            } else {
              normalOptions.value.forEach((state2) => {
                var _a;
                state2.hidden = !((_a = state2.value) == null ? void 0 : _a.toString().includes(value == null ? void 0 : value.toString()));
              });
            }
          }
          const parentMap = optionParentMap.value;
          normalOptions.value.forEach((option) => {
            if (!option.hidden && option.parent) {
              let parent = parentMap.get(option.value) || null;
              while (parent && parent.hidden) {
                parent.hidden = false;
                parent = parent.parent;
              }
            }
          });
        }
        computeHitting();
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (control.value && !isNull(currentValue.value)) {
          control.value.value = String(currentValue.value);
        }
      });
    });
    function computeHitting() {
      const hitting = currentIndex.value;
      let index = -1;
      optionStates.value.forEach((state2) => {
        if (!state2.hidden) {
          index += 1;
          state2.hitting = hitting === index;
          if (state2.hitting) {
            if (control.value) {
              control.value.value = String(state2.value);
            }
          }
        } else {
          state2.hitting = false;
        }
      });
      if (control.value && hitting < 0) {
        control.value.value = lastInput;
      }
    }
    function handleSelect(value, data) {
      if (isNull(value)) {
        return;
      }
      const prevValue = currentValue.value;
      currentValue.value = value;
      emitEvent(props.onSelect, value, data);
      if (value !== prevValue) {
        changed = true;
        handleChange();
      } else {
        visible.value = false;
      }
    }
    function handleInput(event) {
      const value = typeof event === "string" ? event : event.target.value;
      visible.value = !props.dropDisabled;
      currentValue.value = value;
      changed = true;
      lastInput = value;
      if (currentIndex.value !== -1) {
        currentIndex.value = 0;
      }
      emitEvent(props.onInput, value);
    }
    function handleChange() {
      if (!changed || currentValue.value === lastValue)
        return;
      changed = false;
      lastValue = currentValue.value;
      lastInput = String(lastValue);
      const option = optionStates.value.find((option2) => option2.value === lastValue);
      setFieldValue(currentValue.value);
      emitEvent(props.onChange, currentValue.value, (option == null ? void 0 : option.data) || null);
      emit("update:value", currentValue.value);
      validateField();
      visible.value = false;
      if (control.value) {
        control.value.value = String(lastValue);
        control.value.blur();
      }
    }
    function handleToggle() {
      testOptionCanDrop();
      emitEvent(props.onToggle, visible.value);
      if (!visible.value) {
        currentIndex.value = -1;
      }
    }
    function testOptionCanDrop() {
      if (!filteredOptions.value.length || props.dropDisabled) {
        visible.value = false;
      }
    }
    function handleKeyDown(event) {
      const key = event.code || event.key;
      if (key === "ArrowDown" || key === "ArrowUp") {
        event.preventDefault();
        event.stopPropagation();
        const options = filteredOptions.value;
        const length = options.length;
        if (!length)
          return;
        const step = key === "ArrowDown" ? 1 : -1;
        let index = (currentIndex.value + step) % length;
        let option = options[index];
        for (let i = 0; (option.disabled || option.group) && i < length; ++i) {
          index += step;
          index = (index + length) % length;
          option = options[index];
        }
        currentIndex.value = index;
      } else {
        if (["Space", " "].includes(key)) {
          event.stopPropagation();
        }
        if (!["Enter", "ArrowLeft", "ArrowRight"].includes(key)) {
          currentIndex.value = -1;
        }
      }
    }
    function handleEnter() {
      var _a;
      if (filteredOptions.value.length) {
        const option = filteredOptions.value[currentIndex.value === -1 ? 0 : currentIndex.value];
        handleSelect(option.value, option.data);
      } else {
        handleChange();
      }
      emitEvent(props.onEnter, currentValue.value);
      (_a = control.value) == null ? void 0 : _a.blur();
      visible.value = false;
    }
    function handleClear() {
      if (props.clearable) {
        const prevValue = currentValue.value;
        currentValue.value = "";
        visible.value = false;
        if (!isNull(prevValue) && prevValue !== currentValue.value) {
          changed = true;
        }
        handleChange();
        emitEvent(props.onClear);
        nextTick(clearField);
      }
    }
    return {
      props,
      nh,
      locale: useLocale("input"),
      idFor,
      currentValue,
      currentIndex,
      visible,
      hasPrefix,
      hasSuffix,
      select,
      control,
      handleSelect,
      handleInput,
      handleChange,
      handleToggle,
      handleKeyDown,
      handleEnter,
      handleClear
    };
  }
});
const _hoisted_1 = ["autofocus", "spellcheck", "disabled", "placeholder", "readonly"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Icon = resolveComponent("Icon");
  const _component_Select = resolveComponent("Select");
  return openBlock(), createBlock(_component_Select, {
    id: _ctx.idFor,
    ref: "select",
    visible: _ctx.visible,
    "onUpdate:visible": _cache[3] || (_cache[3] = ($event) => _ctx.visible = $event),
    class: normalizeClass(_ctx.nh.b()),
    inherit: _ctx.props.inherit,
    "list-class": _ctx.nh.be("list"),
    value: _ctx.currentValue,
    size: _ctx.props.size,
    state: _ctx.props.state,
    clearable: _ctx.props.clearable,
    "transition-name": _ctx.props.transitionName,
    disabled: _ctx.props.disabled,
    transfer: _ctx.props.transfer,
    placement: _ctx.props.placement,
    "prefix-color": _ctx.props.prefixColor,
    "suffix-color": _ctx.props.suffixColor,
    "no-suffix": !_ctx.hasSuffix,
    placeholder: _ctx.props.placeholder,
    options: _ctx.props.options,
    "key-config": _ctx.props.keyConfig,
    loading: _ctx.props.loading,
    "loading-icon": _ctx.props.loadingIcon,
    "loading-lock": _ctx.props.loadingLock,
    "loading-spin": _ctx.props.loadingSpin,
    transparent: _ctx.transparent,
    onToggle: _ctx.handleToggle,
    onSelect: _ctx.handleSelect,
    onClear: _ctx.handleClear,
    onFocus: _cache[4] || (_cache[4] = ($event) => {
      var _a;
      return (_a = _ctx.control) == null ? void 0 : _a.focus();
    }),
    onBlur: _cache[5] || (_cache[5] = ($event) => {
      var _a;
      return (_a = _ctx.control) == null ? void 0 : _a.blur();
    }),
    onOutsideClose: _ctx.handleChange
  }, createSlots({
    control: withCtx(() => [
      renderSlot(_ctx.$slots, "control", {
        value: _ctx.currentValue,
        onInput: _ctx.handleInput,
        onChange: _ctx.handleChange,
        onEnter: _ctx.handleEnter,
        onClear: _ctx.handleClear
      }, () => {
        var _a;
        return [
          createElementVNode("input", {
            ref: "control",
            class: normalizeClass(_ctx.nh.be("input")),
            autofocus: _ctx.props.autofocus,
            spellcheck: _ctx.props.spellcheck,
            disabled: _ctx.props.disabled,
            placeholder: (_a = _ctx.props.placeholder) != null ? _a : _ctx.locale.placeholder,
            readonly: _ctx.props.loading && _ctx.props.loadingLock,
            autocomplete: "off",
            tabindex: "-1",
            role: "combobox",
            "aria-autocomplete": "list",
            onInput: _cache[0] || (_cache[0] = (...args) => _ctx.handleInput && _ctx.handleInput(...args)),
            onKeydown: [
              _cache[1] || (_cache[1] = withKeys((...args) => _ctx.handleEnter && _ctx.handleEnter(...args), ["enter"])),
              _cache[2] || (_cache[2] = (...args) => _ctx.handleKeyDown && _ctx.handleKeyDown(...args))
            ]
          }, null, 42, _hoisted_1)
        ];
      })
    ]),
    default: withCtx(({ option, index, selected }) => [
      renderSlot(_ctx.$slots, "default", {
        option,
        index,
        selected
      })
    ]),
    group: withCtx(({ option, index }) => [
      renderSlot(_ctx.$slots, "group", {
        option,
        index
      })
    ]),
    _: 2
  }, [
    _ctx.hasPrefix ? {
      name: "prefix",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "prefix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.prefix
          }, null, 8, ["icon"])
        ])
      ]),
      key: "0"
    } : void 0,
    _ctx.hasSuffix ? {
      name: "suffix",
      fn: withCtx(() => [
        renderSlot(_ctx.$slots, "suffix", {}, () => [
          createVNode(_component_Icon, {
            icon: _ctx.props.suffix
          }, null, 8, ["icon"])
        ])
      ]),
      key: "1"
    } : void 0
  ]), 1032, ["id", "visible", "class", "inherit", "list-class", "value", "size", "state", "clearable", "transition-name", "disabled", "transfer", "placement", "prefix-color", "suffix-color", "no-suffix", "placeholder", "options", "key-config", "loading", "loading-icon", "loading-lock", "loading-spin", "transparent", "onToggle", "onSelect", "onClear", "onOutsideClose"]);
}
var AutoComplete = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { AutoComplete as default };
