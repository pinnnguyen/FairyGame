import { defineComponent, ref, computed, provide, reactive, toRef, watch, onMounted, nextTick, createVNode } from "vue";
import "../menu-item/index.mjs";
import "../menu-group/index.mjs";
import "../overflow/index.mjs";
import "../../common/config/src/index.mjs";
import { callIfFunc } from "@vexip-ui/utils";
import MenuRest from "./menu-rest.mjs";
import { menuProps } from "./props.mjs";
import { MENU_STATE } from "./symbol.mjs";
import MenuItem from "./menu-item.mjs";
import MenuGroup from "./menu-group.mjs";
import Overflow from "../overflow/overflow.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const menuMarkerTypes = Object.freeze(["top", "right", "bottom", "left", "none"]);
var Menu = defineComponent({
  name: "Menu",
  components: {
    MenuRest,
    MenuItem,
    MenuGroup,
    Overflow
  },
  props: menuProps,
  emits: ["update:active"],
  setup(_props, {
    slots,
    emit,
    expose
  }) {
    const props = useProps("menu", _props, {
      active: {
        default: null,
        static: true
      },
      accordion: false,
      markerType: {
        default: "right",
        validator: (value) => menuMarkerTypes.includes(value)
      },
      reduced: false,
      horizontal: false,
      transfer: false,
      trigger: "hover",
      groupType: {
        default: "collapse",
        validator: (value) => ["collapse", "dropdown"].includes(value)
      },
      tooltipReverse: null,
      options: {
        default: () => [],
        static: true
      },
      router: null,
      manualRoute: false
    });
    const nh = useNameHelper("menu");
    const menuItemSet = /* @__PURE__ */ new Set();
    const currentActive = ref(props.active);
    const isReduced = ref(false);
    const wrapper = ref();
    const rest = ref();
    const markerType = computed(() => {
      var _a;
      if (props.horizontal && (props.markerType === "left" || props.markerType === "right")) {
        return "bottom";
      } else if (!props.horizontal && (props.markerType === "top" || props.markerType === "bottom")) {
        return "right";
      } else {
        return (_a = props.markerType) != null ? _a : props.horizontal ? "bottom" : "right";
      }
    });
    const className = computed(() => {
      return [nh.b(), nh.bs("vars"), nh.bm(`marker-${markerType.value}`), {
        [nh.bm("inherit")]: props.inherit,
        [nh.bm("reduced")]: isReduced.value,
        [nh.bm("dropdown")]: props.groupType === "dropdown",
        [nh.bm("horizontal")]: props.horizontal
      }];
    });
    const menus = computed(() => {
      var _a, _b;
      if ((_a = props.options) == null ? void 0 : _a.length) {
        return props.options;
      }
      const routes = (_b = props.router) == null ? void 0 : _b.options.routes;
      if (!(routes == null ? void 0 : routes.length)) {
        return [];
      }
      return parseRoutesToMenus(routes);
    });
    const currentRoute = computed(() => {
      var _a;
      return (_a = props.router) == null ? void 0 : _a.currentRoute.value;
    });
    provide(MENU_STATE, reactive({
      currentActive,
      isReduced,
      horizontal: toRef(props, "horizontal"),
      accordion: toRef(props, "accordion"),
      groupType: toRef(props, "groupType"),
      tooltipReverse: toRef(props, "tooltipReverse"),
      transfer: toRef(props, "transfer"),
      trigger: toRef(props, "trigger"),
      markerType,
      handleSelect,
      handleExpand,
      increaseItem,
      decreaseItem,
      beforeExpand: () => {
        if (props.accordion) {
          for (const item of menuItemSet) {
            item.groupExpanded = false;
          }
        }
      }
    }));
    watch(() => props.active, (value) => {
      if (value !== currentActive.value) {
        currentActive.value = value;
      }
    });
    watch(() => props.reduced, (value) => {
      if (props.horizontal)
        return;
      if (value) {
        handleMenuReduce();
      } else {
        handleMenuExpand();
      }
    });
    watch(currentRoute, (value) => {
      var _a;
      if (!props.manualRoute && value) {
        currentActive.value = ((_a = value.meta) == null ? void 0 : _a.label) || value.path;
      }
    });
    onMounted(() => {
      nextTick(() => {
        if (!props.horizontal && props.reduced)
          handleMenuReduce();
      });
    });
    expose({
      expandItemByLabel
    });
    function parseRoutesToMenus(routes) {
      const root = {
        label: "",
        children: []
      };
      const loop = Array.from(routes).map((route) => ({
        parent: root,
        route
      }));
      while (loop.length) {
        const {
          parent,
          route
        } = loop.shift();
        const routeMeta = route.meta || {};
        if (routeMeta.menu === false) {
          continue;
        }
        const options = {
          ...routeMeta,
          route,
          label: routeMeta.label || route.path,
          name: routeMeta.name || route.name
        };
        if (!parent.children) {
          parent.children = [];
        }
        parent.children.push(options);
        if (route.children) {
          loop.push(...route.children.map((route2) => ({
            parent: options,
            route: route2
          })));
        }
      }
      return root.children;
    }
    function increaseItem(state) {
      menuItemSet.add(state);
    }
    function decreaseItem(state) {
      menuItemSet.delete(state);
    }
    function handleSelect(label, meta, route) {
      if (currentActive.value !== label) {
        currentActive.value = label;
        emitEvent(props.onSelect, label, meta);
        emit("update:active", label);
        if (!props.manualRoute && props.router && route) {
          props.router.push(route);
        }
      }
    }
    function handleExpand(label, expanded, meta) {
      if (expanded) {
        emitEvent(props.onExpand, label, meta);
      } else {
        emitEvent(props.onReduce, label, meta);
      }
    }
    function handleMenuReduce() {
      if (props.horizontal)
        return;
      let firstExpandedItem = null;
      for (const item of menuItemSet) {
        item.cachedExpanded = item.showGroup;
        if (!firstExpandedItem && item.showGroup) {
          firstExpandedItem = item;
        }
        item.toggleGroupExpanded(false);
      }
      isReduced.value = true;
    }
    function handleMenuExpand() {
      if (props.horizontal)
        return;
      isReduced.value = false;
      if (wrapper.value) {
        const el = wrapper.value;
        const callback = () => {
          requestAnimationFrame(() => {
            el.removeEventListener("transitionend", callback);
            const selectedItem = Array.from(menuItemSet).find((item) => item.label === currentActive.value);
            requestAnimationFrame(() => {
              requestAnimationFrame(() => {
                for (const item of menuItemSet) {
                  item.groupExpanded = item.cachedExpanded;
                }
                if (selectedItem) {
                  let parent = selectedItem.parentState;
                  while (parent) {
                    parent.groupExpanded = true;
                    parent = parent.parentState;
                  }
                }
              });
            });
          });
        };
        el.addEventListener("transitionend", callback);
      }
    }
    function expandItemByLabel(label) {
      for (const item of menuItemSet) {
        if (item.label === label) {
          item.toggleGroupExpanded(true, true);
        }
      }
    }
    function renderMenuItem(item) {
      return createVNode(MenuItem, {
        "label": item.label,
        "icon": item.icon,
        "icon-props": item.iconProps,
        "disabled": item.disabled,
        "children": item.children,
        "route": item.route
      }, {
        default: () => [item.name ? callIfFunc(item.name) : item.label]
      });
    }
    function renderMenus() {
      return menus.value.map((menu) => menu.group ? createVNode(MenuGroup, {
        "label": menu.name ? callIfFunc(menu.name) : menu.label
      }, {
        default: () => {
          var _a;
          return [((_a = menu.children) == null ? void 0 : _a.length) ? menu.children.map(renderMenuItem) : null];
        }
      }) : renderMenuItem(menu));
    }
    return () => {
      return createVNode("ul", {
        "ref": wrapper,
        "class": className.value,
        "role": "menu",
        "tabindex": -1
      }, [slots.default ? slots.default() : props.horizontal ? createVNode(Overflow, {
        "inherit": true
      }, {
        default: renderMenus,
        counter: ({
          count
        }) => createVNode(MenuRest, {
          "ref": rest,
          "menus": menus.value.slice(-count)
        }, null)
      }) : renderMenus()]);
    };
  }
});
export { Menu as default };
