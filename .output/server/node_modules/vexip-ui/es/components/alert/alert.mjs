import { defineComponent, ref, computed, watch, onMounted, resolveComponent, openBlock, createBlock, withCtx, createElementBlock, normalizeClass, createElementVNode, renderSlot, createTextVNode, toDisplayString, createCommentVNode, normalizeStyle, createVNode } from "vue";
import "../collapse-transition/index.mjs";
import "../icon/index.mjs";
import "../../common/config/src/index.mjs";
import { Flag, CircleInfo, CircleCheck, CircleExclamation, CircleXmark, Xmark } from "@vexip-ui/icons";
import { getRangeWidth } from "@vexip-ui/utils";
import { alertProps } from "./props.mjs";
import _export_sfc from "../../_virtual/plugin-vue_export-helper.mjs";
import CollapseTransition from "../collapse/collapse-transition.mjs";
import Icon from "../icon/icon.mjs";
import { useProps, emitEvent } from "../../common/config/src/props.mjs";
import { useNameHelper } from "../../common/config/src/namespace.mjs";
const predefinedIcons = {
  default: Flag,
  info: CircleInfo,
  success: CircleCheck,
  warning: CircleExclamation,
  error: CircleXmark
};
const alertTypes = Object.freeze(["default", "info", "success", "warning", "error"]);
const _sfc_main = defineComponent({
  name: "Alert",
  components: {
    CollapseTransition,
    Icon,
    Xmark
  },
  props: alertProps,
  emits: [],
  setup(_props, { slots }) {
    const props = useProps("alert", _props, {
      type: {
        default: "info",
        validator: (value) => alertTypes.includes(value)
      },
      title: "",
      colorfulText: false,
      icon: false,
      closable: false,
      iconColor: "",
      noBorder: false,
      banner: false,
      manual: false,
      scroll: false,
      scrollSpeed: 1
    });
    const nh = useNameHelper("alert");
    const closed = ref(false);
    const hidden = ref(false);
    const scrollDuration = ref(0);
    const scrollOffset = ref(0);
    const scrollWidth = ref(0);
    const content = ref();
    const scroll = ref();
    const hasTitle = computed(() => {
      return !!(props.title || slots.title);
    });
    const hasIcon = computed(() => {
      return !!(props.icon || slots.icon);
    });
    const className = computed(() => {
      return {
        [nh.b()]: true,
        [nh.bs("vars")]: true,
        [nh.bm("inherit")]: props.inherit,
        [nh.bm(props.type)]: props.type,
        [nh.bm("colorful-text")]: props.colorfulText,
        [nh.bm("has-title")]: hasTitle.value,
        [nh.bm("has-icon")]: hasIcon.value,
        [nh.bm("closable")]: props.closable,
        [nh.bm("no-border")]: !props.banner && props.noBorder,
        [nh.bm("banner")]: props.banner
      };
    });
    const iconComp = computed(() => {
      var _a;
      if (typeof props.icon === "boolean") {
        return (_a = predefinedIcons[props.type]) != null ? _a : null;
      }
      return props.icon;
    });
    const scrollStyle = computed(() => {
      return {
        width: `${scrollWidth.value}px`,
        transitionDuration: `${scrollDuration.value}ms`,
        transform: `translateX(${scrollOffset.value}px)`
      };
    });
    watch(
      () => props.scroll,
      (value) => {
        value && startScroll();
      }
    );
    onMounted(() => {
      props.scroll && startScroll();
    });
    function handleClose() {
      if (!props.manual) {
        closed.value = true;
      }
      emitEvent(props.onClose);
    }
    function handleAfterLeave() {
      emitEvent(props.onHide);
      hidden.value = true;
    }
    function startScroll() {
      if (content.value && scroll.value) {
        const contentRect = content.value.getBoundingClientRect();
        const rangeWidth = getRangeWidth(scroll.value);
        const duration = (contentRect.width + rangeWidth) * 12 / (Math.max(props.scrollSpeed, 0) || 1);
        scrollDuration.value = 0;
        scrollOffset.value = contentRect.width;
        scrollWidth.value = rangeWidth;
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            scrollDuration.value = duration;
            scrollOffset.value = -rangeWidth;
          });
        });
      }
    }
    function handleScrollEnd() {
      emitEvent(props.onScrollEnd);
      requestAnimationFrame(startScroll);
    }
    return {
      props,
      nh,
      closed,
      hidden,
      content,
      scrollEl: scroll,
      hasTitle,
      hasIcon,
      className,
      iconComp,
      scrollStyle,
      handleClose,
      handleAfterLeave,
      handleScrollEnd
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Xmark = resolveComponent("Xmark");
  const _component_Icon = resolveComponent("Icon");
  const _component_CollapseTransition = resolveComponent("CollapseTransition");
  return !_ctx.hidden ? (openBlock(), createBlock(_component_CollapseTransition, {
    key: 0,
    "fade-effect": "",
    onAfterLeave: _ctx.handleAfterLeave
  }, {
    default: withCtx(() => [
      !_ctx.closed ? (openBlock(), createElementBlock("div", {
        key: 0,
        class: normalizeClass(_ctx.className),
        role: "alert"
      }, [
        createElementVNode("div", {
          class: normalizeClass(_ctx.nh.be("wrapper"))
        }, [
          _ctx.hasTitle ? (openBlock(), createElementBlock("div", {
            key: 0,
            class: normalizeClass(_ctx.nh.be("title"))
          }, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createTextVNode(toDisplayString(_ctx.title), 1)
            ])
          ], 2)) : createCommentVNode("", true),
          createElementVNode("div", {
            ref: "content",
            class: normalizeClass([_ctx.nh.be("content"), _ctx.props.scroll && _ctx.nh.bem("content", "scroll")])
          }, [
            _ctx.props.scroll ? (openBlock(), createElementBlock("span", {
              key: 0,
              ref: "scrollEl",
              class: normalizeClass(_ctx.nh.be("scroll")),
              style: normalizeStyle(_ctx.scrollStyle),
              onTransitionend: _cache[0] || (_cache[0] = (...args) => _ctx.handleScrollEnd && _ctx.handleScrollEnd(...args))
            }, [
              renderSlot(_ctx.$slots, "default")
            ], 38)) : renderSlot(_ctx.$slots, "default", { key: 1 })
          ], 2)
        ], 2),
        _ctx.props.closable ? (openBlock(), createElementBlock("button", {
          key: 0,
          class: normalizeClass(_ctx.nh.be("close")),
          onClick: _cache[1] || (_cache[1] = (...args) => _ctx.handleClose && _ctx.handleClose(...args))
        }, [
          renderSlot(_ctx.$slots, "close", {}, () => [
            createVNode(_component_Icon, { label: "close" }, {
              default: withCtx(() => [
                createVNode(_component_Xmark)
              ]),
              _: 1
            })
          ])
        ], 2)) : createCommentVNode("", true),
        _ctx.hasIcon ? (openBlock(), createElementBlock("div", {
          key: 1,
          class: normalizeClass(_ctx.nh.be("icon"))
        }, [
          renderSlot(_ctx.$slots, "icon", {}, () => [
            createVNode(_component_Icon, {
              icon: _ctx.iconComp,
              scale: _ctx.hasTitle ? 2 : 1,
              style: normalizeStyle({ color: _ctx.props.iconColor })
            }, null, 8, ["icon", "scale", "style"])
          ])
        ], 2)) : createCommentVNode("", true)
      ], 2)) : createCommentVNode("", true)
    ]),
    _: 3
  }, 8, ["onAfterLeave"])) : createCommentVNode("", true);
}
var Alert = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Alert as default };
